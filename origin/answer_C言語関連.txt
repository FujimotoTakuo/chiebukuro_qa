順番に書きます ①カンマで区切られた数字の読み方が解らない ファイルに書かれたカンマ区切りのデータを配列データとして読み込む方法を２つ提示します （１）ファイルより１行読み込んで、改行コードを削除した後に ',' で分割する方法 with open('data', 'r') as f: __data = f.readline().rstrip().split(',') print(data) （２）標準ライブラリであるcsv パッケージを使用する http://docs.python.jp/3.5/library/csv.html import csv with open('data','r') as f: __data = csv.reader(f) # py3の場合は list(csv.reader(f)) とする必要あり print(data) この方法の場合は全ての行が読み込まれますので、結果は２重配列にて行毎のデータが出力されます ③（順番が前後しますが）読み込んだ値を文字列から整数値に変える方法が分からない 文字型を数値型に変換するには組み込み関数 int() を使用します。 http://docs.python.jp/3.5/library/functions.html#int また、配列のデータ全てに上記の int() を適用するには 同じく組み込み関数である map() を使用します。 http://docs.python.jp/3.5/library/functions.html#map ２つを合わせるとこのようになります data = ['25', '10', '5'] data = map(int, data) # py3の場合は data = list(map(int, data)) print(data) ②値の数字の数に寄らない一般化の仕方が分からない 配列データに対して累積的に処理を行うには reduce() を使います。 http://docs.python.jp/2/library/functions.html#reduce http://docs.python.jp/3/library/functools.html (reduce は py2では組み込み関数ですが、py3では 標準ライブラリ functools パッケージに移動しております) from functools import reduce # py3のみこれが必要 data = [25,10,5] res = reduce(lambda a,b: (a*b) ,data) print(res) 上記の３つをまとめると、以下のようになります from functools import reduce #py3のみ with open("data", "r") as f: __res = reduce(lambda a, b: (a * b), map(int, f.readline().rstrip().split(","))) print(res)
下のように書いて実行してみてください。 printf("aiueo"+2); ヒントです。
こちらの「順序論理回路」が参考になるのでは。 https://www.yonago-k.ac.jp/denki/lab/nitta/lecture/E3_digital/note/... (R,S)が逆になっていますが (0,0)→不変 (1.0)→Reset (0,1)→Set とすると (0,0)では不変で(1,0) (1.o)でResetで(0,1) (0,0)で不変なので(0,1) では？
LcdLib.h , LcdLib.c を流用していると思われますが ANSEL=0; // digital I/O mode が無い為、RB7 , RB6 がアナログモードのままです 初期設定に追加してみて下さい また main の最後に while(1); // STOP が無いとリセットがかかり、再度 main から始まります。
問題文を（原文で）示してみて下さい。 「大域変数numには配列tに設定されている要素数が格納されている。」 だと普通、要素の数の事だと思うのですが？
エラーメッセージは何ですか？
エラーが出るのを「恒久的に」防ぐ事はおそらく出来ないと思います。 「いいえ」ボタンを押しまくって無視して下さい。 ソフト自体の動作には影響しません。 【エラーが出る原因】 じつは「苦C」タブのヘルプページの中に「広告」が表示されるようになっているのですが、ソフト自体が古いので広告の中で使用されているスクリプトに対応できずエラーが発生しているようです。つまり、【広告の表示に失敗してエラーが出ている】ようです。 【一時的にエラーが出るのを防ぐ方法】 PCをインターネットから切断した状態でソフトを使用して下さい。そうしますと、広告のスクリプトを読み込めないのでエラーが出なくなります。 (^_^;
1.23という数は二進数では割り切れない数で循環小数になる。それを単精度の有限桁で切るので、どうしても誤差が出る。それが最後に２が付く理由である。 2/3という数を十進法で書くと、0.6666....となるが有限桁で切って四捨五入すれば0.6666667 となるようなものである。 IEEE754で検索すれば分かるが、単精度実数の場合、符号に１ビット、指数部に８ビット、仮数部に23ビット割り当てている。1.23 の場合、指数部によるシフトは無く、1.0 は暗黙の内に勘定されているので、23ビットで0.23を表すことになる。23ビットは、先頭から十進表記で 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625.... という数を表わしているので、今の場合 0,0,1,1,1,0.... という表記になる。 24ビット目で丸め処理を行っているが、丸めのルールは複雑である。 1.23000002 1.2300000190734863 0 01111111 00111010111000010100100 0 01111111111 0011101011100001010010000000000000000000000000000000 0 0 1 1 1 0 1 0 1 1 1 0 0 0 0 1 0 1 0 0 1 0 0 1 0.500000000 0.00000000E+00 0.00000000E+00 2 0.250000000 0.00000000E+00 0.00000000E+00 3 0.125000000 0.125000000 0.125000000 4 6.25000000E-02 6.25000000E-02 0.187500000 5 3.12500000E-02 3.12500000E-02 0.218750000 6 1.56250000E-02 0.00000000E+00 0.218750000 7 7.81250000E-03 7.81250000E-03 0.226562500 8 3.90625000E-03 0.00000000E+00 0.226562500 9 1.95312500E-03 1.95312500E-03 0.228515625 10 9.76562500E-04 9.76562500E-04 0.229492188 11 4.88281250E-04 4.88281250E-04 0.229980469 12 2.44140625E-04 0.00000000E+00 0.229980469 13 1.22070312E-04 0.00000000E+00 0.229980469 14 6.10351562E-05 0.00000000E+00 0.229980469 15 3.05175781E-05 0.00000000E+00 0.229980469 16 1.52587891E-05 1.52587891E-05 0.229995728 17 7.62939453E-06 0.00000000E+00 0.229995728 18 3.81469727E-06 3.81469727E-06 0.229999542 19 1.90734863E-06 0.00000000E+00 0.229999542 20 9.53674316E-07 0.00000000E+00 0.229999542 21 4.76837158E-07 4.76837158E-07 0.230000019 22 2.38418579E-07 0.00000000E+00 0.230000019 23 1.19209290E-07 0.00000000E+00 0.230000019 参考プログラム program hello implicit none real :: a, f, g real(kind(0.0d0)):: d character(len = 80):: text1, text2 integer :: i, m(23) a = 1.23 d = a Print *, a, d write(text1, '(b32.32)') transfer(a, 0_4) write(text2, '(b64.64)') transfer(d, 0_8) print '(a, 1x, a, 4x, a)', text1(1:1), text1(2: 9), text1(10:) print '(a, 1x, a, 1x, a)', text2(1:1), text2(2:12), text2(13:) ! read(text1(10:), '(23i1)') m print '(23i2)', m f = 0.0 g = 1.0 do i = 1, 23 g = g / 2.0 f = f + g * m(i) print *, i, g, g * m(i), f end do end program Hello
こんばんは こんな感じでしょうか？ private void Form1_Shown(object sender, EventArgs e) { listView1.Columns.Add("番号",100); listView1.Columns.Add("住所", 100); listView1.Columns.Add("名前",100); ListViewItem itemx1 = new ListViewItem(); ListViewItem itemx2 = new ListViewItem(); itemx1.Text = "001"; itemx1.SubItems.Add("東京都"); itemx1.SubItems.Add("田中"); listView1.Items.Add(itemx1); itemx2.Text = "002"; itemx2.SubItems.Add("千葉県"); itemx2.SubItems.Add("佐藤"); listView1.Items.Add(itemx2); listView1.CheckBoxes = true; listView1.Items[0].BackColor = Color.White; listView1.Items[1].BackColor = Color.White; } private void listView1_ItemChecked(object sender, ItemCheckedEventArgs e) { if (listView1.Items[0].Checked == true) { listView1.Items[0].BackColor = Color.Blue; }else if (listView1.Items[0].Checked == false) { listView1.Items[0].BackColor = Color.White; } if (listView1.Items[1].Checked == true) { listView1.Items[1].BackColor = Color.Blue; } else if (listView1.Items[1].Checked == false) { listView1.Items[1].BackColor = Color.White; } }
TA7291はドロップがヒドイので使わないほうがいいですよ。普通にMOS-FETでHブリッヂ組んだほうが分かりやすいのに。 あと省エネ目指してるわけでもないなら、「内部プルアップ」つかったほうが良いよ。楽だし。 やり方は幾らでもあるから、下の回答者の言ってるいみが分からないなら他のやりやすい方法でやってみれば。
それぞれスレッドプールから別のスレッドで実行されるようになるため、 処理 1 と処理 2 が別スレッドで並行して実行されるようになります。 もし処理 1 の処理が長くて処理 2 の処理が短い場合、 処理 2 のほうが早く完了することも起こり得ます。
hiroto_kimura_0802さん #include <stdio.h> #include <conio.h> #include <limits.h> #include <math.h> void main() { int i; double x,y; printf( " x sqrt(x)\n" ); printf( "--------------\n" ); for ( i = 0; i <= 100; i++ ) { x=i; x = x / 100.0; y=sqrt(x); printf( "%4.2f %5.3f\n", x, y);//関数は外へ出す。 } _getch(); }
hiroto_kimura_0802さん _getch( ) をヘルプで調べると、 #include <conio.h>
conio.h をincludeしてみてください。
c_crimerさん ファイルはフォルダの中にあるので、 1. ファイル FileName Perc.txt 中村太郎 2. FilePath c:￥Program￥Perc.txt 福岡県福岡市城南区飯倉2-58中村太郎 3. 上のように、住所付き氏名のようなもの。
source という英語は、「元」という意味です。 プログラムの元になるコードの事ですね。 主に、コンパイルして実行プログラムを作るプログラミング言語の人間が直接入力するコードの事です。 これをコンパイルまたは、アセンブルしてリンクして、実行プログラムを作成します。 でも、Javascript とか、perl とか、ruby なんかは、コンパイルしないインタープリター言語なので、ソースコードとは、あまり言いません。そのまま実行します。
乗除算数は左から順番に計算します。 ですので、右を先に計算したら結果は違います。 簡潔にしたいなら =ROUNDUP(RAND()*5,0) です。 2で割ってから10を掛けるのは5を掛けるのと同じですが 20で割るのとは違います。
C言語はプログラミング言語の1つです。プログラミンッグ言語は世の中に沢山存在します、因みに、私も作っています。その中でもC言語はUNIXと呼ばれるOSの移植性を高める為に開発されたプログラミング言語で、それ以降に開発されているプログラミング言語は殆どがC言語で開発されていると言っても過言で無いほどの、ベースとなっているプログラミング言語です。
私の環境では以下のやり方で可能でした。 お試しください。 var shellAppType = Type.GetTypeFromProgID("Shell.Application"); dynamic shell = Activator.CreateInstance(shellAppType); var win = shell.Windows();
for文のi++1の1を消すか、i+=1にしてください。
直角三角形の面積と最大辺の2乗は比例関係にあるかと思います。 （これが間違いなら済みません。) だから、長い順にソートして、最初に直角三角形が成り立つものが、最大の面積になるかと思います。 #include<stdio.h> #define N 2000 int main(void) { FILE *fp; char fn[30]; int n,i,j,d[N],t; double max,m; printf("Number of Bars : "); scanf("%d",&n); printf("Bar Length File : "); scanf("%s",fn); fp=fopen(fn,"r"); for(i=0;i<n;i++)fscanf(fp,"%d",&d[i]); fclose(fp); for(i=0;i<n-1;i++){ for(j=i+1;j<n;j++){ if(d[j]>d[i]){ t=d[i]; d[i]=d[j]; d[j]=t; }}} printf("Max Area of Rectangular Triangle : "); for(i=0;i<n-2;i++){ for(j=i+2;j<n;j++){ if(d[i]*d[i]==d[i+1]*d[i+1]+d[j]*d[j]){ printf("%.1f\n",d[i+1]*d[j]/2.0); return 0; } }} printf("0.0\n"); return -1; } =＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 総当り方式は面倒、、、、、、、、、 #include<stdio.h> #define N 2000 int main(void) { FILE *fp; char fn[30]; int n,i,j,k,d[N],x,y,z; double max,m; printf("Number of Bars : "); scanf("%d",&n); printf("Bar Length File : "); scanf("%s",fn); fp=fopen(fn,"r"); for(i=0;i<n;i++)fscanf(fp,"%d",&d[i]); fclose(fp); for(max=0.0,i=0;i<n;i++){ for(j=0;j<n;j++){ for(k=0;k<n;k++){ if(i!=j&&i!=k&&j!=k){ x=d[i]; y=d[j]; z=d[k]; if(x<d[j]){ x=d[j]; y=d[i]; z=d[k]; } if(x<d[k]){ x=d[k]; y=d[i]; z=d[j]; } if(x*x==y*y+z*z){ m=y*z/2.0; if(max<m)max=m; } } }}} printf("Max Area of Rectangular Triangle : %.1f\n",max); return 0; }
ウォッチウィンドウにkを貼り付けて必要な部分を展開させて表示させるしかありません。
月末の判定にDateTimeを使用していては．．． TimeSpanならこうします。 int TotalDay(DateTime dt1, DateTime dt2) { return (int)(dt2.Date - dt1.Date).TotalDays; } 手動の場合は、 西暦1年１月1日からの通算日数に換算してから比較するのが簡単です。 以下は、ツェラーの公式を応用したものです。 http://ufcpp.net/study/algorithm/o_days.html // グレゴリオ歴→西暦0年3月1日からの通算日数 int DateToSerial(int y, int m, int d) { // 1・2月 → 前年の13・14月 if (m <= 2) { --y; m += 12; } int dy = (y-1) * 365 + y / 4 - y / 100 + y / 400 + (m * 979 - 1033) / 32 + d - 1; return dy; }
まず、旋回しようとしているのになぜTranslateを使用しているのでしょうか。 transform.Translate(Vector3.forward * masinspeed,Space.World); このソースだと「ワールド空間におけるZ+方向へmasinspeedだけ進む」となるので、そもそも旋回もしないと思うのですが…… ローカル座標だと角度がおかしい、バウンドするというのも不思議な話なので、根本的に間違っているように思います。 とりあえずこちらをご覧の上、少しずつ進めるとよいかと思います。 http://tsubakit1.hateblo.jp/entry/2014/08/02/030919
PIC18 は , delay のパラメータ範囲が狭いので void delay10ms(unsigned int i){ while(i){ __delay_ms(10); i-- ; } } を定義しています 但し余分な処理が入るので実際は少し長くなります
/*phahu14さんへ コメントを入れてみました 使用しているが型がunsigned char*でなくchar*になっているのが気になります。 0x80以上の文字の場合、これをインデクスに使用するとマイナス方向へ移動します。よって意図しないメモリ領域を読み書きします。 */ #include<stdio.h> #include<string.h> char *search(char* ,char*); void table(char *); int skip[256];//0～255 void main (void) { static char text[]="This is a pen.That is a pencil."; char *p,*key="pen"; table(key); p=search(text,key); while (p!=NULL) { printf("%s\n",p); p=search(p+strlen(key),key); } } void table(char *key) /*スキップテーブルの作成*/ { int k,n; n=strlen(key); for(k=0; k<=225; k++)//★おそらく225でなく、unsigned charの最大値である255だと思われる skip[k]=n;//とりあえず全要素にキー長さをセット（キーに含まれない文字の時はキーと同じ長さだけスキップする為） for(k=0; k<n-1; k++)//キーの末尾文字を除く文字に対して処理を行う skip[key[k]]=n-1-k;//キーに含まれる文字に該当するスキップ量に「(キー長さ-1)-（キー中の文字位置）」をセット。※これはキーの末尾位置を０とし、末尾文字を除いて先頭方向へ探索した時にその文字が最初に現れる距離である。例：key="abcba"の時、skip['b']=1,skip['c']=2,skip['a']=4となる。 } char *search(char *text,char*key) { int m,n; char *p; m=strlen(text); n=strlen(key); p=text+n-1;//pにキーの最終文字位置に相当するtext位置をセット while(p<text+m) {//テキスト末端から飛び出ない位置まで if(*p==key[n-1]) {//現在位置の文字がキー末尾文字と同じ時 if(strncmp(p-n+1,key,n)==0)//キーと同じ文字列を見つけた時 return p-n+1;//見つけた位置を返す } p=p+skip[*p];//異なる時はスキップテーブルに従ってスキップする（*p文字がキーに含まれていなければキー長さ分スキップ。*p文字がキーに含まれていれば、キー末尾方向から最も近い該当文字が*p位置に合致するようにスキップ） } return NULL; }
/* poi_kouさんへ こんなかんじで… -----実行結果----- 合言葉は？：ひらけゴマ ドアを開けてさしあげましょう。 */ #include<stdio.h> #include<string.h>//文字列処理関数用 int main(void) { char input[256];//半角255文字＋文字列終端コード１文字 を入れるバッファ printf("合言葉は？："); scanf("%255s",input); //※↓strcmp()は文字列を比較する関数です。 // http://www.c-tipsref.com/reference/string/strcmp.html if(strcmp(input,"ひらけゴマ")==0){ //入力された文字列が「ひらけゴマ」と同じ時 printf("ドアを開けてさしあげましょう。\n"); }else{ printf("出直してきなさい。\n"); } return 0; }
回答になっていませんし、有効な解き方も分かりませんが 「入力した１つの数値に含まれる素数を計算して、素数を全部画面に出力する」 というのは、例えば 12345678910111213124151617 という数値のなかから 2,23,5,11,13,17...などを抽出せよという意味でしょうか？ 数値を一旦文字列にしてから、その中から部分文字を取り出して数値に戻して、エラトステネスのふるいにかけるとかでしょうか？
>rebaqbさん 1つめで出力をファイルに書きだして 2つめでそのファイルの中身をみてます man less とすればlessのマニュアルを見れる
#include<stdio.h> void calculation(int,int,int*); struct DATA { int height; int weight; int BMI; }; int main(void) { struct DATA data; int i; for(i=0;i<10;i++){ printf("\n身長:"); scanf("%d",&data.height); printf("体重:"); scanf("%d",&data.weight); printf("身長[cm]:%d\n",data.height); printf("体重[Kg]:%d\n",data.weight); calculation(data.height,data.weight,&data.BMI); printf("あなたのBMIは%d。",data.BMI); if(data.BMI<18)printf("やせすぎです。"); if(data.BMI>=18&&data.BMI<25)printf("やややせです。\n",data.BMI); if(data.BMI>=25&&data.BMI<35)printf("普通です。\n",data.BMI); if(data.BMI>=35&&data.BMI<40)printf("かなり肥満です。\n",data.BMI); if(data.BMI>=40)printf("肥満です。\n",data.BMI); } return 0; } void calculation(int h,int w,int *b) { *b=w*10000/(h*h); } BMI判定を適当に修正しました。 判定は以下のようにしても間違いではないと思うが、、、、、好きではない、、、、、 if(data.BMI<18)printf("やせすぎです。"); else if(data.BMI>=18&&data.BMI<25)printf("やややせです。\n",data.BMI); else if(data.BMI>=25&&data.BMI<35)printf("普通です。\n",data.BMI); else if(data.BMI>=35&&data.BMI<40)printf("かなり肥満です。\n",data.BMI); else if(data.BMI>=40)printf("肥満です。\n",data.BMI);
一部に誤りがありましたので取り消しました。再度回答します。 「案」BCDコードをタクトスイッチみたいなもので実現するなら、もう１ヶスイッチを設けて、BCDスイッチを押してから確定したという信号にするのが簡単でいいと思う。確定したという信号を受けてBCDを読み込み変数に代入すれば保持したことになる。 BCDコードをデコードするには出力コードを配列で持ち、BCDコードでindexすれば簡単。 const unsigned char ot_dat[10] = {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,0x80}; // 0~8までの出力コード if (0<=BCD && BCD < 9){ ____PORTA = ot_dat[BCD]; ____PORTB.0 = 0; } else if(BCD == 9){ ____PORTA = 0; ____PORTB.0 = 1; } else { ____// 適当な処理 } このプログラムの欠点 ポート構成が８ビットである以上、ものすごく速いマイコンを使っても出力に数十nSのグリッチが出る。 これを防ぐにはもう１ビット出力を増設し、コードが確定したした後、パルスをだし外部でラッチするようにすればよいでしょう。 以上を参考に適当にアレンジしてください。
OSは縁の下の力持ち、安定稼動してナンボなのです。 MS社は昔から、未完成品を世の中に出し、まるでユーザに「バグ出し」というプログラムコーディング作業の一部を負わせていると感じます。 全く、MS社の為に人柱になる必要はなく、是非、工場出荷状態に戻し、そのOSを更新して使用することをお勧めします。
indy_indy80さん 次のようなコードでいけるか試してみてください。 DataGridView（インスタンス名はdataGridView1）のあるフォームのコンストラクタで、次のようにします。 ■コード例 dataGridView1.KeyDown += (o, e) => { if (e.KeyCode == Keys.Delete) { DataGridView d = o as DataGridView; foreach (DataGridViewCell c in d.SelectedCells) { c.Value = null; } } }; ■解説 DataGridViewのKeyDownイベントに、キーが押されたときのイベントを追加します。 内容は、Deleteキーが押されたときに選択されていたセルをすべて拾い上げて、値を消す（nullを代入）という処理になります。
すいません、その仕様だとログインフォームにする意味がないと思いますが。 何のためのログインフォームですか？ 本来の承認機能は全て入力させ、それが正しいかどうかをチェックする為のものだと私は思っています。 もし実装するならば IDを完全に入力し終わり、PWにフォーカスが移った時点で INIファイルやxmlファイル等を読み込み、キーが一致すればPWを表示するという形にするかな・・・。 でも、IDが流出した時点でアウトですよね・・・。
>naoakigain15さん 推奨手順1) まず画素の読み出しをやって 正しく画素にアクセスできてるか確認 (テスト用画像を作成するのが良い、ImageMagickとか使えば簡単に作れる) 推奨手順2) 計算式の結果を標準出力に出して 手計算とあうか確認 (手計算できて、確認が簡単なように小さいテスト用画像でテスト) 推奨手順3) 上が上手くいってから元やってたものにたいして行なう で多分解決しそうだけど デバッグまでがプログラムなので デバッグも頑張らないと デバッグが楽になる手順を書いておきました (Python Debugとかでネット検索すれば、デバッガの利用方法もでてくるので デバッガを使えばかなりデバッグは楽になります)
線形代数で行列を習うときかなぁ。 プログラム組む時に使ったぐらいだけど。
#include<stdio.h> #define NUM (200) int isPrime( int a ); int isPrime( int a ) { int i; int ret = 1; /* 偶数は素数ではない */ if( a % 2 == 0 ) { ret = 0; } /* 1は素数ではない */ else if( a == 1 ) { ret = 0; } /* 3以上の奇数 */ else { /* 3以上の奇数で余りを出して素数かチェックする */ for( i = 3; i * i <= a; i = i + 2 ) { if( a % i == 0 ) { ret = 0; break; } } } return ret; } int main(void) { int isPrimes[NUM + 1] = {0}; int i; /* 配列に素数かどうかの情報を詰める */ for( i = 5; i <= NUM; i = i + 2 ) { isPrimes[i] = isPrime(i); /* 要素iにiが素数かどうかを詰める */ } printf("%d 以下の三つ子素数の組は次の通り:\n", NUM); /* バッファをオーバーしないようにループ */ for( i = 5; i <= NUM - 6; i = i + 2 ) { /* 3つの要素をチェックして、すべて1なら三つ子 */ if( ( isPrimes[i] == 1 ) && ( isPrimes[i + 2] == 1 ) && ( isPrimes[i + 6] == 1 ) ) { printf("三つ子素数{ %d, %d, %d }\n", i, i + 2, i + 6); } if( ( isPrimes[i] == 1 ) && ( isPrimes[i + 4] == 1 ) && ( isPrimes[i + 6] == 1 ) ) { printf("三つ子素数{ %d, %d, %d }\n", i, i + 4, i + 6); } } return 0; }
>eclipseに最初から入っているmingwには 入っていません。 Pleiades All in Oneの事を言っているのか? だったらこれはeclipseに日本語プラグインをセットして 配布している亜種であって公式のEclipseではありません。
正確には、Serial.print になります Serial.print(''vale=''); // 文字列 "vale=" の表示（シリアル出力） Serial.println(vale); // 変数 vale の値を表示してから改行します 表示例 vale=xxx (xxxは数値が入ります） Arduino 日本語リファレンス http://www.musashinodenpa.com/arduino/ref/index.php
return 0; の前に free(new); 明示的にメモリの解放が必要なのは、mallocで確保したメモリだけです。
return 0; の前に free(new); 明示的にメモリの解放が必要なのは、mallocで確保したメモリだけです。
build.xmlで指定している対象のクラスが間違っているのではないでしょうか。 http://www.atmarkit.co.jp/bbs/phpBB/viewtopic.php?topic=24042&forum...
与えられるテキストデータの最大長や、その中に格納される文の最大長は不明なので、配列で処理する手法はあまり使いたくありません。 「最も」スマートなやり方については存じませんが、処理目的を達するだけなら、以下に示すような２つの方法で可能でしょう。 ・・・・・・・・・・ １．順次走査法 何文目を取り出すかという入力を受け付けてから、与えられたテキストデータを１文字ずつ読み、区切り文字を見つけ出してその範囲を１文字ずつ表示する。 たとえば、3 という入力があれば、テキストデータを１文字ずつ読み込んでいき、２つ目の区切り文字の次の文字から１文字ずつ表示し、３つ目の区切り文字のところで表示をやめればよい。 この方法は簡易だが、後ろの方の文を取り出すのに時間がかかる。 ・・・・・・・・・・ ２．擬似ランダムアクセス法 この方法では「走査処理」と「問い合わせ処理」を行う。 「走査処理」では、与えられたテキストデータを１文字ずつ読み込み、区切り文字が出てきたら、そのバイト位置を別のテキストファイルに出力していく。 出力ファイルは以下のようなものになる。 0 35 148 246 テキストデータを全て読み終えたら出力ファイルをクローズし、問い合わせ処理に移る。 「問い合わせ処理」では、ｎ文目を取り出すかという入力を受け付けたら、「走査処理」で作成したファイルのｎ行目を読み取り、それをアクセス開始バイト位置として、元テキストデータのアクセス開始バイト位置から区切り文字までを１文字ずつ弓込んで表示する。 この方法はやや複雑だし、元テキストデータに変更があれば「走査処理」を再度実行しなければならないが、「何文目を取り出すか」という問い合わせが頻繁に有り、かつ元テキストデータの変更が少ない場合は、「順次走査法」よりもトータルの処理コストは低い。 ・・・・・・・・・・ どうしても配列に格納したい、というのであれば、上記「擬似ランダムアクセス法」の「走査処理」に似た処理を実行して、１文あたりの最大所要バイト数を求め、それで配列領域を malloc() するという方法もありますが、元テキストデータを「２度読み」する事になり、処理コストは高いです。
http://itpro.nikkeibp.co.jp/article/COLUMN/20090622/332341/?rt=nocn... POIってライブラリなんですね。出来るんじゃないですか。使えば。
windows19970718さん 基礎から、学ぶ。 ソースを読んで、理解できるのは、 自作できるレベルの少し上ぐらい。
セグメンテーション違反がでていますので、どこかでメモリオーバー（たとえばchar配列以上の文字列を読み込もうとしたとか）が起こっています。 ファイルによって出たり、出なかったりしたのは、ファイルの中身のサイズによるものではないでしょうか。
Arduino初心者とのことなので下記のURLを参考にすればできる。 http://www.japanese-makers.com/archives/633 お釈迦様に説法かもしれませんが、数値と数字は違います。 普段パソコンを使っているときは”数字”と”数値”を区別しないでも困りませんがマイコン通信のようなプリミティブなところでは区別しないと思ったように動きませんのでご注意。 テキストファイルから読み込んだ”数値”とあるがテキストファイルであれば数字”です。 ASCIIコード８ビットとすれば 同じように１と書きますが 数字１は３１（HEX) ００１１ ０００１（B) 数値１は０１（HEX) ００００ ０００１（B) です。 それなので数字を送ってそれを数値に直して大小判断することになります。 この処理も上のURLのプログラムに入れる。 パソコン側がわからなければ別に質問を立てたほうがいいとと思う。
こんばんは 動作としてはこんな感じですか？ private void Form2_FormClosing(object sender, FormClosingEventArgs e) { this.Visible = false; Form dialog = new Form(); dialog.Owner = this; dialog.ShowDialog(); }
インテルグラフィックスカーネルモードドライバかな？ 基本自動更新なんだよね これ WindowsUpdateで更新されるのをまつか あとは INTELにいって新しいのを手動でおとすかですね 品名がわからないので この辺で自分のをさがしてみてください。 http://www.intel.co.jp/content/www/jp/ja/support/graphics-drivers/0...
quickbrwn~さんの情報を使わさせていただき回答しています。 でないと読めない。 デバッグは順序をよく考えてすすめる。 １．LEDの取り付け方向はあっているか？ volatile int led = HIGH; とし、 attachInterrupt(***);の行をコメントアウト。 これでLEDが点灯しなければLEDの配線を追う。 ２．スイッチの配線はあっているか？プルアップ／プルダウンはどうなっているか？ プログラムからは回路が予想できません。 sw == 0からは押したときGNDのようであるがattachInterrupt()からは押したときHIGHのようなので。 ３．Arduinoのピン番号とプログラムのattachInterrupt文の指定に間違いがないか？ attachInterrupt()は”割り込み番号”を指定するようだけどあっているか？ ４．割り込みがかかっているか？ 簡単なプログラムでチェックするのがいい。 led = ~led;以外のステートメントをコメントアウトする。貼り付けてあるプログラムはおかしい。!（ビックリマーク）ではない。 だいたい１〜４の順序ではないでしょうか？簡単なことから難しいことへの順序がいいです。 などなど
>surahutoさん 入力した文字をはりつけてくれ 読めない こっちで再現テストするし Sympy+Pythonでも積分可能なので そっちで試してみるのも良いかもしれん (他にも多数数式処理ツールあるので、Sympy以外でも良いけど)
C言語だけに限った話ではないが、コンパイルエラーが発生しないことと、意図した動作をするかは別であることを理解してください。 C言語では文字列は=では代入できないが、コンパイルエラーにもならない。 #include<stdio.h> int main(void) { char str[128]; int i; scanf("%s",str); for(i=0;str[i]!='\0';i++); if(i%2==1){ for(i;i>=0;i--)str[i+1]=str[i]; str[0]='0'; } printf("%s\n",str); return 0; } 文字列関連の関数とワーク用の変数を使えば、記述が少しはスッキリするかも、、、、
/* hunkhunk1022さん こんなかんじで… -----実行結果----- 0:300.000000 1:500.000000 2:700.000000 3:1100.000000 4:1500.000000 */ #include<stdio.h> #define DSIZE 3 //行数 #define AT 5 //列数 int main(void) { double Data[DSIZE][AT]={ {1, 4, 700, 10, 13}, {2, 500, 8, 1100, 14}, {300, 6, 9, 12, 1500} }; double Max[AT]={0};//列の最大値を入れる※１次元配列にしました int i,j; for(j = 0; j < AT; j++){//列数分 for(i = 0; i < DSIZE; i++){//行数分 if(i==0){ //１つ目はそのまま入れる Max[j] = Data[i][j]; }else if(Data[i][j] > Max[j]){ //２つ目以降は、大きかったら入れる Max[j] = Data[i][j]; } } //DrawFormatString(30 + 90*e, 200 + 20*f, Color, "%lf", Max[1][j]); printf("%d:%f\n",j,Max[j]); } return 0; }
WinForms なのか WPF なのか、 それともまったく別のものなのかわかりませんが、 WPF なら System.Windows.Threading.DispatcherTimer クラスで タイマー処理するという方法があります。
>SOR法での最適緩和定数ωとは、どう計算すればいいですか？ 「sor法 加速パラメータ」などで検索すると、例えば以下のようなサイトが出てくるので、それを読解すれば早いです。 Cにより近いC++のソースコードであり、すでに完成されたソースコードなので、もはや「どうするか」の次元ではなく、さらに、「どうやってやるのか」という疑問は吹き飛ぶと思います。 つまり、やり方、仕方そのものが掲載されていますので、あとはそれを納得するまで眺めれば、計算方法を理解できます。 SOR法の加速パラメータωを最適化してみた - eukaryoのブログ http://eukaryote.hateblo.jp/entry/2015/06/29/004723
もしかすると cmd.exe から直接 gcc を実行しようとしていませんか? だとしたらまず msys の bash.exe を起動し、bash から gcc を実行してみてください。 MinGW のファイルを /usr/include のような UNIX 流儀のパスでアクセスできるようにしているのは msys のシェルの機能です。 あと、私は msys2 を使っているので若干違うかもしれませんが、stddef.h は /usr/include ではなく、/usr/lib/gcc/x86_64-w64-mingw32/6.1.0/include/ の下ですね。
#include<stdio.h> void calculation(int,int,double*); struct DATA { char name[20]; int height; int weight; double BMI; }; int main(void) { struct DATA data; printf("名前 :"); scanf("%s",data.name); printf("身長:"); scanf("%d",&data.height); printf("体重:"); scanf("%d",&data.weight); printf("名前 :%s\n",data.name); printf("身長[cm]:%d\n",data.height); printf("体重[Kg]:%d\n",data.weight); calculation(data.height,data.weight,&data.BMI); printf("BMI :%5.1f\n",data.BMI); return 0; } void calculation(int h,int w,double *b) { double t; t=h/100.0; *b=w/t/t; } ＝＝＝＝＝＝＝＝＝＝＝ calculation(data.height,data.weight,&data.BMI); が無いのが0になる原因。 後は電卓で計算した場合と同じようになるように若干の修正をしている。 質問の場合ですとh=h/100;は小数点以下が切り捨てになる。 t=h/100.0; としているのは実数にするだけでは実数演算にならないからです。 t=(double)h/100; とするのが分かりやすいかも、、、、、 ＝＝＝＝＝＝＝＝＝＝＝ 整数での入力を想定しているとしても、小数点以下の演算が必要になるなら、初めから実数の変数に代入するという考え方もある。 #include<stdio.h> void calculation(double,double,double*); struct DATA { char name[20]; double height; double weight; double BMI; }; int main(void) { struct DATA data; printf("名前 :"); scanf("%s",data.name); printf("身長[cm]:"); scanf("%lf",&data.height); printf("体重[Kg]:"); scanf("%lf",&data.weight); printf("名前 :%s\n",data.name); printf("身長:%.0fcm\n",data.height); printf("体重:%.0fKg\n",data.weight); calculation(data.height,data.weight,&data.BMI); printf("BMI :%5.1f\n",data.BMI); return 0; } void calculation(double h,double w,double *b) { h/=100; *b=w/h/h; } どうでも良いことではあるが、このプログラムを他人が使うことを想定するなら、入力する時に単位を表示した方が良いかと思います。 特に身長は例えば160cmなら、1.6とか入力されそう、、、、、
C#のバージョンを決定づけているのは、MonoDevelopではなくて、Unityに含まれるmonoでしょう。 Windows版 C:\Program Files\Unity\Editor\Data\Mono\bin\mono.exe -V Mono JIT compiler version 2.0 (Visual Studio built mono) Mac版 /Applications/Unity/Unity.app/Contents/Frameworks/Mono/bin/mono -V Mono JIT compiler version 2.6.5 (tarball Tue Apr 12 22:30:16 CEST 2016) なので、C# 3.0のようです。 https://en.wikipedia.org/wiki/Mono_%28software%29 http://ufcpp.net/blog/2015/07/unityasyncbridge/ >C# 3.0相当 もっと新しいのもこっそり入っていて、 C:\Program Files\Unity\Editor\Data\MonoBleedingEdge\bin\mono.exe -V Mono JIT compiler version 2.11 (Visual Studio built mono) /Applications/Unity/Unity.app/Contents/Frameworks/MonoBleedingEdge/bin/mono -V Mono JIT compiler version 3.4.0 (unity-future-fix-elcapitan2/f503adb Wed Jul 15 15:15:36 CEST 2015) これだと、C# 4.0～5.0あたりかと思われます。
実は、結構簡単です。 まず、form のコードは、こんなおまじないを書きます。 C:\Users\nanco\test.html は、ご自分の html のパスを書いてください。 <System.Runtime.InteropServices.ComVisibleAttribute(True)> Public Class Form1 Private Sub Form1_Load(sender As System.Object, e As System.EventArgs) Handles MyBase.Load WebBrowser1.ObjectForScripting = Me WebBrowser1.Url = New System.Uri("file://C:\Users\nanco\test.html", UriKind.RelativeOrAbsolute) End Sub Public Sub CallMe(msg As String) MsgBox(msg & " OKOK") End Sub End Class これで、 html の javascript で、 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <HTML> <HEAD> <META http-equiv="Content-Type" content="text/html; charset=SHIFT_JIS"> <META http-equiv="Content-Style-Type" content="text/css"> <TITLE></TITLE> </HEAD> <BODY> <FORM><INPUT type="button" name="TEST" value="押してね" onClick="window.external.CallMe('KITAYO!')"></FORM> </BODY> </HTML> こんな感じで、 window.external.CallMe('hogehoge') を呼ぶと form の CallMe に引数を渡して飛んできます。
/* 2016/8/18 02:26:09 次のプログラムをstracat関数を使わずに、同じ実行結果と なるように、プログラムを作りなさい ＞＞＞stracat ← strcat ？ ＿＿＿何れにしろ「次のプログラム」にこれらは影も形もありません ＿＿＿文脈と文字列から、やりたいことは容易に想像出来るので ＿＿＿勝手に作ります、御参考に。 */ // Visual C++ 2013 #define _CRT_SECURE_NO_WARNINGS // VC++ only, to stop warning for fopen(), scanf() etc. #include <stdio.h> #include <stdlib.h> #include <string.h> char *strscat(char *s1,char *s2); int main(void){ ＿char＿str1[40],str2[40],str3[40]; ＿ ＿strcpy( str1, "Let's" ); ＿strcpy( str2, "study" ); ＿strcpy( str3, "programming." ); ＿ ＿strscat( str1, str2 ); ＿strscat( str1 ,str3 ); ＿ ＿printf ("%s\n" , str1 ); ＿ ＿// 終了 ＿printf("\n# 正常終了 #\n\n"); // 確認表示 ＿system("pause");＿// キイ待ち停止 ＿return 0;＿ // main()終了 } // strscat("aaa","bbb") → "aaa bbb" char *strscat(char *s1,char *s2){ ＿char＿＿*p=s1; ＿do{ p++; } while(*p); ＿*p++ = ' '; ＿do{ *p++ = *s2++; } while(*s2); ＿*p = '\0'; ＿return s1; } /* 実行出力：console Let's study programming. # 正常終了 # 続行するには何かキーを押してください . . . */
出力文字コードがUTF-8なのに画面表示がShift_JIS(WindowsならばCP932)になっているから起こる文字化けです。 出力文字コードと表示する文字コードを合わせましょう。 なお、閏年ロジック間違ってませんか。 100で割り切れかつ400で割り切れなかったら平年です。
コードだけとかフォームの画像だけでは関連性が掴みにくいと思うよ 必要なのは回答者が再現するための情報だけど、そもそも質問者さんが混乱しているならプロジェクト毎頼むのも良いかもしれない →有償・無償で色んな依頼先があるけど せめて画像のどのコントロールがコードのどのコントロールになるのか、画像に書き込むってのもあるよ
この辺はどうでしょうか？ 管理者権限のあるなしで動作が異なる。 今回作成したアプリケーションを管理者権限で実行した場合、管理者権限のない状態で実行しているExcelアプリケーションは取得できません。両者を管理者権限で実行するか、両者を管理者権限なしで実行するか、または、UAC(User Account Control)を無効にする 必要があります。 参考：http://pro.art55.jp/?eid=1304141
クイックソートと選択ソートは全然違いますので、 ソート部分は流用できません。 ごっそり入れ替えてください。 クイックソート https://ja.m.wikipedia.org/wiki/%E3%82%AF%E3%82%A4%E3%83%83%E3%82%A... なお、標準で用意されているqsort関数を使用する こともできます。
◆C言語… ◎極座標系の座標(r,θ)→直交座標系の座標(x,y)に変換する関数だと… #include <stdio.h> #include <math.h> #define pi 3.14159265 /*円周率の定義*/ #define r 2 /*半径の定義*/ int getXY(double rad) { double x , y; x = r * cos(rad); y = r * sin(rad); return x , y; } int main(void) { int deg; double rad; double x, y; for(deg=0;deg<=90;deg+=5) { rad=deg*pi/180; getXY(rad); printf("θ = %d deg\n",deg); printf("x = %f\n", x); printf("y = %f\n", y); } return 0; } 以上… ★蛇足… グローバル変数にする必要はあるけどね… 違うかな…(泣) getXYとmain関数内が不味いかな…？(泣) だとしたらdouble x,yを中止して#defineの直下の行で宣言するといいかもね… 以上… 早稲田大学理工学部マキ姫
DXライブラリは誰かが作った自作関数 知らない人が作った自作関数の使い方なんてわからない PlaySoundMem()なんて今初めて見た
kahgjaさん 1. エクセルから(*.csv)ファイルに出力して、それを使う。 2. エクセルから直接読むのは、上級?かな
>ItemをPlayerに追加する >Playerの中にある これが具体的にどういう状況か分からないとなんとも言えません。次からもっと具体的に書くようにしてください。 Playerというクラスがあってその変数に代入しているのか、それとも単にPlayerというオブジェクトのtransformの子につけているのか。多分後者だと思うけど、後者だったら int itemCount; //アイテムの数はこっちに保存 void CountItems(){ int count = 0; Transform[] objList = gameObject.GetComponentsInChildren(typeof(Transform)); foreach( Transform child in objList ) { if(child.gameObject.tag == "Item"){ count++; } } itemCount = count; } これでOKなはず。
ほとんど想像ですが。 Cは古いです。1970年代の技術で作られました。 複数の値を返せることを基本設計としてしまうと、その領域の確保だとか返り値の格納でコンピュータ様のCPUタイムを浪費してしまいます。 それはおそれ多いので、一つの値だけ、特にint型についてはレジスタ(特にアキュムレータ)に格納して返すことにすれば高速な処理が期待出来ます。 当時のコンピュータ(システム)の能力は低かったので、コンピュータ様のお時間を使うのは申し訳ないので人間が苦労する、というのが基本思想です。(完全にその思想に染まりきって、未だにCのやり方が当然だという解説をされる方も多いようですね) 高速大容量の今どきのコンピュータであれば、「それでどれだけ得するの?」というようなことも多いですが、昔と違ってCぐらいしか使える言語がないという状況でもなく、そう思った時には他の言語を選択出来ることも多いです。
// neutralize.c 弱酸&強塩基限定 /* 参考 : https://ja.wikipedia.org/wiki/%E4%B8%AD%E5%92%8C%E6%BB%B4%E5%AE%9A%... */ #include <stdio.h> #include <stdlib.h> #include <math.h> // 定数 #define ACID_V 10.0e-3 // CH3COOH体積 #define ACID_C 0.100 // CH3COOH濃度 #define Ka 1.75e-5 // CH3COOH電離定数 #define BASE_V 20.0e-3 // NaOH体積 #define BASE_C 0.100 // NaOH濃度 #define DELTA 50.0e-6 // 一滴の量 #define Kw 1e-14 // 水のイオン積 // プロトタイプ宣言 double calc_H_plus_in_acid(double Na_plus,double c); double calc_H_plus_in_base(double Na_plus,double c); int main(void){ // 変数宣言 double x,y,v,c,Na_plus,acid_mol=ACID_V*ACID_C; int i,kaisu=(int)(BASE_V/DELTA); // 酸性にて滴定 for(i=0;i<kaisu/2;i++){ x = DELTA*i; // 滴定量 v = ACID_V+x; Na_plus = (BASE_C*x)/v; c = acid_mol/v; y = -log10(calc_H_plus_in_acid(Na_plus,c)); // pH printf("%f\t%f\n",x,y); } // 塩基性にて滴定 for(;i<kaisu+1;i++){ x = DELTA*i; // 滴定量 v = ACID_V+x; Na_plus = (BASE_C*x)/v; c = acid_mol/v; y = -log10(calc_H_plus_in_base(Na_plus,c)); // pH printf("%f\t%f\n",x,y); } printf("## Calculation is over!\n"); } // ニュートン法による水素イオン濃度の計算 double calc_H_plus_in_acid(double Na_plus,double c){ double a=Ka+Na_plus,b=(Na_plus-c)*Ka,func,result=1.0; func = pow(result,2)+a*result+b; while(func > 1e-20){ result = result-(func/(2*result+a)); func = pow(result,2)+a*result+b; } return result; } double calc_H_plus_in_base(double Na_plus,double c){ double a=Ka+Na_plus,b=Na_plus*Ka-Kw-Ka*c,d=Ka*Kw,func,result=1.0; func = a*pow(result,2)+b*result-d; while(func > 1e-20){ result = result-(func/(2*a*result+b)); func = a*pow(result,2)+b*result-d; } return result; }
OSは？ とりあえず、環境にあったのを入れればいいですよ。 https://gcc.gnu.org/install/binaries.html
正解は、-64を表す①でしょう。
よくできていると思います。
/* 2016/8/3 15:38:08 c言語 フィボナッチ数列 emacsでフィボナッチ数列のn項を求めるプログラムをつくった のですがセグメンテーションエラーと表示され実効できません。 プログラムは以下のとおりです ＞＞＞ １．なんでもかんでも malloc では、ぎごちない場合がある。 ２．ここは、大きめの固定域を設定して、要求のnがこなせるかを ＿＿ チェックするだけにしておくとどんな感じになるか試す。 ３．固定域を int fsn[1000]; ぐらいにしても、実用上何も ＿＿ 問題ないし、ここに質問するレベルと使用環境（課題？） ＿＿ なら、このサイズで十分と思われる。 ４．上記に必要な変更の他、出力命令の改善を行った。 */ // Visual C++ 2013 #define _CRT_SECURE_NO_WARNINGS // VC++ only, to stop warning for fopen(), scanf() etc. #include <stdio.h> #include <stdlib.h> #define＿M＿ 1000 void fib(int n,int *a){ ＿int i; ＿ ＿a[0] = 0; ＿a[1] = 1; ＿for(i=2;i<=n;i++){ ＿＿a[i] = a[i-1]+a[i-2]; ＿} ＿return; } int main(){ ＿int＿ fsn[M]; // n項フィボナッチ数列の配列 ＿int＿ n;＿＿＿// フィボナッチ数列のn項 ＿int＿ k;＿＿＿// 上記を格納する配列のインデクス ＿int＿ repeat; // 入力繰り返しフラグ ＿int＿ ntry=0; // n 入力回数 ＿ ＿do{ ＿＿printf("n ?= "); scanf("%d",&n); ＿＿repeat = n<1 || M<n+1;＿// 0,1,2,...,n ＿＿if(repeat){ ＿＿＿if(ntry>5) goto ERR; ＿＿＿printf("n must be >0, or less than M(=%d)\n",M); ＿＿＿printf("repeat by another n, if please.\n"); ＿＿＿printf("may be able while ntry(==%d) <= 5.\n",ntry); ＿＿＿ntry++; ＿＿} ＿}while( repeat ); ＿ ＿fib(n,fsn); ＿ ＿printf("series for upto %d is:\n",n); ＿printf("----------------------\n"); ＿for(k=0;k<=n;k++){ ＿＿printf(" %d",fsn[k]); ＿＿if( k>0 && k%8==0 ){ ＿＿＿printf(" (～%d)\n",k); ＿＿} ＿} ＿if( k%8!=0 ) printf(" (～%d)",n); ＿printf("\n"); ＿ ＿// 終了 ＿printf("\n# 正常終了 #\n\n"); // 確認表示 ＿ERR: ＿system("pause");＿// キイ待ち停止 ＿return 0;＿ // main()終了 } /* 実行出力：console n ?= 30 series for upto 30 is: ---------------------- 0 1 1 2 3 5 8 13 21 (～8) 34 55 89 144 233 377 610 987 (～16) 1597 2584 4181 6765 10946 17711 28657 46368 (～24) 75025 121393 196418 317811 514229 832040 (～30) # 正常終了 # 続行するには何かキーを押してください . . . */
ソースファイルのより変わります。 大きな違いは Fortran77：固定フォーマット（ソースは7カラムから72カラムに書く） fortran90：フリーフォーマット
知らへんで～～～～～～
ScriptAの中で public bool swicthOn; //必ずpublicで宣言 ScriptBの中で public ScriptA switch; //画面上でスイッチのオブジェクトをドラッグ&ドロップする if(switch.switchOn == true){ } else{ } これでOK。基本中の基本。
PIC12F1612 は新しい石なので未経験ですが 単に ANSELA=0; デジタルI/Oポート指定が抜けている為と思われます プルアップ抵抗は10KΩで十分です、また内蔵プルアップ機能を使えば外付け抵抗は不要です
http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1116232596... の逆だよ。要は、aaが含まれない文字列。理由は簡単で受理状態(終了状態)が入れ替わってるよね。
下記のようなものは如何でしょうか。 \documentclass{jsarticle} \usepackage{amsmath,amssymb} \usepackage{enumerate} \begin{document} \noindent\textbf{問題2-4}\raisebox{-.3485zh}[1ex][-3ex]{\Huge{\text{$\boxplus$}}} \hrulefill （復元抽出・非復元抽出） $n$を5以上の自然数とする。1から$n$までの数字が1つずつ書かれたカードが1枚ずつ、合計$n$枚あり、箱の中に入っている。 \begin{enumerate}[(1)] \item 箱の中からカードを1枚取り出して数字を記録してカードを箱に戻すことを3回繰り返すとき、次の確率を求めよ。 \begin{enumerate}[(i)] \item 3つの数字がすべて5以下になる確率 \item 3つの数字の最大値が5となる確率 \item 3つの数字の中に1と5が必ず含まれる確率 \end{enumerate} \item 箱の中からカードを3枚同時に出すとき、上記の(i)(ii)(iii)の確率をそれぞれ求めよ。 \end{enumerate} \end{document} 問題2-4の4をカウンタかenumerate.styで扱うことも出来るかもしれませんが、こんな感じで…
一例です。 SetのひとつであるHashSetを使いました。 contains()メソッドで既に含まれているかを取得できます。 -- import java.util.HashSet; import java.util.Scanner; import java.util.Set; public class Yahooq14163088574 { public static void main(String[] args) { // 入力文字列を保持するためのインスタンス Set<String> set = new HashSet<>(); // 入力受付 Scanner scanner = new Scanner(System.in); while (true) { String inputStr = scanner.nextLine(); if (inputStr.equals("print")) { System.out.println(set); continue; } if (inputStr.equals("end")) { break; } if (set.contains(inputStr)) { System.out.println(inputStr + "はすでに入力されています。"); } else { set.add(inputStr); } } scanner.close(); } }
一例です。 -- import java.util.ArrayList; import java.util.List; public class Yahooq11163087601 { public static void main(String[] args) { List<String> list = new ArrayList<>(); list.add("イチゴ"); list.add("クリーム"); list.add("マンゴー"); list.add("チョコレート"); for (String s : list) { System.out.println(s); } } }
programmer_hiroさん ノーベル賞とか、フィールズ賞とか、何年間かの論文審査の上で選考される賞は、サイエンスというか学術的な土台からの積み上げが検証された事柄で無いと、受賞できないものです。 ところが、Ｃ言語のコンパイラは、プログラミング言語のデザインにおける学術的評価は低いといわざるを得ません。 後段に示すように、何時までも、ドロ臭い造りであり続ける宿命を負ったＣコンパイラに、サイエンスチックな賞など、与えるのは、不適切でしょう。 ＜補足＞ 何故なら、「未だに 誰も、学術的な厳格さでは、Ｃ言語の文法を記述できていない」からです。 その為、Ｃコンパイラの実装としてgccコンパイラやclangコンパイラの他、幾つも在りますが、「全く同一の仕様のＣコンパイラを、複数の実装者が創り上げた」という瞬間は、コレまで一度も無かったのです。 Ｃ言語が、AT&Tベル研究所のデニス・リッチーが主体となって、1972年に作られて５０年近くも、曖昧な文法のまま放置されてきた理由もあります。 それは「Ｃコンパイラを開発メンバを招集できるようなスポンサーは、ソノ時々の新しいＣＰＵのメーカで、何時もＣＰＵが完成してから間も無く、”早く、動くＯＳを造れ！！”、”ＯＳを造る前提のＣコンパイラを早く作れ”、という突貫作業で造られ続けてきたし、これからも突貫作業が続くからです。 ”突貫作業”のニュアンスは、数ヶ月位の場合もあるが、最近のＩＴ業界のニュースにモレ出てきた例も在ります。 Apple社がmacやiPhoneのAPUであるARM系のCPU用のコンパイラとして、初期の段階はgccコンパイラを用いていたものの、gccコンパイタが図体が大きくなりすぎて簡単にカスタマイズできなくなってきた。 そして、「gccコンパイラの改造速度ではビジネス的に間に合わない！だから0から綺麗に作り直したclangコンパイラに乗り換えるのだ！！」ということが起きたそうです。 最近のモダンなプログラミング言語は、Ｃ言語の20分の1以下のコンパクトサで、数学的にも厳格に定義できていて、なおかつＣ言語より高機能なプログラミング言語は幾つもあるのです。 ＜参考１＞ ★Towards・Higher-Order Syntax of・C Programming Language http: www.kmonos.net/pub/Presen/HiC.pptx 引用「 中間的な表現力を持つ言語を使って. C言語の文法を記述してみたい. ・Cの文法は文脈自由ではないと言われる。 ・文脈自由じゃないなら、BNFより強力な文法記述言語で書けばいいじゃない！ ・ISO/IEC 9899:1999 自然言語で書いてある ・gcc, clang, ... ： C や C++ で書いてある ・「∞: チューリングマシン」、「再帰文法」「停止証明付き計算」 「文脈依存文法」 この辺なら書けるはずだけど・人類には難しい ・高階文法でもまだ無理なことがわかりました。 」 ＜参考２＞ 智恵袋には、Ｃ言語の文法を正確に理解できている人が居ない証拠； ★ｃ言語の複雑さを悟るクイズ 「a*b*c; に括弧を入れたパターンの内、有効な宣言文と、それ以外（代入文や式等）として多重に解釈できるパターンを、出来るだけ沢山列挙してみてください」 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1414284588... このパズルは、上述の論文が元ネタで、Ｃ言語の文法を正確に理解していないと解けない問題だが、まともな正解例を何例か示すことができたのは、智恵袋では、私位しかいません。 回答例＝http ://ideone. c o m/j2vf1n
文面から察するに、オブジェクトの移動に関して誤解があるように思われます。 まず、「Translate」は、物理挙動とは関係の無い処理です。 移動と言うよりは、ごく短い距離を連続してワープする事で、画面上では、あたかも移動しているかのように見えているだけです。 なので、本来であれば、「Translate」で動いているオブジェクトは、他のどのオブジェクトとも衝突できません。（めり込むだけ） しかし、ご質問の内容では、物理挙動以外の方法で動かしているオブジェクトに、Rigidbodyが付いている事で、意図せずして弾かれるという現象が起きているものと思われます。 つまり、本来であれば、Rigidbodyを持つコライダー同士が接近し、接触した瞬間に衝突イベントが発生し、停止するなりの処理を行うハズです。 が、今回の状況では、Rigidbodyを持つコライダー同士が、短距離のワープによって近付き、どかの段階で相手のコライダーにめり込んだ位置にワープする事になります。 重なったままでは、正常に物理挙動が計算できない為か、Rigidbodyを持つコライダー同士がめり込むと、弾けるようにして離れようとします。 これが、今回の原因と思われます。 結論としては、Rigidbodyを持つオブジェクトを移動させるなら、「velocity」で移動速度を指定するのが、最も単純で分かりやすい方法ですので、これに切り替えてみてはいかがでしょうか。 ↓公式ドキュメント「Rigidbody.velocity」 docs.unity3d.com/ja/current/ScriptReference/Rigidbody-velocity.html
PICのC言語と言っても色々なCコンパイラがあります。 中には RC0のようにビット単位の名称を使用できないものもあります。 PORTAはバイト単位の名称でほとんど全部のCコンパイラで使用できます。 ポート名と16進数の論理積を用いた書き方はビット単位の名称を扱えないCコンパイラでも通用する書き方になります。
環境に合わせてでいいと思います。 ソースの流用が前提で、（Win→Linux等）プログラミングしなければならない場合はUTF-8、Winのみだったらs-jisという形で。 サンプルプログラムの書きためでしたら、そこまでこだわる必要もないでしょうし、どうしても文字コードの変更が必要になった場合に、テキストエディタ等で文字コード変換して再度保存すればいいと思います。
割り込みを使ってみれば良いかと思います。 ピン変化割り込みとか 参考になりそうなサイト https://developer.mbed.org/users/okini3939/notebook/ref_jp/
ラズベリーパイにワイヤレスマウス・キーボードとWiFiアダプターと 「ラズベリーパイ」専用の液晶ディスプレイとAC電源を繋いで、PCとして使っています。 電子工作等にも使っています。 参考HP「http://store.techshare.jp/html/page101.html」 従って、「ラズベリーパイ」に他のパソコンは、ロボットなど、本体を積み込まない限り必要はないのではないでしょうか？ 夏休みの課題とのことなので、こんなところで。
＞C言語でのゲーム作りの参考になるサイト Rogue http://yozvox.web.fc2.com/526F677565.html デバッグではじめるCプログラミング : 山本 貴光 : 本 : Amazon https://www.amazon.co.jp/dp/4798114197
/* tanabe_tatsuya_0516さんへ こんなかんじで… -----実行結果----- 5 ○△□○△ */ #include <stdio.h> int main(void) { char *list[]={"○","△","□"}; int n,i; scanf("%d",&n); for(i=0;i<n;i++){ printf("%s",list[i%3]); } printf("\n"); return 0; }
条件を満たそうとするとこれ以上は短くならなかった import static java.util.stream.IntStream.range; import static java.lang.System.out; public class T{ public static void main(String[]a){ a=range(1,13).mapToObj(i->i+"月").toArray(String[]::new); for(int i=0;i<12;out.println(a[i++])); } }
その書き方だと、 for /r %%i in (*.jpg *.jpeg *.cr2) do ( と混同されてループ変数%%iと区別が付かないかと。 " " で囲ったら上手く行くかも。 for %%i in ("E" "F" "G" "H" "I" "J" "K" "L" "M") do (   for /r "%%i:\DCIM\" %%k in (*.jpg *.jpeg *.cr2) do (     if exist %%k (move /-Y %%k %outputdir%) ) )
#include <iostream> int main () { std::cout << "(^_^)\\/\n"; return 0; } こんな感じです。
人に教えを乞うのに 何でID非公開なんですか？ ID非公開のバカが、はめまして(笑)
Intel Fortran に付属の installation guide ないし インストール・ガイド に詳しいことが書いてあるので、それを参照するのがもっとも確実である。（必要とするものがヴァージョンごとに異なっているので。） 最近の Intel Visual Fortran では、コマンドライン実行の場合でも Microsoft 配布の SDK などをあらかじめインストールしておく必要がある。不明だがリンカなどを利用していたと思う。 Visual Studio との統合に関しては、Visual Studio を先にインストールしておく必要がある。Fortran のインストーラが、インストールされている Visual Studio を探し出して、統合できるヴァージョンならば統合するかどうか、選択肢を出したと思う。（日本語環境ではうまくいかないことがあった。） たしか有料版では Visual Studio 2010 込みのインストーラもある。
・アルファベット（小文字）判定 if ( char >= 'a' and char <= 'z' ) ・toupper関数 大文字へ変換 （大文字から大文字でも問題なし） これが分かればあとは完成できるはず。 がんばってください。
１． Ｘ＿__X1＿_X2___10進数 000__111__000__0=(0) 001__110__111__1=(-7) 010__101__110__2=(-6) 011__100__101__3=(-5) 100__011__100__(4)=-4 101__010__011__(5)=-3 110__001__010__(6)=-2 111__000__001__(7)=-1 ２． ＞＞ 2、1、の結果を用いて、「この計算機の」積和標準形を求めよ ちょっと、この「」部分がひっかかって悩んでます。。。
/* 2016/8/2 13:14:55 C言語について質問です。 以下に示すソースコードは、配列と関数の定義を使ったものです。 以下のソースコードを変更するところは変えて ファイル(.txt)から入力⇒ソート⇒ファイルに出力するプログラム に変更していただけませんか？ 10個の数字があり、ソーティングして小さい順に並べ替えたいです。 よろしくお願いします。 */ // Visual C++ 2013 #define _CRT_SECURE_NO_WARNINGS // VC++ only, to stop warning for fopen(), scanf() etc. #include <stdio.h> #include <stdlib.h> #include <math.h> #define N (10)＿＿＿// データ数 void sort(int *data); int main(void){ ＿char＿＿*fni="tst.txt"; // 入出力ファイル ＿char＿＿*fno="tst.log"; // 出力ファイル ＿FILE＿＿*fi;＿＿＿// 入力ファイル ＿FILE＿＿*fo;＿＿＿// 出力ファイル ＿int＿＿ num[N];＿ // データ保存配列 ＿int＿＿ i;＿＿＿＿// 配列のインデクス ＿ ＿// 入力 ＿if((fi=fopen(fni,"r"))==NULL){ ＿＿printf("%s not found, stop job.\n",fni);＿goto ERR; ＿} ＿printf("数値は "); ＿for(i=0;i<N;i++){ ＿＿fscanf(fi,"%d",num+i);＿printf(" %d",num[i]); ＿} printf("です\n"); ＿printf("%s から読込みました\n",fni); ＿fclose(fi); ＿ ＿// ソート ＿printf("\n昇順に並べ替えます\n"); ＿sort(num);＿printf("sort(num);\n"); ＿printf("交換しました\n\n"); ＿ ＿// 出力 ＿if((fo=fopen(fno,"w"))==NULL){ ＿＿printf("%s not opened, stop job.\n",fno); goto ERR; ＿} ＿printf("数値は "); ＿for(i=0;i<N;i++){ ＿＿fprintf(fo," %d",num[i]); printf(" %d",num[i]); ＿} printf("です\n"); ＿printf("%s に書き込みました\n",fno); ＿fclose(fo); ＿ ＿// 終了 ＿printf("\n# 正常終了 #\n\n"); // 確認表示 ＿ERR: ＿system("pause");＿// キイ待ち停止 ＿return 0;＿ // main()終了 } // 昇順にソートする void sort(int *data){数値は＿2 4 6 8 10 1 3 5 7 9です tst.txt から読込みました 昇順に並べ替えます sort(num); 交換しました 数値は＿1 2 3 4 5 6 7 8 9 10です tst.log に書き込みました # 正常終了 # 続行するには何かキーを押してください . . . ＿for(int i=0;i<N-1; i++){ ＿＿for(int j=i+1;j<N;j++){ ＿＿＿if(data[i] > data[j]){ ＿＿＿＿int tmp = data[i]; ＿＿＿＿data[i] = data[j]; ＿＿＿＿data[j] = tmp; ＿＿＿} ＿＿} ＿} } /* 実行出力：console 数値は＿2 4 6 8 10 1 3 5 7 9です tst.txt から読込みました 昇順に並べ替えます sort(num); 交換しました 数値は＿1 2 3 4 5 6 7 8 9 10です tst.log に書き込みました # 正常終了 # 続行するには何かキーを押してください . . . */
このへん見ればわかると思う。 http://www.scs.stanford.edu/histar/src/pkg/uclibc/include/limits.h http://www.tutorialspoint.com/c_standard_library/limits_h.htm
ID非公開さん int w[2000]; void fx(int x,int s,int k) { int i; if(x == 1) { if(k > 1) { for(i=0;i<k;++i) { if(i==0) printf(" = %d",w[i]); else printf(" * %d",w[i]); } } return; } for(i=s;i<=x;++i) { if((x % i) == 0) { w[k] = i; fx(x/i,i,k+1); } } } void gx(int u) { printf("%d ",u); fx(u,2,0); printf("\n"); } int main () { int d; d=24; do { gx(d); printf("Input not zero!"); scanf("%d",&d); }while(d > 1); return 0; }
questionacount3さん べき乗の計算は y = x^k (xのk乗) となりますが、power関数の引数と変数に対応させると、 base → x n → k p → y となります。 あと、プログラム間違っていますね。下記に訂正したものを掲載します。 /* ←★ココだよ！★ */ の部分をよく見てください。 #include <stdio.h> int power(int m, int n); int main() { int i; for (i = 0; i < 10; i++)/* ←★ココだよ！★ */ printf("%d %d %d\n", i, power(2, i), power(-3, i)); return 0; } int power(int base, int n) { int i, p; p = 1; for (i = 1; i <= n; i++)/* ←★ココだよ！★ */ p = p * base; return p; }
/* 2016/8/16 15:08:09 c言語の問題を解こうとしたのですが、 どういったプログラムになるのかわからなかったので 質問しました。 問題 char型の配列を、"OKINAWA"を初期配列として宣言し、 文字列の順番を逆にして、"AWANIKO"と出力するプログラムを 作りなさい */ #include <stdio.h> #include <stdlib.h> int main(void){ ＿char＿okinawa[]="OKINAWA"; ＿char＿*p=okinawa; ＿ ＿printf("original: "); while(*p) printf("%c",*p++);＿ p--; ＿printf("\n"); ＿printf("reversed: "); while(okinawa<=p) printf("%c",*p--); ＿printf("\n"); ＿ ＿// Hold screen before back to OS. ＿printf("\n# Normal End #\n\n"); ＿system("pause"); ＿return 0; } /* 実行出力：console original: OKINAWA reversed: AWANIKO # Normal End # 続行するには何かキーを押してください . . . */
http://www.avnet.co.jp/embedded/column/Theme3/04.aspx のサイトが参考になるかも知れません。
dszsxpmさん 囲碁・将棋・C言語 本を読めば、中学生でもわかる。 気楽に学ぶ。
＞組み込みのC言語を使った簡単なプログラミング Z80のシミュレータでCPUの構成と機械語のコツを学ぶ
周期が同じなら同じタイマーを使用することができます。
OSは、機械語で作れます。 機械語は、コンピュータを直接制御できます。
EventChartCustom()でユーザ定義イベントを任意のチャートへ送ることができ、送信先チャートのOnChartEvent()で受け取ることができます。 ボタンが押されたチャートのOBJECT_CLICKイベント契機で、他のチャートにユーザイベントをブロードキャストしてやればよいと思います。 ほぼそのような仕様のサンプルが以下のページにありました。 https://docs.mql4.com/eventfunctions/eventchartcustom
内容がテキストなので、データ幅がバラバラだと思いますので、一旦全部読みだしてから不要なデータを削除して、書き込み直すのが一番スマートでしょう。 または… １．読み出しつつ、作業用ファイルに書き込みつつ不必要データを書込みスキップして目的の内容を作成。 ２．元ファイルを削除。 ３．作業用ファイルの名前を元ファイル名に変更 みたいな感じでしょうか… //ファイル移動（ファイル名変更）関数 http://yukifx.web.fc2.com/sub/reference/19_file_func/cone/file_move... ------------------------------------------------------------ ただ、なぜそのような事をしたいのかという根本的な問題からの解決を考えると、よりスマートな解決法が存在するかもしれません。
一例です。 -- package test20160808.q10162701125; public class NewMember extends Member { public String tel; // 電話番号 public void displayTel() { System.out.println("電話番号: " + tel); } @Override public void display() { System.out.println("名前: " + name); } }
showClickにIMouseインターフェースの実装クラスのインスタンスを渡せばよいと思います。 以下一例です。 -- package test20160815.q13162994958; public class Porimo2 { public static void main(String[] args){ showClick(new PrimeMouse()); showClick(new FujitsuMouse()); } private static void showClick(IMouse mouse){ mouse.click(); } } -- package test20160815.q13162994958; public class PrimeMouse implements IMouse { public void click() { System.out.println("Primeマウス"); } public void doubleClick() { System.out.println("Primeマウス連打"); } } -- package test20160815.q13162994958; public class FujitsuMouse implements IMouse { public void click() { System.out.println("富士通マウス"); } public void doubleClick() { System.out.println("富士通マウス連打"); } } -- package test20160815.q13162994958; public interface IMouse { abstract public void click(); abstract public void doubleClick(); }
以下の一文だと思います。キャストが必要な問題だと思われます。 ((Kodomo)oya).showName();
一例です。 --Manga.java-- package test20160808.Yahooq11162700331; public class Manga extends Book { String author; // 著者 String title; // タイトル int chapter; // 章 public int getPageByChapter() { // 1章あたりのページ数を返す return getPage() / chapter; } } --MangaTest.java(Mangaクラスを使うテストクラス)-- package test20160808.Yahooq11162700331; public class MangaTest { public static void main(String[] args) { Manga manga = new Manga(); manga.setPage(100); manga.chapter = 3; System.out.println(manga.getPageByChapter()); } }
ここでいうカプセル化とは、フィールドを private にし、getter / setter を作成せよ、ということでしょう。答えは以下のコードになります。あくまで教科書的な回答で、本来は getter / setter を用意するだけでカプセル化されるわけではありませんが。 -- class Capsule{ private String name; private double amount; private boolean poisonFlag; public String getName() { return name; } public void setName(String name) { this.name = name; } public double getAmount() { return amount; } public void setAmount(double amount) { this.amount = amount; } public boolean getPoisonFlag() { return poisonFlag; } public void setPoisonFlag(boolean poisonFlag) { this.poisonFlag = poisonFlag; } }
参考 XC8 BLINK GP2 -- GPx 点滅するポート番号 0,1,2,4,5 __delay_ms(500); -- 点滅速度 単位mS / 500mS=0.5秒 間隔 #include <xc.h> #pragma config CP=OFF #pragma config OSC=IntRC #pragma config MCLRE=OFF #pragma config WDT=OFF #define _XTAL_FREQ 4000000 // 4MHz void main(){ OPTION=0xDF; // GP2-I/O T0CS_OFF GPIO=0; TRISGPIO=0B11001000; // GPIO 5,4,2,1,0 OUTPUT while(1){ GP2 ^=1; // GP2 反転 __delay_ms(500); // 0.5S } // while }
タスクスケジューラを使わないとなると、力押ししか手段はなくなります。 Do WScript.Sleep 100 Loop Until (Now() = "2016/08/14 22:02:00") MSGBOX Now() こんな形で、指定時刻が得られるまでループさせておきます。 他の手段だと、間接的にであってもタスクスケジューラを利用する方法になってしまうでしょう。
>a[i] = i-- * 2 + 1; この動作は未定義。 http://www.kouno.jp/home/c_faq/c3.html#0
間違いがいくつか。 赤の下線は、なんらかのミス として認識されています。 最初の #include文にもついています。 見ると、 studion.h となっていますが、そんなものありません。 (自作ヘッダならともかく。) stdio.h です。 (1) とかは外してください。 (2) は回答されていませんよ? (3)も。 ... もしかして問題文ですか？それならOKです。 エラトステネスのふるい の概念というかロジック(?) を思い出してください。 エラトステネスのふるいは、 0から n-1 の n 個の配列を使います。 0 と 1 は 素数に含まれませんから 0番目と1番目のフラグを折ればいい。 で、2から開始... で、すべて終わったら、 フラグが立っているものが素数という扱いです。 なので、表示等で素数を・・・のときは、 if文でフラグが立っているかどうかを調べて、立っていれば素数、立っていないなら素数ではない という風に。 たとえば、質問の例だと、 0 = 素数でない, 1 = 素数 ( 0番目と1番目が 0 になっていることから。 ) となっていますので、 if( flag[i] == 1 ){ __printf( "%d : 素数" ); } を for文に埋め込む。みたいな。
学習方法っていろいろあります。 ひとつだけではないです。 なので一例。 私は 1. その言語の最低限必要な書式を覚える 2. 実際に作りたいもの、あったらいいなと思うものをイメージ 3. ( なくてもいいが ) 2をノート等に絵や文字で表現 ( 忘れないようにするため。 ) 4. 3 ( または2 ) を実際に作る 5. わからないことがあれば書籍やサイトを辞書代わりにして調べる 6. 5でもわからないなら、最終手段として知恵袋やその手の掲示板で聞く みたいな感じ。 あと、いろんなソースコードを読む。 サイトや書籍はひとつだけではなくて複数読む。 (読んでいるうちにひらめくことがある。) 「データ構造とアルゴリズム」もやってみる。 オブジェクト指向言語 ( C++, Java etc. ) なら 「デザインパターン」もやってみる。 「"C++" デザインパターン」等で検索する。 とにかく何度も組んでみる。挑戦してみること。
他の方もおっしゃっているように、 情報が少なすぎます。 C#やJava等の別の言語にするとき、どういう風に記述すればいいのか... なのか、 JNI等で Javaと連携をとりたいが、 String 型のため、どういう風にすればいいか... なのか、 String クラスっていう自作クラスを作ってstringを使いやすくしたものに... なのか、 ... もしかして、string型の配列ですか？ 大文字と小文字ではだいぶ印象が変わりますよ？ もし配列にしたいなら、普通に string sLine[10]; // sLineという変数を10個 (?) とすればいいと思いますよ？
Player character();//これはPlayerを返す関数のプロトタイプ宣言ですか？ それとも、Player character;の間違いですか？
>gmailid1さん 入れなおす必要はなくて http://nozawashinichi.sakura.ne.jp/fs/2009/07/octavemac-x11-or-aqua... に従って必要な設定を行なえば良いと思う 適当にやってるからわけわからなくなってるので ちゃんと調べてからやりましょう 本家の文書が一番信頼できるけど 今回の上のリンク先を探すように octave terminal とか「ツール名 キーワード」「ツール名 やりたいこと」「OS名 ツール名 やりたいこと」「OS名 ツール名 キーワード」などでネット検索しても良い
append([a,b], [c,d], X). ↓ append([b],[c,d],X). /* １つめの引数を分割して再帰 */ ↓ append([], [c,d], X). /* １つめの引数を分割して再帰 */ ↓ append([], [c,d], [c,d]). /* １つめのappend定義によって確定 */ ↓ append([b],[c,d],[b,c,d]). ↓ append([a,b], [c,d], [a,b,c,d]). という動きになります。 処理系によって、debugとかtraceとか、途中の式を表示しながら動かせる機能があるので、調べてみてください。
整数は小数点以下の無い数です、全てのビットで値を表現します。浮動小数点は小数点が浮動ですのでビットを指数部と仮数部に分けて持ち極端に小さな値から極端に大きな値を記憶出来ます、ただし、仮数部の桁数の関係で計算した時に丸められて誤差が出る場合が有ります。２の補数は加算回路で引き算が出来るメリットが有ります。
答えは①という事でいがが？
>前回の質問で いつの質問？ここはチャットじゃないもんで、明示しないとわからん で本題だけれども、謎だなぁ。 VSを修復インストールしてみるか、ウィルス対策ソフトをアンインストールして試してみるか、VS入れなおしてみるか、くらいしか浮かばない。
n>=1に対し G(n)= |F(n+1) F(n)| |F(n) F(n-1)| とおくと |1 1||F(n+1) F(n)| |1 0||F(n) F(n-1)| = |F(n+2) F(n+1)| |F(n+1) F(n)| =G(n+1) ∴ G(n+1)= |1 1| |1 0| G(n) (n>=1) ∴ G(n)= |1 1|^(n-1) |1 0| G(1) G(1)= |F(2) F(1)| |F(1) F(0)| = |1 1| |1 0| より G(n)= |1 1|^n |1 0| (n>=1)
Character.isDigitメソッドで数値かどうか判定できます。 以下、サンプルです。 --ソース-- package test20160731; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Yahooq12162352827 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); char[] aaa = new char[2]; for(int i = 0; i < aaa.length; i++){ String str = br.readLine(); aaa[i] = str.charAt(0); } for(int i = 0; i < aaa.length; i++){ if (Character.isDigit(aaa[i])) { System.out.println(aaa[i] + "は数値です。"); } else { System.out.println(aaa[i] + "は数値以外です。"); } } } } --実行例-- a1 1a aは数値以外です。 1は数値です。
＞下の画像のような図 エスパー検定３級試験・遠視
単精度：2進数で仮数部２３ビット、指数部８ビット、 符号1ビット →１０進数だと 有効数字７桁くらい、 大きさは10の±38乗くらい 倍精度：2進数で仮数部５２ビット、指数部１１ビット、符号1ビット →１０進数だと 有効数字１５桁くらい、 大きさは10の±308乗くらい ＞数字の直後にd0をつけるのはDouble Precisionですか。 間違いではない。 指数表現 1000→1.0e3 の倍精度版 1000→1.0d3 → 1000d0でも間違いではないがアホっぽい。
gatoringoriraさん main()がないと、テストできない。
問題ありません。 http://www.wdic.org/w/TECH/%E3%82%B5%E3%83%95%E3%82%A3%E3%83%83%E3%...
どうぞ。 http://neareal.com/1230/ ちなみに、初心者の場合コードを０から考えるのは恐らく不可能です。 １．「どうしたら目的のコードを検索出来るか」を考える。（今回は「unity ドラッグ オブジェクトを動かす」で発見しました） ２．お手本となるコードを見付けたらそのままコピペする。 ３．そのコードがなぜ動いているか考える。 →わからないスクリプトがあったら、その部分だけ調べてみる。 →お手本のコードを少しだけ改変してみる。 これを繰り返していると、Unityがどう動いているか、どのコンポーネントがどんな役目を持っていてどうすればどんな動きをするのかわかってきます。 コードを０から考えるのはそれからです。
いいと思います ありです
splitは解決したようなので、後半の改良ですが・・・ サンプルソースのうち、if文と「int iAns = iVal1 + iVal2;」以外は各計算式で共通なので、共通部分を何度も書いているとすれば無駄かと。 個別の部分だけをif文で切り替えるのはどうでしょう♪
見方によると思います。 【C言語は簡単】 文法が単純なんですね。一瞬で覚えられます。覚えるべきところがあまりないからです。 演算子がやや多めですけれども、機械語の感覚からするとあまり違和感が無いため、これまた習得の妨げにはなりません。 おそらく１週間はかからないと思います。ていうか、２日もあれば十分じゃないでしょうか。それくらい簡単なものです。 【C言語は難しい】 前述の通り、C 言語が難しいだなんて、まずそういうことは無いです。なのに１００人中１００人（じゃないか、１００人中９０人くらいにしときますか）、C 言語は難しいと言う。 何故ですかね。 C 言語が難しいように見えて実は、C 言語ではない部分が難しかったりするのですよ。 （１）二進数、ブール代数 二進数やブール代数の勉強って C 言語に入門しようとする何か月も前に終わってなければ駄目ですよ。まさか、C 言語と同時入門だなんて、それじゃ C 言語も（？）ビックリです。 ビット演算の & 、 | 、^ 、そして >> と << とか、二進数を知らずにどうやって勉強するの？無理ですよね。 & と &&、| と || の違いとかも、ワケが分からなくなってしまう可能性が大。 ! 演算子で論理反転させて、&& が || になったり、その逆だったり、とか、そういうのも C 言語と同時入門って変ですよ。そういうことするから難しくなる。 （２）メモリのこと メモリのことが分かっていない状況でいきなり C 言語に入門したら大変だと思う。ポインタが分からないとかいう話をよく聞きますけれども、それ、ポインタが問題なのではなくて、メモリのことが分かってないだけのことです。 配列の勉強とかで [ ] 記号が出てくる。実際、[ ] は演算子なんですよね。それと * 演算子と、どちらで書いても意味は同じだなんて聞かされると、入門者の多くは驚いてしまうと思います。 他の言語にあるような立派な配列が C 言語にあるわけがありません。単に、メモリ上に連続領域が確保されている（あるいは、そのように想定されている）、というだけの話です。メモリのことが分かれば配列もポインタも直ちに理解出来てしまいます。全く悩むべきところがありません。 反対に、メモリのことが分かってないと配列のことも理解不能。ポインタもダメ。なのに両者を絡めた練習問題とかが出てきてしまって、そうなったらもう丸投げ質問を知恵袋でするしかないでしょ。 （３）システムのこと C 言語単体で何かを出来ると思っていたら大間違いです。出来るわけないですね。だって、言語自体には入出力の機能がありませんから。 一応、ライブラリ関数に古臭い printf だの scanf だのといったバカ関数があったりしますけど、こんなのでまともなプログラムなんか作れる筈がないです。 文字を大きくするにはどうしたら良いかとかはマシな方かも。色を付けるには？曲の演奏？動画再生？そういった質問が出て来ることも多々あるわけですが、だから、できるわけないでしょ。ということを知らずに C 言語に入門してしまうなんて…。 ですからね、C 言語でそんなことできたらおかしいって。 でも、出来る。 システムを特定すればね。システムが備えている機能を呼び出す。OSの機能呼び出し（システムコール、Windows の場合なら Win32 API）です。C 言語で呼び出すことが出来ますからね。 じゃ、呼び出すとしますか。 どういう関数があるんだろう。引数は？戻り値は？ ここから大変なことになります。 何千（いや、何万かな）とある機能呼び出しをどうやって覚えれば良いの？説明見てもワケが分からないし…。 そりゃそうですよ。単に一つの関数を呼び出して済む話ではないのです。準備処理があって、そして本番（？）の処理、その後の処理…とか。いろいろやって、目的の動作を行わせることが出来る。その流れを全部分かってないと辛いですよ。 C 言語、難しい…。 いや、C 言語じゃなくて、システムの機能呼び出しが難しいんですよね。 とか、こんな具合で C 言語そのものとは関係ない次元で難しいって皆さんおっしゃってると思う。そんなことでは丸１年やっても無理でしょう。２年やっても無理かもしれませんよ。というよりも、その前に投げ出してしまうのが普通だと思います。なぜならば、その途中段階では全く面白くないバカっぽいプログラムしか出来ないからです。それじゃ面白くないでしょ。だから続かないのです。 え？面白いって？ バカっぽいプログラムでも自分で作ったら面白いって？ そう思える人は成功します。そう思える人のみ、成功します。数としてはあまり居ませんよ。だって、面白くないもの。そんなので面白いって思えるなんて、滅多に居ませんからね。 《備考》 一般教養という意味合いで C 言語に入門する場合、それで本当に C 言語技術を習得しようというわけではないですから、これは何か月か取り組んで雰囲気を体験してですね、大雑把な形で理解できれば、とりあえずそれだけでも成功かもしれません。その程度であれば、C 言語と二進数とかの同時入門でも、そんなに難しくないかもしれませんね。
>まではOKだと思います。 OKじゃないんじゃ？ 5.75=101.11(2進数)=1.0111*100(2進数) 100(2進数)=2^(2)=2^(129-127) ゆえに、 S=1 E=10000001 M=01110000000000000000000 11000000101110000000000000000000(2進数)=C0B80000(16進数) だから、④です。 試験では、先頭が全て異なることに着目。 5.75=101.11(2進数)=1.0111*100(2進数) E=10000001 さらにマイナスなので、1100(C)から始まるのを探せばいい。 だから④です。
cgengoaquaさん 以下抜粋部で、for文の繰り返し条件の不等号が逆でした。 /* ←★ココだよ★ */とした部分が直したところです。 printf("\n得点ヒストグラム\n\n"); printf("-------------------------------\n"); printf(" 0～ 19 %d ", a); for (k = 0; k < a; k++) {/* ←★ココだよ★ */ printf("*"); } printf("\n20～ 39 %d ", b); for (k = 0; k < b; k++){/* ←★ココだよ★ */ printf("*"); } printf("\n40～ 59 %d ", c); for (k = 0; k < c; k++){/* ←★ココだよ★ */ printf("*"); } printf("\n60～ 79 %d ", d); for (k = 0; k < d; k++){/* ←★ココだよ★ */ printf("*"); } printf("\n80～100 %d ", e); for (k = 0; k < e; k++){/* ←★ココだよ★ */ printf("*");
なんか、変です。 関数のポインタを渡しても、引数が無いと計算してくれませんし、 無駄です。 これは、平均を覚えておいて、 値を渡す様に直してください。 #include<stdio.h> #include<math.h> float sd(int, float[], float); float ave(float, int); int main(void){ int n; float x[100], kei = 0, ave1; printf("データを入力して下さい。\n"); n = 0; while(1){ printf("%d 件目-> ", n + 1); scanf("%f", &x[n]); if (x[n] == 0)break; kei = kei + x[n]; n++; } printf("合 計＝%10.1f\n", kei); printf("件 数＝%10d\n", n); printf("平均値 ＝%10.1f\n", ave1=ave(kei, n)); printf("標準偏差＝%10.1f\n", sd(n, x, ave1)); return 0; } float ave(float kei, int n){ return kei / n; } float sd(int n,float x[],float ave){ int i; float sum = 0, sd; for (i = 0; i < n; i++){ sum = sum + (x[i] - ave)*(x[i] - ave); } sd = sqrt(sum / n); return sd; }
List<T> tlist =new List<T>(); List<List<T>> ttlist= new List<List<T>>(); ttlist.Add(tlist); 実行していないので、ビルドエラーになったらご容赦。
おそらくscanfが悪さをしています //a値をキーボードから入力する puts("Type a value."); scanf("%d",&a); この部分で標準入力バッファには最後の入力の改行が残ってしまいます その後, 下から5行目のgetchar();で残っていた改行が読まれるため 入力待ちにならないのでしょう scanfの部分を //a値をキーボードから入力する puts("Type a value."); scanf("%d%*c",&a); // %*cで残った改行を読み捨てる にすればよいと思います ここが参考になります http://www9.plala.or.jp/sgwr-t/c/sec05.html http://blog.unfindable.net/archives/604
どの様な入力に対して、どのような結果を期待して どの様に"うまくいかない"のか、を書く事。 エラーが出る場合は、何処で、どの様なエラーが出るのか、 を書く事。 エラーメッセージは省略せずに書く事。 >for(a=0;(p1=strstr(p1, search)) != NULL;a++){ >p1++; >} >if(a>0){ >printf("run away\n"); >} >... if(strstr(p1, search)) printf("run away\n"); でいいのでは?
「<」は関係演算子です。 a < bとしたとき、aがbより小さいとき1に、それ以外は0に評価されます。 sample関数は、その評価結果をfloat型に型変換して返していることになります。 なお、valueはfloat型であるにもかかわらず、printfの書式に%dを使っています。 未定義の動作になるので要注意です。
そもそも、何かよほどの理由があるのでない限り、「ド素人が１からC言語を学ぶ」べきではありません。 もっと新しくて学びやすい言語にすべきです。 C言語は40年も前に、当時のエキスパートが使うために設計された言語であり、初心者の学びやすさとか、安全性とかはほとんど考えられていません。 それゆえ多くの人がつまずきます。 似たような系統の言語ならJavaやC#、もっとゆるい言語ならPythonやRubyから始めたほうがいいです。
daichi_0803_777さん ググッテ補える”暗記”レベルの知識など、ソモソモ役に立ちません。 意味や概念を本質的に”理解”できていなければ、”ダメ”です。 ＞c言語でswitch.while.do~while.for.if文は完璧に理解しないとダメですか？ とはいえ、知恵袋に回答をよせている程度の”ナンチャッテC言語プログラマ”には、「そんなもの全部覚えなくても、行き当たりばったりで、試行錯誤してソースコードを修正する」ということしか出来ない人も多いようです。 ＞皆さんはどうですか？ 「C言語の文法の全体に比べれば、タッタの１％にも満たない部分を覚えないで、良い訳がない」でしょう。 また、私のC言語の理解を下回る”ナンチャッテC言語プログラマ”は、納期通りに御仕事が出来る”プロ”のプログラマとは認められないでしょう。 何故なら、Cコンパイラのエラーメッセージを見て試行錯誤無く修正できなくて、何時終わるか予定を立てることが出来ない試行錯誤の繰り返しの上でようやくソースコードを修正できる程度の人は、納期に間に合わせることができないからです。 もし、そんなプログラマを許容する組織があったら、それは「予定期限を過ぎたら、給与を支払わないからね！」的な、ブラック企業でしょう。 C言語を中途半端に覚えて、ブラック企業に入りたい？ では、「救われる道は無いのか？」というと、あることは在って、「C言語より圧倒的に文法がコンパクトで、凸凹で覚え難い複雑さも無いRuby言語を覚える」という方法も有ります。 ６５００行を超えるC言語の文法をナントナク５０％位、つまり３千行相当行を覚えても役に立たないが、「Ruby言語なら、文法がコンパクトで４００行弱なので、全てを覚えることが現実的」なのです。 ＜補足＞ C言語の文法は、解説文を取り除いても６５００行以上の定義が在るものです。 その中で、selection_statementとかiteration_statementに分類されているif/while/for文等は、約５０行で定義されている部分です。 つまり、if/while/for文は、C言語の全体の中の１％程度の部分で、残りの９９％は宣言文や式の定義など雑多で凸凹な文法の部分です。 もし、C言語のif/while/for文を理解できないで居るなら、残りの残りの９９％を占める凸凹仕様を理解することなどできないでしょう。 しかも、C言語の文法の６５００行全体をナントナク覚えただけでは、Cコンパイラが出すエラーメッセージ観ても、適切な修正方法を考え出すことが出来ないでしょう。 また、Apple社の様に、社会的な影響力も大きな会社では、Cコンパイラの開発達と対峙したこともあるようですが、Cコンパイラの開発者達と対等なレベルで「C言語の文法を知ってる」という人が居なければ、喧嘩できていません。 Microsoft社のVisual studioのCコンパイラをつかっている企業の中でも或る程度の大手・中堅の会社にも、Cコンパイラの開発者達と対等なレベルでC言語に詳しい人が居て、喧嘩の相手たるMicrosoft社を呼びつけるために年間数百万円程度の費用をかけているものです。 ＜C言語の文法の全容＞ ・C/C++本体の文法の全容：約5000行 この中で、if/while/for文の定義は、下記の行番号の当りに記述されている約５０行です。 4075 selection_statement： 4077 LITERAL_if LPAREN 4078 condition RPAREN 4079 single_statement 4080 (options {warnWhenFollowAmbig = false;}: 4081 LITERAL_else single_statement)? 4082 {#selection_statement = #(#[CSM_IF_STATEMENT, "CSM_IF_STATEMENT"], #selection_statement);} 4083 | 4084 LITERAL_switch LPAREN condition RPAREN single_statement 4085 {#selection_statement = #(#[CSM_SWITCH_STATEMENT, "CSM_SWITCH_STATEMENT"], #selection_statement);} 4086 ; 4088 iteration_statement 4090 while_statement | do_while_statement | for_statement 4091 ; http://hg.netbeans.org/main/file/tip/cnd.modelimpl/src/org/netbeans... ・C/C++プリプロセッサの全容：約1500行 http ://hg.netbeans.o rg/main/file/tip/cnd.apt/src/org/netbeans/modules/cnd/apt/impl/support/aptlexer.g ・Ruby言語の文法：４００行弱 http://www.antlr3.org/grammar/1160820213459/rubyParserLexerSPGramma... ★C言語の複雑さを悟るクイズ 「a*b*c; に括弧を入れたパターンの内、有効な宣言文と、それ以外（代入文や式等）として多重に解釈できるパターンを、出来るだけ沢山列挙してみてください」 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1414284588... このパズルは、C言語の文法に詳しくないと解けないパズルです。 でも、まともな正解例を４例出せているのは、私くらいです。 正解例＝http ://ideone. c o m/j2vf1n <見捨てられたCコンパイラの例=GCC> C言語を用いていると、C言語のコンパイラ担当と対立する局面は出てくるものです。 C言語のコンパイラ担当と対立するとき、「俺の方がC言語の在るべき姿に詳しい」と言えなければ、勝ち目は無い。 Apple社がGCCというCコンパイラ担当者たちと対峙したとき、GCCを見捨ててclangというC言語コンパイラを造ったそうです。 「 GCCは巨大なシステムで開発がしづらい面もあり、長年のGCCの開発者の一人は「カバにダンスを踊らせるのはあまり楽しいことではない」と述べている。 アップルは Objective-C を多用しているため性能を向上させることに興味を抱いていたが、通常の GCC の開発からはほとんど進展が見られず、Objective-C の性能を上げるためには、 GCC をアップル版に分岐させるか、新しいコンパイラを採用するかを選択することになった。そこで、アップルは C99、Objective-C と C++ をサポートするコンパイラを1から作成した。 この Clang プロジェクトは2007年7月にオープンソース化された。 」
いわゆる、サインカーブというヤツですね。 一応、回答は書きますが、この例はJavaScriptの書式なので、C#への翻訳は、公式ドキュメント等を見て確認して下さい。 gameObject.GetComponent.<Rigidbody>().velocity = Vector3(0, Mathf.Sin(Time.time), 1.0); まず、前提として、この敵オブジェクトがRigidBodyである物としています。 そして、RigidBodyの速度（velocity）を指定する事で、オブジェクトを移動させています（こうしないと、攻撃やら他のオブジェクトと衝突できませんので） さて、上下に移動する部分を「Mathf.Sin(Time.time)」としてあります。 「Mathf.Sin()」は、数学関数のサインです。 その引数「Time.time」は、経過時間です。 つまり、時間と共にサインの値が計算され、その計算結果を敵オブジェクトの上下の速度に使っている訳です。 これに、前進方向の移動を足せば、サインカーブを描いて移動する事ができます。 あとは、前進の速度や上下の速度に係数を掛けるなどして、自分のゲームにあった波長や速度に調整して下さい。 参考になれば。
kaee_aoiwさん 自分で、作る。 他人に従うのは、足軽。
chielien_6c97b5752c86c19aff6a0736fさん なんとなく調べてみたんですが 以下のようなことではないですか？ c = 0xABCD addi・・・r1 = r0 + c:上位16bit _r1 = 0x??AB sla・・・r1 <<= 16 _r1 = 0xAB00 ori・・・r1 += c:下位16bit _r1 = 0xABCD
そもそもオブジェクト図に変数の値がどうこうを書いているのならそれは粒度が細かすぎると思います。 プログラム(ソースコード)に書いてあるのとは違う視点からみるからこそ別の図に描く意味があるので、プログラムを機械的に変換するようでは何の役にも立たない、もしそれを設計図面とするのなら逆にメンテナンスが面倒なだけのお荷物になるでしょう。
(int/int)はintになります。 intは小数点以下を表現できません。 buy は buytotal よりおそらく小さいので、(buy/buytotal)は必ず０に。 ０に何をかけても０になるので、waruは常に０。(^_^; static int bartotal,buytotal ,buy;を static double bartotal,buytotal ,buy;にするか、 if( buy>0 && buytotal>0 ) waru = (buy / buytotal )*1000;を if( buytotal>0 ) waru = ((double)buy / buytotal )*100;にすれば たぶん大丈夫だと思います。 って、前の質問でokamochさんが上記のヒントを書いていてくれたので、それで大丈夫だと思っていたんですけどね…(^_^;
ファンクションポイント法は、ソフトウエアの見積もりにおいて、外部ファイルや内部ファイルの数と難易度の高さから論理的にファンクションポイント(FP)を算出し、開発規模を見積もる手法です。 プログラム言語に依存しない、開発する機能数を測るためユーザ側から見てもわかりやすいなどの利点がある。 内部モジュール数はプログラム言語や、設計技法・技能に依存するためFPにに適しません。
【サンプル】 struct WindowOfThread { WindowOfThread(DWORD _dwThreadId) : hWnd(nullptr) , dwThreadId(_dwThreadId) { (void)EnumWindows(EnumWindowsProc, LPARAM(this)); } HWND hWnd; private: DWORD dwThreadId; bool SetWindowHandleOfThread(HWND _hWnd) { if (GetWindowThreadProcessId(_hWnd, NULL) == dwThreadId) { hWnd = _hWnd; return true; } else return false; } static BOOL CALLBACK EnumWindowsProc(HWND hWnd, LPARAM lParam) { return !reinterpret_cast<WindowOfThread*>(lParam)->SetWindowHandleOfThread(hWnd); } }; int main(){ const HWND hWnd = WindowOfThread(GetCurrentThreadId()).hWnd; for (;;) { POINT mouse_pos; if (GetCursorPos(&mouse_pos)) { ScreenToClient(hWnd,&mouse_pos); printf("クライアント座標→(%ld,%ld)\n", mouse_pos.x, mouse_pos.y); Sleep(10); } } return 0; } 【解説】 GetStdHandle はファイルハンドルを返すものですからね。型も HWND ではなくて HANDLE であり、別物。 それで、コンソールウィンドウのハンドルを得るにはどうするかというところが問題。直接的なやり方が存在しているのかどうか知りませんけれども、単純な形でやるとしますと上記のサンプルの形が思い浮かびます。 EnumWindows によってウィンドウを列挙。それぞれのウィンドウに関して GetWindowThreadProcessId でスレッド ID を取得します。それと GetCurrentThreadId で得た自己スレッド ID とが一致しているウィンドウを探せば良いというわけです。
>>visualStudio(?)でソフトを作るのが良いと聞いたのですが、visual studio community は、商業利用できますでしょうか？ 個人でなら商用利用でもできるようです。 組織の場合はエンタープライズの組織の場合は一定の条件で利用できるようです(PCが250台以上かユーザーが250人以上またはまたは年間売上が100万米ドル以上(またはほかの通貨の相当額)の場合は利用できないようです) エンタープライズの組織でない場合は、最大5人で利用できるようです。
抵抗器の抵抗値が十分大きいなら、流れる電流は微々たるものなので、１０個付けても大丈夫だと思います。 同時に押したら、判定が可能なポートがちゃんと３個あれば、同時に押したのが分かります。
画像は小さくてわかりません。 Mainメソッドはstaticなので静的関数として実行されるので問題ないのですが、 メソッドcは普通のメソッドなのでclass Appのインスタンスが必要です。 なので、 private int c(int value){ ↓ private static int c(int value){ にすると、cもstaticメソッドとして普通のC言語の関数のように実行できるようになります。 そうでなくインスタンスを生成する場合は、 Mainの中で、 App app = new App(); a = app.c(c); のように書く必要があります。 ついでに本題とは無関係ですが、 a = c(b);になっていますけれど、 b = c(b);の誤記だと思います。
「ちゃんと奇数が表示される」方の動作順序です。 ① i = 1 ② i < 101 なら③、そうじゃなければ⑧ ③ !(i % 2) なら④、そうじゃなければ⑤ ④ ⑥へ ⑤ printf("%d", i); ⑥ i++ ⑦ ②へ ⑧ return 0; continue は④のところです。 「偶数が表示されてしまいます」の方の動作順序です。 ① i = 1 ② i < 101 なら③、そうじゃなければ⑧ ③ !(i % 2) なら④、そうじゃなければ⑤ ④ printf("%d", i); ⑤ ⑥へ ⑥ i++ ⑦ ②へ ⑧ return 0; continue は⑤のところです。 ＜continueの仕組みについてよくわかっていないため、詳しく説明してくれると有り難いです＞ for 文で continue が現れると、for のカッコ内にある３つ目のパラメータのところに飛びます。ご提示の例だと i++ のところですよ。そして、第２パラメータの判定式に飛び、真である間ループが続けられる。そういう形です。 continue は「続ける」という意味。ループを続けるわけ。途中の処理は飛ばすけど、でも、ループ自体は続ける。break とは違いますからね。break の場合はループをやめてしまいます。 途中の処理を飛ばすっていうのは、continue を含む複文、つまり { と } の区間において、} のところまで飛ばすっていう話ですよ。 そう考えると簡単だと思います。
Visual Studio Community 2015 お勧めです。 https://www.visualstudio.com/ja-jp/products/visual-studio-community... 8月2日の Anniversary Update 後なら、 Windows Subsystem for Linux で gcc が使えるのでしょうか。 MinGW や Cygwin は選択肢でなくなってゆくのかな？
コンビニのレジだってITだろうが。道路の信号もIT。冷蔵庫や洗濯機だってIT。発電所も。病院のカルテも（場合によっては診断も）。個人商店すら在庫管理にコンピュータを使う時代だ。テレビだってデジタルなんだからコンピュータがないと発信できない。応力計算ができないとビルも建たない。 むしろ、ITなしでできる事を数えた方が早い。
演算子もキーボードから入力させるようにすれば宜しいと思います
とりあえず思い付いた方法を 3 通り挙げてみます。 挙動としては B が一番合っていると思いますが、 場合によっては一番難しい方法かもしれません。 A. SelectionChanged イベント SelectionChanged イベントがありますが、 これは画面が切り替わった後になってしまうのでちょっと違いますよね。 B. TabItem コントロールのカスタマイズ だとしたら TabItem の Header にボタンを置くようにして、 このボタンを押すことによって確認ダイアログの表示や タブの切り替えをおこなうようにすればいいと思います。 このとき、外観がだいぶおかしなことになると思うので、 ボタンの配置は TabItem のデフォルトスタイルを 変更すればいいと思います。 ボタンも標準の Button ではなく、 Button.Tempalte に対して ControlTemplate を指定した 独自のボタンにするといいでしょう。 C. SelectedIndex プロパティ ちょっと強引ですが、SelectedIndex プロパティとデータバインドして 無理矢理やる方法もあります。 手順は次の通りです。 (0. ViewModel の int SelectedIndex と View の TabControl.SelectedIndex をデータバインドで紐付けておく) 1. SelectedIndex の set アクセサで、変更時に変更前の値に戻す (画面が切り替わらないようにする) 2. 確認ダイアログを表示するように View に指示を出す (添付ビヘイビアが有用です) 3. ダイアログのコールバックを ViewModel で処理し、OK なら SelectedIndex を変更する 手順 1 と 3 で SelectedIndex を変更するのに、一方は変更前に戻し、 一方はそのまま変更を受け付けるようにするのに少し工夫が必要です。 また、手順 1 で変更時に変更前の値に戻しているので、 目には見えないとしても、一瞬画面が切り替わっていることになります。 そのため、切り替え後の画面の Loaded イベントなどで何かしている場合は 影響が出てしまうかもしれません。 手順 2 は SelectedIndex プロパティの変更通知が View に伝わってから実行する必要があるため、 Dispatcher.BeginInvoke などで実行させる必要があります。
push_backを使用したvectorへの追加は 他の方のご回答通りですが、 もしもCPoint型に以下のようなコンストラクタが 存在しているのなら、 emplace_backを使うべきです。 CPoint(double x, double y) : x(x), y(y) {} //... { vector<CPoint> v; v.emplace_back(1.0, 2.0) // CPoint(1.0, 2.0)が格納される }
（１）Windows API（Win32API）というのは、今はほとんど使われていないのですか？ 毎日使ってます。これでもかっていう位。え？個人的な話じゃなくて…ですか？ じゃ、使う人が減ってきているのは事実としてあると思います。 「今はほとんど使われていない」って、いや、そこまでのレベルにはなっていないと思いますけど。 ただし、ある種の希少価値が生じてきている感じ。やる人が少ない。やりたくてもできない。だから、Win32 API を呼ぶようなプログラムを開発する場合の単価が高い。.NET は誰もが出来るので安い。そういった状況かと。 （２）最近は.NET？などで作ると聞きましたが・・・。 C++ から C# に逃げた人が多数居る模様。C++ でイヤな思いをしてた人は C# で救われた格好じゃないでしょうか。また、昔の VB6.0 をやってた人とかは、これはかなり頑張ったみたいですね。VB.NET を覚えて、今まで以上のアプリケーションをどんどん作っている。.NET 、流行ってますね。 ところで、もともと C++ でイヤな思いをしてなかった人（ていうか喜んでた人）は C# とか、やらないと思う。やっても良いと思ってたのですけれども頼まれないんですね。C# で何かをやってくれって全然言われない。（サンプルを C# や VB.NET で作ってくれって頼まれることはありますけど。） .NET 絡みで頼まれるケースでは、根本的に C# だとキツイものだったしますので、C++/CLI を使ってですね、C# 用の切り口は .NET 、そして OS とのやり取りは Win32 API という形で作ります。こうすると喜ばれるのですよ。C# でやろうとすると無理が出るからこそ C++ プログラマに頼もうっていう話になってるので、それに応えるには C++/CLI が最適です。 結局、.NET が出る前って、無理して Win32 API を使ってた人たちが沢山居たと思うのですよ。今、.NET があるので無理する必要が殆ど無いんですよね。C# だけ、VB.NET だけで十分なのです。C++/CLI を登場させなきゃならないようなケースは稀です。 元から Win32 API を無理なく存分に使ってた人は、そりゃ、今でも存分に使ってる。.NET など、使う気がしないでしょうから。だって、自分が直接 OS に話しかけられるわけです。なのに .NET Framework などというものを間に挟んで、伝言ゲーム的なことをするなんてバカバカしいですからね。 とか、そういう話かと。
opendir, readdir, closedirあたりを調べましょう。 https://developer.apple.com/legacy/library/documentation/Darwin/Ref...
jlkhgasvybilさん 多分、波形を作りたいだけじゃないんですか。 求める式を書いて範囲を決めればどんな波形でも書いてくれる。 #include<stdio.h> #include<math.h> int main(void) { ＿＿＿FILE *fp; ＿＿＿double t,y; ＿＿＿double pi = 3.14; ＿＿＿fp = fopen("sin.csv","w"); ＿＿＿for(t=-pi;t<=pi;t+=0.1){ ＿＿＿＿＿ y = sin(t); ＿＿＿＿＿ fprintf(fp,"%f,%f\n",t,y); ＿＿＿} ＿＿＿fclose(fp); ＿＿＿return 0; }
カンマ単独では演算子として成り立ちませんので、「そんなものない」という答えしかつかないですね。 もしかして、三項演算子のことを言っていますか？ (a == b)?c:d; のような。 であれば、 A?B:C と考えた時に、「Aが偽と評価できるならばCを返して、それ以外ならばBを返すような式」と考えることができるというだけです。 ちなみにC++だと、::はスコープの解決として使われる演算子です。
分からない単語(多重定義)は勝手に解釈せずに調べましょう。 間違えて理解してしまったり、理解できなくなったりすることになります。 多重定義(オーバーロード)とは、引数の型の異なる同名の関数を定義することです。 int a(int x) { … } double a(double x) { ... } のように同じ名前だが引数の型の異なる関数を定義することです。 引数がintであればint a(int x)の方が実行され、 引数がdoubleであればdouble a(double x)の方が実行される、という仕組みです。 ここで、typedef int hoge; として、 int a(int x) { ... } hoge a(hoge x) { ... } とすることはできません、ということです。 あくまでintもhogeも名前が違うだけで同じものなので、 int a(int x) { ... } int a(int x) { ... } と同じ意味になり、どちらを実行して良いのかわからなくなるからです。
if(key & ボタンの定義) と書いてその下に処理を書けば取得できると思います。 同時入力はif文を並べて書けば大丈夫ではないでしょうか？
①はスーパースカラーの定義が複数命令の同時実行が可能なことから 当然発生する可能性を持ちます。 ③のVLIWは、①と関係してハザードが発生しないようにVLIWを 構築する必要があるので、”依存関係にない複数の命令をまとめて” の部分が間違いだと思います。 ④はVLIWの話であり、スーパースカラー自体は、reorder等実行して スケジューリングします。
＞どのように考えるべきか 近くに仲間がいると攻撃力が上がります すなわち、密集すると何かしらのポテンシャルが単体のときよりも上がります つまり、半径ｒ以内に他の〈粒子〉が存在しますと、その粒子の『ナントカ能』はさらに向上します 電子などですと、場の影響力は、半径の二乗に反比例します。
結構沢山あります。 ここなんか、どうですか？ https://paiza.io/?locale=ja-jp
必要ないよ(elseが不要な場合は省略できるよ)。
3Dの描画の話は知らない。 それと、returnのないラベルにgosubし続けると良くないことが起こらないかなぁ? ユーザーが制御出来ないwparamを毎回読みだすのをやめて、キーイベントがあった時だけwparamを読み込み、処理したらキー結果をクリアしておけばいいんじゃない? onkey gosub *handle repeat color 255,255,255 boxf color 0,0,0 pos 0,0 mes key key=0 ;クリア await 20 loop stop *handle key=wparam ;ハンドルの中でだけ読み出し return キーイベントの性質上、「キーが押されている」の検出ではなくて「キーが押された」の検出になるから、キーリピートに応じて反応することになりますけれど。 それが嫌ならイベントハンドラではなくてgetkeyでボーリングとか。 repeat getkey w,87 getkey s,83 getkey d,68 getkey a,65 x=x-w+s y=y+d-a color 255,255,255 boxf color 0,0,0 pos 0,0 mes x mes y await 20 loop
いろんな、やり方があるかと思いますけど、1行単位で読み込んで、プログラム名だけ取り出しています。 #include<stdio.h> #include<stdlib.h> #define MM 128 int main(void) { FILE *fp; char w[MM],Name[512][MM]; int i,n; if((fp=fopen("./232/MDFPC201.csv","r"))==NULL){ printf("Error"); system("pause"); } n=0; while(fgets(w,MM,fp)!=NULL){ sscanf(w,"%[^,]",Name[n++]); } for(i=0;i<n;i++){ printf("%s\n",Name[i]); } system("pause"); return 0; } 今はファイル名が固定されているが、以下のようにすれば実行時の引数でファイル名を与えることができる。 ただ、クラス別のファイル名を書いたファイルから、1行読んでは処理を繰り返すのが良いかと思います。 処理結果もファイル出力が良いかと思います。 #include<stdio.h> #include<stdlib.h> #define MM 128 int main(int argc,char *argv[]) { FILE *fp; char w[MM],Name[512][MM]; int i,n; if((fp=fopen(argv[1],"r"))==NULL){ printf("Open Error\n"); system("pause"); } n=0; while(fgets(w,MM,fp)!=NULL){ sscanf(w,"%[^,]",Name[n++]); } for(i=0;i<n;i++){ printf("%s\n",Name[i]); } system("pause"); return 0; }
少し前のMSVC++ですと、プロジェクト新規作成でアプリケーション設定画面において、「□Security Development Lifecycle (SDL) のチェック(C)」というオプションのチェックを外せば_CRT_SECURE_NO_WARNINGSを打ち込まなくても大丈夫でした。 もし、そのオプションが新規作成の設定画面から消えてしまっている場合は、 https://msdn.microsoft.com/ja-jp/library/jj161081.aspx １．プロジェクトの [プロパティ ページ] ダイアログ ボックスを開きます。 ２．[C/C++] フォルダーを選択します。 ３．[全般] ページで、[SDL チェック] ドロップダウン リストからオプションを選択します。（SDLチェックしないように設定します） とするとよさそうな気がします。
Java…ですよね？ int[] x＝new int[10]は、 int型データが１０個並んだメモリをxに割り当てます。 Javaの配列変数は参照型変数（どこかに存在するデータを参照する変数）で、それ自体はデータの実体を持ちません。 ですので、例えば… int array1[] = {1,2,3,4,5}; int array2[] = array1; とすると、array1とarray2は同じメモリを参照します。 そのため、array2[0]=10;とすると、array1[0]も10になります。
http://echoes.hak.hokkyodai.ac.jp/db/369/dsp0426.pdf?id=13848
樹脂カバー精度は甘いですが使えます 参考写真 上が「DCプラグ 2.1mm ロングタイプ」です
素数判定の高速なアルゴリズム（数学的なもの）についてはほかの方に譲るとして、プログラミング的な観点でお答えします。 ループ処理（for, while, do-while）の高速化の指針として、 ①ループ内で同じ計算を何回もしないこと ②for文の繰り返し条件（この場合はk<=sqrt(i)）は毎回評価されるので、できれば定数にすること があります。 ご質問のプログラムでは、8行目、10行目でsqrt(i)をそれぞれ呼んでいますが、 これは８行目のfor文に入る前に計算しておけば良いですよね。 なので８行目に int sq = (int)sqrt(i); を挿入し、以降のsqrt(i)をsqに置き換えれば①、②とも解決し、多少速くなると思います。 ただし最近のコンパイラは賢いので、コンパイルの際に自動的に上記のようなことが行われてしまい（最適化といいます）、速くならないことも多々あります。
PORTC = a / 0x64 % 0x0A;この式が正しいかどうかがわかるのはプログラムを組んだ人だけです。 だって、こうこうこうゆう計算をしたいという説明がない。 第三者はこれでいいのかなとは思います。 ポートBは８ビットしかないので正負の整数であるなら−１２８〜１２７の範囲。それを計算すれば答えはいつも−１か０か１。これでいいのだろうか？と疑問にはおもう。だけどプログラムを組んだ人はそうしようとしているのかもしれない。 非負数０〜２５５でも０か１か２。 なので一言で式がおかしいとはいえないです。 PORTA = (((a / 0x0A) % 0x0A) * 0x10) + a % 0x0A; これも同じ。 あと、 １）PICはやったことないがANSELHは０セットしなくていいいのですか？ Note: The ANSELH register must be initialized to configure an analog channel as a digital input. Pins configured as analog inputs will read ‘0’. とマニュアルに書いてあるのだけれど。マニュアルから無断転載して怒られるかな？ ２）ポートBに接続されている回路が気になる。 OPTION_REG.NOT_RBPU = 1; /* プルアップ無効 */ とあるので。
今手元にあるのは、CC-RXの「ユーザーズマニュアル RXコーディング編」ですが･･････ 7. 3. 4 低水準インタフェースルーチンに、以下の関数はユーザーが自作しなければならない旨が明記されています。 open, close, read, write, lseek, sbrk その他、スタートアップで記述すべき内容などもマニュアルに明記されていますので、必ず最初に通読すべきです。 RX以外のマイコン、具体的にはSH、H8、R8C、M16C、M32Cなどでも同様かと思います。
>>programmer_hiroさん アスキーコードだと思う アスキーコード表で検索してトップが以下 http://www9.plala.or.jp/sgwr-t/c_sub/ascii.html
budoupan19さん 回答します。 ■プログラム例 #include <stdio.h> /* int型配列を逆順に並べ替える */ void reverse(int *a, int size) { int *a1 = a, /* 配列の前部分を示すポインタ */ *a2 = a + size - 1; /* 配列の後部分を示すポインタ */ int tmp; while (a1 <= a2) { /* 配列の前部分と後部分を入れ替え */ tmp = *a1; *a1 = *a2; *a2 = tmp; /* ポインタを移動 */ a1++, a2--; } } /* メイン */ int main(void) { int a[10]; /* 配列 */ int num = sizeof(a) / sizeof(*a); /* 配列の要素数 */ int i; printf("配列の値を入力\n"); for (i = 0; i < num; i++) { printf("a[%d] = ", i); scanf("%d", &a[i]); } /* 配列を逆順に並べ替える */ reverse(a, num); printf("逆順にした配列を表示\n"); for (i = 0; i < num; i++) { printf("a[%d] = %d\n", i, a[i]); } return 0; } ■実行例 配列の値を入力 [0] = 1 [1] = 2 [2] = 3 [3] = 4 [4] = 5 [5] = 6 [6] = 7 [7] = 8 [8] = 9 [9] = 10 逆順にした配列を表示 [0] = 10 [1] = 9 [2] = 8 [3] = 7 [4] = 6 [5] = 5 [6] = 4 [7] = 3 [8] = 2 [9] = 1
TCに入っている日本の銀行銀行名（旧銀行名も含）と同じ銀行なら、既に買い取りを止めている銀行でも換金可能です。又、Travelexは下記のTCに限り換金可能です。 Travelex http://www.travelex.co.jp/JP/For-Individuals/Products-and-Services/... ※みずほ銀行、三菱東京UFJ銀行、三井住友銀行では自行発行以外のTCの買い取りを止めています。
二番目のIFの後の=は不要です。 =IF(C1="", "",IF(A1+B1<D1,F1,0))
プロセスは処理手続きですのでプログラミングに重点を置いた開発手法と考えます。一方、データはデータに重点を置いた開発手法と考えます。平たく言えばプロセスはデータの登録から結果までプロセスを繋げていますが、データは中心にデータベースを置いてデータを登録するシステムとデータを使って何らかの結果を出すシステムを分離する手法となっていると考えます。どちらにしても最近のシステム作りはリレーショナルデータベースを使う場合が多いので、プログラムとデータが完全に分離しているので、結果的にはデータ中心アプローチに近い方法にシステム作りが変化していると考えます。
> gorygory02111さん 作者が使い方を決めてるので 作者提供の文書を読むのが良いよ 本家のサイトに文書あるでしょ 関数のマニュアルも見れるけど見かた知ってる？ ソースも表示可能なので そこらを利用すれば使い方わかると思うけど Rは非常に使いかた調べやすい環境なので ちゃんと調べないといかんよ
■１ プログラムを学ぶと世界中どこでもネットがあれば仕事ができる又なぜ？ たぶんほとんどの人は、プログラミングが出来るだけでは「世界中どこでも～仕事ができる」ようにはならないでしょう。 なぜなら、「プログラミングが出来る」というのは、「日本語が使える」「絵が描ける」「楽器が弾ける」というのと似ていて、それが出来るからと言って、それで仕事が出来るかどうかは、また別の話だからです。 ■２ 好きな場所で、パソコン一つで本当に生きていける、ごく一部の人？ はい。 ■３ もし本当であれば、皆やっているとおもいますが？？？ だからほとんどの人がやっていません。 ■４ そもそおプログラミングとはどうゆうものでしょうか？ 似た質問と回答がありますので参考になさってください。 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1498092824 ■５ 言語を使って、パソコンを動かすのですか？ 狭義には、その通りです。 ■６ どのような人が向いていますか？ プログラミングを「楽しい」と感じて、やり続けている人です。 逆に、プログラミングがキツい、難しいと感じてしまう人は向いていません。 また、下記「知恵ノート」のような質問をする人も向いていません。 http://note.chiebukuro.yahoo.co.jp/detail/n197358 ■７ じっとしていられない人は向いていませんか？ そうでもないと思います。 ■８ 英語ができると有利になりますか？ はい。 プログラミングやコンピュータに関する事は米国で発展してきたので、使う用語はほぼ英単語です。 英語を知っていると、そうした用語の意味を素早く推測出来るので、学習効率は上がります。 スペルミスを繰り返したり、単数形／複数形で惑わされたりしていると学習効率が低くなります。 ■９ 自営で生きていけますか？ 分かりません。 「日本語が使える」「絵が描ける」「楽器が弾ける」からと言って、自営で生きていけるかどうかは、また別の話だからです。 ■10 TECH CAMP 研修という学校について教えて下さい 「TECH::CAMP研修」は、企業向けのプログラミング・キャンプ・サービスです。 つまり、企業で採用予定の新人さんや、すでに企業で働いている人達の研修のために供されているサービスであり、個人向けではありません。 （最短２週間・16万円、助成金制度有り） 同社の個人向けサービスには「TECH::CAMP」があります。 （１ヶ月コース社会人 12万8000円、学生 6万4000円） 参加条件は、 ・１ヶ月コースでは期間内に 100時間以上の学習時間が確保できること ・Mac 持参（月額 5千円＋税のレンタル有り） ・キャンプ終了後も継続的に学習を続けていく覚悟を持つこと だそうです。 なお、「TECH::CAMPに関する質問になんでもお答え」するチャット・サービスが公式に用意されているので、そこで詳しい話が聞けると思います。 https://tech-camp.in/training 参考 https://blog.codecamp.jp/programming_camp http://shiroku.ma/visit/8591/05/10/
/* akakakakqakaさん 効率はともかく、分かりやすさ重視で… (^_^; -----実行結果----- 200 以下の三つ子素数の組は次の通り: 三つ子素数{ 5, 7, 11} 三つ子素数{ 7, 11, 13} 三つ子素数{ 11, 13, 17} 三つ子素数{ 13, 17, 19} 三つ子素数{ 17, 19, 23} 三つ子素数{ 37, 41, 43} 三つ子素数{ 41, 43, 47} 三つ子素数{ 67, 71, 73} 三つ子素数{ 97, 101, 103} 三つ子素数{ 101, 103, 107} 三つ子素数{ 103, 107, 109} 三つ子素数{ 107, 109, 113} 三つ子素数{ 191, 193, 197} 三つ子素数{ 193, 197, 199} */ #include<stdio.h> #define NUM 200 int isPrime(int n){ int i; if(n < 2){ return 0; } if(n == 2){ return 0; } if(n % 2 == 0){ return 0; } for(i = 3; i*i <= n; i += 2){ if(n % i == 0) return 0; } return 1; } int main() { int i; printf("200 以下の三つ子素数の組は次の通り:\n"); for(i = 5; i <= NUM-6; i+=2){ if(isPrime(i) && isPrime(i+2) &&isPrime(i+6)){ printf("三つ子素数{ %d, %d, %d}\n",i,i+2,i+6); }else if(isPrime(i) && isPrime(i+4) &&isPrime(i+6)){ printf("三つ子素数{ %d, %d, %d}\n",i,i+4,i+6); } } return 0; }
カテゴリマスター >buynnnmmm1さん 答えになってないから カテゴリマスター（笑）くん 論点ずらさないと答えられないガイジなのかなぁ？？？
>kyarottokunさん2016/7/2818:05:41 >I2I ID てなんですか？ 前後の文脈によります。
#include<stdio.h> #define MM 100 void Sort(int*,int); void Show(int*,int,int); int main(void) { int i,n,a[MM]; printf("Input integers:\n"); for(n=0;n<MM;n++){ scanf("%d",&a[n]); if(a[n]==0)break; } Show(a,n,0); Sort(a,n); Show(a,n,1); return 0; } void Sort(int *a,int m) { int i,j,t; for(i=0;i<m-1;i++){ for(j=i+1;j<m;j++){ if(a[i]>a[j]){ t=a[j]; a[j]=a[i]; a[i]=t; }}} } void Show(int *a,int m,int s) { char *h[]={"Before sorting:","After sorting:"}; int i; printf("\n%s%d",h[s],a[0]); for(i=1;i<m;i++)printf(",%d",a[i]); printf("\n"); }
これだけだとエラー場所が特定できないので、AVIFileOpen,AVIFileGetStreamの２つを実行して、何がエラー原因なのか見てみては？
thegreatさん、こんなのどう？ //【１次遅れ】 t=linspace(0,0.12,100); // ｔ 0～0.12秒 を100分割 s=poly(0,'s'); // 多項式の変数 s を定義 G=4/(1+0.02*s); // 1次遅れ系・直列接続例の伝達関数 sys=syslin('c',G); // 連続時間線形システムへ、関数 G を登録 y=csim('step',t,sys); // sys へステップ入力( t秒 ) xset("window",0);clf(); xtitle('G(s)=4/(1+0.02s)','Time(sec)','Step Respons') B=get('current_axes'); //現在の軸情報を変数 B に代入する。 title=B.title;title.font_size=4; //タイトルのフォントサイズ xset("wdim",600,400); // 画面の大きさ xset('thickness',2);plot2d(t,y,1); // 黒色 xset('thickness',1);xgrid() // 黒色のグリッド
リクエストをいただきありがとうございます。C++ の項目が大体終わったとのことで、早いですね。これは素晴らしいと思います。 さて、 「ほかに覚える事ってありますか？」 とのことで、「ほかに」というと何の他に…かな。 これまでに差し上げた回答の中で既に申し上げていますけれども、機械語が何より重要。機械語を知らないというのはあり得ない。で、機械語が分かると、とりあえずリバースエンジニアリングの勉強が始められるかもしれれない。というくらいのものです。 あと、英語。英語についても、もうお話してたかもしれませんが、資料はすべて英語です。日本語の資料に価値があることは稀です。なので、英語の資料を読み進めなければなりません。なお、英会話じゃないです。資料が読めれば良いのですよ。 あまり有意義な回答になっていないかもしれませんが、いずれにしろ頑張ってくださいね。
4つのタイヤがついたものになってしましますが http://www.zmp.co.jp/products/robocar-110?lang=jp で様々なセンサーや通信方法に対応したラジコンカーを買うことができますよ 少しだけお金がかかりますがあなたの要求する条件に一致する製品としてはかなり安いものだと思います 実車1/10スケールロボットカー RoboCar 1/10 2016 RoboCar 1/10 2016 一般 80万円（税別） アカデミック 68万円（税別） RoboCar 1/10 2016前後レーザレンジセンサセット 一般 104万円（税別） アカデミック 92万円（税別）
>ID非公開さん ***お勧めの手法(前処理を文字列操作が楽なツールでやってから読み込む 一番簡単なのは前処理を他の文字列操作が楽なツールでやること Windowsならcygwin とか を入れればgrepとかAwkを簡単に使えます RubyとかPython,Perlなどのツールを入れても良い grep なら grep DEB, 元データ.csv でいけそうな気はする もっと真面目にマッチ部分の条件を正規表現使って書けば2番目の,の前がDEBならとか簡単だよ ***あまりお勧めしない手法1 読み込んでから正規表現マッチライブラリを利用して そういうデータかどうか判別して読み込む ***あまりお勧めしない手法2 ,で区切って二番目の文字列を調べて判別処理する
アニメーションをもう一つ用意して、そこでX座標の位置を拡大量の半分だけ減らす。 サンプルコードいる？
>kyarottokunさん2016/7/2818:16:45 >I2I IDって何ですか？ 前後の文脈によります。
まず最初に。 ラムダ式とstream apiは異なるものです。 確かにstream apiはラムダ式を前提とした記述方法ではありますが、ラムダ式そのものはstream apiを使わなくても記述できます。 そのため、stream apiをもってラムダ式と書くのは根本で間違っています。 そしてparallelクエリはstream apiの特徴であってラムダ式とは無関係です。 ラムダ式の本質は、メソッドを式として扱うことにあります。 Javaの場合はinterfaceとデフォルトメソッドという形で実現しています。 記述されたif文をラムダ式に変えるのであれば、 if(5<num)という条件を判断してbooleanを返すメソッドを作成すればいいでしょう。 ようは boolean p(int n){ return 5<n; } というメソッドです。 intを受け取りbooleanを返すinterfaceはIntPredicateですので、これを使ってラムダ表記すると IntPredicate p = n->n<5; となります。 以上より、ラムダ式表記するなら IntPredicate p = n->n<5; int num=0; if(p.test(num)){ return; } となります。 元のコードと比べると冗長になっているように思われるかも知れませんし、メリットも感じられないかもしれませんね。 しかし、実は大きなメリットがあります。 たとえば、現在の条件はn<5ですが、これがn>0に変わった場合はどうしますか。 プログラム中からif文を探し出して、そのロジックを修正しなければなりませんよね。 では、ラムダ式の場合はどうでしょうか。 コード先頭の IntPredicate p = n->n<5; を IntPredicaet p = n->n>0; と書き換えるだけで修正できます。 今回のケースは単純なロジックでしたのでメリットは薄いですが、複雑なビジネスロジックであった場合、インターフェースを切り替えるだけでコード細部を修正しなくて済むラムダ式は、大きなメリットを持っています。
そういう場合にはタイマー（System.Windows.Forms.Timer）の使用はおすすめできません。 なぜかというと、タイマーが実行されるスレッドは、Formを処理するスレッドと同じであるため、タイマーで重い処理を実行すると、フォームの更新処理が滞ってしまうからです。 なので、重い処理は別スレッドを使いましょう。 .netでは、きわめて簡単にマルチスレッド処理を利用できます。 使用するのはTaskクラス（System.Threading.Tasks名前空間）になります。 使い方は簡単で、 Task.Factory.StartNew(() => { // ここに重い処理を書く }); のように使います。 以下のプログラム例では、タイマーとTaskクラスを使用して同じような処理（Sleep()で処理を中断する）をしています。 button1をクリックしてフォームを移動させると、カクカクしてうまく動かないのが分かります。 これはFormを処理するスレッドの処理がSleepによって滞るためです。 対してbutton2をクリックした場合、フォームを移動させてもスムーズに移動できます。 これによってマルチスレッド処理ができていることが分かります。 プログラム例： using System; using System.Windows.Forms; using System.Threading.Thread; using System.Threading.Tasks; namespace WindowsFormsApplication1 { public partial class Form1 : Form { Timer tm; //UIタイマー public Form1() { InitializeComponent(); tm = new Timer(); tm.Interval = 1000; tm.Tick += (sender, e) => { // button1を押したときの処理 Sleep(1000); }; } // UIタイマーを使う private void button1_Click(object sender, EventArgs e) { tm.Start(); } // Taskを使う private void button2_Click(object sender, EventArgs e) { Task.Factory.StartNew(() => { // button2を押したときの処理 Sleep(10000); }); } } }
AVRはやったことないです。それなので質問者さんの書き方が正しいとしています。 int main(void) { ____DDRB = 0b00000111; ____PORTB = 0b00000000; // 初期化 ____int i; ____PORTB = _BV(PB0);//PB0のみHigh ____shift_SCK(); ____delay_us(10);//10マイクロセコンドのつもり。正しい書き方にしてください。 ____shift_RCK(); ____delay(300);//300mSのDelayのつもり。正しい書き方にしてください。 ____PORTB &= ~_BV(PB0); //PB0だけをLOW ____for (i = 0; i < 7; i++) ____{ ________shift_SCK(); ________delay_us(10);//10マイクロセコンドのつもり。正しい書き方にしてください。 ________shift_RCK(); ________delay(300); ____} ____while (1) ____{ ____} } その後どうしたいか質問に書いてないので。 74HC595のリセットはリセットがかかるようにする。 アウトプットエネーブルも制御したほうが将来のため良いでしょう。 「注意点」 １． void shift_SCK(void){ PORTB = _BV(PB1); //PB1だけHIGH PORTB &= ~_BV(PB1); //PB1だけをLOW } マイコンのスピードとコンパイラーの吐くアッセンブリによりこれだとPB1のパルスが短くなる恐れがあるのですがいいのでしょうか？ プロであればチェックするところです。 ２． for (i = 0; i < 8; i++) { PORTB = _BV(PB0); shift_SCK(); } このループだとシフトクロックがものすごいスピード（定量的でなくて申し訳ない）で出るが74HC595が動作するか検討する余地あり。プロであればシンクロスコープを持ちだしてチェックするところです。マイクロセコンド単位のディレイを入れたほうがよさそう。 動くかどうかわからないので参考程度。
こんにちは 先頭列の検索サンプルです。 private void Form1_Shown(object sender, EventArgs e) { button1.Text = "検索"; listView1.View = View.Details; listView1.Columns.Add("名前", 100); listView1.Columns.Add("住所", 100); string[][] s1 = new string[][] { new string[] { "伊藤","東京" }, new string[] { "佐藤","神奈川"}, new string[] { "田中","千葉"} }; for (int i = 0; i < s1.Length; i++) { listView1.Items.Add(new ListViewItem(s1[i])); } } private void button1_Click(object sender, EventArgs e) { List<string> strlist = new List<string>(); strlist.Clear(); foreach (ListViewItem itm in listView1.Items) { strlist.Add(itm.Text); } foreach(string str in strlist) { if (str.Contains(textBox1.Text)) { MessageBox.Show((strlist.IndexOf(str)+1).ToString()+"行目です"); } } } 列を全て検索するには条件文（if)で追加検索してください。
こんばんは ＞Form1のListViewを読み取って プロパティを使います。 こんな感じです。 public string msg1 { get { return this._msg1; } } 項目を選択してボタンを押します。 単純なサンプルです class Form1側 private void Form1_Shown(object sender, EventArgs e) { //アイテムの作成 listView1.View =View.Details; ListViewItem itemx1 = new ListViewItem(); ListViewItem itemx2 = new ListViewItem(); itemx1.Text = "001"; itemx1.SubItems.Add("東京都"); itemx1.SubItems.Add("田中"); listView1.Items.Add(itemx1); itemx2.Text = "002"; itemx2.SubItems.Add("千葉県"); itemx2.SubItems.Add("佐藤"); listView1.Items.Add(itemx2); } private void button1_Click(object sender, EventArgs e) { //項目が１つも選択されていない場合 if (listView1.SelectedItems.Count == 0) //処理を抜ける return; ListViewItem itemx = new ListViewItem(); //1番目に選択されれいるアイテムをitemxに格納 itemx = listView1.SelectedItems[0]; string txt1 = itemx.Text; string txt2 = itemx.SubItems[1].Text; string txt3 = itemx.SubItems[2].Text; Form2 f2 = new Form2(); f2.Show(); //class Form2に値を渡す f2.itm(txt1, txt2, txt3); } class Form2側 string _msg1; string _msg2; string _msg3; private void Form2_Shown(object sender, EventArgs e) { ListViewItem itemx = new ListViewItem(); itemx.Text = msg1; //アイテムの追加 itemx.SubItems.Add(msg2); itemx.SubItems.Add(msg3); listView1.Items.Add(itemx); } public void itm(string str1, string str2, string str3) { //class Form1から値を受け取る _msg1 = str1; _msg2 = str2; _msg3 = str3; } public string msg1 { get { return this._msg1; } } public string msg2 { get { return this._msg2; } } public string msg3 { get { return this._msg3; } }
どちらも型のポインタを定義する書き方で、機能的に違いはありません。 C/C++どちらの言語も、どちらの表現でも書けますが、C言語の場合は[型名] *[変数名];、C++の場合は[型名]* [変数名];で書くことが多いようです。 つまりもともとは前者の書き方でした。後者のようになったのは、*も含め型名とみなす、ということのようです。ただし int* p, q; と書く場合、pはint*型ですが、qはint型ですので注意が必要です。
// ダメな例 private void Form1_Load(object sender, EventArgs e) { var timer = new System.Timers.Timer(); timer.Interval += 1000.0; timer.Elapsed += (s, ev) => listBox1.Items.Clear(); timer.Start(); } ↑System.Timers.Timerは、Elapsedイベントを 別スレッドで実行します。 これですと、UIに対する操作が別スレッドで実行されてしまうため、 例外が発生します。 // 大丈夫な例1 private void Form1_Load(object sender, EventArgs e) { var timer = new System.Timers.Timer(); timer.Interval += 1000.0; timer.Elapsed += (s, ev) => listBox1.Invoke((Action)(() => listBox1.Items.Clear())); timer.Start(); } ↑Elapsedイベントが別スレッドなので、 Control.InvokeメソッドによりUIスレッド上で実行するように 依頼しています。 // 大丈夫な例2 private void Form1_Load(object sender, EventArgs e) { var timer = new System.Timers.Timer(); timer.Interval += 1000.0; timer.Elapsed += (s, ev) => listBox1.Items.Clear(); timer.SynchronizingObject = this; timer.Start(); } ↑Timer.SynchronizingObjectにFormを設定することにより、 TimerのElapsedイベントがUIスレッド上で発生するようになります。
何が問題なのかわかりませんが、 そのようにキーボードを叩くとか、ファイルに記述しておけばよいのではないですか? Cでは処理系毎にINT_MAXは違う可能性がありますが。 intが16bitのC処理系であれば、普通は #include <stdio.h> int main(void){ int n; scanf("%d",&n); return 0; } として、キーボードから32767と入力すればINT_MAXに相当する値を入力出来るでしょう。何なら、 #include <stdio.h> #include <limits.h> int main(void){ int n; printf("INT_MAX=%d\n",INT_MAX); scanf("%d",&n); return 0; } とすれば、見たままを入力すればいいので楽です。
if (s6 == s6) //リミットが押されたらYモーター停止 これは誤記？ if Xの処理 else Yの処理 なんかやってたらおかしいでしょ？ else外してそれぞれ単独でif文完結させること
2008年2月は29日で2009年2月は28日とかそんなんじゃないの？
マイコンのようにソフトもハードも自分がやるようなシステムではまずハードを確実なものにしないとハードが悪いのかソフトが悪いのかわからなくなります。 複雑なものの開発時であればソフトの力を借りてハードの動作をチェックすることはあるがその場合はソフトの影響をできるだけ排除するため極力簡単なものにします。 １）スイッチは押したとき、”H"か”L"かはっきり質問にかく。 スイッチ回路は押したとき”L"になる回路ならばプルアップ抵抗が要ります。これがないと”H"レベルが確定せずプログラムが正常に動きません。Arduinoはピンごとにプルアップイネーブルにできたと思う。 ２）モータ２が回転しないとのことですがプログラム上は回転するはずです。 モータ１と２で回路が同じかチェックする。回転方向は質問に回路のことが書いてないのでわかりません。 以下のプログラムがソフトの力を借りたハードの動作チェックの例となります。極力簡単にしています。 //int val=0; void setup()｛ pinMode(2,OUTPUT); //モーター1 pinMode(3,OUTPUT); pinMode(4,OUTPUT); //モーター2 pinMode(5,OUTPUT); pinMode(6,OUTPUT); //モーター3 pinMode(7,OUTPUT); pinMode(8,INPUT_PULLUP); //リミット1 pinMode(9,INPUT_PULLUP); //リミット2 pinMode(10,INPUT_PULLUP); //リミット3 }________//質問のプログラムにないようですが？ digitalWrite(2, HIGH); digitalWrite(3, LOW); digitalWrite(4, LOW); digitalWrite(5, HIGH); void loop ()｛ } あと、プログラムのデバッグは一歩一歩すすめるほうが結果的には早くできる。 この場合はモータ２が回らないことを最初に解決する。次にスイッチの論理を解決する。 で上のような案を提案しました。 以上、お役にたてれば嬉しいです。
まず、Visual Studio 2015は、おまかせでインストールしただけではC/C++は使えませんが、そこはいいですか? インストール時にC/C++を追加しなかった場合は、vs_community.exeを再度実行して追加することができます。 で、そのプログラムを見せてほしいのですが、黒い画面が開いて白い文字がずらずら出るタイプのプログラム(コンソールアプリケーション)か、綺麗な窓が開くタイプのプログラム(GUIアプリケーション)か、どっちですか? それによって、新規プロジェクト作成時のテンプレートを適切に選ぶ必要があります。
public static string henshin(string message) { if(message.contains("好き")) { return "寝ぼけたことを抜かすな"; } else if(message.contains("嫌い")) { return "わらわはピーマンが嫌いじゃ"; } else { return $"「{message}と聞こえたような気がした」"; } return ""; } ケータイからなのでタイプミス、スペルミスなどがあるかもしれませんがそこは修正して下さい
budoupan19さん 次のようになります。繰り返し文にはwhileを使用しました。 #include <stdio.h> int main(void) { int n = 0, /* 自然数 */ a; /* 階乗 */ printf("n = "); scanf("%d", &n); a = n; while (n > 1) { n--; a *= n; } printf("階乗 = %d\n", a); return 0; } おそらく次は、繰り返しを使わず再帰関数を使え、になりますね。このパターンは。
>kusuna_kithuneさん 配布元にたいていの場合どういう手順でやれば コンパイルできるかっていう説明書がついてるケースが多いよ 本家のDocumentsとか (本家とGithubが別れてるケースも多い) 有名なソフトならバイナリも配布されてること多いし そっちを使うとか C#のオープンソースバージョンもあるので そっちでコンパイルする手順を試すとか VisualC#なら プロジェクトの種類を色々試してみるとか 配布物のディレクトリにReadmeとかInstallとかが含まれてるファイルないか それを読まないといけない docとかのディレクトリがあれば、そのなかに文書ある場合もある
行列式の一般化の結果をコピペしてみてください。
具体的にどう操作してどういうエラーになるのかを正確に具体的に書いてください。
ListViewItem を元に新たなクラスを作っていろいろオーバーラドして苦労すると出来ます。 でも、おそろしく難しいです。 はっきて言ってやってられないので、誰もやってません。 こういう複雑な入力は、 DataGridView 上に実現するのが、普通です。 それでも、結構難しくて、みんな苦労して作っている様です。 ちなみに、DataGridView 用のは、作ってみました。 using System; using System.Windows.Forms; namespace WindowsFormsApplication1 { public class NumericUpDownColumn : DataGridViewColumn { public NumericUpDownColumn() : base(new NumericUpDownCell()) { } public override DataGridViewCell CellTemplate { get { return base.CellTemplate; } set { base.CellTemplate = value; } } } public class NumericUpDownCell : DataGridViewTextBoxCell { public override void InitializeEditingControl(int rowIndex, object initialFormattedValue, DataGridViewCellStyle dataGridViewCellStyle) { base.InitializeEditingControl(rowIndex, initialFormattedValue, dataGridViewCellStyle); NumericUpDownCellEditingControl ctl = DataGridView.EditingControl as NumericUpDownCellEditingControl; if (this.Value != null) ctl.Value = decimal.Parse(this.Value.ToString()); } public override Type EditType { get { return typeof(NumericUpDownCellEditingControl); } } public override Type ValueType { get { return typeof(decimal); } } public override object DefaultNewRowValue { get { return (decimal)0; } } public override object ParseFormattedValue(object formattedValue, DataGridViewCellStyle cellStyle, System.ComponentModel.TypeConverter formattedValueTypeConverter, System.ComponentModel.TypeConverter valueTypeConverter) { return base.ParseFormattedValue(formattedValue.ToString(), cellStyle, formattedValueTypeConverter, valueTypeConverter); } } class NumericUpDownCellEditingControl : NumericUpDown, IDataGridViewEditingControl { DataGridView dataGridView; private bool valueChanged = false; int rowIndex; public object EditingControlFormattedValue { get { return this.Value; } set { String newValue = value as String; if (newValue != null) { this.Value = decimal.Parse(newValue); } } } public object GetEditingControlFormattedValue( DataGridViewDataErrorContexts context) { return EditingControlFormattedValue; } public void ApplyCellStyleToEditingControl( DataGridViewCellStyle dataGridViewCellStyle) { this.Font = dataGridViewCellStyle.Font; } public int EditingControlRowIndex { get { return rowIndex; } set { rowIndex = value; } } public bool EditingControlWantsInputKey( Keys key, bool dataGridViewWantsInputKey) { switch (key & Keys.KeyCode) { case Keys.Left: case Keys.Up: case Keys.Down: case Keys.Right: return true; default: return false; } } public bool RepositionEditingControlOnValueChange { get { return false; } } public DataGridView EditingControlDataGridView { get { return dataGridView; } set { dataGridView = value; } } public bool EditingControlValueChanged { get { return valueChanged; } set { valueChanged = value; } } public Cursor EditingPanelCursor { get { return base.Cursor; } } protected override void OnValueChanged(EventArgs eventargs) { valueChanged = true; this.EditingControlDataGridView.NotifyCurrentCellDirty(true); base.OnValueChanged(eventargs); } public void PrepareEditingControlForEdit(bool selectAll) { } } }
これですかね。 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1216220091... 以下、便乗解答（？）です。 C 言語と C++ とで違いがありますよ。カッコ内に何も書いてない場合、 【Ｃ言語】引数の構成について言及無し 【Ｃ＋＋】引数は１個も無い こうなります。 今回はC++ですので、引数は１個もないのだという宣言をしてしまっている。 void Sort_1(); void Sort_2(); これが、 void Sort_1(void); void Sort_2(void); と解釈されているというわけです。 C言語の場合はプロトタイプ宣言なるものが登場する前に、引数の部分を書かない（ていうか、書けなかったので）形の宣言を置いて、それで戻り値の型だけを明らかにする。そういうやり方がありました。プロトタイプ宣言登場後もこの形は有効。よって、カッコ内に何も書かないのと (void) とは別物ということになったんですね。
loveutikawaさん 以下のようになります。 #include<stdio.h> int frac(int n) { if (n > 1) return n * frac(n-1); else return 1; } int main(void) { int n; printf("n = "); scanf("%d", &n); printf("%d! = %d\n", n, frac(n)); return 0; }
http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1416217820... を、teratermかなにかのターミナルプログラムで受信してlogに記録していけば特にプログラムは不要な気がするけれど、それじゃダメ?
loveutikawaさん strcpy()とstrrev()を、①使用するバージョンと、②しないバージョンで回答します。 ①のプログラム例 #include <stdio.h> #include <string.h> int main(void){ char str1[256]; char str2[256]; /* 文字列を入力 */ printf("Input string : "); scanf("%s", str1); /* 入力された文字列を表示 */ printf("str1 : %s\n", str1); /* 文字列をコピー */ strcpy(str2, str1); /* 文字列を反転 */ strrev(str2); /* 反転された文字列を表示 */ printf("str2 : %s\n", str2); return 0; } ②のプログラム例 #include <stdio.h> #include <string.h> int main(void){ char str1[256]; char str2[256]; char *p1, *p2; /* 文字列を入力 */ printf("Input string : "); scanf("%s", str1); /* 入力された文字列str1を表示 */ printf("str1 : %s\n", str1); /* str1の末尾を探す */ p1= str1, p2 = str2; while (*p1 != '\0') p1++; p1--;/* 1文字戻す */ /* str1をstr2にコピーする。 このときstr1は末尾から、str2は先頭からたどる */ while (p1 >= str1) { *p2 = *p1; p1--; p2++; } *p2 = '\0';/* str2の末尾 */ /* 反転された文字列を表示 */ printf("str2 : %s\n", str2); return 0; }
ハードウエアでは”算術演算だと、-32768～32767が範囲、論理演算だと、0～65535が範囲”などはわかりません。ようするにそんことを判断している論理回路などないということです。 もちろん、SLAで算術レフトシフトとはわかります。（アッセンブル後の機械語のレベルで） 算術レフトの規則（CASLの）に従ってシフトするだけです。ハードウエアがそうなっている。 CASL2の「算術レフトシフト」規則によると１５〜０ビットで１５ビットはそのままで１４〜０が指定数だけシフトしOFには１４、１３、１２、１１・・・・１、０ビットの状態が入る。 で、質問のこと。 GR1=0xD12C=1101 0001 0010 1100(B) これを４ビット左算術シフトするのだから、OFにはシフトとする度に1、0、1、0と入っていくことになる。最後は0 したがってシフトが終わったあとはOF=０です。 「SLL GR1,4」はロジカル４ビット左シフトだから・・・・・あとは考えてください。 １０進数に直しては反対にわからなくなります。
2進法で説明してみます。。
ジャンプ処理は、重力による落下処理と 組み合わせて、成立するものです。 そのため、キー判定だけでなく 時間に応じた落下処理も必要なので 以下の部分だけでは、作成できません。 「////////////////////////////////////////// if (GetKeyboardPress(DIK_Z)){ ＿＿//ジャンプ処理 } //////////////////////////////////////////」
12番を最初に作ってからにするといいよ。 一番難しいって？ そうだね。でも一番・・・。
私が試した方法でよければ、少し。 これは、いわゆるシューティングゲームの追尾弾の挙動を作った時の方法です。 まず、追尾する弾オブジェクト（以下、本体）は、Velocity等の方法で常に前進しています。 そして、本体のスクリプトに、着弾地点となる座標（実際には動いているオブジェクトのtransform.position）を指定しますが、その座標に直接向かう訳ではありません。 本体に着弾地点が指定されたら、その時点での本体の座標から、着弾地点の座標までの間を、Vector3.Lerp()を使って、時間をかけて移動する”可動ターゲット座標”を算出します。 そして本体は、この”可動ターゲット座標”に向かって進む（Transform.LookAt()でこの動いている座標を指定する）事で、本体はある程度の時間をかけて、進路を曲げつつ（弧状の軌道で）目標に着弾するという挙動になりました。 とまぁ、文章にすると分かりにくいのですが、要するに、本体が向かおうする座標自体を時間と共に移動させてやれば、直線的な動きにはなりにくい、という事です。 参考になれば。
回答します。 ■１．整数値128を変数に記憶した後、表示する ▼プログラム例 #include <stdio.h> int main(void) { /* 整数値128を変数に記憶 */ int i = 128; /* 表示 */ printf("%d\n", i); return 0; } ▼実行例 128 ■２．int型の変数aとdouble型の変数bを宣言する。 キーボードから変数bに値を入力した後、100で割った余りを求め、変数aに代入する。 最後に、変数bとaの値を表示する ⇒ 剰余算（%）はdouble型に対しては適用できないので、bをint型にキャスト（変換）してから計算します。 ▼プログラム例 #include <stdio.h> int main(void) { int a; double b; /* キーボードから変数bに値を入力 */ printf("b = "); scanf("%lf", &b); /* 100で割った余りを求め、変数aに代入 */ a = (int)b % 100; /* 変数bとaの値を表示 */ printf("b = %lf\na = %d\n", b, a); return 0; } ▼実行例 b = 150 b = 150.000000 a = 50 ■３．キーボードから２つの値を変数aとbに入力する。 aとbの参照値の符号が一致している場合は"+"、それ以外の場合は"-"と表示する ⇒aとbの型の指定が無いので、int型とします。 ▼プログラム例 #include <stdio.h> int main(void) { int a, b; /* キーボードから２つの値を変数aとbに入力 */ printf("a = "); scanf("%d", &a); printf("b = "); scanf("%d", &b); /* a,bの符号が一致しているか確認 →掛算して正なら符号一致、負または0なら符号違いか、どちらかまたは両方が0 */ if (a * b > 0) printf("+\n"); else printf("-\n"); return 0; } ▼実行例1 a = 3 b = -2 - ▼実行例2 a = 9 b = 6 + ■４．入力値が999となるまで、繰り返しキーボードから値を入力し、合計を求める。 ただし、break文を使ってはいけない。 ⇒合計は表示します。また、999は合計しません。 ▼プログラム例 #include <stdio.h> int main(void) { int in = 0, /* キーボードからの入力 */ sum = 0; /* キーボードからの入力の合計 */ /* 入力値が999となるまで、繰り返し */ while (in != 999) { /* 合計を求める(最初は0) */ sum += in; /* キーボードから値を入力 */ printf("number = "); scanf("%d", &in); } printf("合計 = %d\n", sum); return 0; } ▼実行例 number = 1 number = 2 number = 3 number = 4 number = 5 number = 999 合計 = 15
・２つの整数値を入力し、加減乗除算および剰余演算を行ない、結果を表示する #include<stdio.h> int main(void) { int x,y; printf("x:"); scanf("%d",&x); printf("y:"); scanf("%d",&y); printf("%d+%d=%d\n%d-%d=%d\n%d*%d=%d\n%d/%d=%d\n",x,y,x+y,x,y,x-y,x,y,x*y,x,y,x/y); return 0; } ・小数値を５つ入力し、最小値１つと、最大値１つを除いた３つの値の平均値を求めて表示する #include<stdio.h> #define MM 5 int main(void) { double d[MM],t; int i,j; for(i=0;i<MM;i++)scanf("%lf",&d[i]); for(i=0;i<MM-1;i++){ for(j=i+1;j<MM;j++){ if(d[i]<d[j]){ t=d[j]; d[j]=d[i]; d[i]=t; }}} printf("%f\n",(d[1]+d[2]+d[3])/3); return 0; } ・得点データとして-1が入力されるまで繰り返し得点データを入力し、平均値を求めて表示する。ただし、最後に入力された-1は平均値の計算に含まない。 #include<stdio.h> int main(void) { int n,g,i; scanf("%d",&n); i=0; g=0; while(n!=-1){ i++; g+=n; scanf("%d",&n); } if(i>0)printf("%d\n",g/i); return 0; } ・10000個のデータ（小数）をキーボードから入力し、分散を求める ==>分散の計算式を提示してください。
/* 2016/8/10 14:56:43 配列の要素をランダムに0 引数で与えられた確率でランダムに配列の要素を0にしたい 例えば， P=0.1(10％)の場合，配列の10個に1個が0になるようにしたい 「1.配列の確保・表示」 「2.要素を0にする関数で処理」 「3.配列の表示」 という流れにしたのですが 「2.要素を0にする関数で処理」 の中身がわからないので教えて下さい． ＞＞＞それ以外にも実行結果の確認に便利な ＿＿＿改善を施したのでよく読んで理解して下さい。 */ #include<stdio.h> #include<stdlib.h> #include<time.h> #define N＿ 100＿＿ // 配列のサイズ、データ数 #define M＿ 10000＿ // 配列要素の上限値 #define P＿ 0.3＿＿ // ランダムな要素0化の期待確率 /* 確率Pで配列の要素をランダムに0化 */ void loss(double p, int *ary); int main(int agc, char *agv[]){ ＿int＿＿ trim=0; // count of trim＿by loss() ＿int＿＿ org[N]; // サンプル配列：0化以前 ＿int＿＿ ary[N]; // サンプル配列：0化以後 ＿int＿＿ i;＿＿＿// 同インデクス ＿ ＿// 初期化 ＿srand((int)time(NULL));＿ // rand()系列初期化 ＿ ＿// 配列の初期状態表示 ＿printf("Initial status of array[%d]:\n",N); ＿printf("original array copied array\n"); ＿for(i=0;i<N;i++){ ＿＿org[i] = rand()%M;＿＿＿＿// 要素初期化：5桁乱数 ＿＿ary[i] = org[i];＿＿＿＿＿// 0化用配列にコピー ＿＿printf("org[%2d]=%5d＿", i, org[i]); ＿＿printf("ary[%2d]=%5d\n", i, ary[i]); ＿} printf("\n"); ＿ ＿// トリミング実行 ＿printf("Execute randum trimming by loss(P,ary)\n"); ＿printf("Probability P = %f\n", P); ＿loss(P,ary); ＿ ＿// トリム後の配列表示 ＿printf("\nAfter randam trim by rate %f\n",P); ＿printf("original array trimmed array\n"); ＿for(i=0;i<N;i++){ ＿＿printf("org[%2d]=%5d＿", i, org[i]); ＿＿printf("ary[%2d]=%5d\n", i, ary[i]); ＿＿if(ary[i]==0) trim++; ＿} printf("\n"); ＿printf("%d elements of ary[%d] were cleared.\n",trim,N); ＿printf("Probability P = %f\n", P); ＿// 終了 ＿printf("\n# normal end #\n\n"); // 確認表示 ＿system("pause");＿// キイ待ち停止 ＿return 0;＿ // main()終了 } // Execute randum trimming by P the expect rate. void loss(double p, int *ary){ ＿int＿ i;＿＿// 要素インデクス ＿ ＿for(i=0;i<N;i++){ ＿＿if( ary[i] < p*M ) ary[i] = 0; ＿} } /* 実行出力：console Initial status of array[100]: original array copied array org[ 0]= 7170＿ary[ 0]= 7170 org[ 1]= 9373＿ary[ 1]= 9373 org[ 2]= 3240＿ary[ 2]= 3240 org[ 3]= 8323＿ary[ 3]= 8323 org[ 4]=＿780＿ary[ 4]=＿780 org[ 5]=＿623＿ary[ 5]=＿623 org[ 6]= 5276＿ary[ 6]= 5276 org[ 7]= 5540＿ary[ 7]= 5540 org[ 8]=＿481＿ary[ 8]=＿481 org[ 9]= 9025＿ary[ 9]= 9025 org[10]= 9517＿ary[10]= 9517 org[11]= 4614＿ary[11]= 4614 org[12]= 9010＿ary[12]= 9010 org[13]= 6617＿ary[13]= 6617 org[14]= 8400＿ary[14]= 8400 org[15]=＿181＿ary[15]=＿181 org[16]= 2539＿ary[16]= 2539 org[17]= 6390＿ary[17]= 6390 org[18]= 2959＿ary[18]= 2959 org[19]= 9813＿ary[19]= 9813 org[20]=＿405＿ary[20]=＿405 org[21]= 4589＿ary[21]= 4589 org[22]= 2092＿ary[22]= 2092 org[23]= 1553＿ary[23]= 1553 org[24]= 5115＿ary[24]= 5115 org[25]= 4173＿ary[25]= 4173 org[26]= 4178＿ary[26]= 4178 org[27]=＿388＿ary[27]=＿388 org[28]= 7260＿ary[28]= 7260 org[29]=＿154＿ary[29]=＿154 org[30]= 3886＿ary[30]= 3886 org[31]= 3452＿ary[31]= 3452 org[32]= 8241＿ary[32]= 8241 org[33]=＿775＿ary[33]=＿775 org[34]= 1855＿ary[34]= 1855 org[35]= 2475＿ary[35]= 2475 org[36]= 2320＿ary[36]= 2320 org[37]= 2965＿ary[37]= 2965 org[38]= 7146＿ary[38]= 7146 org[39]=＿976＿ary[39]=＿976 org[40]= 2144＿ary[40]= 2144 org[41]= 6188＿ary[41]= 6188 org[42]= 6769＿ary[42]= 6769 org[43]= 2549＿ary[43]= 2549 org[44]= 7117＿ary[44]= 7117 org[45]= 4647＿ary[45]= 4647 org[46]= 2341＿ary[46]= 2341 org[47]= 7306＿ary[47]= 7306 org[48]= 9662＿ary[48]= 9662 org[49]= 6437＿ary[49]= 6437 org[50]= 8009＿ary[50]= 8009 org[51]= 9251＿ary[51]= 9251 org[52]= 8469＿ary[52]= 8469 org[53]= 9133＿ary[53]= 9133 org[54]= 5417＿ary[54]= 5417 org[55]= 9054＿ary[55]= 9054 org[56]= 7447＿ary[56]= 7447 org[57]= 8114＿ary[57]= 8114 org[58]= 8587＿ary[58]= 8587 org[59]= 1623＿ary[59]= 1623 org[60]= 3933＿ary[60]= 3933 org[61]= 7095＿ary[61]= 7095 org[62]= 6196＿ary[62]= 6196 org[63]= 1231＿ary[63]= 1231 org[64]= 1658＿ary[64]= 1658 org[65]= 4405＿ary[65]= 4405 org[66]= 7070＿ary[66]= 7070 org[67]= 2522＿ary[67]= 2522 org[68]=＿334＿ary[68]=＿334 org[69]=＿634＿ary[69]=＿634 org[70]= 2169＿ary[70]= 2169 org[71]= 4631＿ary[71]= 4631 org[72]= 3963＿ary[72]= 3963 org[73]= 2276＿ary[73]= 2276 org[74]= 4160＿ary[74]= 4160 org[75]= 6118＿ary[75]= 6118 org[76]= 9110＿ary[76]= 9110 org[77]= 9742＿ary[77]= 9742 org[78]= 9997＿ary[78]= 9997 org[79]= 9622＿ary[79]= 9622 org[80]= 9887＿ary[80]= 9887 org[81]= 6075＿ary[81]= 6075 org[82]= 2511＿ary[82]= 2511 org[83]= 5660＿ary[83]= 5660 org[84]=＿260＿ary[84]=＿260 org[85]= 6881＿ary[85]= 6881 org[86]= 7051＿ary[86]= 7051 org[87]= 7242＿ary[87]= 7242 org[88]= 1939＿ary[88]= 1939 org[89]=＿759＿ary[89]=＿759 org[90]= 1505＿ary[90]= 1505 org[91]=＿239＿ary[91]=＿239 org[92]= 4191＿ary[92]= 4191 org[93]= 6098＿ary[93]= 6098 org[94]= 6641＿ary[94]= 6641 org[95]= 6732＿ary[95]= 6732 org[96]= 3829＿ary[96]= 3829 org[97]= 4764＿ary[97]= 4764 org[98]= 2494＿ary[98]= 2494 org[99]= 2439＿ary[99]= 2439 Execute randum trimming by loss(P,ary) Probability P = 0.300000 After randam trim by rate 0.300000 original array trimmed array org[ 0]= 7170＿ary[ 0]= 7170 org[ 1]= 9373＿ary[ 1]= 9373 org[ 2]= 3240＿ary[ 2]= 3240 org[ 3]= 8323＿ary[ 3]= 8323 org[ 4]=＿780＿ary[ 4]=＿＿0 org[ 5]=＿623＿ary[ 5]=＿＿0 org[ 6]= 5276＿ary[ 6]= 5276 org[ 7]= 5540＿ary[ 7]= 5540 org[ 8]=＿481＿ary[ 8]=＿＿0 org[ 9]= 9025＿ary[ 9]= 9025 org[10]= 9517＿ary[10]= 9517 org[11]= 4614＿ary[11]= 4614 org[12]= 9010＿ary[12]= 9010 org[13]= 6617＿ary[13]= 6617 org[14]= 8400＿ary[14]= 8400 org[15]=＿181＿ary[15]=＿＿0 org[16]= 2539＿ary[16]=＿＿0 org[17]= 6390＿ary[17]= 6390 org[18]= 2959＿ary[18]=＿＿0 org[19]= 9813＿ary[19]= 9813 org[20]=＿405＿ary[20]=＿＿0 org[21]= 4589＿ary[21]= 4589 org[22]= 2092＿ary[22]=＿＿0 org[23]= 1553＿ary[23]=＿＿0 org[24]= 5115＿ary[24]= 5115 org[25]= 4173＿ary[25]= 4173 org[26]= 4178＿ary[26]= 4178 org[27]=＿388＿ary[27]=＿＿0 org[28]= 7260＿ary[28]= 7260 org[29]=＿154＿ary[29]=＿＿0 org[30]= 3886＿ary[30]= 3886 org[31]= 3452＿ary[31]= 3452 org[32]= 8241＿ary[32]= 8241 org[33]=＿775＿ary[33]=＿＿0 org[34]= 1855＿ary[34]=＿＿0 org[35]= 2475＿ary[35]=＿＿0 org[36]= 2320＿ary[36]=＿＿0 org[37]= 2965＿ary[37]=＿＿0 org[38]= 7146＿ary[38]= 7146 org[39]=＿976＿ary[39]=＿＿0 org[40]= 2144＿ary[40]=＿＿0 org[41]= 6188＿ary[41]= 6188 org[42]= 6769＿ary[42]= 6769 org[43]= 2549＿ary[43]=＿＿0 org[44]= 7117＿ary[44]= 7117 org[45]= 4647＿ary[45]= 4647 org[46]= 2341＿ary[46]=＿＿0 org[47]= 7306＿ary[47]= 7306 org[48]= 9662＿ary[48]= 9662 org[49]= 6437＿ary[49]= 6437 org[50]= 8009＿ary[50]= 8009 org[51]= 9251＿ary[51]= 9251 org[52]= 8469＿ary[52]= 8469 org[53]= 9133＿ary[53]= 9133 org[54]= 5417＿ary[54]= 5417 org[55]= 9054＿ary[55]= 9054 org[56]= 7447＿ary[56]= 7447 org[57]= 8114＿ary[57]= 8114 org[58]= 8587＿ary[58]= 8587 org[59]= 1623＿ary[59]=＿＿0 org[60]= 3933＿ary[60]= 3933 org[61]= 7095＿ary[61]= 7095 org[62]= 6196＿ary[62]= 6196 org[63]= 1231＿ary[63]=＿＿0 org[64]= 1658＿ary[64]=＿＿0 org[65]= 4405＿ary[65]= 4405 org[66]= 7070＿ary[66]= 7070 org[67]= 2522＿ary[67]=＿＿0 org[68]=＿334＿ary[68]=＿＿0 org[69]=＿634＿ary[69]=＿＿0 org[70]= 2169＿ary[70]=＿＿0 org[71]= 4631＿ary[71]= 4631 org[72]= 3963＿ary[72]= 3963 org[73]= 2276＿ary[73]=＿＿0 org[74]= 4160＿ary[74]= 4160 org[75]= 6118＿ary[75]= 6118 org[76]= 9110＿ary[76]= 9110 org[77]= 9742＿ary[77]= 9742 org[78]= 9997＿ary[78]= 9997 org[79]= 9622＿ary[79]= 9622 org[80]= 9887＿ary[80]= 9887 org[81]= 6075＿ary[81]= 6075 org[82]= 2511＿ary[82]=＿＿0 org[83]= 5660＿ary[83]= 5660 org[84]=＿260＿ary[84]=＿＿0 org[85]= 6881＿ary[85]= 6881 org[86]= 7051＿ary[86]= 7051 org[87]= 7242＿ary[87]= 7242 org[88]= 1939＿ary[88]=＿＿0 org[89]=＿759＿ary[89]=＿＿0 org[90]= 1505＿ary[90]=＿＿0 org[91]=＿239＿ary[91]=＿＿0 org[92]= 4191＿ary[92]= 4191 org[93]= 6098＿ary[93]= 6098 org[94]= 6641＿ary[94]= 6641 org[95]= 6732＿ary[95]= 6732 org[96]= 3829＿ary[96]= 3829 org[97]= 4764＿ary[97]= 4764 org[98]= 2494＿ary[98]=＿＿0 org[99]= 2439＿ary[99]=＿＿0 36 elements of ary[100] were cleared. Probability P = 0.300000 # normal end # 続行するには何かキーを押してください . . . */
dayが1～7の時、 day-1は0～6 これを7で割ったら、整数値なら0 0に1を足すから1 dayが8～14の時、 day-1は7～13 これを7で割ったら、整数値なら1 1に1を足すから2 以下同様。
どの行を選択しても結果は変わらないと思いますが、列ヘッダ名を取得したいのならこんな感じかな? dataGridView1.Rows[1].Selected = true; foreach (DataGridViewCell c in dataGridView1.CurrentRow.Cells ) { DataGridViewColumn col=dataGridView1.Columns[c.ColumnIndex ]; textbox.AppendText(col.HeaderText + "\r\n"); } dataGridView1.SelectedRowsは DataGridViewRow のコレクションなので、DataGridViewColumnにはキャストできないです。
文字列1と2の文字列長は同じであることが前提条件です。 #include<stdio.h> int main(void) { char w1[256],w2[256]; int i,j; printf("文字列1="); scanf("%s",w1); printf("文字列2="); scanf("%s",w2); for(j=2,i=0;w1[i]!='\0';i++)if(w1[i]!=w2[i])j--; if(j<0)j=0; printf("%d点\n",j); return 0; } ＝＝＝＝＝＝＝＝＝＝ 文字列1と2の文字列長は異なる場合 #include<stdio.h> int main(void) { char w1[256],w2[256]; int i,j,k; printf("文字列1="); scanf("%s",w1); printf("文字列2="); scanf("%s",w2); i=0; j=0; k=2; while(1){ if(w1[i]!=w2[j])k--; if(w1[i]!='\0')i++; if(w2[j]!='\0')j++; if(w1[i]=='\0'&&w2[j]=='\0')break; } if(k<0)k=0; printf("%d点\n",k); return 0; } ちなみに宿題とかではなく、ただ単に私が個人的に気になって調べ倒しましたが解決しなかったため書き込みました・・・。 ==>そのようなことは書かなくて良い。純粋に仕様を明確にして質問してください。 点数がマイナスになっても引いています。0点になった時点で比較を止めても構わないが、、、、
「プログラミング関係のお仕事」ばかりやってます。ていうか、他のことはやったことありません。 では、アドバイスしますよ。 「将来はＡＩやプログラミング関係の職」とのこと。 で、どっち？ （１）ＡＩ （２）プログラミング関係 どちらの方面を希望してるのかな。 （１）の場合、プログラミングは些末になる可能性があります。おそらく設計が大事なになるのではないでしょうか。ましてや C 言語とか言ってる場合ではないと思う。 （２）の場合、これは色々です。プログラミング職人になりたいですか？なら、今の内から（あるいは小学生の時からでも） C 言語をやることは意味があると思います。 あと、学校の勉強、大丈夫ですか？ 「年から二年かけてじっくり学ぼうと思っています」とのことで、もしかして中高一貫校かな？高校受験が不要？だとしても注意しないと。 大事な時期ですので、学業に悪影響が出ないか心配なのですよ。 特に英語と数学。 英語、得意ですか？得意なら結構。もっと伸ばしてくださいね。万一苦手だとしたら、これは本当に危険です。将来ＡＩをやる場合、非常にまずい事態になります。おそらく、プログラミングをやる場合も同じ。ものすごく困った事態になりそう。 資料、英語ですからね。日本語で書いてあるわけないじゃないですか。 え？書いてある？ じゃ、そういうのもあるのかもしれません。 あるとして、それって大したことない資料かも。ほぼ、読む価値が無い資料かもしれません。 読むべき資料が英語版しかないとして、それで諦めてしまうというのはまずいです。 要注意ですよ。 数学については、ＡＩやる場合は無茶苦茶大事でしょう。 プログラミングをやる場合、分野によります。大多数の分野では数学不要。全然使いません。知ってると使えることが稀にあるかもしれませんが。 でも、将来は大学受験しますか？ 受験するなら数学は大事ですよ。苦手だとすると急に取り組んでも間に合わなくなりますのでね。英語もだけど。 将来のことを考えると今一番大事なのは学校の勉強です。この時期に C 言語を覚えても、学業成績の状況によっては、将来それを活かすことが難しくなる恐れがあります。そこだけ注意してくださいね。 《備考》 小学生の時からハードウェアっていうかアナログ回路の電子工作ですけど、をやってました。中学生のころマイコンなるものが登場しまして、デジタル回路やら二進数やら勉強しました。高校生くらいで機械語などをやりまして…。 英語は資料を読む都合もあり、知らず知らずに語彙が増えて得したのですけど、数学は絶望的な状態でした。ホントにひどかった。 受験では苦労しましたよ。 そういう実体験に基づくアドバイスですからね。
#include<stdio.h> int main(void) { double x, y; printf("x :"); scanf("%lf",&x); printf("y :"); scanf("%lf", &y); printf("x + y = %f\n", x+y); printf("x - y = %f\n", x-y); printf("x * y = %f\n", x*y); printf("x / y = %f\n", x/y); return 0; } こんな感じでいかがですか？？
class A { public: void m() {} }; の&A::mを返すとして、一番簡単な方法は下記の通りです。 auto f() { return &A::m; } あるいは、明示的に auto f() -> decltype(&A::m) { return &A::m; } としてもよいでしょう。 なお、一番古い書き方では、次のようにします。 void (A::*f())() { return &A::m; }
回文の場合がないとつまらないので、蛇足をつけました。 #include <stdio.h> int is_palindrome(char *str){ char *head =str; char *tail =str; while(*++tail != '\0'); tail--; while(*head==*tail){ head++; tail--; } if(head>=tail){ return 1; } else{ return 0; } } int main(void){ char *s1 ="abc"; char *s2 ="abab"; char *s3 ="abba"; char *s4 ="ababa"; printf("%d\n", is_palindrome(s1)); printf("%d\n", is_palindrome(s2)); printf("%d\n", is_palindrome(s3)); printf("%d\n", is_palindrome(s4)); return 0; }
#include <stdio.h> int is_sq_num(int n) { int i, p; for(i = 1; (p = i * i) < n; ++ i){ int j, q; for(j = i + 1; (q = j * j) < n; ++ j){ if(n == p + q) return 1; } } return 0; } int main(void) { int i; for(i = 1; i <= 1000; ++ i){ if(is_sq_num(i)) printf("%d\n", i); } return 0; }
・終了直前にキー入力待ちにする。 ・終了直前にブレイクをセットする などなど。
大体そうですが、かなり訓練しない限り100Mの距離で撃ち合ってもほぼ外れます！ 訓練してないからでは？
>manbou1129さん 参考書も必要だけど重視すべきは過去問 過去問をやりまくって、解けない問題について必要なら参考書も利用しながら 類題を解けるように準備 言語はCじゃなくてアセンブラが選択可能ならアセンブラを選択すべき (格段に問題が簡単で容易に満点取れるから) 参考書は図書館で借りまくって手元におきたいものを買う方が 外れは少ないと思う 複数あるほうが わかりにくい所を別の説明で読めるので 複数持ってた方が良いと思う 参考書で準備すると効率悪いので 過去問重視で準備することをお勧めします 過去問は解説が詳しいものが良い こちらも複数もってても良い 過去問は多いものも必要 最初はほぼできないけど その苦しさに耐えて何年もやれば 似た問題が出る傾向あるので だんだん解けるようになってくる 出来ない問題にはマークして 何度もやりなおすようにする (出来る問題をやっても点がのびないので) 満点を取る必要はないので 労力少なく点を取れるものを優先して準備
> 一行の出力(簡潔)と書式出力だけの違い だといえば、確かにその通りです。 大きな違いですけどね。
言っていることがよくわからない。 そもそも、このプログラムは何をするものなの？ どういった値を入力して、どういった結果が出れば正解なの？ こういったことを具体的に書いた方がよっぽど答えに近づくわ。
d=1はgcd(943,gcd(1219,2173))から得られるとして，そこから先は「不定方程式 maxima」でぐぐるとよさげな気がします。
chielien_dedd15481ecb7a2bdc98f06さん 1から100までの整数で、3の倍数でないものの合計 N1=1+2+...+100=101*50=5050 N2=3+6+...+99=3(1+2+...33)=3*33*34/2=1683 N=N1-N2=3367 ???
質問文で「実行したところエラーが発生」と書かれていますが、kuro_neko_g_sanさんの回答への返信を見るとビルド時のエラーですよね。(実行まで行けていないはず) 技術的な話をする場合ですので、どういう環境で、どういう事をしたときに、どういうエラーが出た、というのを正確に記述しなければ正しい情報のやりとりが出来ません。 本題ですが、そのエラー内容はリンク時のエラーですのでlibファイルの参照が出来ていないということになります。 まず、MIDIIOd.libとMIDIIO.libは1つのビルド構成で片方のみを設定します。 ビルド構成というのは「Debug」とか「Release」とか選択を切り替えられるやつです。 すなわち、「Debug」ビルド用の設定では「MIDIIOd.lib」の参照を。「Release」ビルド用の設定では「MIDIIO.lib」の参照を行います。 (プロジェクトの設定ダイアログでも左上でどのビルド構成を対象にしているかわかります) 次に正しいパスで参照を行わなければなりません。 リンカの入力欄に単に「MIDIIO.lib」などファイル名のみを記述してもだめです。 libファイルをどこに置くかによりますが、たとえば「MIDIIO.lib」をソリューションファイル(*.sln)のある場所に作った「rls」フォルダ内に置いた場合には、リンカ入力に「$(SolutionDir)rls\MIDIIO.lib」と指定することになります。 よく分からなければ、ひとまず動作させるためにフルパスで指定しておいて先に進むのも手です。(その場合は後で理解してよりメンテしやすい設定になおしましょう) そして、サンプルのコードを実行して音を出すには上にもすこし書きましたが環境も影響してきます。 リンク先のサンプルコードでは古いOSようになっていますが、たとえばWindows7であれば「"Microsoft GS Wavetable SW Synth"」の部分は「"Microsoft GS Wavetable Synth"」に変える必要があります。(あるいは他にインストールしてあればそのMIDI音源名) 当方の環境で試したところ、それらしい音がでることは確認出来ました。
Visual Studio 2012のどのエディションですか? Expressだと思いますが、デスクトップアプリの開発には"for Windows Desktop"が必要です。 https://www.microsoft.com/ja-jp/download/details.aspx?id=34673 "for Windows 8"や"for Web"ではコンソールアプリは作れません。 http://forest.watch.impress.co.jp/docs/news/559421.html
>mkn4724さん 宿題をこんなところで聞くのがまずよろしくなさすぎ 出来ない理由ははっりしまくり 準備不足 復習ちゃんとやって (もともと授業の範囲の知識できるようになってんだし) ノートをとってないならノートちゃんとしてるヤツからノートをコピー (賄賂的なものをあげて、高級お菓子とか高級な食事をおごるとか) あとはキーワードはっきりしてるし ネット検索すれば証明方法の例もすぐみつかるから そこの問題を、こっちの問題をおいておいてまずやってみて 解説みずにできるようになってから こっちの問題やれば多分自己解決できる 自己解決できないなら それは君の能力が低すぎるから 更なる工夫をするか 他の単位でなんとかするかだね
私も悩みましたが、 それぞれの機能をイメージして使います。 STL は vector, string, list, map, multimap, stack, deque, set, multiset... とありますが、 vector -> 配列状にならんだもの string -> 文字列用。 vectorとかに文字列を入れるときはこれになる。 list -> ポインタでつなぎとめられていて、途中挿入や、途中削除 に有利。 map -> 辞書のように データ A と データ B がセットになっているもの。 multimap -> map は 重複はゆるさないが、これは重複OK。 stack -> 上に積み重ねて、最新のデータから処理する必要がある場合。あと計算機を作る場合とか。 キュー -> 古いやつから順に 処理する必要がある場合。(順番が決まっているとか。 ) ... と考えると、 -------------------------------- データを入れるが、保存用 ( 配列等 ) なのか 順をつけて一時的に確保するのか "保存" なら vectorか list, map etc。 そうでなければ stack, キュー... -------------------------------- 1番目から n-2 番目 のデータを頻繁に削除したり追加したりするか "削除・追加あり" なら list, "〃なし" なら vector... -------------------------------- という感じで機能を考えてやればなんとなくわかるかと思います。 違いがまっっったくわからん っていう感じなら、 STLを使わずに「データ構造とアルゴリズム」の "リスト構造", "スタック", ”キュー" 等をやってみてください。 「C言語 データ構造 アルゴリズム」 みたいに検索すれば出てきます。 ( C++でもできますが、STLがあるので、それの使い方が主になるので。 )
Windowsなら 1. 対象のウィンドウハンドルを取得 2. 閉じるを送る みたいな感じなんでしょうね。
サクラエディタでできます。 印刷の設定で ・行番号を印字にチェック ・段数を２ ・ヘッダー(フッター)に$/$fを指定（$/でファイルのパス、$fでファイル名） ・ヘッダー(フッター)に$dを指定（現在日付） その他、いろいろと、特殊記号の組合せでヘッダー、フッター各３か所（左寄せ、中央、右寄せ）に設定できますので、目的のかたちで印刷できるかと思います。 http://sakura-editor.sourceforge.net/htmlhelp2/HLP000284.html
>rorsonwさん エラーメッセージからすると ファイルのパーミッションの問題の可能性もあるので そのユーザーで開くファイルをコピーして そのコピー先を開いたらどうなりますか？ 有料ソフトっぽいし、ユーザーサポートが利用できるはずなので メーカーのサポートに電話してきくのが効率良いと思う
if(ansr[k1] == ansrc[k1]){ 格納されるポインタは違うので、当然毎回違うという結果になります。 文字列が同じ文字列かどうかを判定するのは、通常 strcmp() などの関数を使います。 当然 strcmp() と同じように、 １文字づつ文字が同じかどうか確認するようにプログラムにしてもかまいません。
（＾＾）つ【ttp://www.kk.iij4u.or.jp/~kondo/wave/】 がんばりなはれ データとしては、LチャンネルRチャンネルの順に交互に記録していけば良いだけみたいね。
>gorygory02111さん 無理して作れないもの作らなくても スプレッドシートソフトでも可能だよその処理 他にもそれができるツールは山ほどある先人のおかげで 課題なら自分で出来るところまでやって 提出やね 他人にやってもらおうとするんじゃないよ
> その時にa[0]問いったリストの呼び出しを使って計算を行いたい あなたが自分で書いている通り、a[0]とすればリストの呼び出しになる。 a[0] で [1,2] が出てくるし、a[0][0] で 1が出てくる。 2つの「intのリスト」のリスト が前提なら from math import sqrt sqrt(sum((a1 - b1)**2 for a1, b1 in zip(*a))) ですかね。 a = [[1,2,3], [4,5,6]] sqrt(sum((a1 - b1)**2 for a1, b1 in zip(*a))) #=>5.196152422706632 sqrt((1-4)**2 + (2-5)**2 + (5-6)**2) #=>5.196152422706632 http://docs.python.jp/3.5/library/functions.html#zip
8 1 7 3 4 5 9 6 2 2 4 6 1 9 7 8 5 3 5 9 3 6 2 8 1 7 4 6 2 9 8 3 1 5 4 7 3 8 1 5 7 4 6 2 9 7 5 4 2 6 9 3 1 8 4 3 2 9 1 6 7 8 5 9 6 5 7 8 2 4 3 1 1 7 8 4 5 3 2 9 6
多角形対頂点の内外判定そのものについてはあまり高速化の余地はありませんので、やはり衝突判定の高速化に重要なのは空間分割アルゴリズムをどうするかだと思います。 よく使われるアルゴリズムとしては、 ・Uniform Grid ・kd-tree ・BVH あたりでしょうか。 実装が一番お手軽なのはUniform Gridかと思います。
//Form1にStringGrid1とButton2を配置して //Button2を押した時にStringGrid1に読み込む例です。 //あらかじめStringGrid1の「列数」は必要な量を設定しておくものとします。 void __fastcall TForm1::Button2Click(TObject *Sender) { //単純にファイルをグリッドに流し込む例(比較的簡単です) //※行の自動拡張を行います。 //※列の自動拡張はしません。 if(!OpenDialog1->Execute())return;//ファイル選択キャンセルした時 //ファイル選択した時 //ファイルをStringListに読み込みます TStringList *StringList = new TStringList(); StringList->LoadFromFile(OpenDialog1->FileName);//読み込みに失敗すると例外が発生します。例外でプログラムがストップする事を避けたい場合は、例外処理を追加して下さい。 //StringListの内容をグリッドに表示します StringGrid1->RowCount = 1;//行数は１未満にはならないので１にしておきます for(int i=0;i<StringList->Count;i++){ if(StringGrid1->RowCount <= i){ //行数が足らない時 StringGrid1->RowCount = i+1;//行数を拡張します } //グリッドの行にファイルの行をスペース区切りで流し込みます StringGrid1->Rows[i]->Delimiter=' ';//スペース区切り StringGrid1->Rows[i]->StrictDelimiter=true;//falseにすると非表示文字も区切り文字扱いになります StringGrid1->Rows[i]->DelimitedText = StringList->Strings[i]; } delete StringList; }
＞各関数ごとの最終的な演算時間を求めたい 以下のようにします。 各々の関数をstartとendで挟み、totalに加算します。 ＊＊＊ #include<stdio.h> #include<time.h> #define FUNC 3 #define LEN 500 int funcA(int x, int y, int z){ int i, j; int m = 5923; for(i=0; i<LEN; i++){ for(j=0; j<LEN; j++){ x += (x*i*j) % m; } x %= m; } printf("m=%d, x=%d\n", m, x); return x; } int funcB(int x, int y, int z){//Tarai if(x <= y){ return y; } funcB(funcB(x-1, y, z), funcB(y-1, z, x), funcB(z-1, x, y)); } int funcC(int x, int y, int z){//Tak if(x <= y){ return z; } funcC(funcC(x-1, y, z), funcC(y-1, z, x), funcC(z-1, x, y)); } int main(void){ int i, j; clock_t start, end; double total[FUNC] = {0}; int (*func[FUNC])(int, int, int);//関数ポインタ func[0] = funcA; func[1] = funcB; func[2] = funcC; for(i=0; i<5; i++){ for(j=0; j<FUNC; j++){ start = clock(); (*func[j])(10, 7, 0);//関数ポインタ end = clock(); total[j] += (double)(end - start)/CLOCKS_PER_SEC; } } for(i=0; i<FUNC; i++){ printf("func %c: %f [s]\n", 'A'+i, total[i]); } return 0; }
そもそも「以下」がないんだけど。 基礎的なことがわかっていないことがわかっているのなら、それなりの資料を調べたらいかがかしら。 &はアドレス演算子。オブジェクトのアドレスを求める。 *は、間接演算子かな? ポインタが指している先にアクセスする。 ->は、構造体/共用体ポインタ演算子、通称? アロー演算子。構造体等へのポインタからメンバーにアクセスする それぞれググれば出てくるかと思います。
ster_sky_1101さん for文をビシッとつかいました。 #include <stdio.h> void printaster(int space, int aster, int space2) { while (space > 0) printf(" "), space--; while (aster > 0) printf("*"), aster--; while (space2 > 0) printf(" "), space2--; printf("\n"); } int main(void) { int i; for (i = 1; i <= 10; i++) { if (i == 1) printaster(11-i, i, 0); else printaster(10-i, i, 1); } return 0; }
>jicojapan2006さん 問題の番号を間違ってるか リンクを間違ってると思う 23はXMLに関する問題だよ
>ryuyalikesoccerさん *** 本のソースをコンパイルできないことは普通はありません 普通は本のとおり打ち込めば動くはず エラーメッセージを真面目に読んで、 エラー発生行が書いてあるので、そこで使ってる関数とかの使い方にあってない 打ちまちがいしてる可能性がかなり高い エラーは一番最初のエラーが次に影響してるかもしれないので 一番上のエラー発生行のエラー原因を取りのそいたら もう一度コンパイル、エラーが発生しなくなるまでくりかえせば 動くようにできる 使ってる関数は全部調べて、使いかたをサンプルソースを動かす ソース熟読(わからない関数は前部調べて)、元のソースをできるだけ見ないようにして作る(使いかたの練習、それしないと普通は使えない) を面倒くさがらずに地道にやれば質問のような事態にはならない *** Excelでもプログラムできるけんについては 言語がことなります。 それでも良ければそれを使えば良い *** エディタでプログラム プログラム用のものとか 補完ができるもの使う方が良いと思う 私はVimを愛用してます エディタが補完機能ないと打ちまちがいが増えてデバッグ量が増えるので それなりのエディタ使った方が良いと思う コンパイルはGNU Makeを使うと楽です(IDE使うより) 短いプログラムを書く場合は特に ****まとめ * ソースを真面目に読みましょう *わからない関数は 関数名 ソースに含まれそうなキーワード でネット検索。例えば printf #include * エディタはそれなりのものを使って、GNU Makeを利用するとIDE使うより楽です http://note.chiebukuro.yahoo.co.jp/detail/n36864
まず こちらの「Arduinoトラブルシューティング」を試してみて下さい http://100year.cocolog-nifty.com/blog/2014/06/arduino-9471.html
簡単な話 チケットナンバーを受け取るグローバル変数がありますよね？ ここではgTicketとでもしときましょう これを持ちたい最大ポジション数分作るわけです。 gTicket1 gTicket2 gTicket3 gTicket4 という具合です。 そして、チケットナンバーをOrderSend関数から各々専用のgTicketに受け取って おきます。 このチケットナンバーを利用してOrderSelectし OrderModifyでトレーリングストップをかけてやればいいんですよ。 mqlのOrderSendにはSELECT_BY_POSもありますが 私の場合はこの機能はポジションの管理やリスクの管理が非常にしづらいと 感じるので基本利用してません ポジションを持てる限り持つEAなどリスク管理上よろしくないと思いますので
(1) 1001 (2) i (3) i (4) flag[j] = 0; j *= 2; (5) if(flag[i] == 1){ printf("%d ", i); /* 横に並べて表示する場合 */ printf("%d\n", i); /* 縦に並べて表示する場合 */ }
PIC の種類は？ OSCCAL欄が灰色 <- 設定不要です VCC , GND , /MCLR , ICSPDAT ,ICSPCLK の接続ピン確認 PIC 単体で PICKIT2 に接続してますか、ICSPDAT , ICSPCLK ピンはプルアップ禁止 /MCLR は 10KΩでプルアップ PICKIT 2 Programmer でも HEX ファイルは読み込めませんか？ http://www.ne.jp/asahi/air/variable/picmel/integration/write/pickit...
VBAでしょう 就職先で必要ならどうせ勉強させられますが、Ｃを使うようなガチガチのＩＴ系なら言語以外の仕様書やらネットワーク技術やらその都度勉強になるでしょうし、事務系にいくならＶＢＡは覚えていたほうが便利そうです この際、苦手意識をなくしてしまいましょう Ｃを復習するなら絶版でしょうけどＣノート（近代科学社）をお勧めします １００ページほどしかありませんが、Ｃ言語を俯瞰できます
だいたいプログラムのディレクトリにreadmeとかリファレンスとかがあってバージョンなり更新ログなりの情報が書いてありますよ。 それか-versionみたいなコマンド探すか。 manとかで確認できませんか？
下記のサイトを参考にしてください。 http://dobon.net/vb/dotnet/file/writefile.html
文字コードを指定してテキストファイルに書き込む http://dobon.net/vb/dotnet/file/writefile.html
scanf(" %c", &name); 文字列入力処理を文字入力命令でやってるからだと思います。
SVG の最大の利点は、XML ベースであり、XML ファミリーの様々なツールを使えるということ。 逆に言えば、XML であることに利点を感じないのなら、あまり使う意味はないよ。
あまりその傾向は感じ取れませんが、皆が学ぶ必要はないでしょう。
n→∞で収束するときan+1もanも同じ値になるのでαと置くと、 α=0.5α+3 α=6 よって、6に収束します。
>surahutoさん ツール名 やりたいこと ツール名 キーワード でネット検索すれば大抵すぐやり方は調べれます データはその使いかた調べたサイトの方法にあわして用意する方が良いよ 今回だと gnuplot 等高線 データファイル でネット検索 http://www.eml.ele.cst.nihon-u.ac.jp/~momma/wiki/wiki.cgi/gnuplot/%... あたりがわかりやすそう 同じキーワードでネット検索かけてもらって検索上位で一番良いと思うサイトを利用するのが良いと思うよ まず自分のやりたいことをやるまえに そのサイトのデータを使って同じことやってみて データの構造を確認 自分のやりたいこともそのデータフォーマットにあわせて用意して プットすれば同じことできるはず、君のやりたいテータにたいして
if(a<b<c) って書けるのか？ if(a<bかつb<c) じゃなくて？ 見当違いだったらすまん。
%sにしか対応できていませんが、作ってみました。 #include <stdio.h> #include <stdarg.h> int my_printf(const char *str, ...) { va_list args; va_start(args, str); int count = 0; while (*str != '\0') { if (*str == '%') { ++str; switch (*str) { case 's': { const char *p = va_arg(args, const char *); while (*p != '\0') { putchar(*p); ++count; ++p; } break; } } } else { putchar(*str); ++count; } ++str; } va_end(args); return count; } int main() { my_printf("Hello, %s World!", "My"); return 0; }
>ak_meadokaemasitasupamuさん 検索するときに漢字間違ってるからヒットしてないとかないかな 線形リスト でgoogleでネット検索してトップのサイトが最高にわかりやすい サンプルソースもあるし *快絶を全部読む *サンプルコードを全部動かしてソース熟読 *わからない関数は全部調べる +どうせ授業の課題やろ<ノートの見直しと、買わされてる参考図書を真面目に復習 これらで準備してからやれば馬鹿じゃなければ普通に自己解決や 課題を人にやってもらって なんとかしようとか考えかた間違ってます 時間の無駄なのでそんなことは止めましょう どうしてもやる気になれないなら やる気になれるもので単位をそろえましょう 必須科目なら上の方法で準備をしないから 自己解決できてない 非常に重要なこととして(難易度を下げる) 開発環境を家のPCにも入れて ちゃんとコンパイル,実行できるようにしとくこと デバッガも入れて使いかた覚えればかなりハードル下がるよ 最悪はできたところまで提出とか 勝手に難易度が下がるように問題の設定を変更して それで出しとくことやね 出さないよりはずっと良いし 他人にやってもらうのよりもはるかに良い
.NETの仮想マシンをはさんでいることで、マルチプラットフォーム化が容易になっていることは確かでしょう。 しかし、そうでなければマルチプラットフォーム化できないわけではありません。
日本語等のようなものは基本的に全角です。 全角文字は2つでひとつなので、文字列扱いです。 なので 二次元配列でやるか、ポインタのポインタとかみたいになります。 例. char eto[][] = { "子", "丑", ... }; または char *eto[] = { "子", "丑",... }; 等。

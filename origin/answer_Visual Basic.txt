３回連続、という条件がよく判りません。 A列の2行目,3行目と値を入力し、4行目が入力された時点でユーザーフォームを開きたいのでしょうか？ その場合、ユーザーフォームを閉じた後で5行目を入力した時点で、再び「3,4,5行目に連続して入力した」と見なしてユーザーフォームを開くのでしょうか？それとも一旦ユーザーフォームを開いたら「連続」のカウントをリセットするのでしょうか？ またA2,A3,B3,C3,A4という順に入力した場合は3回連続と見なすのでしょうか？
一例です。 対象シートのシートタブ上で右クリック→コードの表示→サンプルコードを貼り付けてお試しください。 Private Sub Worksheet_Change(ByVal Target As Range) Dim r As Range Set Target = Intersect(Target, Range("A1:A100")) If Target Is Nothing Then Exit Sub For Each r In Target If r = 5 Then MsgBox r.Address(0, 0) & "に【５】が入力されました！" End If Next End Sub
有りがちなのは、 ・必要階層数だけ再帰呼出でループ変数を複製 ・最初から必要階層数だけのループ変数を配列持ち の何れかでは。 例として、２進数３(複数)桁をループで 列挙するコードを挙げてみます。 [VBScript/VBA/VB.Netの種別が不明なので VBScriptで記述。他は高機能版なので変換可] ''http : //codepad.org/n0aMREJ8#コードは後述# Main01では、フツーにi,j,kの３つのループ 変数を使って三重ループを組んでいますが、 Main02では、必要回数だけ再帰呼出でループ 変数 i を３つ分 確保して使っています。 Main03では、ループ変数配列a(*)を確保して a(*)をループ内でカウントアップ調整します。 正直言えば再帰型は書き易くともデバッグ他 保守が面倒になりがちなので、可能なら配列 型で書くことをオススメします。 重複・非重複に関わらず、順列 列挙であれば 配列型で多重ループを駆使せずに記述出来ます。 [別言語コードからの移植版で少々煩雑ですが] ''http : //codepad.org/wmhnNDt3#コードは後述# ''http : //codepad.org/n0aMREJ8#２進数３桁を列挙# Option Explicit Sub Main01 ''直接３重ループ''   Dim i, j, k, lc   For i = 0 To 1     For j = 0 To 1       For k = 0 To 1         lc = Array(i, j, k)         WScript.Echo(Join(lc, ","))       Next     Next   Next End Sub Sub Main02(n, m, o) ''再帰型多重ループ''   Dim i   If n <= m Then     WScript.Echo(Mid(o, 2))   Else     For i = 0 To 1       Call Main02(n, m + 1, o & "," & CStr(i))     Next   End If End Sub Sub Main03(n) ''非再帰型多重ループ''   Dim i, j, a()   ReDim a(n - 1)   For i = 0 To n - 1     a(i) = 0   Next   i = 0   Do While 0 <= i     WScript.Echo(Join(a, ","))     i = n - 1     Do While 0 <= i       a(i) = a(i) + 1       If 2 <= a(i) Then         a(i) = 0         i = i - 1       Else         Exit Do       End If     Loop   Loop End Sub Call Main01 WScript.Echo("--------") Call Main02(3, 0, "") WScript.Echo("--------") Call Main03(3) ''http : //codepad.org/wmhnNDt3#(非)重複順列4Π2,4Ｐ2を列挙# 'Option Explicit Const SS = 1 ''開始番号'' Sub RP(n, r) ''重複順列nΠr''   Dim i, j, o, a()   ReDim a(r - 1)   For i = 0 To r - 1     a(i) = SS   Next   i = 0   Do While 0 <= i     o = ""     For j = 0 To r - 1       If 0 < j Then o = o & ", "       o = o & CStr(a(j))     Next     WScript.Echo(o)     i = r - 1     Do While 0 <= i       a(i) = a(i) + 1       If SS + n <= a(i) Then         a(i) = SS         i = i - 1       Else         Exit Do       End If     Loop   Loop End Sub Sub NP(n, r) ''非重複順列nＰr''   Dim i, j, o, a()   ReDim a(n - 1)   For i = 0 To n - 1     a(i) = i + SS   Next   i = 0   Do While 0 <= i     o = ""     For j = 0 To r - 1       If 0 < j Then o = o & ", "       o = o & CStr(a(j))     Next     WScript.Echo(o)     i = r - 1     Do While 0 <= i And i < n       a(i) = a(i) + 1       If SS + n <= a(i) Then         i = i - 1       Else         For j = 0 To i - 1           If a(i) = a(j) Then Exit For         Next         If j >= i Then           i = i + 1           If i < n Then a(i) = SS - 1         End If       End If     Loop   Loop End Sub Call RP(4,2) WScript.Echo("--------") Call NP(4,2)
下記のサイトはいかがでしょうか？ http://www.excel-excel.com/vbachair/step1-7.html そのほか「vba デバッグ」でググると様々なサイトがヒットしますので、ご自分で判りやすいサイトを探してみて下さい。
Sub sample() With Range("B1") .Copy .End(xlDown).Offset(1).PasteSpecial xlPasteValues End With End Sub
アルゴリズムの基本が分かっていて、他の言語を知っている状態ならば、ネットで調べれば十分かもしれません。命令の置き換えと、VBAに特化した命令を調べるだけで済みますから。 しかし、何も下地がない状態では、かえって混乱を招きかねません。せっかく教本があるのですから、まずは全部読んで、試してみるのが良いと思います。 その後で、扱い慣れたと思ったら、自分で適当な例題を定めて作ってみてください。そこまで来れば、効率良くネットで調べられると思います。 例題ですが、知恵袋で回答を試みるのも一案ですよ。
表示しないのではなく、更新しないのです。つまり値の変更があってもノーケアです。何かの理由で変になってもそのままです。 タイトルバーはおそらく手はないと思います。
「retNum」はClass側で >Public retNum As Double とPublic宣言してますが「chcount」はしてませんね。それが原因かもしれません。 ただ、私はVBAでClassを作ったことありませんが、一般的なオブジェクト指向としてはClass内にPublic変数を持った時の動作についてVBAでどのように扱われるか疑問はあります。 クラス変数として扱われるのか、インスタンス変数として扱われるのか。どちらでしょう？ また、インスタンス変数として扱われる場合でもPropertyとしてメソッド（関数）定義を行ってアクセスする方法がないのか、可能ならそのほうが作法として適していないか調べたほうがいいのではないでしょうか。 Public変数だと読み込み専用にできないと思います。誤って標準モジュール側で値を変更するとバグにつながる可能性もあります。 実経験がないので「こうすべき」とは申し上げられませんが、少し調べられたほうがいいと思います。
添付図のようなことをしたい、というのであれば Range("A3:C" & Range("D" & Rows.Count).End(xlUp).Row).FillDown です。
基本的にはtachyon_takionさんの方法で良いのですが、少し工夫が必要です。 仮に「処理を実行したいフォルダの場所」をThisWorkbook.Pathと同じフォルダにしたとします。 そのフォルダにはTest1.csvとTest2.csvが存在するとします。 最初の検索でTest1.csvがヒットしてout.csvが作られます。 次のファイルの検索ではTest2.csvがヒットしてout.csvに追記されていきます。 ところが次のファイルの検索で「out.csv」までヒットしてしまい、tachyon_takionさんのテストで発生したように「"out.csv"が既に開いていると言うエラー」が発生してしまいます。 そこでCSVファイルを読みながら書き出すのではなく、 CSVファイルをCollectionオブジェクトに格納し、CSVファイルを全部読み終えてから、一気に保存ファイルへ書き出す、という方法を採れば、このエラーを回避することができます。
下記のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim InputFileFolder As String, OutputFilePath As Variant Dim FileName As String Dim fn1 As Integer, fn2 As Integer Dim data As String, buf As New Collection, i As Long Dim IsFirstFile As Boolean, IsFirstLine As Boolean '統合対象のフォルダの場所を問い合わせる With Application.FileDialog(msoFileDialogFolderPicker) .Title = "統合対象フォルダ選択" If .Show = True Then InputFileFolder = .SelectedItems(1) & "\" Else 'キャンセルボタンが押されたら何もしない Exit Sub End If End With '処理終了後の保存先とファイル名を問い合わせる OutputFilePath = Application.GetSaveAsFilename( _ InitialFileName:="test.csv", FileFilter:="CSVファイル (*.csv), *.csv", Title:="保存先ファイル選択") If VarType(OutputFilePath) = vbBoolean Then 'キャンセルボタンが押されたら何もしない Exit Sub End If '保存ファイルが存在したら削除しておく On Error Resume Next If Dir(OutputFilePath) <> "" Then Kill OutputFilePath End If 'CSVファイルを検索する FileName = Dir(InputFileFolder & "*.csv") IsFirstFile = True Do Until FileName = "" 'CSVファイルを開く fn2 = FreeFile Open InputFileFolder & FileName For Input As #fn2 'CSVファイルを１行ずつ読み込む IsFirstLine = True Do Until EOF(fn2) Line Input #fn2, data '２つ目以降のファイルの１行目は出力しない If Not IsFirstFile And IsFirstLine Then Else buf.Add data End If IsFirstLine = False Loop 'CSVファイルを閉じる Close #fn2 '次のCSVファイルを検索する FileName = Dir() IsFirstFile = False Loop '保存ファイルを開く fn1 = FreeFile Open OutputFilePath For Output As #fn1 '保存ファイルに書き出す For i = 1 To buf.Count Print #fn1, buf(i) Next i '保存先ファイルを閉じる Close #fn1 End Sub
実行して見ました。 >一番右の予約表(月)シートのC2かもしくは >コピーした予約表(月)シートのC2の値をひろってしまいます。 という現象は再現できませんね。 やってみるのなら dt = Sheets(1).Range("C2") ↓ dt = Sheets("予約表(月)").Range("C2") としてみてどうなのか試してみるのが１つの手段ですかね。
"C:\Users\Pc-User\Desktop\【請求書】1234-（”Ｐ5”）.pdf" を "C:\Users\Pc-User\Desktop\【請求書】1234-” & Range("P5").Value & ".pdf" として下さい。 表現が紛らわしいのですが、店舗コードに () はつかないものとしています。
kenmon_01さん、こんにちは。 以下Application.FileDialog オブジェクトを使用した一例です。 変数を追加します。 Dim fname 以下のコードを 'CSVファイルを開く のコメントの下に挿入します。 With Application.FileDialog(msoFileDialogFilePicker) .InitialFileName = ThisWorkbook.Path ’デフォルトパスを指定する .Filters.Add "CSVfiles", "*.csv", 1 '対象ファイルの拡張子を指定する .FilterIndex = 1 If .Show = True Then fname = .SelectedItems(1) End With If fname="" Then Exit Sub ファイルを開くコードを変数使用に変更します。 Open fname For Input As #fn *** 他、GetOpenFileName メソッドを使う方法もあります。 fname=Application.GetOpenFilename("CSV Files (*.csv), *.csv") If fname=False Then Exit Sub こちらはデフォルトパスを指定するパラメータはないので、他の方法でカレントディレクトリを変更します。 いかがでしょうか？
If A = 6 Then も書かずに下記のようにすればすっきりします。 Dim A As Integer For A = 1 To 6 Worksheets("Sheet1").Cells(A + 1, 1) = A Next
Sub 件数表示() Dim myCri Dim LR Dim myR1, myR2 On Error Resume Next LR = Cells(Rows.Count, 1).End(xlUp).Row Set myR1 = Cells(2, "B").Resize(LR - 1) Set myR2 = Cells(2, "D").Resize(LR - 1) myCri = ActiveSheet.AutoFilter.Filters(4).Criteria1 If IsEmpty(myCri) = False Then MsgBox WorksheetFunction.CountIfs(myR1, "<>[?]", _ myR2, myCri) Else MsgBox WorksheetFunction.CountIfs(myR1, "<>[?]") End If End Sub --------------------------------------------- 【フィルタ列D列、抽出条件は一つだけ(Criteria1)】とします。 Countifs(B列,B列の条件,D列,D列のフィルタ条件) Countifs関数は、フィルタの状態に関係なく、 全データに対して条件を満たす件数をカウントします。 フィルターの列が複数だったり、Criteria2が指定してある場合でも countifs関数の検索範囲、検索条件を増やせばできると思います。
C2: =INDEX(B$2:B$5,MATCH("*"&SUBSTITUTE(TRIM(ASC(A2))," ","")&"*",SUBSTITUTE(TRIM(ASC(B$2:B$5))," ",""),0)) 【お断り】上式は必ず配列数式として入力のこと
小数点を入力させるのであれば下記のコードでどうでしょうか？ 小数点ボタンを「CommandButton10」と仮定しています。 Private Sub CommandButton10_Click() If InStr(TextBox1.Text, ".") = 0 Then TextBox1.Text = TextBox1.Text + "." End If End Sub
ワークシートに実行用のボタンが貼り付けてある場合は、ワークシートのモジュールにコードが書かれているかもしれません。 その場合は、VBAのソリューションエクスプローラでボタンが貼り付けてあるワークシートを右クリック→コードの表示でシートモジュールが表示されます。 もしくは Ctrl + F で検索ダイアログを表示。検索する文字列に sub を設定、検索対象を カレントプロジェクト に設定して検索するとプロシージャが次々に表示されるので、それらしいプロシージャを探します。 Sub graph() Sheets("01").Activate ActiveSheet.ChartObject("graph2").Activate ActiveChart.ChartArea.Copy Sheets("02").Activate ActiveSheet.ChartObject(1).Delete 'グラフを削除する ("A3").Select ActiveSheet.Paste End Sub コードは実行していないので、エラーしたらご容赦。
Crystal Report の経験はありませんが、 FindWindow でズームダイアログのウィンドウハンドルを取得。 SetParent でズームダイアログを強制的に３の子ウィンドにしてしまう、とか。
下記のコードでいかがでしょうか。 新しいブックを作成し、そのブックのSheet1に複数のCSVファイルの11行目以降をコピーします。 Option Explicit Sub Sample() Dim bkSrc As Workbook, stSrc As Worksheet Dim bkDst As Workbook, stDst As Worksheet Dim rDst As Long Dim fPath As String, fName As String 'CSVファイル読み込み先のフォルダを選択する With Application.FileDialog(msoFileDialogFolderPicker) If .Show = False Then Exit Sub fPath = .SelectedItems(1) End With 'エクセルの再描画を一時停止する Application.ScreenUpdating = False '新しいブックを作成する Set bkDst = Workbooks.Add Set stDst = bkDst.Worksheets("Sheet1") '選択されたフォルダのすべてのCSVファイルを検索する fName = Dir(fPath & "\*.csv") Do While fName <> "" 'CSVファイルをExcelで開く Set bkSrc = Workbooks.Open(fPath & "\" & fName) Set stSrc = bkSrc.Worksheets(1) 'Sheet1のコピー先を設定する rDst = stDst.Range("A" & Rows.Count).End(xlUp).Row If rDst > 1 Then rDst = rDst + 1 '11行目から最終行までをSheet1にコピーする stSrc.Range("11:" & stSrc.UsedRange.Rows.Count).Copy stDst.Range("A" & rDst) 'CSVファイルを閉じる bkSrc.Close False '次のCSVファイルを検索する fName = Dir Loop 'エクセルの再描画を再開する Application.ScreenUpdating = False End Sub
再帰、ファイル一覧 で検索してください。
以下でどうなりますか 確認は、新規ファイルの標準モジュールに以下を転記して DATA シートを作ってから確認用データ作成 testData を実行し Samp1 を実行してみます やっていることは Dictionary を使用し、 キーには DATA シート以外のシート名を････ 関連する値部分には次の書き出し位置を覚えておきます 後は、A 列の名前を Dictionary に覚えていたらシートはある 無かったら、シートを追加して、１行目の項目部分をコピーして･･･ 次の書き出し位置に A2 を覚えて････ A 列を除いた範囲の行をコピーし、次の書き出し位置を更新･･･ ※ CurrentRegion から処理範囲を求めているので、 B ～ E 列が B ～ F 列になっても変更は不要かと･･･ ※ A 列の名前をシート名にしているだけなので、 シート名に使えない文字とか入っていれば･･･エラーで止まると思います Option Explicit Public Sub Samp1()    Dim dic As Object    Dim ws As Worksheet    Dim vA As Variant    Dim i As Long    Set dic = CreateObject("Scripting.Dictionary")    Application.ScreenUpdating = False    With Worksheets("DATA")       For Each ws In Worksheets          If (ws.Name <> .Name) Then             dic.Add ws.Name _                   , ws.Cells(Rows.Count, "A").End(xlUp).Offset(1)          End If       Next       With .Range("A1").CurrentRegion          vA = .Columns(1).Value          With .Offset(, 1).Resize(, .Columns.Count - 1)             For i = 2 To UBound(vA)                If (Not dic.Exists(vA(i, 1))) Then                   Set ws = Worksheets.Add(After:=Worksheets(dic.Count + 1))                   ws.Name = vA(i, 1)                   .Rows(1).Copy ws.Range("A1")                   dic.Add ws.Name, ws.Range("A2")                End If                .Rows(i).Copy dic(vA(i, 1))                Set dic(vA(i, 1)) = dic(vA(i, 1)).Offset(1)             Next          End With       End With       .Activate    End With    Application.ScreenUpdating = True    Set dic = Nothing End Sub ' 確認用データ作成 Public Sub testData()    Dim vC As Variant, v As Variant    Dim i As Long, j As Long    Const CRH As Long = 1000    vC = Array( _          Array("りんご", "果物A"), Array("バナナ", "果物B"), _          Array("時計", "小物A"), Array("ネクタイ", "小物B"), _          Array("車", "大物"), Array("家", "超大物") _       )    Randomize    Application.ScreenUpdating = False    With Worksheets("DATA")       .Cells.Delete       .Cells(1, "A").Resize(, 5).Value = _          Array("名前", "区分", "原価", "在庫", "原価")       For i = 2 To CRH          v = vC(Int((UBound(vC) + 1) * Rnd()))          .Cells(i, "A").Resize(, 5).Value = _             Array(v(0), v(1) _                , (Int(99 * Rnd()) + 1) * 100 _                , Int(99 * Rnd()) + 1 _                , (Int(99 * Rnd()) + 1) * 100)       Next       .Columns.AutoFit    End With    Application.ScreenUpdating = True End Sub
Sub Macro1() Sheets("Sheet1").activate ActiveSheet.ChartObjects(1).Activate ActiveChart.ChartArea.Copy Sheets("Sheet2").Activate Range("A1").Select ActiveSheet.Paste End Sub 他人のマクロは置いといて、目の前にあるグラフをシート２にコピーします。 グラフが１個しか無いなら、これで対応出来る筈です。 ただし、シート２にコピーしても元データは変わりません。
Sub 一例です() Dim rng As Range, rngs As Range For Each rng In Range("B1", Cells(Rows.Count, 2).End(xlUp)) With rng If .Value Like "@*" Then If rngs Is Nothing Then Set rngs = .Cells Else Set rngs = Union(rngs, .Cells) End If End If End With Next rng If Not rngs Is Nothing Then rngs.EntireRow.Delete End If End Sub
似ていると言えば似てますけど。。 VBだとこちらで無料版を使ってみるのはどうですかね。 https://www.visualstudio.com/products/vs-2015-product-editions
Sub sampleⅡ() Dim sh As Worksheet, xAry, i, xMsg As String If MsgBox("すべてのシート名をA1セルの値にしますか？", vbOKCancel) = vbCancel Then Exit Sub xAry = Array("Sheet1", "Sheet3") '★ For Each sh In Worksheets With sh i = Application.Match(.Name, xAry, 0) If IsError(i) Then On Error Resume Next .Name = .Range("A1").Value If Err.Number <> 0 Then xMsg = xMsg & vbLf & .Name End If End With Next sh If xMsg <> "" Then MsgBox "以下のシートを処理中にエラーが発生しました" & xMsg End Sub
次のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim area As Range Dim rng As Range Dim fa As String '検索範囲をA2からA列の最終行に設定する Set area = Range("A2:A" & Range("A" & Rows.Count).End(xlUp).Row) '検索範囲の右２つ分のセルを一旦クリアする For Each rng In area rng.Offset(, 1).Resize(, 2).ClearContents Next rng '検索範囲からF11に一致するセルを検索する Set rng = area.Find(Range("F11").Value) '該当するセルが存在したとき If Not rng Is Nothing Then fa = rng.Address Do '１つ右のセルにG11の内容をコピーする rng.Offset(, 1).Value = Range("G11") '２つ右のセルにH11の内容をコピーする rng.Offset(, 2).Value = Range("h11") '次に一致するセルを検索する Set rng = area.FindNext(rng) '一致するセルがなくなるか、最初に一致したセルになるまで繰り返す Loop While Not rng Is Nothing And rng.Address <> fa End If End Sub
ListBox1のソースはシートでしょうか、データを書き込んでいるんでしょうか？ シートがデータソース(RowSource)が設定されているなら、シートが更新されたら再計算のタイミングで更新されるはずです。 コードの進行でapplication.Calculation=xlCalculationManualがあったならApplication.Calculateを入れてみてはいかがでしょうか。 ちなみに、提示されているコードは何をどうしたいか全くわかりません。コード左端をクリックして●をつけてコードをブレークしてF8キーでステップ実行して変数に何が入って何が起こっているか観察して考えてください。
ヘルプのバージョン情報から。 http://homepage1.nifty.com/rucio/main/kiso/Version.htm
こんにちは。 変数に、正しく値が入っているのか、再度チェックしてください。 uboundと、for nextでmsgbox だしてください。 データのチェックですが、i と jですか？ 要素1なら、それぞれのチェック、 要素2のチェックと、 ループ1回で、チェックする気がするのですけど。
maruc_yhさん、こんにちは。 先にブックを作成してからシートをコピーすると、どうしても余分なシートができてしまいます。 Worksheet.Copy メソッドでは、引数 before , after を両方省略すると、自動的に新しいブックを生成して、そこにコピーしたいシートだけを作成してくれるので、 Workbooks.Add st.Copy Before:=ActiveWorkbook.Sheets(1) を st.Copy だけにすればよいと思います。
>CELLに代入する行を入れると これの意味が分かりませんが、とりあえず正常動作のように見えます。 Exit For されており、プロシージャは途中終了せず最後まで進みます。 途中でi, jの値を見たいようですが、 msgbox i & ", " & j とするといいですよ。
"*" の文字自体を検索する場合、"[]" で囲む必要があります。 次のように修正してください。 "***" -> "*[*]*"
A列が順番にならんでいないんですね？ Sub sample() Dim xDic, AP, xKey As String, i As Long Set xDic = CreateObject("Scripting.Dictionary") Set AP = Application For i = 1 To Cells(Rows.Count, 1).End(xlUp) xKey = Join(AP.Transpose(AP.Transpose(Cells(i, 1).Resize(, 4).Value)), "/") If Not xDic.Exists(xKey) Then xDic.Add xKey, xKey Else Cells(i, 2).Resize(, 3).ClearContents End If Next i End Sub
WebBrowserには、PictureBoxのMouseMoveのようにコントロール内でのマウスの動きを検知するイベントが用意されていないので、出来ません。 Windowsの内部動作に相当詳しければ手段はあるのですが、そう簡単に習得できる技術ではありませんので。
たぶんPHPからtwitterAPIを使って取得しているんですかね？ なら、user_idやscreen_name等々取得できますよ。 ぐぐれば色々資料が出てきます。頑張ってください。
テストしてません Private Sub コマンド0_Click() Dim fDialog As Object Dim Rst As DAO.Recordset Dim file As String Set fDialog = Application.FileDialog(3) fDialog.InitialFileName = "指定のパス" fDialog.Show for each file in fDialog.SelectedItems DoCmd.TransferText acImportDelim, "新しいテキスト ドキュメント インポート定義", "T1", file, False Next End Sub
バフッとした説明で良いですか D列 E列 D001 AAA D001 BBB D001 AAA というデータがあった時 Dictionary には、D001 をキー、初めに出現した AAA を値として覚える 同じキーが出現した時には、覚えていた値と比較し、違ったら、 E列 部分から D001 を探して１巡するまで色を付けるまわる 誤動作はしないと思いますが、以下データなら D列 E列 D001 AAA D001 BBB D001 BBB D001 CCC D001 AAA ２行目データで色付け１巡しているので、 ３行目以降で同じ処理を繰り返すのは無駄 この処理で満足なら以下スルーで また、多くても重複するものは１つ･･･ならスルーで Dictionary が使えるのなら、Dictionary を２段構成にするとか･･･ 以下は２段構成にして、 １段目キー：D列の値 ２段目キー：E列の値 関連する値部分には、出現した行番号を空白区切りで Dictionary に１巡覚えたら、 １段目キーでループしながら２段目のキー数が >1 なら、 E 列の値は複数あるので、覚えていた値（行番号）を Split 展開して 個々の行番号に展開しながら色付け･･･ 無駄に繰り返す処理は無くなったと思います Option Explicit Public Sub Samp1()    Dim dic As Object    Dim vA As Variant, vK As Variant, v As Variant    Dim i As Long    Const CSEP As String = " "    Set dic = CreateObject("Scripting.Dictionary")    With Range("D4", Cells(Rows.Count, "D").End(xlUp))       vA = .Resize(, 2).Value       For i = 1 To UBound(vA)          If (vA(i, 1) <> "") Then             If (Not dic.Exists(vA(i, 1))) Then                dic.Add vA(i, 1), CreateObject("Scripting.Dictionary")             End If             dic(vA(i, 1))(vA(i, 2)) = _                   dic(vA(i, 1))(vA(i, 2)) & CSEP & i          End If       Next       Application.ScreenUpdating = False       .Interior.ColorIndex = xlNone       For Each vK In dic.Keys          If (dic(vK).Count > 1) Then             For Each vA In dic(vK).Items                For Each v In Split(Trim(vA), CSEP)                   .Cells(v, 1).Interior.ColorIndex = 38                Next             Next          End If       Next       Application.ScreenUpdating = True    End With    Set dic = Nothing End Sub ' 確認用簡易データ作成 Public Sub testData()    Dim r As Range    Dim i As Long, j As Long    Const CRH As Long = 35    Randomize    Application.ScreenUpdating = False    Cells.Delete    For Each r In Range("D1:E1").Resize(CRH)       If (r.Row >= 10) Then          If (Rnd() > 0.5) Then             If (r.Column = Range("D1").Column) Then                i = Int(r.Row * Rnd())                j = i                r.Value = r.Offset(-i).Address(False, False)             Else                i = Int(r.Row * Rnd())                If (Rnd() > 0.5) Then i = j                r.Value = r.Offset(-i).Address(False, False)             End If          Else             r.Value = r.Address(False, False)          End If       Else          r.Value = r.Address(False, False)       End If    Next    Columns.AutoFit    Application.ScreenUpdating = True End Sub
=F1 & "-" & H1 & (R1*10) A1に↑の式を入れて、B列にコピペすると =G1 & "-" & I1 & (S1*10) このように、列参照が相対的に一つずれます。 ------------------------------------------ Sub A列関数を下までコピー_相対参照() Range("A1").Formula = "=F1 & ""-"" & H1 & (R1*10)" Range("A1").Copy _ Destination:=Range("A1", Range("A" & Rows.Count).End(xlUp)).Offset(, 1) End Sub ------------------------------------------ =$F1 & "-" & $H1 & ($R1*10) 数式を絶対参照にする場合は下記のコードになります。 ------------------------------------------ Sub A列関数を下までコピー_絶対参照() Range("A1").Formula = "=$F1 & ""-"" & $H1 & ($R1*10)" Range("A1").Copy _ Destination:=Range("A1", Range("A" & Rows.Count).End(xlUp)).Offset(, 1) End Sub
お示しになった２つのプログラムと、質問内容との関係が解りませんが、 ↓のような例文でよいのでしょうか？ Sub sample() Dim sh As Worksheet For Each sh In Worksheets With sh .Name = .Range("A1").Value End With Next sh End Sub
.NET ですか？ 実は、とっても簡単なんです。 追加で、モジュールを追加します。 そして、 Module Module1 Public Foo As Integer End Module なんて書くと、 プログラムの何処からでも、 Module1.Foo で読み書きできます。
こんちには。 テストしたいので、呼び出すほうのコードなんですが、 webにあったサンプルだと function openChild() { var obj = {text1:document.all.text1.value, text2:document.all.text2.value}; rtn=window.showModalDialog( "child.html", obj, "dialogHeight:200px; dialogWidth:400px;"); document.getElementById("res").innerHTML = rtn; } --> </script> <body> <input type="button" value="windowを起動します" onclick="openChild();"><br/> というぶぶんで、 変数objに{}記号で、配列要素をわたして、 child.htmlでは、window.dialogArgumentsとして、受け取っていました 主様の場合は、「文字列」として渡したようなんですが、 この場合、「テスト専用のファイル」を作成したほうが、いいですね。 そっちのアプローチをしてみてください
考え方は同じです。 Sub Macro3結果の右ズラし() Dim i As Long Application.ScreenUpdating = False For i = 15 To 6455 Step 280 Cells(i, "AF").Resize(12).Value = Cells(i, "AA").Resize(12).Value Cells(i, "AA").Resize(12).Value = "" Next i Application.ScreenUpdating = True End Sub やってみてください。。
ActiveWindow.SmallScroll Down:=282 ActiveWindow.SmallScroll Down:=276 ↓ これは、シートのスクロールなので処理に影響ないと思います。 すべて消去してみて。。 処理中に画面が上下に動いていたでしょう。 この動きを止めるのがApplication.ScreenUpdating = False kkyy5223さんの仰るとおり Range("AA10").Cut Range("AB10").Select ActiveSheet.Paste のようにすると良いと思うけど、、 もし、AA10→AB10という移動を280行ごとにするだけなら、 Sub Macro1日付を右にズラす() Dim i As Long Application.ScreenUpdating = False For i = 10 To 6450 Step 280 Cells(i, "AB") = Cells(i, "AA") Cells(i, "AA") = "" Next i Application.ScreenUpdating = True End Sub これだけで終わっちゃうよ。。 サンプル作って、これだけ動作させてみたら…
Dim WB1 As Workbooks, Wb2 As Workbooks を Dim WB1 As Workbook, Wb2 As Workbook としてみてください。
コードだけとかフォームの画像だけでは関連性が掴みにくいと思うよ 必要なのは回答者が再現するための情報だけど、そもそも質問者さんが混乱しているならプロジェクト毎頼むのも良いかもしれない →有償・無償で色んな依頼先があるけど せめて画像のどのコントロールがコードのどのコントロールになるのか、画像に書き込むってのもあるよ
◆入力した情報をきっちりセル内に収める方法 該当するセル範囲を選択し、 Ctrl＋1で[セルの書式設定]ダイアログを表示します。 [配置]タブを選択し、 □縮小して全体を表示する にチェックを入れてOKします。 これで、セル内に収まるようExcelがフォントサイズを自動調整してくれます。
やってみる価値はありますが、使い物になるかどうかはわかりません。 access2010 SharePointリスト ADO接続 http://mukkumuku.blogspot.com/2011/04/access2010-sharepoint-ado.htm... AccessアプリからSharePointリストへ接続 http://nanbo.org/accesssplist/ Access：SharePointリストのリンク -1- http://nanbo.org/access-lts1/
ユーザーフォームを使う方法が見つかりましたので回答します。字数がオーバーしますので前の回答を取り消しとしました。 新旧対の二つのブックと抽出先のブックの３つのブックを扱うことにします。新旧対の二つのブックはダイアログボックスで任意に選ぶことができます。抽出先のブックのシート１の７行目から下に抽出されたデータを置き、このマクロを動かすボタンをシート１に作ります。シート２には作業領域があります。 ユーザーフォームも作ります。ユーザーフォームによってシートと管理番号を指定しています。複数のシートのうちどれを使うかを名称でなく、シート番号で選ぶことにしています。ユーザーフォームにシート番号と管理番号を書き込んだ後、コマンドボタンを押すと、条件に一致したデータが、抽出先のブックのシート１にまとめられます。ユーザーフォームのコマンドボタン用のコードとシート１のボタン用のコードを下に示します。 シート１のボタンを押すとダイアログボックスが現れますのでコントロールキーを押しながら二つのブックを選びます。このあとユーザーフォームで管理番号、シート番号を指定してから、コマンドボタンを押します。 ユーザーフォームのコマンドボタン用のコード Option Explicit Private Sub CommandButton1_Click() Sheets(2).Cells(3, 1) = TextBox1 Sheets(2).Cells(3, 2) = TextBox2 Unload UserForm1 End Sub シート１のボタン用のコード Sub Macro2() ' ' Macro2 Macro ' ﾏｸﾛ記録日 : 2016/8/7 ﾕｰｻﾞｰ名 : ' Dim ファイル名一覧 As Variant Dim ブック As Workbook Dim no As Integer Dim shtno As Integer Dim i As Integer Dim j As Integer Dim mygyo As Integer ファイル名一覧 = Application.GetOpenFilename("Excelのファイル,*.xls", MultiSelect:=True) If VarType(ファイル名一覧) = vbBoolean Then Exit Sub Application.EnableEvents = False mygyo = 6 UserForm1.Show no = Sheets(2).Cells(3, 1) shtno = Sheets(2).Cells(3, 2) 'MsgBox no For i = 1 To UBound(ファイル名一覧) Set ブック = Workbooks.Open(ファイル名一覧(i)) For j = 2 To Cells(2, 1).End(xlDown).Row If ブック.Worksheets(shtno).Cells(j, 1).Value = no Then ブック.Worksheets(shtno).Cells(j, 1).EntireRow.Copy ThisWorkbook.Worksheets(shtno).Cells(mygyo, 1).PasteSpecial mygyo = mygyo + 1 End If Next Next ' End Sub
Win32APIのGetSystemPowerStatusを使用するとできそうです。 https://msdn.microsoft.com/ja-jp/library/ms812491.aspx
↓の式で実現できることを、わざわざマクロでやるのでしょうか？ =IF(COUNTIF(Sheet2!A1:A100,Sheet1!A1)>0,1,2)
何が問題なのかよく解りませんが、↓のプログラムで上手くいくと思います。 Sub ブロック消去1() ' ブロック消去 Macro Dim myrng As Range, xrng As Range Dim sp As Variant Set myrng = Cells(4, 2).Resize(, Range("B2").Value) For Each sp In ActiveSheet.Shapes On Error Resume Next Set xrng = Intersect(Range(sp.TopLeftCell, sp.BottomRightCell), myrng) If Err.Number = 0 Then sp.Delete End If Next Set myrng = Nothing End Sub
文字同士の足し算は ＋ではなく ＆ですね。
【追記】 For～Nextで纏められるのでは？ ーーーーーーー バージョンがわからないですが、正規表現で置換と言う方法もありかもしれないですね ところで数字を変えてとは For i = 1 To 5 '置換したい文字を i & "の" や i & "／" と変数を使う Next でもよいのでは？ →２桁以上であっても結局 数字+の の１つの数字を使えば良いのでしょ？
hope35mさん、こんばんは。 一例です。 Sub Sample() Dim iTmp As Integer, iStart As Integer, iEnd As Integer Dim rg As Range, rg2 As Range iStart = Range("A1").Value iTmp = iStart Set rg = Range("A2") Set rg2 = Range("B1") Do Until IsEmpty(rg) If rg.Value <> iTmp + 1 Then iEnd = iTmp If iStart = iEnd Then rg2.Value = iStart Else rg2.Resize(, 3).Value = Array(iStart, "～", iEnd) End If Set rg2 = rg2.Offset(1) iStart = rg.Value iTmp = iStart Else iTmp = rg.Value End If Set rg = rg.Offset(1) Loop iEnd = iTmp If iStart = iEnd Then rg2.Value = iStart Else rg2.Resize(, 3).Value = Array(iStart, "～", iEnd) End If Set rg = Nothing Set rg2 = Nothing End Sub
おおざっぱには、西暦年だけから元号に出来ますが 厳密にするには日付にしないといけません。 例えば 1989年1月7日は、昭和64年 1989年1月8日は、平成元年
Private Sub CommandButton1_Click() Worksheets("Sheet1").Cells(8, Columns.Count).End(xlToLeft).Offset(, 1).Value = TextBox9.Value End Sub ということですか？
オブジェクト変数そのものを表示しているので当然の結果ではないでしょうか。内容を表示したいのであれば、何らかのプロパティを指定します。 objTd(0).InnerText objTd(0).InnerHTML
セルの値でも代入してみたら？ それでは初期値が表示されるだけでは？
日本語URLの場合は、URLエンコードを行なわなくてはならないのですが、それは行ないましたか？
これで試してください。 Sub AAA() Dim i As Integer, j As Integer, k As Integer, df As Integer Dim vv, vx, ErFlg Dim 日付() As Date, 最小日 As Date, 最大日 As Date, dt As Date Dim ID() As String, 名前() As String, ct As Integer Dim rng As Range, rng0 As Range, ws As Worksheet vv = Range(Range("B2"), Range("B2").End(xlDown).Offset(0, 4)) ReDim ID(0), 名前(0) 最小日 = CDate(vv(1, 3)) 最大日 = 最小日 ct = 0 For i = 1 To UBound(vv) If 最小日 > CDate(vv(i, 3)) Then 最小日 = CDate(vv(i, 3)) If 最大日 < CDate(vv(i, 3)) Then 最大日 = CDate(vv(i, 3)) For j = 1 To ct If ID(j) = CStr(vv(i, 1)) Then Exit For Next If j = ct + 1 Then ct = ct + 1 ReDim Preserve ID(ct), 名前(ct) ID(ct) = CStr(vv(i, 1)) 名前(ct) = CStr(vv(i, 2)) End If Next df = 最大日 - 最小日 ReDim vx(ct, df + 2) ReDim ErFlg(ct, df + 2) For i = 1 To ct vx(i, 0) = ID(i) vx(i, 1) = 名前(i) Next vx(0, 0) = "ID": vx(0, 1) = "名前" For i = 0 To df vx(0, i + 2) = 最小日 + i Next For i = 1 To UBound(vv) k = CDate(vv(i, 3)) - 最小日 + 2 For j = 1 To ct If ID(j) = CStr(vv(i, 1)) Then vx(j, k) = vv(i, 4) & vv(i, 5) If vv(i, 4) <> "" And vv(i, 5) <> "" Then ErFlg(j, k) = 1 Else ErFlg(j, k) = 0 End If End If Next Next ' 出力 Set ws = Worksheets("Sheet2") Set rng0 = ws.Range("A1") Set rng = ws.Range(rng0, rng0.Offset(ct, df + 2)) rng = vx ' 着色クリアー With ws.Cells.Font .Bold = False .ColorIndex = xlAutomatic .Italic = False End With ' 着色 For i = 1 To ct For j = 2 To df + 2 If ErFlg(i, j) = 1 Then With rng0.Offset(i, j).Font .Bold = True .Color = -16776961 .Italic = True End With End If Next Next End Sub
下図のように、現在のアクティブセル(ピンク色)から水色のセルに相対的にジャンプする場合でしたら、名前を定義すれば可能です。 とりあえずA1を選択して―― 名前の定義 ・名前：任意（とりあえず TGT） ・参照範囲：=OFFSET(A1,1,1) で、任意のセルで [F5] → [参照先]に TGT → [OK]
http://www.geocities.jp/maru3128/wmi.html#drive 上記にあるドライブの一覧とドライブの種類を参考にして、１つのプログラムに組み合わせれば、デバイス毎の処理を記述しなくてもいいですよ。 例えば Option Explicit Dim QfeSet Dim Qfe Dim Locator Dim Service Dim Ret Set Locator = WScript.CreateObject("WbemScripting.SWbemLocator") Set Service = Locator.ConnectServer Set QfeSet = Service.ExecQuery("Select * From Win32_LogicalDisk") For Each Qfe In QfeSet Ret = Ret & Qfe.Name & vbTab & Qfe.VolumeName & vbTab & Qfe.FileSystem & vbTab & Qfe.DriveType & vbCrLf Next Wscript.Echo Ret Set QfeSet = Nothing Set Qfe = Nothing Set Service = Nothing Set Locator = Nothing これをそのまま実行すると、各ドライブの名前、ボリューム名、ファイルシステム、ドライブタイプが表示されます。 なので、For Each の中で各ドライブのドライブタイプを調べ、ドライブタイプが2であれば、Removable Disk＝USB等で接続されているドライブ。 5であればDVD Drive等になります。 ということは、ドライブタイプが2であればその時点でUSBが刺さっていることになるので、処理中断し、windowsの終了もさせない。 5であれば、ボリューム名が入っていればDiscが入っていると思うので、入ってなければUSBの時と同じくwindowsを終了させないという処理を行えばいいはずです。
ご自身の質問で解決している内容だと思いますが。 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1316267881... 違う内容なら、変数の内容を補足して下さい。
下記のコードでいかがでしょうか？ Sub Sample() Dim pt As String 'ActiveWorkbookが保存されているフォルダを取得する pt = ActiveWorkbook.Path 'ひとつ上の階層のフォルダを取得する pt = Left$(pt, InStrRev(pt, "\")) 'フォルダCのフルパスを取得する pt = pt & "フォルダC\" 'Shell関数を使ってフォルダを開く Shell "explorer.exe " & pt, vbNormalFocus End Sub
ハッシュ(SHA256)でいいんじゃないの？ 暗号化にする(可逆性を持たせる)意味あるの？ VBでSHA256を使うなら、SHA256CryptoServiceProviderを使えばいい 参考 http://www.atmarkit.co.jp/fdotnet/dotnettips/964computehash/compute...
Sub Sample() Dim xTtl, i As Long, ii xTtl = Array("時間", "名前", "住所") For Each sh In Worksheets With sh For i = LBound(xTtl) To UBound(xTtl) ii = Application.Match(xTtl(i), .Range("A1:J1"), 0) If Not IsError(ii) Then .Cells(1, "K").Offset(, i).Value = .Cells(Rows.Count, ii).End(xlUp).Value End If Next i End With Next sh End Sub
ＶＢＡでクエリを動的に生成して実行する方法をご存じでしょうか？ 下記で解説されています。 ＳＱＬ文のひな形はクエリで作り、ＶＢＡ上で条件となる部分を変数に置き換えます。 ＳＱＬはＡＮＤ条件は高速に処理出来ます、ＯＲ条件の場合処理速度が極端に遅くなる事が有ります。 そんな時は１条件毎に（ＡＮＤはまとめて実行でＯＫ）ＳＱＬ文を実行し、一時的なテーブルに書き出し。 ＯＲとなる条件で再度実行して書き出しを繰り返せば最終的に一時的なテーブルに結果は得られます。 クエリを作らずにＳＱＬ文を実行する http://www.moug.net/tech/acvba/0040010.html
で、それをどうしたいと？その問題自体を考えろという質問？
文字数が多くて、返信不可なので、一度削除して後再投稿です。 あまり、はまって考える時間も無いので、中途半端ですがアップします。 「一覧表に記入する」「知恵袋の質問」「マークを消す」などはOKです。 でも、「今日」とか「漢字一文字」とかの熟語に対応できないです。 もう一息みたいだけど、、これからが大変みたい… とりあえず、、挫折します。。 Sub Sample2() Dim c As Range Dim i As Long Dim j As Long Dim r As Long Dim r2 As Long Dim cnt As Long Dim myRow As Long Dim flag As Boolean Dim myLen As Long Dim myPh As String Dim myWdAll As String Dim myWd0 As String Dim myWdH As String Application.ScreenUpdating = False myRow = 1 For Each c In Range("A1:A" & Cells(Rows.Count, 1).End(xlUp).Row) r = 1 cnt = 0 myWdAll = Application.GetPhonetic(c) For i = 1 To Len(c) myWd0 = Mid(c, i, 1) If Asc(myWd0) > -30559 And Asc(myWd0) < -26373 Then '漢字のとき myPh = Application.GetPhonetic(myWd0) Do myLen = Len(myPh) If myLen <= Len(myWdAll) Then If myPh = Mid(myWdAll, cnt + 1, Len(myPh)) Then Exit Do End If End If myPh = Application.GetPhonetic() Loop Until myPh = "" If myPh = "" Then r2 = r cnt = cnt + 1 flag = True End If Cells(myRow, r + 1) = StrConv(myPh, vbHiragana) Else Cells(myRow, r + 1) = StrConv(myWd0, vbHiragana) cnt = Len(Application.GetPhonetic(Left(c, r))) End If r = r + 1 cnt = cnt + Len(myPh) myPh = "" Next i If flag = True Then myWdAll = StrConv(myWdAll, vbHiragana) For i = 1 To Cells(myRow, Columns.Count).End(xlToLeft).Column If Cells(myRow, i + 1) <> "" Then If Cells(myRow, i + 1) = Mid(myWdAll, 1, Len(Cells(myRow, i + 1))) Then myWdAll = Right(myWdAll, Len(myWdAll) - Len(Cells(myRow, i + 1))) End If Else If WorksheetFunction.CountBlank(Cells(myRow, 2).Resize(, r - 1)) = 1 Then For j = r2 To r myWdH = myWdH & Cells(myRow, j + 1) Next j Cells(myRow, i + 1) = Mid(myWdAll, 1, Len(myWdAll) - Len(myWdH)) Exit For End If End If Next i End If flag = False myWdH = "" myRow = myRow + 1 r = 2 Next c Application.ScreenUpdating = True End Sub
>ダブルクリックすると作成するか、、フォームが表示される >そこで作成をするを押したときに、「別シートの名前、年齢、職… ダブルクリックした行を変数「myRow」に入れて、 そのシートモジュールからユーザーフォームを立ち上げます。 Public myRow As Longは標準モジュールの1番上に。。 シートモジュールに ↓ Option Explicit Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) If Target.Column <> 1 Then Exit Sub myRow = Target.Row Cancel = True Call 呼び出し End Sub Sub 呼び出し() UserForm1.Show End Sub _____________________________________ 標準モジュールに ↓ Option Explicit Public myRow As Long _____________________________________ 作成するのボタン ユーザーフォームモジュールに ↓ Option Explicit Private Sub CommandButton1_Click() Range("B" & myRow).Resize(, 3).Copy Sheets("Sheet2").Range("A2") End Sub _____________________________________
>Vcells( , )としてみたところ なにをどうしようとして、そんなこと（そんなこと自体もどんな事を行ったのかわかりませんが・・）をしたのかよく解らないです。 提示されたプログラムのおかしな点を指摘するならば、 >Select Case V(i - 1, 1).Value >V(i, 1).Value = V(i - 1, 1).Value >V(i, 2).Value = V(i, 3).Value 配列に、「.Value」を付けるのですか？ 「.Value」は、セルやテキストボックスなどに入力された値の取得のためのプロパティ。 配列に使用するものではありません。 他の場所 >If V(i, 3) = "合格" Then では、正しくコーディングされているのになぜなんですかね？
VBAのソースなら、コピペして質問文に貼り付けた方が簡単で、誰にでも分かりやすい内容になると思いますが・・・（なぜ、写真を？） 写真だと文字が小さすぎで分かりにくいです。 >この写真のコードだと、エラーのメッセージも入力チェックも両方出てしまいます。 Msgboxが２つ並んでいるので、そりゃ出るでしょうね。 メッセージを表示して、戻り値を変数に入れているだけです。 メッセージは出したいところに入れるのが基本です。 また、エラーの時は Exit Sub で処理を抜けるのでは？ ------------------------------ With の使い方もおかしい。 Range の使い方もおかしい。 ここで全て説明するのは大変なので、VBAのリファレンスサイトを見て勉強すれば良いかと思います。 https://www.google.co.jp/search?num=50&newwindow=1&site=&source=hp&...
こんにちは。 1) 手っ取り早く、タスク専用のブックを作成する。 2) タスクスケジュールの設定を全部確認して、資料のとおりに設定する。 早いのは1です あと、 http://www.ken3.org/vba/backno/vba086.html の話だと、主様のコードはacessの話。エクセルは、だめです ブログの話だと、VBSで動作しているからタスクで、引数を渡していません。 エクセルをラッピングしている。 ここらへんに、おちつきそうです
>select case文を使い Select Case 変数 Case 値1 Set x = Range("A1") Case 値2 Set x = Range("A2") End Select Range("B2").Interior.Color=x.Interior.Color
ワンクッションは作業セルを使わなくても、数式中で良いですね。 H1セルとI1セルに名前を付けた範囲の「名前」が項目として有るとします。 リストの元の値欄に次式を入力します。 =INDIRECT(IF(OR(A$1=H$1:I$1),A$1,"O"))
COUNTA で出来ると思います。
Cells(1, 1)はオブジェクトです。セルといっても色々あって アドレスはA1 値は1 背景色 文字色 高さ 幅 と色々あります。プロパティと言います。.Valueは値を示すプロパティです。なのでCells(1, 1).Value=1はセルの値を1にせよとの意味で正しい表現です。 しかし、.Valueは使用頻度が非常に高いため、省略した場合は.Valueにしましょうと決められてます。だから無くてもいいのです。 実際、どちらにすべきかは、何とも言いがたいですね。
フィルタをかけたデータ範囲を、別シートにそのままコピペすればOKです。 ----------------------- Sub フィルタ後のデータ範囲をコピペ() Dim sh1, sh2 Set sh1 = Sheets("サンプル") Set sh2 = Sheets("別シート") sh2.Cells.Clear sh1.Cells(1).CurrentRegion.Copy _ Destination:=sh2.Cells(1) End Sub
>>VBで2個のバイトデーターを結合する方法を教えて頂けませんでしょうか？ Dim BArray() As Byte BArray = CStr(A) & CStr(B) >>例えば、０ｘD3と０ｘFAという2個のバイトデーターを結合して、 ０ｘD3FAという1個のInteger型のデーターにしたいのですが 基本的には、↓のような力技しかないはず。 http://7ujm.net/VB/str_integer.html
↓のような感じなのでは？ If 容積重量.Value > 実重量.Value Then 配送重量.Value = 容積重量.Value Else 配送重量.Value = 実重量.Value End If
ご提示のプログラムには、コンパイルエラーが残ってます。 （大文字・小文字、「.」と「,」の間違いだけではありません） ↓のように書き直すとエラーは解消しますが、あなたが実際に実行したプログラムと同じものなのでしょうか？確認してください。 あと、 「セル値がどのような値で、どんな条件で、どのような結果になれば嬉しい」 のかを説明してください。 「上手く出来ない」だけでは、回答者は「エラーなく実行されますよ！」と回答するしかないのはご承知ですよね？ あとサンプルデータの提示もお忘れなく。 Dim i As Integer Dim a As Integer Dim b As Integer Dim hantei As Boolean For b = 2 To 11 hantei = False If Cells(b, 1) <> "" Then hantei = True Else Exit For End If Next b For i = 2 To 11 For a = 2 To 6 If hantei = True Then If Cells(i, a) <> "" Then hantei = False Else With Cells(i, a).Interior .Color = vbYellow End With End If End If Next a Next i
どんなコードなのですか？
下記のコードでいかがでしょうか？ 数式が入っていないセルはチェックしません。 Option Explicit Sub Sample() Dim rng As Range, f As String If TypeName(Selection) <> "Range" Then Exit Sub Application.ScreenUpdating = False For Each rng In Selection If rng.FormulaR1C1 <> "" Then If f = "" Then f = rng.FormulaR1C1 MsgBox "選択範囲の数式はすべて同一です" Else If f <> rng.FormulaR1C1 Then rng.Select MsgBox "数式が一致していません。" Exit For End If End If End If Next rng Application.ScreenUpdating = True End Sub
＞フォームに表示された は Me.テキストボックス名 で取得出来ます。 ＞テーブルやクエリの条件から必要なフィールド名 は下記で解説されています、 (Access 2000/2002/2003)と書かれていますが、Access 2000以後なら動作すると思います、クエリ名を指定すればクエリ内のフィールド名も取得できるはずです。 テーブル内のフィールド名の一覧を取得する https://www.moug.net/tech/acvba/0080049.html
>johnnys_19990915_arashi_amnosさん2016/8/1514:53:16 >csv形式のテキストファイルの保存方法と任意の名前かつ任意の場所で保存する方法がわかりません。VBAのコードもどう入力していいかわかりません。 書籍を購入する事から始めるといいと思います。
下記のコードでいかがでしょうか。 Option Explicit Private Index As Long Private Sub ComboBox1_Change() Dim ListNo As Long, i As Long Dim txt As String With ComboBox1 ListNo = .ListIndex If ListNo < 0 Then Exit Sub Application.EnableEvents = False For i = 0 To .ColumnCount - 1 txt = txt & .List(ListNo, i) If i < .ColumnCount - 1 Then txt = txt & vbTab Next .Text = txt Index = ListNo End With Application.EnableEvents = True End Sub Private Sub CommandButton1_Click() Dim lRow As Long, i As Long If Index < 0 Then MsgBox "いずれかの行を選択してください" Exit Sub End If With ActiveSheet lRow = .Range("E" & Rows.Count).End(xlUp).Offset(1).Row For i = 0 To ComboBox1.ColumnCount - 1 .Range("C" & lRow).Offset(, i).Value = ComboBox1.List(Index, i) Next i End With ComboBox1.Value = "" Index = 0 End Sub '------------------------------------------------------------ Private Sub CommandButton2_Click() Unload Me End Sub Private Sub UserForm_Initialize() Dim LastR As Long Dim myData With Worksheets("M") LastR = .Range("A" & Rows.Count).End(xlUp).Row myData = .Range("A2:C" & LastR).Value End With With ComboBox1 .ColumnCount = 3 .ColumnWidths = "50;50;50" .List = myData End With CheckBox1.Value = False End Sub
添付図の画像は小さすぎで、判別付きません。 ので、当てずっぽう。 Sub sample() With Range("F2") .Offset(-1, -1).Copy Range(.Cells, .End(xlToRight)).PasteSpecial Paste:=xlPasteFormulas End With End Sub >そのプログラムもご教示いただけるとありがたい 画像が小さいせいなのか、全く意味が通じません。 やりたいことを纏めて、新スレ立ててください。
'Sheet1のデータ最終行は､B列で判断しています｡ Sub sample() Dim sh As Worksheet, xFrm, xTo, i As Long, ii As Long Set sh = Sheet1 xFrm = Split("B5:D5,F5,M5,S5:U5,AS5:AW5,AX5:BB5,BC5", ",") xTo = Split("B9:D9,D10,E9,F9:H9,I9:M9,I10:M10,N9", ",") With Sheet2 Do While sh.Range("B5").Offset(i).Value <> "" For ii = LBound(xFrm) To UBound(xFrm) .Range(xTo(ii)).Offset(i * 2).Value = sh.Range(xFrm(ii)).Offset(i).Value Next ii i = i + 1 Loop End With End Sub
こういったQAがありますので、VBAからは不可能ではないかと思います。 http://www.gomplayer.jp/player/bbs/view.html?intSeq=1889 ActiveXオブジェクトというのは、簡単に言えば、CreateObjectで作成されるものです。IEならば、 Set ie=CreateObject("InternetExplorer.Application") などとして制御用に取得できます。
こんにちは。 とりあえず、ぱっとみため、違和感のあるのは Set os = wmi.ExecQuery("SELECT *FROM Win32_OperatingSystem") です。 FROMの手前に、スペース一文字ありませんよね、 クエリにとっては、それって致命的なミスです。 そこを修正してみてください。 あとは、もともとのコードをよく確認です。 コピーペーストだったら、スペースが消えるなんて、ないですし、 手入力したのでしたら、全部の文字、確認してください。 他の心配は、コードは、実績のあるコードなんですかね、そこだけです。
会話など弾まなければ、しんどいかな、愛されてないかなと不安になりますよね。 特に遠距離だとそう思うのも仕方ありません。 ただ『釣った魚に餌はやらない』じゃないですが、大抵の男は恋人になってしまうと安心してしまうのか、それほど話してくれなくなるものです。 男はそういうものだと割り切るより他ないかも知れませんが、しかし彼の趣味を勉強して話題を増やすとか貴方が出来ることはあるはずです。 また遠距離恋愛は会って話せない分だけ互いの気持ちを確認する術がなくなりますから、自分の気持ちを素直に出さないと『冷められたかな？』と相手もなってしまいます。 恥ずかしいでしょうが、たまには好きだと伝えるのも必要だと思いますよ
エクセル 散布図 補完 でググる ここなどを参考に http://homepage3.nifty.com/gakuyu/excel/kinji.html 正弦波なら、3次で近似するのがいい。10ノードあれば、人間には正弦波に見える。 要は、①近似曲線の「種類」タブ－②「多項式近似」－③次数「２」－④近似曲線 を追加するをしてから、散布図の点を見えなくすればいい。
BitBlt関数を利用します。 https://msdn.microsoft.com/ja-jp/library/cc428307.aspx VB.NETですが「画面をキャプチャする」の中で「Win32 APIを使用する方法」に参考コードがありますよ。 http://dobon.net/vb/dotnet/graphics/screencapture.html
If Cells （1.9）> then 59が抜けてます。 If Cells(1.9) < 60 Then Cells(1.1) = "不可" End If 上の方で59点を超える場合の処理は終わってるので、この行で残ってる人は全員60点未満です。つまりIf Cells(1.9) < 60 Then は不要です。 上記で対応出来るのは確かに１個だけです。 For i=1 to 10 If cells(i,9)～ ～ Next i とやれば i の値によって処理を変えてくれます。 これでとりあえず動くようになったら（その気があるなら）ElseIf を使うとか、Select Caseを使うとかやってみましょう。
下記のコードをSheet1の「Private Sub Worksheet_Change(ByVal Target As Range)」から「End Sub」と置き換えて下さい。 Option Explicit Private Sub Worksheet_Change(ByVal Target As Range) Dim rng As Range, shp As Shape, w As Long Dim endCell As Range '変更されたすべてのセルを検査する For Each rng In Target.Cells 'B列が変更されたとき If rng.Column = 2 Then w = Val(rng.Value) If w > 0 Then 'このシートのすべての図形を検索する Set endCell = Nothing For Each shp In Me.Shapes '同じ行にあるオートシェイプを検索する If shp.Type = msoAutoShape And _ shp.TopLeftCell.Row <= rng.Row And shp.BottomRightCell.Row >= rng.Row Then '該当する長方形の幅・高さ・左端位置・上端位置を調整する shp.Width = w * Range("C2").Width - 1 shp.Height = rng.Height / 2 shp.Left = shp.TopLeftCell.Left shp.Top = rng.Top + rng.Height / 4 Set endCell = shp.BottomRightCell End If Next shp '同じ行にオートシェイプが存在したとき If Not endCell Is Nothing Then 'このシートのすべての図形を検索する For Each shp In Me.Shapes '同じ行にあるテキストボックスを検索する If shp.Type = msoTextBox And _ shp.TopLeftCell.Row <= rng.Row And shp.BottomRightCell.Row >= rng.Row Then 'テキストボックスのプロパティを変更する shp.TextFrame2.WordWrap = msoFalse shp.TextFrame2.AutoSize = msoAutoSizeShapeToFitText '該当するテキストボックスの内容を変更する shp.TextEffect.Text = Cells(2, endCell.Column).Value & "(" & rng.Value & ")" '該当するテキストボックスの左端位置・上端位置を調整する shp.Left = endCell.Offset(, 1).Left If shp.Height > rng.Height Then shp.Top = rng.Top - (shp.Height - rng.Height) / 2 Else shp.Top = rng.Top + (rng.Height - shp.Height) / 2 End If End If Next shp End If End If End If Next rng End Sub
h838170さん、こんにちは。 EXCELは、多重起動することができます。つまりEXCEL のウインドウそのものを複数立ち上げることができます。 この時、例えば１つのWindow でBook1.xlsxを、もう１つのウインドウでBook2.xlsxを開いているとすると、Book1 からVBA projectを見ても、Book2は見えません。（その逆もしかりです。） つまり、それぞれ独立して生成されたEXCEL インスタンスの上にあるので、相互に認識が取れない状態にあるものと思われます。 なので、社内開発したソフトからBook1.xlsxを開いた後で、同じインスタンス上で質問者様のマクロファイルを開けば問題なく操作できるのではないかと思います。 どんな場合でも対処できる(EXCELインスタンスをまたいで認識させる)方法は、浅学のため私には判りません。すみません。(他の回答者様の知恵頼みです。)
Select状態に出来るのはアクティブシート上だけですから、先にSheet2をアクティブにしてください。 Sheets("Sheet2").Activate Sheets("Sheet2").Range("B2").Select
>前者の方がいい理由はありますか？ >下のほうがキレイにまとまって見える 提示されたコードの範囲では、あなたの意見に全面的に賛成です。 異論の余地はないですね。
オートシェイプとテキストボックスを同時に変更するコードです。 Option Explicit Private Sub Worksheet_Change(ByVal Target As Range) Dim rng As Range, shp As Shape, w As Long Dim endCell As Range '変更されたすべてのセルを検査する For Each rng In Target.Cells 'B列が変更されたとき If rng.Column = 2 Then w = Val(rng.Value) If w > 0 Then 'このシートのすべての図形を検索する Set endCell = Nothing For Each shp In Me.Shapes '同じ行にあるオートシェイプを検索する If shp.Type = msoAutoShape And _ shp.TopLeftCell.Row <= rng.Row And shp.BottomRightCell.Row >= rng.Row Then '該当する長方形の幅・高さ・左端位置・上端位置を調整する shp.Width = w * Range("C2").Width - 1 shp.Height = rng.Height / 2 shp.Left = shp.TopLeftCell.Left shp.Top = rng.Top + rng.Height / 4 Set endCell = shp.BottomRightCell End If Next shp '同じ行にオートシェイプが存在したとき If Not endCell Is Nothing Then 'このシートのすべての図形を検索する For Each shp In Me.Shapes '同じ行にあるテキストボックスを検索する If shp.Type = msoTextBox And _ shp.TopLeftCell.Row <= rng.Row And shp.BottomRightCell.Row >= rng.Row Then 'テキストボックスのプロパティを変更する shp.TextFrame2.WordWrap = msoFalse shp.TextFrame2.AutoSize = msoAutoSizeShapeToFitText '該当するテキストボックスの内容を変更する shp.TextEffect.Text = Cells(2, endCell.Column).Value & "(" & rng.Value & ")" '該当するテキストボックスの左端位置・上端位置を調整する shp.Left = endCell.Offset(, 1).Left If shp.Height > rng.Height Then shp.Top = rng.Top - (shp.Height - rng.Height) / 2 Else shp.Top = rng.Top + (rng.Height - shp.Height) / 2 End If End If Next shp End If End If End If Next rng End Sub
下記のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim st1 As Worksheet, st2 As Worksheet Dim cMax As Long, c1 As Long Dim r1 As Long, r2 As Long Set st1 = Worksheets("シート１") Set st2 = Worksheets("シート２") 'シート１の最終列を求める cMax = st1.Cells(1, Columns.Count).End(xlToLeft).Column 'エクセルの再描画を停止する Application.ScreenUpdating = False 'シート２を一旦クリアする st2.Cells.Clear 'シート２に見出しを書き込む st2.Range("A1:E1").Value = Array("品番", "原価", "売価", "店名", "数量") r2 = 2 'シート１の4行目から最終行まで繰り返す For r1 = 4 To st1.Range("A" & Rows.Count).End(xlUp).Row 'シート２に品番の数だけ転記する For c1 = 2 To cMax With st2.Range("A" & r2) .Offset(, 0).Value = st1.Cells(1, c1).Value '品番 .Offset(, 1).Value = st1.Cells(2, c1).Value '原価 .Offset(, 2).Value = st1.Cells(3, c1).Value '売価 .Offset(, 3).Value = st1.Cells(r1, 1).Value '店名 .Offset(, 4).Value = st1.Cells(r1, c1).Value '数量 End With r2 = r2 + 1 Next c1 Next r1 'シート２を品番および店名でソートする r2 = r2 - 1 With st2.Sort .SortFields.Clear .SortFields.Add Key:=Range("A1:A" & r2), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal .SortFields.Add Key:=Range("D1:D" & r2), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal .SetRange Rows("1:" & r2) .Header = xlYes .MatchCase = False .Orientation = xlTopToBottom .SortMethod = xlPinYin .Apply End With ' st2.Activate st2.Range("A2").Select 'エクセルの再描画を再開する Application.ScreenUpdating = True End Sub
① は例えばセルC10の関数式は =sumIf(A5:A10,"小 計",C5:C10) と普通です。 しかし②は =sumif(Range(A5:A10),"小 計",Range(Cells(5,x ), Cells( ben, x ))) とRange等が入っており関数式としては誤りです。セル範囲Rangeでなくセル範囲のアドレスA5:A10である必要があります。修正は.addressを付けるだけです。 Cells(num, x).Formula = "=sumif(" & Range(Cells(5, "A"), Cells(ben, "A")).address & ",""小 計""," & Range(Cells(5,x ), Cells( ben, x )).address & ")"
セキュリティ上、指定された拡張子以外のファイルは読めないようになっています。 https://support.microsoft.com/ja-jp/kb/436329
こんな感じです。・・・・・・・・・・・・・ Sub 平均() On Error Resume Next Dim a, b, c As Long Dim temp As Long temp = Range("A" & Rows.Count).End(xlUp).Row For a = 1 To temp For b = 1 To 3 c = c + Cells(a, b).Value Next Range("D" & a).Value = Int(c / 3) c = 0 Next End Sub
提示のコードの [フィールド名] というのはオプショングループのコントロールソースですか。 オプショングループに連結したフィールドには、数値しか入力できません。 オプショングループのValueも数値です。 もし、やりたいことがフォーム上のテキストボックスにオプショングループの選択に対応したテキストを表示させたいということなら、ＶＢＡは必要ないです。 テキストボックスのコントロールソースに下記の式を設定してください。 =Choose([フレーム名], "東京", "大阪", "名古屋, "静岡", "")
私の理解している限りではテーブルに部分的に色を変えるような機能は有りません。 テーブル内容をフォーム上のテキストボックスに表示できるようにして、条件付き書式を使うか、ＶＢＡで処理します。
下の図のようなことで、 C5セルには、 ① =LOOKUP(10^9,LEFT(B5,ROW($1:$50))*1)*LOOKUP(10^9,RIGHT(LEFT(B5,LOOKUP(10,MID(B5,ROW($1:$50),1)*1,ROW($1:$50))),ROW($1:$50))*1) の式を入れて、下にオートフィル（コピー）しています。
sample: push each charactors to an array from 4 digit number string - JSFiddle https://jsfiddle.net/sii_side/t2rahm2q/ いくつか方法が思いつきますが、文字列を空文字でsplitするのが最も手軽かと思います。 ほとんどの方法では、配列に格納された各要素が文字列型であることに注意してください。
ご希望の操作は単純にワイルドカード置換で対応できそうです。 Ctrl+Hで置換ダイアログを出して、検索する文字列に「点（*)」置換後の文字列に何も記入せず「すべて置換」します。
こんにちは。 開くファイルの種類も、ほぼ決まっているようですし、具体的に言ってください。 たとえば、でいいんですが、今あるコードは、どの程度、 textファイルは、「このように開く」 jpegは、こうする、というように、ファイルごとに様子が変化します ファイルが100見つけたとき、その100のファイルを全部開くとは、思えないからです
①このマクロを統合後ファイルの標準モジュールに記載 ②統合後ファイルと同一フォルダに「data」フォルダを作り、社員データのエクセルファイルを入れる ③データをコピーしたいシートをアクティブにしてマクロ起動 Sub Macro() Dim LastRow As Long, InputRow As Long Dim buf As String Const SttRow As Long = 7 With ActiveSheet buf = Dir(ThisWorkbook.Path & "\data\*.xlsx") Do While buf <> "" InputRow = .Cells(Rows.Count, "B").End(xlUp).Row + 1 Workbooks.Open Filename:=ThisWorkbook.Path & "\data\" & buf LastRow = Cells(Rows.Count, "A").End(xlUp).Row Range(Cells(SttRow, "A"), Cells(LastRow, "A")).Copy Destination:=.Cells(InputRow, "B") Range(Cells(SttRow, "B"), Cells(LastRow, "H")).Copy Destination:=.Cells(InputRow, "E") Cells(4, "C").Copy Destination:=.Range(.Cells(InputRow, "D"), .Cells(InputRow + LastRow - SttRow, "D")) Application.DisplayAlerts = False Workbooks(buf).Close savechanges:=False Application.DisplayAlerts = True buf = Dir() Loop End With End Sub あなた一人で使う分には問題ありませんが、複数人で使うとなると、あなたは自動的にこのマクロの担当者になります。何か問題が起こると全部あなたに来ますので、この機会にVBAを勉強しておくことを勧めます。
下記のコードでいかがでしょうか？ Option Explicit Sub Sample() Dim WSH As Object Dim Path As String Dim FSO As Object Dim Folder As Variant Dim folderObj As Object Dim fileObj As Object Set WSH = CreateObject("Wscript.Shell") Path = WSH.SpecialFolders("Desktop") & "\AAA" Set FSO = CreateObject("Scripting.FileSystemObject") For Each folderObj In FSO.GetFolder(Path).SubFolders For Each fileObj In folderObj.Files If fileObj.Name Like "0_*" Then fileObj.Move Path & "\" End If Next Next Set FSO = Nothing Set folderObj = Nothing Set fileObj = Nothing End Sub
データが大量であれば、マクロ処理が良いと思います。 同じデータで重複箇所が複数あるかもしれないので、 Sheet2のデータを基準にチェックしました。 Sub Sample() Dim i As Long Dim j As Long Dim myRow1 As Long Dim myRow2 As Long Dim sh1 As Worksheet Dim sh2 As Worksheet Dim flag As Boolean Dim c1() As String Dim c2() As String Application.ScreenUpdating = False Set sh1 = Sheets("Sheet1") Set sh2 = Sheets("Sheet2") myRow1 = sh1.Cells(Rows.Count, 1).End(xlUp).Row myRow2 = sh2.Cells(Rows.Count, 1).End(xlUp).Row ReDim c1(myRow1) As String ReDim c2(myRow2) As String For i = 17 To myRow1 c1(i - 16) = sh1.Cells(i, 1) & "_" & sh1.Cells(i, 49) Next i For i = 3 To myRow2 c2(i - 2) = sh2.Cells(i, 1) & "_" & sh2.Cells(i, 13) Next i For i = 1 To UBound(c2) - 2 For j = 1 To UBound(c1) - 16 If c2(i) = c1(j) Then sh1.Cells(j + 16, 50) = "重複" flag = True End If Next j If flag = False Then sh2.Rows(i + 2).Interior.ColorIndex = 6 End If flag = False Next i Application.ScreenUpdating = True End Sub << 標準モジュールに貼り付ける >> マクロのコードを記述・編集するときは、別のVBEという画面です。 １．上記のマクロコードを全てドラッグして、コピーします。 ２．Altキーを押しながら[F11]キーを押します。 ３．上の「挿入」メニューをクリックして、「標準モジュール」を挿入する。 ４．右のウィンドウの「マクロを書くところ」に貼り付けます。 あとは、この画面はいらないので、右上の「×」で閉じます。 ココを参考にしてください。 ↓ http://officetanaka.net/excel/vba/beginner/10.htm << マクロを実行する >> １．Altキーを押しながら[F8]キーを押します。 ２．出てきたマクロのダイアログで「Sample」を選択して「実行」
質問内容が曖昧で、状況が分かりませんが・・ ↓無料で使える「Visual Studio」を使ったのでは？ https://www.visualstudio.com/ja-jp/products/visual-studio-community... 個人利用や小規模会社での開発なら、無料でも十分な機能があります。 私はこの無料版でソフト開発して、販売していますよ。 もちろん、有料版もあります。（個人利用では不要かも・・）
InputBox関数の戻り値は文字列なので Dim a As VariantでもDim a As Stringでもどっちでも構いません。 Sub 検索() Dim a As String, b As String, c As Variant, d As Variant, e As Long a = InputBox("日付を入力してください。例 210610") b = InputBox("社員番号を入力してください。") If a = "" Or b = "" Then MsgBox "入力されていません" End If On Error GoTo Err_Trap Worksheets("Dt").Activate c = Application.WorksheetFunction.Match(a * 1, Columns("B"), 0) d = Application.WorksheetFunction.Match(b * 1, Columns("C"), 0) MsgBox "検索値は" & c & "行目、" & d & "行目です" Exit Sub Err_Trap: MsgBox "エラーコードNo." & Err.Number & vbCrLf & Err.Description MsgBox "検索値が見つかりませんでした" End Sub という感じで検索文字に１を掛けると数値になるので検索するなり、エラー処理にいくなりすると思います。 ちなみにWorkSheetFunctionを省略するとマクロはエラーで止まらずエラー値を返すので Sub 検索() Dim a As String, b As String, c As Variant, d As Variant, e As Long a = InputBox("日付を入力してください。例 210610") b = InputBox("社員番号を入力してください。") If a = "" Or b = "" Then MsgBox "入力されていません" End If Worksheets("Dt").Activate c = Application.Match(a * 1, Columns("B"), 0) d = Application.Match(b * 1, Columns("C"), 0) If IsError(c) Or IsError(d) Then MsgBox "検索値が見つかりませんでした" Else MsgBox "検索値は" & c & "行目、" & d & "行目です" End If End Sub というのもアリだと思います。
エラーの原因は、Unionの引数にRangeオブジェクト以外を使用したからですね。文字列型は使えません。 間違いを起こす原因は、きちんとした記述をする癖を付けていないからでしょう。 Cells(1,3) これは確かに、1行3列のセルの値を示しますが、暗黙のプロパティが含まれている結果です。正式には Cells(1,3).Value と記述します。省略した場合は、Valueが付くものとするという、暗黙のルールがあるのです。 本来、Rangeオブジェクトにプロパティを付けない場合は、Rangeオブジェクトそのものを表わします。 上記のような区別が付いていて、Unionの書式が分かっていれば、暗黙のプロパティなどを使っては混乱することは想像に難くないのではないでしょうか。 Set S=Cells(1,3) Set R=Union(Range(Cells(1,1), Cells(1,2), S) Rangeオブジェクトで値や数式を扱う場合は、きちんと適切なプロパティを記述する癖を付けてみてください。
A2=IFERROR(INDEX(Sheet1!B$1:B$10,SMALL(INDEX((Sheet1!A$1:A$10<>A$1)*10^5+ROW(A$1:A$10),),ROW(A1))),"") ★下にコピー
エラー：0x80041017 コード：80041017 ソース：(null) になりますか？ もしかするとoClassSetに何も入っていないのかも。 Set oClassSet = oService.ExecQuery("Select * From Win32_Process Where Description= " & seetoo) なので、inputboxで入力されたプロセス名が正しくないのかもしれませんね （サービス名と一致していない？）
> エラーが起こります。 > If FoundCell.Address = FirstCell.Address Then これを再現してみます まず、新規ファイルを開いて標準モジュールに以下を転記します Public Sub test()    Dim r As Range    Set r = Cells.Find("A", LookAt:=xlPart)    Debug.Print r.Address    Set r = Cells.FindNext(r)    Debug.Print r.Address End Sub 上記では "A" を検索するものになっているので、 今アクティブなシートの何処か１か所に A を入力しておきます 上記 test をステップ実行すると、 検索後のアドレスがイミディエイトウィンドウに表示されます ※ この実行ではおかしなところはありませんね？ A を入力したセルと右横のセルを結合して、test を実行してみます おかしくなるところはありませんね？ そのセル結合を解除して、今度は下のセルと結合して実行してみます FindNext 後の、Debug.Print でエラーになりますね･･･ このことから、シートにはセル結合された部分があるかも･･･ これを前提に処理記述すれば良いですね > Dim date_list(1000, 5) これは、事前にMAX行数分用意しておいて････ このような場合は、次元を入れ替えて ReDim が使えるようにしてみるとか･･･ 入れ替えて作った後は、Transpose で入れ替えて設定･･･       i = 0       ReDim vA(1 To 2, 1 To i + 1)          i = i + 1          ReDim Preserve vA(1 To 2, 1 To i)          With rng             vA(1, i) = .Offset(, 1 - .Column).Value             vA(2, i) = .Value          End With       With Range("A2").Resize(i, 2)          .Value = WorksheetFunction.Transpose(vA)       End With 雰囲気以下でどうなりますか ※ F1 の値がどうの･･･チェックしていないので ※※ 未検証なので、おかしかったらごめんなさい Public Sub Samp1()    Dim ws As Worksheet    Dim rng As Range, sAdr As String    Dim vA As Variant    Dim i As Long    Set ws = Worksheets("分け方")    Set rng = ws.Cells.Find(Range("F1").Value, LookAt:=xlPart)    If (Not rng Is Nothing) Then       i = 0       ReDim vA(1 To 2, 1 To i + 1)       sAdr = rng.Address       Do          i = i + 1          ReDim Preserve vA(1 To 2, 1 To i)          With rng             vA(1, i) = .Offset(, 1 - .Column).Value             vA(2, i) = .Value          End With          Set rng = ws.Cells.FindNext(rng)          If (rng Is Nothing) Then Exit Do       Loop While (rng.Address <> sAdr)       With Range("A2").Resize(i, 2)          .Value = WorksheetFunction.Transpose(vA)       End With    End If End Sub
正規表現の置換で処理するのは難しいと思います。 「35文字以内」という点は、例えば以下のような記述で可能です。 replaceallfast "^.{1,35}(、|。|★)", "\\0\\n", regular; 行頭から改行文字以外の文字が、1個以上35個以下連続した後に、「、」か「。」か「★」があった場合、その後ろに改行文字を入れる、というマクロです。「一番後ろの」という点については、正規表現は、特に何も指定しなければ、一番長い文字列にヒットしますので、問題ありません。 ただこの場合、35文字以上指定文字がない部分があると、それ以降改行されません。パターンの論理和を使って「35文字以内に指定文字がない場合は35文字で改行する」と同時に指定できないものかと、正規表現を色々検討して見ましたが、私の知識が足らないせいなのかどうか分かりませんが、うまい方法を見つける事ができませんでした。 指定文字で改行するマクロと、35文字で改行するマクロで、2回に分けて行ったらどうか、という方法も検討しましたが、1行の文字数がずれてしまうので、同時に行う必要があると思います。 また、正規表現では文字数しか指定できませんが、整形という観点から言えば、文字数ではなく桁数で指定した方がいいのではないか、という事もあります。例文のように全て全角文字ならいいですが、半角文字が多い行は短くなってしまいます。 結局、上から1行ずつ処理して行くのがいい、という事になりました。 以下はサンプルマクロです。 setcompatiblemode 0x2000f; // 改行する桁数の定義 #lf_column = 70; // 改行する指定文字列の定義 $lf_str[0] ="、"; $lf_str[1] ="。"; $lf_str[2] ="？"; $lf_str[3] ="！"; $lf_str[4] ="★"; $lf_str[5] ="」"; $lf_str[6] ="（笑）"; $lf_str[7] ="・・・+"; // 中黒が3つ以上連続 #lf_str_num = 8; // 検索用文字列の作成 $search_str = $lf_str[0]; #i = 1; while( #i < #lf_str_num ) { $search_str = $search_str + "|" + $lf_str[#i]; #i = #i + 1; } begingroupundo; disabledraw; replaceallfast "\n", ""; // 改行文字を一旦全削除する gofiletop; // 改行挿入ループ while( 1 ) { beginsel; moveto2 #lf_column, lineno; if( code == eof ) break; // ファイルの最後なら終了 searchup2 "(?\\2)(" + $search_str + ")((?!" + $search_str + "))", regular, inselect; // ※1 insert "\n\n"; } escape; // 選択範囲を解除 insert "\n"; // 最下行の処理 gofiletop; endgroupundo; endmacro; ※1 指定文字列が見つからなければカーソルは70桁目から動きませんので、検索結果に関わらず、カーソル位置で改行文字を挿入しています。 (?\\2) は、秀丸独自の「ヒットした扱いにするタグ指定」です。 http://hidemaruo.mydns.jp:81/helpsite/hidemaru/html/190_CmdSearch_R... 普通の検索では、ヒットした文字列の頭にカーソルが移動しますので、その位置では改行文字を挿入できません。指定文字列が固定長なら、検索した後にカーソル移動するなどすればいいですが、指定文字列が可変長なので、こういう方法を採っています。 (?! … ) は、「後方不一致指定」です。 http://hidemaruo.mydns.jp:81/helpsite/hidemaru/html/190_CmdSearch_R... これを使わないと、指定文字列が連続している箇所、例えば「。（笑）」のような場合に、「。」の後で改行されてしまいます。 指定文字列に正規表現のメタ文字が含まれている場合、例えば半角の「?」などは、エスケープして下さい。 http://www.shuiren.org/chuden/teach/hidemaru/seiki/01.htm $lf_str[8] ="!\\?"; // リテラル文字中なので「\」は2個必要です 秀丸独自のタグ付き正規表現では、検索文字列の最初と最後には「\f」は必要ありません。またこの機能は制限が多いので「一般的正規表現互換のタグ付き正規表現」を使った方がいいと思います。
可能ではあるのですが、具体的なURLや、そのページのHTMLソース全体がないと、方法は分かりません。 具体性のない回答ならば、対象タグの前で、ID属性値を持つタグや、特定できるNAME属性値のタグを見つけて、先にそれを取得し、取得したものから更に特徴を捉えて絞り込みを繰り返す、という形になります。最終的には、タグ名で取得したものの中から順番を指定することになるでしょう。
記載のやり方はテキストファイル用でありACCESSでは通用しません。 というのも、ACCESSはDBファイルを開くとファイルの更新日付がその時点の日時に書き変わるからです。 誤って開いてしまっただけで即更新対象です。 運用方法としては何通りかありますが、ここではDBのテーブルにバージョン情報を持つ方法を記します。 DBファイルとして３つ必要です。 (1) 通常運用用DB（ローカル配置） (2) 最新版DB（サーバ配置） (3) 更新用DB（１と同じ場所） DB(1)(2)にバージョン管理用のテーブルを設置します。 テーブル名を「tblVersion」とします。 フィールドはとりあえず１つで、名前を「Version」とします。 フィールド型はお好みでどうぞ。 DB(1)に下記のコードを配置し、DBスタート時に起動させます。 '--- ここから↓ Const ttl = "バージョンチェック" Dim strRefDB Dim strQRY Dim RS Dim FLAG ' strRefDB = "【配置したパス】" & "\(2)最新版DB.accdb" strQRY = "Select * FROM tblVersion IN '' [MS ACCESS;DATABASE=" & strRefDB & ";]" On Error Resume Next Err.Clear Set RS = CurrentDb.OpenRecordset(strQRY) If Err.Number Then MsgBox "バージョンアップ参照のDBに不具合あり" & String(2, 13) & Err.Number & vbCr & Err.Description, vbCritical, ttl Exit Sub 'Function End If On Error GoTo 0 FLAG = False If RS.RecordCount > 0 Then 'バージョンの比較 If DLookup("Version", "tblVersion") <> RS!Version Then FLAG = True End If RS.Close Set RS = Nothing If FLAG Then If MsgBox("新しいバージョンがあります" & String(2, 13) & "バージョンアップしますか？", vbInformation + vbYesNo, ttl) = vbYes Then '更新用DBを起動 Shell """" & SysCmd(acSysCmdAccessDir) & "msaccess.exe""" & " " & """" & CurrentProject.Path & "\(3)更新用DB.accdb""", vbNormalFocus 'そして、このDBはコピー対象となるので終了させる DoCmd.Quit End If End If '--- ここまで↑ あとは (3)更新用DB でファイルをコピーし、完了した旨を告知させます。 ＜省略＞（もしかしたら(3)で(1)が終了するまで待機させるコードが必要かも）
Public Sub Samp1()    Dim sS As String    Dim i As Long, k As Long    Const CROWF As Long = 5    Const CCF1 As String = "=SUM(R[{%1}]C:R[-1]C)"    Const CCF2 As String = "=IF(RC[-2]<>0,RC[-1]/RC[-2],"""")"    Const CCF3 As String = _       "=SUMIF(R[{%1}]C1:R[-1]C1,""小計"",R[{%1}]C:R[-1]C)"    Application.ScreenUpdating = False    Application.Calculation = xlCalculationManual    k = CROWF    For i = CROWF To Cells(Rows.Count, "A").End(xlUp).Row       Select Case Cells(i, "A").Value          Case "小計"             sS = Replace(CCF1, "{%1}", k - i)             With Cells(i, "C").Resize(, 3)                .Cells(1).Resize(, 2).FormulaR1C1 = sS                .Cells(3).FormulaR1C1 = CCF2                .AutoFill .Resize(, Range("AD1").Column - 2)             End With             k = i + 1          Case "合計"             sS = Replace(CCF3, "{%1}", CROWF - i)             With Cells(i, "C").Resize(, 3)                .Cells(1).Resize(, 2).FormulaR1C1 = sS                .Cells(3).FormulaR1C1 = CCF2                .AutoFill .Resize(, Range("AD1").Column - 2)             End With             Exit For       End Select    Next    Application.Calculation = xlCalculationAutomatic    Application.ScreenUpdating = True End Sub '確認用データ作成 Public Sub testData()    Dim r As Range    Dim i As Long, j As Long    Const CRH As Long = 130    Randomize    Application.ScreenUpdating = False    Cells.Delete    For i = 5 To CRH - 1       With Cells(i, "A")          Select Case i             Case 5, CRH - 1                .Value = .Address(False, False)                For j = 2 To Range("AD1").Column - 1                   .Offset(, j).Value = Int(100 * Rnd()) + 1                Next             Case Else                If ((.Offset(-1).Value <> "小計") _                      And (Rnd() > 0.8)) Then                   .Value = "小計"                Else                   .Value = .Address(False, False)                   For j = 2 To Range("AD1").Column - 1                      .Offset(, j).Value = Int(100 * Rnd()) + 1                   Next                End If          End Select       End With    Next    Cells(i, "A").Value = "小計"    Cells(i + 1, "A").Value = "合計"    Columns.AutoFit    Application.ScreenUpdating = True End Sub
"([^,\(\)]+)(,|\(|$)" でどうですか。 Public Sub Sample() Dim rex As RegExp Set rex = New RegExp rex.Pattern = "([^,\(\)]+)(,|\(|$)" rex.Global = True Dim s As String s = "桜島,富士山(静岡),八ヶ岳(長野)" Dim mc As MatchCollection Set mc = rex.Execute(s) Dim i As Long For i = 0 To mc.Count - 1 Debug.Print mc(i).SubMatches(0) Next End Sub
2015のほうから古いプロジェクトを開くと「古いんでコンバートしますか？」ってきいてきて「はい」 んでコンパイルすると警告やエラー出るんで、虱潰しにそれを尚してゆくだけの作業ですわ
Listの配列で もし２列が１でないなら・・・ iをすっ飛ばすからエラーになる。List の配列は１つずつ増加するには別の変数が必要。 Private Sub UserForm_Initialize() Dim i As Long, j As Long Dim lastRow As Long ListBox1.ColumnCount = 2 For i = 2 To 6 If Worksheets(2).Cells(i, 2) = 1 Then ListBox1.AddItem Worksheets(2).Cells(i, 1) ListBox1.List(j, 1) = Worksheets(2).Cells(i, 2) j = j + 1 End If Next End Sub
Aさんが9:30から10:30に予約した場合は予約シートにはどのように記入されるのでしょうか？ 日付は予約券印刷のシートのどこに出力すればよいのでしょうか？ 予約時間は予約券印刷のシートのどこに出力すればよいのでしょうか？ 予約されたIDは予約券印刷のシートに出力しなくても良いのでしょうか？ 同一日に同一IDで複数の予約が入ることはないのでしょうか？
質問文の場合だと、それぞれの行で最大に色をつけるのですね。 VBAとか今の設定をどう変更させるかより、最初からの設定方法を覚えた方がいいと思います。 先に条件を付けたい範囲を範囲指定してから 式は =AND(E4<>"",E4=MAX($E4:$AJ4)) 適用先は自動で =$E$4:$AJ$17 になります。 あえて E4<>"" をつけたのは、行全体が空白の場合全てに色がついてしまうのを防ぐためです。 条件付き書式設定の数式では、適用先のセル範囲を考えて、適宜アドレスに$をつけるかつけないかが決まってきます。
Sub sample() Dim rng As Range For Each rng In Range("A4:A33,A38:A42") With rng .Value = StrConv(.Value, vbNarrow) End With Next rng End Sub 繰返しのコードは1回で済ましましょう。
CCS-C は未経験ですが、調べたところ int i; は８ビット値 0-255 なので long i; 16ビット値 0-65535 に変えてみては？ 参考先 http://www.picfun.com/cinst03.html
表の形はわかりませんが、コードを実証しましたがエラーが再現しませんでした。どの行でエラー起きていますか？ ただ↓ Select Case TCol のTcolが何も格納されていないので9,10行でなにも起きない～やるならi 文字色の変数にもなにも格納されていない～変数を使わず直接指示 ブレークポイントを使ってコードの実証をしてください。 コードの左端をクリックして●をつけたら、イベントコードでもそこで処理が一時停止します。F8キーでステップ実行できるので、あとは変数をマウスオンやローカルウィンドウを使って確認してみましょう。
前提が各数値が１セルごとに入っているのであれば、VBAにて可能です。 ただ明示されていませんが、３ポイント離れた数値との比較は真下のセルだけを比較でしょうか？ それともフィーリングカップルばりにすべての組み合わせにライン成立を判定するのでしょうか？
新しいプログラムを作る事は、新しい物を発明しようとするのと同じで、失敗の繰り返しです。なので、ある程度どのようにするかは分かっているようですので、作り始めるのが一番の早道です。作りながらわからない部分を知らべ、失敗しながら作り上げるしか無いです。尚、リレーショナルデータベースはテーブルの構造が簡単な２次元の表で持っているので、SQLも簡単で、命令数も少ないので習得は容易ですが、簡単な分、実際のプログラム作りには知恵が必要です(簡単な機能を組みあわせる知恵)、また、RDBMSの違いで方言のような文法の異なる部分も結構沢山あるので注意が必要です。データの操作する部分はSQLを使う事で、全てプログラミング言語で対応するよりも、格段に簡単に早く出来るので、多分、データベースにデータを登録するまでは早く出来ると思います。難しいのは警告を出す判断のプログラムと想定します。
Clen関数なんて無いと思います。 整数に丸めるなら、 Round(8030/81,0) です。
Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Dim xhy If Target.Column = 5 Then With Me .Range("E4").Value = Target.Value MsgBox .Range("E4").Value & " をリンク表示します" Set xhy = .Hyperlinks.Add(Anchor:=.Range("E3"), Address:="https://www.google.co.jp/maps/place/" _ & .Range("E4").Value, TextToDisplay:="地図を開く") xhy.Follow NewWindow:=True End With End If End Sub 関数をFollowしようとするのは無理があるのでしょう？
フロントエンドをサーバ上の共有フォルダーに置くという方法も考えられますが、破損の危険性が高いらしくお勧めできません。また、ユーザーが使用中は上書き更新できませんので、ユーザーが使用してないときにしか更新できません。 フロントエンドはローカルにおいて、サーバー上の共有フォルダーに最新ファイルをおいて、ローカルとサーバーのファイルのバージョンを比較して、更新されていたらコピーして上書きするという方法がいいかと思います。 下記でWSHスクリプトを紹介していますのでご参考に。 複数ユーザーで共有している場合のフロントエンドファイルのバージョンアップ http://hatenachips.blog34.fc2.com/blog-entry-422.html ただし、上記はフロントエンドのパスは固定なので、下記の方法でスクリプトのパスを取得してそれを利用するようにしてください。スクリプトとフロントエンドは同じフォルダに置きます。 WSHでスクリプトファイル自身が存在するフォルダパスを取得する - Qiita http://qiita.com/asterisk9101/items/54cdcedb9ef60ea0bb21WSH スクリプトの方法を紹介しましたが、Access自身で起動用のプログラムを作成してもいいでしょう。
書籍じゃないですが、、ここ。 http://officetanaka.net/excel/
下記のコードでいかがでしょうか。 基本的な考え方はkotashiji10_10さんの作ったプログラムに合わせてあります。 ただしコピー先の列は質問に合わせてB～D列にしてあります。 Option Explicit Sub Sample() Dim st1 As Worksheet, st2 As Worksheet Dim r1 As Long, fnd As Range, r2 As Long Application.ScreenUpdating = False Set st1 = ActiveWorkbook.Worksheets("Sheet1") Set st2 = Workbooks("データ一覧.xlsx").Worksheets("Sheet1") '一旦管理シートのB列からD列をクリアする st1.Range("B3:D" & Rows.Count).ClearContents '管理シートのA列を3行目から最終行まで繰り返す For r1 = 3 To st1.Range("A" & Rows.Count).End(xlUp).Row 'データ一覧のA列から管理シートのA列の値を検索する Set fnd = st2.Columns("A").Find(st1.Range("A" & r1).Value) '存在していたらデータを転記する If Not fnd Is Nothing Then '一致したデータの行番号を取得する r2 = fnd.Row st1.Range("B" & r1).Value = st2.Range("D" & r2).Value '管理シートのB列にデータ一覧の4列目(D列)の値を転記する st1.Range("C" & r1).Value = st2.Range("H" & r2).Value '管理シートのC列にデータ一覧の8列目(H列)の値を転記する st1.Range("D" & r1).Value = st2.Range("I" & r2).Value '管理シートのD列にデータ一覧の9列目(I列)の値を転記する Else '存在していなかったらメッセージを表示する MsgBox "検索できません" End If Next r1 Application.ScreenUpdating = True MsgBox "終了しました。" End Sub
MouseMoveイベントを使います。 MouseEventArgs.Buttonから、 ボタンが押されているかどうかを取得してください。
回答がついていないようなので・・・ http://xfs.jp/WdQq8 PW:38q8f11s まじめに回答を求めるなら「ID非公開」はやめ、 同一ＩＤで質問すべし。
質問主様 こんにちは。 ●まず、名前を先に指定させるには、コードの前後入れ換えでよいです。 fileName = ・・・ の後に ThisWorkbook.SaveAs ・・・ を実行すればよいです。 ●デスクトップフォルダ指定の末尾に"\"を付けることも前回答者殿の指摘通りです。 ●実行時エラー1004が出る理由の可能性は２か所あります。 (1) コードから読み取ると、セルE2,E3,I4には日付が入力されていると思いますが、日付のスラッシュ("/")記号はファイル名として使えない文字ですので、含まれていればエラーになります。 (2) ファイル保存形式をマクロ有効テンプレートファイルとして保存する意図で、ファイル名の最後に拡張子.xltm を付けていると思いますが、これではファイル保存形式を変更する指示にはなりません。 SaveAs 命令に追加の引数が必要です。 コードとしてはこんな感じです。 ------------------------- Dim fileName As String 'ファイル名作成 ※拡張子は付けない fileName = "保存名 " & Range("B8") & "様 " & Range("J8") & " 日程 " & Range("E2") & " ～" & Range("E3") & " 会議日" & Range("I4") If MsgBox(fileName & " で保存しますか？", vbYesNo) <> vbYes Then Exit Sub '保存するか確認して保存しない場合は終了 Application.DisplayAlerts = False '同名のファイルがある場合の警告禁止(必要なら) '指定フォルダに保存 ThisWorkbook.SaveAs "C:\Users\myname\Desktop\" & fileName, xlOpenXMLTemplateMacroEnabled Application.DisplayAlerts = True '警告許可(上で警告禁止した場合は警告許可に戻す) ------------------------- あと、蛇足ですが、 デスクトップフォルダはPCごとに違うので、固定でコードに書き込まずに環境変数から取得する方法もあります。(VBA 中級テクニックです) Dim wSH As Object Dim DTfolder As String Set wSH = CreateObject("WScript.Shell") DTfolder = wSH.SpecialFolders("Desktop")
ActiveWorkbook.Saveの前にくっつければいいのだと思いますが。 （シート名を指定していないのが気になりますが） 検索は”A"がなかったときエラーにならない、ワークシート関数のCOUNTIFが最適ですね。 Sub ボタン_Click() '------------ Dim i As Long, r As Range Dim lastrow As Long '------------- Application.ScreenUpdating = False Dim FileName As String ChDrive Left(ThisWorkbook.Path, 2) ChDir ThisWorkbook.Path FileName = Dir("*.xls*") Do While FileName > "" If FileName <> ThisWorkbook.Name Then Workbooks.Open FileName Range("J:J,L:L,N:N,P:P,R:R").Delete Shift:=xlToLeft '-------------- lastrow = Cells.SpecialCells(xlCellTypeLastCell).Row For i = lastrow To 1 Step -1 Set r = Range(Cells(i, 1), Cells(i, 5)) If WorksheetFunction.CountIf(r, "A") Then Rows(i).Delete End If Next '--------------- ActiveWorkbook.Save ActiveWorkbook.Close End If FileName = Dir Loop Application.ScreenUpdating = True End Sub
こんな感じです。・・・・・・・・・・・・・・・・・・・ Sub test() Dim temp As Range For Each temp In Range("A1:B20") If temp.Value >= 1.5 Then temp = temp & " ↑" End If Next End Sub
ファイルを開くときに入力（テキストモード）で開いているので、テキストにならないデータは無視されます。 ファイルをバイナリモードで開く Dim buf As Variant Open myFileName For Binary As #1 buf = InputB(10, #1) ではどうでしょう？
下記のコードでいかがでしょうか？ Public Function CellColor(セル位置 As String) As Long CellColor = Range(セル位置).Interior.Color End Function Sub セル色数値換算() Dim Aa As Integer Dim Bb As Integer Aa = 4 Bb = 22 Range("C" & Aa + 0 & ":" & "BI" & Aa + 0).Formula = "=cellcolor(""C" & Bb + 0 & """)" Range("C" & Aa + 1 & ":" & "BI" & Aa + 1).Formula = "=cellcolor(""C" & Bb + 3 & """)" End Sub
こんにちは。 単純に、updateの設定で出来ない、というのだと、仕様の限界かもしれません。 エクセルの作業ウィンドを標準にして、画面の外に配置して、これらのコードを実行して、正しい位置に戻す、という方法は、試してみてください エクセルアプリのウィンド制御のコードですよ。
参照設定の呪縛から逃れたいのであれば、 Set cb = CreateObject("new:{1C3B4210-F441-11CE-B9EA-00AA006B1A69}") With cb .SetText Cells(1, 1).Value .PutInClipboard End With
VB.NET http://log.windows78.net/2015/03/1295/ C# http://tomosoft.jp/design/?p=5543 DLLで提供されているAPIをコールしていく形になると思います。 C#の参考サイトが自分が見た限りでは、基本的な部分を抑えているとおもわれるので、こちらを参考にVB.NETへ置き換えるような形ですと、いいかと思います。
計算結果がセルA１に表示されるとすると・・。 Sub Message() If Range("A1").Value < 0 Then MsgBox "マイナスだよ" End If Ens Sub
vanvalia さん、こんばんは。 ストライクな回答ではないですが・・・・。 当方の環境（Windows7-32bit、EXCEL2010）で試したところ、非表示範囲きっちりでない行指定で、隠された行のHiddenプロパティFalse にした行は、問題なく表示されました。 (テストでは、"5:30" 行を隠した状態で、"6:30"、"5:31"、"10:20" などを実行してみました。) 非表示行に結合セルを含む場合でも問題なかったですし、オートフィルタ機能で隠された行についても問題なく実行されました。 質問内容ですと、「何も起こらない」ということなので、エラー表示も何もない、ということですね？ であれば、.Hiddenプロパティの設定方法そのものに問題があるのでなくて、別のところに問題がありそうな気がします。 (例えば、コード例では、Rows オブジェクトにワークシートの修飾子がないので、アクティブシートが操作の対象となり、それ以外のシートには作用しないのでそういう類の問題でないかと推測します。) プログラムのコードと、そのブックの環境が判らないので、これ以上の考察は難しいです。
すべてのコードから Worksheets("テスト"). ←最後のドットも含む を削除してみてはどうですか。
IF text1.text="" then msgbox "メッセージを入力してください" end if とか
こんな感じです。・・・・・・・・・・・・・ Private Sub CommandButton1_Click() Randomize Dim a As Integer a = 6 Dim c, d, j, h As Integer Dim b(6) As Integer h = 0 owari: j = 0 d = Int(Rnd() * a + 1) For c = 0 To a - 1 If b(c) = d Then j = 1 End If Next If j = 1 Then GoTo owari ElseIf h < a - 1 Then b(h) = d h = h + 1 GoTo owari End If If h = a - 1 Then b(h) = d End If For c = 0 To a - 1 TextBox1.Text = TextBox1.Text & b(c) & " " Next End Sub Private Sub CommandButton2_Click() a = 0 TextBox1.Text = "" End Sub
Change 等の他のイベントで動作を試されましたか？
惜しい！ >func1 (tmp()) func1 tmp 括弧は不要です。
Set sh1 = Sheets("Sheet1") Set sh2 = Sheets("Sheet2") For i = 0 To sh1.Range("C4:C23").Count - 1 sh2.Cells(6, 7 + i * 2).MergeArea.Value = sh1.Cells(4 + i, 3).Value Next コピー先が結合されているようですので、MergeAreaを使用して値を設定します。
数か所変数名にミスがあります 「_root.last_pass_1」 が「_root._last_pass_1 」となっている等々 作りはだいぶ違いますが、自分が以前作った時には以下のようなスクリプトでやりました <初期化> _root.last_pass =""; <左> on(release){ _root.last_pass = _root.last_pass + "左"; } <右> on(release){ _root.last_pass = _root.last_pass + "右"; if(_root.last_pass.indexOf("左左右右左右")!=-1){ _root.last_flg=true; //正しい順序で押した時の処理 } }
「メソッド」と「引数」の区別が理解できていないようです。 VBAの基本的なことですからしっかり理解して下さい。 コードは下記のようになります。 Sub Macro1() '選択したセル範囲の周囲に実線を引く Selection.BorderAround LineStyle:=xlContinuous '選択したセルの水平罫線に実線を引く Selection.Borders(xlInsideVertical).LineStyle = xlDot '選択したセルの垂直罫線に実線を引く Selection.Borders(xlInsideHorizontal).LineStyle = xlDot End Sub
VB2010で実行してみましたが、線は途切れることが有りませんでしたよ？ 何かブレイクポイントとかつけてるんではないでしょうか？
自分だったら、部分一致も含めて instrを使いますね。 If instr(sh2.Cells.("i",4).Valuen,Books)>0 And instr(sh2.Cells.("i",5).Value,authors)>0 And instr(sh2.Cells.("i",6).Value,Series)>0 Then 空白ならすべて一致になるし、テキストボックスでの入力なら完全一致するほど記憶が完璧じゃないので。 コピー数が増えると時間がかかるので Application.screenupdating=falseは入れといたほうがいいですよ。
日々の商品の流れと 最終日の在庫を分けてシートにすればいいのでは textbox1=日付け textbox2=品番 textbox3=在庫数 textbox4=生産数 他に TEXTBOX5=出荷数が 必要でしょう しかも TEXTBOX3,5 出庫数と 在庫数を 入替えたほうが良い 在庫数は 入力するものでなく カウントするものだから。 それを踏まえて TEXTBOX1～TEXTBOX4は Ｓｈｅｅｔ１の 日々の移動状況 項目が A列 Ｂ列 Ｃ列 Ｄ列 月日 品番 出庫数 生産数 SHEEＴ2に A列 Ｂ列 Ｃ列 Ｄ列 Ｅ列 品番 出庫数 生産数 在庫数 初期在庫 出庫数は=SUMIF(Sheet!B:B,A2,Ｓｈｅｅｔ1!C;C) で 品番毎の出荷数が 生産数 =SUMIF(Sheet!B:B,A2,Ｓｈｅｅｔ1!Ｄ;Ｄ) で 品番毎の生産数が 出ます。 在庫は 各初期在庫+生産数-出庫数で 最終日の在庫数が出ます。 日々の生産数と出庫数は シート１を ピボットテーブルで 表示する 日々の在庫まで 必要であれば シート２の値をシート３に毎日値貼り付け こんな手ではいかがでしょうか?
売上管理A.xlsm と同時に開きたくないブック全てに、下記のOpenイベントマクロを書くしか方法はないのでは、と思います。 それぞれのThisWorkbook に下記を記載しておけば可能です。 Private Sub Workbook_Open() Dim wb As Workbook For Each wb In Workbooks If wb.Name = "売上管理A.xlsm" Then MsgBox "「売上管理A.xlsm」が開いているので他のブックは開けません" ThisWorkbook.Close Exit For End If Next wb End Sub
USB接続のバーコードリーダーはキーボードと同等なので、単なる文字入力として扱います。セルの属性は日本語コントロールオフ、バーコードリーダーの設定は改行コード付加、としとけば一発読むごとに次のセルに移動しますから、2つのセルの値が等しいかどうか判定しましょう。
以下のプログラムを、各オートシェープに登録してください。 線の長さは、B列に入力してあるものとしてます。 Sub sample() Dim sh As Worksheet Set sh = ActiveSheet With sh.Shapes(Application.Caller) .Width = sh.Cells(.TopLeftCell.Row, "B").Value End With End Sub 個人的には、 「B列の値を変更すれば、自動的に線の長さが変更される」 というほうが使いやすそうに思えますが。。。。
お役に立てて何よりです。 優先順位というよりは、製品ごとに生産可能な日付を指定すると、副次的に生産する順序を設定することができます。（実際には生産できない日の生産量を0に制限する） 詳しいことは下記に追加しています。 広めに生産可能日を設定する方が平準化がうまくいくかも知れません。 http://note.chiebukuro.yahoo.co.jp/detail/n389664
貴方のマクロの目的は 良く分かりませんが 単純に挿入であれば Rows("36:36").Select Selection.Copy Rows("36:36").Select Selection.Insert Shift:=xlDown 36行をコピーして 36行に コピーした行をそのまま挿入です。 こうすれば36行目に入っている式はそのまま行きますし 1行ずれて所は 自動的式を変更してくれます。 もちろん罫線も追随します。 36行目を 式のみいれて 空白行にしておく事です。 もし 37行目に =SUM()の 式があれば =SUM(A1:A36)と 空白行まで入れておけば =SUM()行が 38行目になったとき 自動的に =SUM(A1:A37) と成ります。 ５回繰り返す繰り返したいのなら Rows("36:36").Selectは マクロにせず まず空白行を選んで マクロを 実行すればよい 最初から 5行と決まっているなら L = ActiveCell.Row Rows("L:L").Select Selection.Copy Rows("L:L+5").Select Selection.Insert Shift:=xlDown という方法も有る。指定した行Ｎｏを 取得し コピーし それをその行から5つ下の行まで コピーするという方法です。
>for nextステートメントは他に使用方法があるのでしょうか。 For ～ Next文は、変数（今回の場合「a」)の値を、開始値から終了値まで、一定の増分で増やしながら、For ～ Nextで挟まれたステップを実行するだけ。 変数が実際の処理に使われようが、使われまいが関係ありません。 お示しのコードでは、Nextの直前のステップ Base = Base + 17 で、変数：Baseの値が変更されるので、繰り返しのなかで、参照されるセルが17行ずつ下にずれて処理されていますね。 次のように書くと解り易かったのかも。。。 Base = 9 For a = 1 To 20 ↓ For Base = 9 To 349 Step 17
お使いの構文は、XL2003までに使用されていたもの。 XL2003までは、並び替えのキーは３つまでです。 なので、 「Key4」などのキーワードは使えません。 XL2007以降の環境で、並び替えの操作を行い、マクロ記録を録れば、コードの元ネタは手に入ります。
tmkzu0801さん、こんにちは。 データを書き換える列が、B列からG列になった、ということですね。 最小限の変更で対応するならば、 Dt = Range(Range("A2"), Cells(Rows.Count, 1) _ .End(xlUp)).Offset(0, 1) を Dt = Range(Range("A2"), Cells(Rows.Count, 1) _ .End(xlUp)).Offset(0, 6) に、 Range(Range("B2"), Cells(UBound(Dt) + 1, 2)) = Dt を Range(Range("G2"), Cells(UBound(Dt) + 1, 7)) = Dt にすればよいと思います。
temp + 1 と指定すればよろしいかと思います。 Sub test() Dim temp As Long temp = 1048576 Do While Range("A" & temp).Value = "" temp = temp - 1 Loop MsgBox temp End Sub
変数aに「1a2b"3c4"d5」が入っている場合に 中身のダブルコーテ－ションを二重にしたいなら a = Replace(a, """", """""") でどうですか？
ほんとに、「連続印刷できるマクロは組めました。」できたんですか？ 文章からは、ちゃんとしたものが組めたように思えません。 説明が大まかすぎます｡他人にはわかりません。 シートの追加だけ書きます｡ Dim 新シート名 As String Dim Ws新 As Worksheet 新シート名 = Cells(2,"E").Value Set Ws新 = Worksheets.Add Ws新.Name = 新シート名 ただ、動いたから良いわけではありません。 VBの１行１行の意味を理解していないと応用が利きません。 応用が利かないということは、いつまでも初心者ということです。
どのように履歴を残したいのかにもよるでしょうね 少なければテキストファイルに書き出すと言うのはありますが、ボタンを押すたびに書き込んでは面倒だから、リストクラスに順に保存しておき最後に書き出すとか？ 希望とは違うならスルーして下さい ちなみに携帯なので具体的コードは提示できませんっていうか、どのように組み込めば良いか検討がつかない
＞RunではなくできればＣａｌｌがいいです。 Callではできません。Runを使用してください。
こんにちは。 主様、コードは、 set p = me.image1 p.loadpicture というように、ターゲットはオブジェクトにしてください。 単純にdim p as objectだけでは、実行時エラーになりますよ
自動ではなかったはずです。 下記を参考にして頑張ってコマンドを記述してください。 http://language-and-engineering.hatenablog.jp/entry/20130502/Patter... http://www.atmarkit.co.jp/ait/articles/1506/26/news026.html
以前の質問の続きであれば、せめて前質問のリンクを示してください。初めて見る人には伝わりません。 新規タブが発生しないのであれば、そのまま、現状のIEオブジェクト変数を利用するだけです。「IE」という名前で使っているのであれば、それをそのまま利用するだけで良いのです。 同じタブ・ウインドウでページ遷移している限り、制御元の変数は同じです。
グーグルスプレッドシートならスクリプトエディタを開いてデフォルトのfunction myFunction(){}を削除した上で以下を記述して保存します。 function onOpen() { Browser.msgBox("記入漏れがないか必ず確認してください"); } 保存したらいったんスプレッドシートを閉じ、また開いて下さい。そうしたらメッセージが現れると思います。
star_msr0246さん,こんにちは。 例えば、こんな感じですか。 Sub hoge() '対象者のシートを追加作成 Dim hoge As Range Dim er As Long For Each hoge In Worksheets("Main").Range(Worksheets("Main").Range("B9"), Worksheets("Main").Cells(Rows.Count, "B").End(xlUp)) On Error Resume Next Worksheets(hoge.Value).Activate er = Err.Number On Error GoTo 0 If er <> 0 Then Sheets("data").Copy After:=ActiveSheet ActiveSheet.Name = hoge.Value End If Next hoge Worksheets(1).Activate End Sub シートを作る前に、そのシート名でActivateメソッドを実行します。 シートがなければエラーが発生しますから、そのエラーをOn Error で拾って判定させてます。
> エクセル2013の関数について教えてください。 関数に別セルに何かを実行する機能は一切ありません。 関数は計算結果を表示する為のものです。
以下でどうなりますか Public Sub Samp1()    Dim r As Range    Dim v As Variant    Application.ScreenUpdating = False    With ActiveSheet.UsedRange       With .Offset(1, 2).Resize(.Rows.Count - 1, .Columns.Count - 2)          For Each r In .SpecialCells(xlCellTypeConstants)             v = r.Value             Select Case v                Case "公休": v = "×"                Case Is <= 0: v = "×"                Case 1 To 360: v = "△"                Case 390 To 510: v = "▲"                Case 540 To 1440: v = "◎"             End Select             r.Value = v          Next       End With    End With    Application.ScreenUpdating = True End Sub もしくは >   With ActiveSheet.UsedRange ↓    With ActiveSheet.Range("A1").CurrentRegion
パスワード付での出力は、Acrobat付属のOffice用COMアドイン「Acrobat PDFMaker Office COM Addin」を利用するしか方法は無いようです。もしAcrobatがインストールされているならば下記サイト参照下さい。 https://www.ka-net.org/blog/?p=6209 名前A～XのシートのみをPDF出力（パスワード無し）するのは、 ．For Each ～ Next で全シートをループします。 ．シート名を Like演算子で調べます。 Like "名前[A-Z]" ．ヒットしたシートをアクティブにします。 ．アクティブシートをExportAsFixedFormat Type:=xlTypePDFで出力します。 ※出力先はこのマクロが保存されているフォルダにしています。 ※エラー発生時の処理は考慮していません。 －－－－－サンプルコード－－－－－－ Sub PDF出力() Dim objSheet As Worksheet 'ループ用の変数 Dim fName As String '保存先フォルダパス＆ファイル名 ' ブックの全シートを 1 つずつループして処理する For Each objSheet In ThisWorkbook.Worksheets If objSheet.Name Like "名前[A-Z]" Then objSheet.Select fName = ThisWorkbook.Path & "\" & objSheet.Name & ".pdf" ActiveSheet.ExportAsFixedFormat Type:=xlTypePDF, fileName:=fName End If Next End Sub －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
現在6シートのブックに人数分300シートも追加しようとしているのですよね？ 一つだけシートを追加して、名前を入力でその人のデータを表示という形式ではだめなのですか。無駄にシートが多くなるだけのように思います。 印刷が目的ならなおさら、そうした方がいいと思います。
コード例です。 A列の２行目から最終行までのセルを一個ずつコピーして B1セル、C1セル、D1セル。。。のように貼り付けます。 20列目まで貼り付けたら、次の行に貼り付けます。 Cells(i, 1).Copy Destination:=Cells(j, m) Destinationで貼り付け先を指定しています。 --------------------------- Sub macro1() Dim i, j, m m = 2 j = 1 For i = 2 To Cells(Rows.Count, 1).End(xlUp).Row Cells(i, 1).Copy Destination:=Cells(j, m) If m < 20 Then m = m + 1 'mが20より小さい時は、1を加算 Else m = 2 '1ずつ加算していったmが20より小さくなかった場合 '(20列目までペーストした場合) 'm(貼り付ける列)を2にします。 j = j + 1 'j(貼り付ける行)を1、加算します。 End If Next Application.CutCopyMode = False End Sub ---------------------------- 上のコードの場合、一個ずつコピペを繰り返すので時間がかかります。 20行分のセルをまとめてコピーして(行・列を入れ替えて貼り付け）をするのが下のコードになります。 TransposeをTrueにすると、(行・列を入れ替えて貼り付け)ができます。 --------------------------- Sub macro2() Dim i, j j = 1 For i = 2 To Cells(Rows.Count, 1).End(xlUp).Row Step 20 Cells(i, 1).Resize(20, 1).Copy Cells(j, 2).PasteSpecial Paste:=xlPasteValues, Transpose:=True j = j + 1 Next Application.CutCopyMode = False End Sub
こんにちは。 コードをぱっとみただけなんですが、 For Each rng In sh.Range("A2", sh.Cells(Rows.Count, 1).End(xlUp)) On Error Resume Next Set sh0 = Worksheets(rng.Offset(, 1).Value) これ、データが50行だとして、A2からA50のセルのループでB2からB50のシート名を処理してますよね、 For Each rng In sh.Range("A2", sh.Cells(Rows.Count, 1).End(xlUp)) On Error Resume Next if sh.Range("W" & rng.row).value = "○" then Set sh0 = Worksheets(rng.Offset(, 1).Value) というようにしたらいいんですが、 シートのコピーなので、単一ファイルになっている、というのでしたら、 示したifが必要なコードです。 Next rng End With End Sub の手前に end ifを追加してください
リストボックス２、リストボックス３の SelectedIndex プロパティを設定したらどうですか？
元々シートが５枚あったとして、シート１から５まで調べようとしたけど、途中で該当シートを削除して４枚になったのに、予定通り５枚目を調べようとしてエラーになったのでしょう。 対策： 削除する時は最後から始めて最初に戻るのがいいです。 変更前：For i = 1 To Worksheets.Count 変更後：For i = Worksheets.Count To 1 Step -1
Sub sample() Dim i As Long i = 9 With Worksheets("Main") Do While .Cells(i, "B").Value <> "" .Hyperlinks.Add Anchor:=.Cells(i, "B"), Address:="", SubAddress:= _ .Cells(i, "B").Value & "!A1" i = i + 1 Loop End With End Sub
d5_monkey さん、こんにちは。 Pictures オブジェクトで挿入された画像は、デフォルトで縦横比が固定されている様子ですので、画像の縦横比とセレクション範囲の縦横比を比較して、縦・横どちらの値を設定するか選択するIf文を入れてみるのがよいかと思います。 こんな感じです。(追加修正箇所は'▽▽▽▽ と '△△△△ の間の行です。) Sub 選択セルに合わせて() Dim myFileName As String If TypeName(Selection) <> "Range" Then MsgBox "セルを選択して実行して下さい。" Exit Sub End If myFileName = Application.GetOpenFilename( _ FileFilter:="画像 ,*.jpg; *.gif; *.bmp", MultiSelect:=False) If myFileName <> "False" Then With ActiveSheet.Pictures.Insert(myFileName) .Left = Selection.Left .Top = Selection.Top '▽▽▽▽ If .Width / .Height > Selection.Width / Selection.Height Then .Width = Selection.Width Else .Height = Selection.Height End If '△△△△ End With End If End Sub
既に回答がついていますが、C13に空白が入っていませんか？ もし空白もBLANKと同一と見なしたいのであれば IF(ISBLANK(TRIM(C13)), "", VLOOKUP(C13,[★★一覧★★.xlsm]現場一覧!$B$5:$C$70,2,FALSE)) としてみて下さい。 あるいはC13には本当は数値の0が入っていて、数式設定で見かけ上何も表示しないようにしていませんか？ 更に・・・ VLOOKUPの結果が＃N/Aになる可能性があるのですから、その場合はどのような値にしたいのかも考えて下さい。 もし空欄にしたいのであれば =IF(ISBLANK(TRIM(C13)),"",IFERROR(VLOOKUP(C13,[★★一覧★★.xlsm]現場一覧!$B$5:$C$70,2,FALSE),"")) としてください。
回答を修正しました。 A3を選択した状態で、 [Ctrl][Shift][アスタリスク(*)]を同時に押すと選択できる範囲を データ範囲とみなします。 フィルタの条件を書き出すセル範囲AA1:AC4 データを出力するセル AE3 としています。 ●AE3から数えて、下に１０００行：右に100列の範囲(AE3:DZ1002)を データ出力前にクリアしてから出力します● ------------------------------- Sub 複数条件フィルタ() Dim 検索NO, 検索NO2, 検索NO3 Dim LR Dim 条件範囲 LR = Cells(Rows.Count, 1).End(xlUp).Row Set 条件範囲 = Range("AA1:AC4") Range("AE3").Resize(1000, 100).Clear Range("A3:C3").Copy Range("AA1") 検索NO = InputBox("検索NO", Default:="22050") 検索NO2 = InputBox("検索NO2", Default:="3389770") 検索NO3 = InputBox("検索NO3", Default:="67312H") Range("AA2") = 検索NO Range("AB3") = 検索NO2 Range("AC4") = 検索NO3 Range("A3").CurrentRegion.AdvancedFilter _ xlFilterCopy, _ 条件範囲, Range("AE3"), False Application.Goto 条件範囲, True End Sub
A21はシャツワンピとチェニックワンピの両方がヒットしますが、その場合はどちらを選ぶのでしょうか？
こんにちは。 まず、編集前データのシートに2行目の「空白行」を作成します。 rows()は、コピーして、編集前データにペースト そのあとrows()はdeleteしてください 今の動作は、仕様です。カットと削除は、まったくコードが違いますよ シートなんですから
私は ID非公開でこういう質問をする人は信用しないことにしてますので 具体的な回答をする気は全くありませんが「検索システムを作ろう」と いっているのなら人任せにしてはいけないと思います。 あなた自身に VBAの知識がないなら無理な相談です。ちゃんと勉強してか ら挑戦して分からないところを質問して下さい。 というかマクロ云々の前に一般機能をちゃんと勉強した方がいいです。 フィルタの詳細設定を 記録マクロにするだけでもできるでしょうし デー タベースクエリでパラメータを設定する形なら マクロもいらんでしょう。 言葉が厳しくなるのは ID非公開質問者が嫌いだからなのであしからず。
質問文で「実行したところエラーが発生」と書かれていますが、kuro_neko_g_sanさんの回答への返信を見るとビルド時のエラーですよね。(実行まで行けていないはず) 技術的な話をする場合ですので、どういう環境で、どういう事をしたときに、どういうエラーが出た、というのを正確に記述しなければ正しい情報のやりとりが出来ません。 本題ですが、そのエラー内容はリンク時のエラーですのでlibファイルの参照が出来ていないということになります。 まず、MIDIIOd.libとMIDIIO.libは1つのビルド構成で片方のみを設定します。 ビルド構成というのは「Debug」とか「Release」とか選択を切り替えられるやつです。 すなわち、「Debug」ビルド用の設定では「MIDIIOd.lib」の参照を。「Release」ビルド用の設定では「MIDIIO.lib」の参照を行います。 (プロジェクトの設定ダイアログでも左上でどのビルド構成を対象にしているかわかります) 次に正しいパスで参照を行わなければなりません。 リンカの入力欄に単に「MIDIIO.lib」などファイル名のみを記述してもだめです。 libファイルをどこに置くかによりますが、たとえば「MIDIIO.lib」をソリューションファイル(*.sln)のある場所に作った「rls」フォルダ内に置いた場合には、リンカ入力に「$(SolutionDir)rls\MIDIIO.lib」と指定することになります。 よく分からなければ、ひとまず動作させるためにフルパスで指定しておいて先に進むのも手です。(その場合は後で理解してよりメンテしやすい設定になおしましょう) そして、サンプルのコードを実行して音を出すには上にもすこし書きましたが環境も影響してきます。 リンク先のサンプルコードでは古いOSようになっていますが、たとえばWindows7であれば「"Microsoft GS Wavetable SW Synth"」の部分は「"Microsoft GS Wavetable Synth"」に変える必要があります。(あるいは他にインストールしてあればそのMIDI音源名) 当方の環境で試したところ、それらしい音がでることは確認出来ました。
Set Opnbook2 = Workbooks.Open(FPss) で、Opnbook2は、絶対パスFpssのワークブックというワークブックオブジェクトとしていしているので、 Opnbook2.Activate でアクティブにできます。 Workbook().Activateの括弧内は、絶対パスではなく、インデックス番号か、ワークブックオブジェクトのNameプロパティになります。例：book1.xlsx
>マクロ＆VBAの通信講座に取り組んでおり、下記課題が分らなく たぶん、課題のある章の内容で答えるのでは・・。 問題文からすると、セルB2の文字がA9からA54までの中であれば、その文字を「太字」という文字列に置換すると考えます。 Sub 書式の置換() Dim rng As Range, B2 As String, Word As String B2 = Range("B2") Word = "太字" For Each rng In Range("A9:A54") rng.Value = Replace(rng.Value, B2, Word) Next rng End Sub ただ、書式の置換となっているので、もしかしてB2の文字を太字という書式にしなさいとも受け取れますね。それなら以下で可能です。 Sub 書式の置換() Dim rng As Range For Each rng In Range("A9:A54") If rng.Value = Range("B2").Value Then rng.Font.Bold = True End If Next rng End Sub
https://www.microsoft.com/ja-jp/download/details.aspx?id=26347 ここからダウンロードしました？ また、Win7は32bitですか？64bitですか？ x86は32bit用ですので、64bitの場合は、x64版をダウンロードしてください。
うむ、調べたら面白かったです。 https://social.msdn.microsoft.com/Forums/windows/ja-JP/ed6960a6-414...
うむ、調べたら面白かったです。 https://social.msdn.microsoft.com/Forums/windows/ja-JP/ed6960a6-414...
加工指図書を閉じる時にどうしているかじゃないか？ そこは提示されてないけど .Close False としないと .Close だと上書き保存されるのかも
Sub あああ() Dim S As Worksheet For Each S In Worksheets S.Cells.Copy S.Cells.Select S.Selection.PasteSpecial (xlPasteValues) Next S End Sub
なんか解り難いロジックですね。 移動位置がずれていくので解り難いのですかね？ 後ろから、1番前に移動していけば解りやすいでしょう。 Sub シート設定() Dim myRange As Range '表を格納する変数 Dim myCell As Range '表を格納する変数 For i = 4 To 1 Step -1 For Each myCell In Range("A1:I1") If Cells(i, 10).Value = myCell.Value Then myCell.EntireColumn.Cut Columns(1).Insert shift:=xlToRight Exit For End If Next Next End Sub
例えば、 j = Range("A1").Cells(Application.Match(i,Range("C1:C80"),0),1).Value エラー回避は適宜工夫してください。
VBAでフィルタで抽出したデータはどうやってコピーします？ たとえば３列２０行の表から３列５行が抽出されたとします。これをコピーしてA25に貼り付けるには Range("A1:C20").Copy Range("A25") またはクリップボードを使わないで Range("A1").CurrentRegion.Copy Destination:=Range("A25") などとしますね。これはどういう意味でしょうか？ HIddenを使って同じようにした表を同じコードでコピーすると全部コピーされてしまいます。 明らかにフィルタとHIddenでは違うことをやっているのがわかると思います。 ちょっと調べてみてもわかりませんでしたがフィルタは抽出結果のアドレスを変換しているのかもしれません。 HIddenの場合は Range("A1:C20").SpecialCells(xlCellTypeVisible).Copy Destination:=Range("A25") の SpecialCells(xlCellTypeVisible)で変換しているのでは？などと妄想してみました。 MSはOFFICEのコードを公開していないらしいので調べるのは大変かもしれません。また記事も少ないと思います。
管理用のシートを追加して、ボタンに以下の処理を追加してみてはどうでしょうか。 Private Sub CommandButton1_Click() With ActiveSheet '番号を取得 no = .Range("B3").Value '番号に一致する行のデータを取得 select_row = Range("B6:B22").Find(no).Row book_path = .Cells(select_row, 3).Value active_sheet = .Cells(select_row, 4).Value '対象のブックを開く Workbooks.Open book_path '対象のシートをアクティブ化 ActiveWorkbook.Sheets(active_sheet).Activate End With End Sub
フィルターを 使用するなら フィルターの詳細設定を 利用すれば良い 他者で 利用事業者が 東京のデータを シート２に出すなら 添付の画像を参照下さい。 シート２の１行目には 図では シート１の千項目をコピーしています。 が 必要な項目だけ また並び変えてコピーしておきます。 そして Ｋ１：Ｌ１に 条件項目をコピーしておきます。 そして 実際にＫ２に他社 Ｌ２に 東京 と 入力しておきます。 他社 大阪のシートも作成しておきます。 自社 のシートも作成 但し 自社の条件は 自社だけなら K列のみ入力 これからがマクロになるので マクロも記録で 作成すれば できます。 が まず記録せずやってみてください。 東京の場合シート２で A1:H1を選択後 フィルターの詳細設定をクリック 画面の オプション設定画面がでてきます。 抽出先を 指定した範囲に チェックを入れ リスト範囲を Ｓheet1!A:H と 列のみ指定（実際SHEET1に移り選択すれば可） 検索条件を K1:L2 と 入力 抽出範囲を 最初にコピーされた必要な項目 全部ならA1:H10 と入力します。 行数が足りなくなると 追加するかどうか聞いてくるので 行数は 適当で可 これで ＯＫを おせば 他社で 東京だけのデーターがコピーされます。 この詳細設定を 押して OKを 押すまでをマクロとしてください。 一つだけなら マクロも必要ないですが 部署が多いので 一連のマクロにするか 地区ごとにマクロをつくるか 自由です。 ただ 最初だけ リスト含むなどの警告がでますが かまわずＯＫで 可です。
ワークシートの名前が、全件になっていないと、 Set ws = ThisWorkbook.Worksheets("全件") ここで出ますよ。
Excel vbaはExcelが起動していなければ動きません。Windowsのタスクスケジューラでその時刻にマクロ付きのExcelブックを起動させることができるのでworkbook_openイベントを記述すれば自動実行になります。
全て、バラバラに覚えてください。いま、ムリに連結すると混乱して嫌になると思います。 では、私の順番で説明します。 メソッドとは、命令文です。 IF文とか、While文とかです。 関数とは、ある機能の塊です。 ExcelでSUM関数とかありますが、あれは実際は指定されたセルを足し算する機能がある関数となります。 さきに述べたメソッドとの違いは、プログラムやソフトによって名前が違うだけ。と今は思って下さい。VBAのIF文(メソッド)とEXCEL関数のIF関数のように明らかに同じものもありますが、関数と呼ぶ単位は何か？を自分で作って感じないと理解できないと思います。 変数とは、プログラムにおけるデータを扱う箱の事です。 データ型と一緒に話が出てくるのは、この為です。 定数とは、定数、定められてた、定めた値です。 プログラム上、固定しておきたい値です。 Dim lngA as long で変数lngAを宣言しました。 これで、longのルールに基づく値を格納する箱が生まれました。 static SyouhiZei as long = 1.08 これで、slngAと言う名前の100の値をプログラム上で使えるようになりました。 この違いは、lngAには、longのルールに従う限り、好きな値を格納できますが、SyouhiZeiには値を格納する事は出来ないと言うことです。正確には、SyouhiZeiは箱でさえないです。lng型の100と言う値にslngAと言う別名を付けたのです。宣言には、見えない言葉も隠れる事や省略記述しか許さないソフトがあります。 Dim lngA as long は、 本当は、 Dim lngA as new long と現代では記載されるべき内容です。 この事は、後で述べるオブジェクト(オブジェクト思考)に基づくものです。 さて、なぜ定数なんて必要かと言うと、例えばSyouhiZei=1.08のような値を毎回1.08と記載すると、全ての処理を将来は1.10に書き換える必要がありますが、定数化すると、宣言した所だけ1.10に書き換えれば、別名(1.08と宣言したSyouhizei)を記載した箇所全てを書きかえた事になるからです。 定数とは、別名をつけることなのです。事実、コンパイル時に全ての定数は1.08に書き換えられます。これが定数です。 引数の説明はしません。 これは、名前だけです。呼び方です。覚えてください。関数に渡すのが引数です。 ステートメント、これも覚えてください。メソッドに対して、指定や追加命令などのオプションを施す際に、引数のように書くのです。 オプションも、そのまま覚えてください。付加。付け加える。必要な情報または追加情報の指定です。 optional は、指定したらその値を使用し、未指定なら事前に決めたデフォルト値が使用されるだけで、実際には関数などに渡す際は、こちらが各手間を省いているだけです。オプション値は、こちらが指定しなければ、勝手に裏で記載されています。見えていないだけです。 引数の値渡し、参照渡しに関しては、今回は省きます。 オブジェクトは、関数やクラスのくくりです。関数もオブジェクトです。クラスもオブジェクトです。つまり、枠です。 宣言をして、初めて実体(箱)を持ちます。具体的には、オブジェクトとは設計書です。 設計書だけでは、何も出来ません。それを元に作ったのが宣言をした変数です。 ミカンの箱の設計書を元に、 ミカンの箱(実体)を作る(宣言する)のです。 設計書には、ミカン(値)は入りませんが、箱(実体)には入りますよね。 この実体を別名でインスタンスと呼びます。 なので、宣言をインスタンス化と呼ぶ書物もあります。 値が入るものは、全てインスタンス化しないと無理です。 紙の上に、スープは注げません。 そんな処です。 勘違いしないで頂きたいのは、入れるとは、A=X のように書くときだけとは、限りません。 関数でも引数には実体が必要です。 メソッドには事前に用意されているだけです。用意済みの箱をメソッドは持っています。 ちなみに、箱、箱と書きましたが、物理的な話をすると、例えば、lngAの場合は、long型、つまり64bitを、物理メモリに確保する事を指します。ここは、lngAの領域だと、CPUに伝えて確保するのです。 まあ、こんな説明が限界かなぁ。
sheriedolceさん、こんにちは。 まずはF8で逐次実行させて、どこの行でエラーがでるか、確認してみましょう。 （On Error は一旦無効にして。） たぶん怪しいのは、クエリテーブル削除の行でしょう。 ws.Names("CsvData").Delete でなくて、 ws.QueryTables("CsvData").Delete とすべきかと思います。 （元の書き方では、シートのセル範囲に付けられた名前を削除する命令になると思います。） ご確認くださいマセ。
どの程度をエクセルを使いこなせていますか。 1クリックで、というのはマクロを作成する事になります。 一般的な考え方ですが、固定情報である「マスター」と日々の来院という、固定でないデータ「トランザクション」を別に管理するのが基本です。 まず顧客マスターを1つのシートに登録します。これが >また、No.に対し氏名、年齢、住所、電話番号など、 >パーソナルデータを登録させることは可能ですか？ の回答になります。可能か、ではなく登録をして下さい。これは手作業です。 日々のデータは日付、顧客、担当者などその時の情報をどんどん入力していきます。 このデータがあれば、色々な集計はエクセルの機能を使ったり関数で出来ます。 最終形だけがイメージにあって、ワンクリックで、と考えてしまうと、融通のきかないものになってしまいます。 まずは基本に沿ってデータを作成する事が大切です。 機能や関数を使いこなせたら、そのあとでマクロの処理を勉強させるといいと思います。
元々のアプリが最大化/最小化に対応していない（ウインドウサイズ固定）なのではないですか？
situmontarou777 さん、こんばんは。 画像が小さくて質問内容がうまく読み取れないですが、本文と合わせて推定で回答してみます。 元となるデータはSheet1にあって、A列＝入庫日、B列＝入庫時間、C列＝商品名、D列＝入庫数、E列＝梱包員数、F列＝入庫箱数、となっており、２行目がタイトル行で、３行目以下がデータ列であるとします。 E列は１箱に入る商品数の最大値とします。 Sheet2に展開した後のデータを書き込みます。表のフォーマットはSheet1と同じで、データセルは空白であるとします。 下のコードを標準モジュールにコピペして実行してみてください。 ------------------------------------------ Sub 入庫展開() Dim i As Long, j As Long, lp As Long Dim vData(1 To 1000, 1 To 6) Dim inQty As Integer, inEnv As Integer, inBuf As Integer With Worksheets("Sheet1").Range("A3") '▼展開元セル指定 i = 1 j = 0 Do While .Cells(i, 1).Value <> "" inQty = CInt(.Cells(i, 4).Value): inBuf = inQty inEnv = CInt(.Cells(i, 5).Value) Do While inBuf > 0 j = j + 1 vData(j, 1) = .Cells(i, 1).Value vData(j, 2) = .Cells(i, 2).Value vData(j, 3) = .Cells(i, 3).Value vData(j, 4) = inQty vData(j, 5) = -(inBuf > inEnv) * inEnv - (inBuf <= inEnv) * inBuf vData(j, 6) = 1 inBuf = inBuf - inEnv Loop i = i + 1 Loop End With Worksheets("Sheet2").Range("A3").Resize(j, 6).Value = vData '▲展開先セル指定 End Sub ------------------------------------------ シート構成、フォーマットが違う場合は、コメントに ▼ ▲ が書いてある行のWorksheets指定とRange指定を修正してもらえばよいです。 また、扱えるデータのサイズは、展開後で1000行までにしています。1000行を超える場合は、Dim ｖData の引数を適宜変更してください。 まずはお試しください。
wantatta01533 さん、こんばんは。 書かれた説明文だけではやりたいことを理解するのが難しいですが、下記のように適当に推定してコードを書いてみました。 データはSheet1 シートにあり、A列がグループ番号、B列がなんらかの数値、C列がグループ番号毎の数値の合計値が書き込まれているとします。 １行目はタイトル行として、２行目からデータが記入されている、とします。 A列にあるグループ番号を検索キーとして、A列を検索列、B列を合計列としてSUMIFを取り、その値がC列の値と一致するかどうかを比較します。比較結果をD列に 一致/不一致 で書き込みます。 下記コードを標準モジュールにコピペしてお試しください。 ----------------------------- Sub グループカウント() Dim rg As Range Dim comp With Worksheets("Sheet1") '処理シート指定 Set rg = .Range("A2") '処理開始グループ番号セル指定 Do While Not (IsEmpty(rg)) comp = WorksheetFunction.SumIf(.Range("A:A"), rg.Value, .Range("B:B")) If rg.Offset(, 2).Value <> comp Then rg.Offset(, 3).Value = "不一致" Else rg.Offset(, 3).Value = "一致" End If Set rg = rg.Offset(1) Loop End With Set rg = Nothing End Sub -----------------------------
試しに手元で動かしてみたけどエラーにならないな。 どこでエラー吐いてるか教えてもらえる？ 原因不明でもとりあえず回避したいだけなら、 On Errorを使うといいよ http://officetanaka.net/excel/vba/statement/OnError.htm
これだけなら マクロなんか作らないで 一覧表と SUMIF関数で簡単にできるのでは マクロの方が 関数より優れているわけではないですよ。 マクロは あくまで 繰り返し作業の 手抜き で なにかトリガーが必要 関数は 瞬時に 計算してくれます。 マクロの勉強ということなら マクロの手順を 繰り返すことです。 一つ一つ作業を 行って見ることです。 まず店舗名ごと これは 店舗名が 違っても 同じシート 別シート その抜き出し方は わかってますか? 次に同じ店舗で 商品別のデーター行の抽出の方法は? このように 作成する手順を 一つ一つ分解して命令語に 変えていくのが マクロです。関数のようにいきなり 結果を表示できるものでは ありません。 マクロを勉強しようとするなら この手順を 一つ一つ覚えていく必要が有ります。 やり方は 人によって いろいろになってきます。 その一つ一つの作業のどこがわからないという質問なら 回答できます。
ブックを定義した方がいいと思います。 Dim wb As Workbook と定義して Workbooks.Open file を Set wb = Workbooks.Open(File) と書きます。 こうしておけば wb.Close False で選択したブックが閉じます。
こんにちは。 全てのエクセルを表示②に近いコードです。 開かれているBooKを全て表示モードに しています。 Option Explicit Sub Sample1() Dim Wb As Workbook For Each Wb In Workbooks Wb.Activate ActiveWindow.Visible = True Next Wb End Sub
shell関数はプログラムを実行するものなので、パスだけ指定しても何も起こりません。実行するプログラムがないというエラーになるだけです。 先に回答なさっているかたで "explorer " を書けば良いと書いていらっしゃるのでそれで良いと思いますが念のため、explorer.exe まで書けば確実と思います。 それと質問文の"￥受注データ" の円マークが大文字になっているので もとのVBAは小文字になっているかもご確認くださいね。 Shell "explorer.exe " & ActiveWorkbook.Path & "\受注データ", vbNormalFocus
雰囲気以下でどうなりますか > 図が一つのシートに8個入っています。 > （1月～7月） シート内に ・どのように配置されている･･･？ ・８個の表が 1月～7月 と、どう対応付けされている･･･？ わからないので、 ・シート内を "合計" で検索し、 ・セル結合されている "合計" の場合、 その表の、最終列、最終行１つ前のセル値を入手します 以下を、新規ファイルの標準モジュールに転記し、Samp1 を実行すると、 ファイル選択になり、 選択したファイルを対象に拾い集めて、 アクティブシートをきれいにした後、 ２行目から、拾い集めた順に出力します 結果良ければ、１行目に 何月 を設定してください また、必要に応じて並び替えてください Option Explicit Public Sub Samp1()    Dim dic As Object, dicW As Object, oFso As Object    Dim ws As Worksheet    Dim vFile As Variant, vK As Variant, v As Variant, vA As Variant    Dim sS As String    Dim i As Long, j As Long    With Application.FileDialog(msoFileDialogOpen)       .AllowMultiSelect = True       .FilterIndex = 2       If (Not .Show) Then Exit Sub       Set dic = CreateObject("Scripting.Dictionary")       Set oFso = CreateObject("Scripting.FileSystemObject")       Application.ScreenUpdating = False       For Each vFile In .SelectedItems          sS = oFso.GetBaseName(vFile)          dic.Add sS, CreateObject("Scripting.Dictionary")          With Workbooks.Open(vFile, ReadOnly:=True)             For Each ws In .Worksheets                Set dicW = CreateObject("Scripting.Dictionary")                Call DicMk(ws, dicW)                If (dicW.Count > 0) Then                   dic(sS).Add ws.Name, dicW                End If             Next             .Close False          End With       Next    End With    Cells.Delete    i = 2    For Each vK In dic.Keys       For Each v In dic(vK).Keys          Cells(i, "A").Value = v          j = Cells(i, "B").Column          For Each vA In dic(vK)(v).Items             Cells(i, j).Value = vA(2)             j = j + 1          Next          i = i + 1       Next    Next    Application.ScreenUpdating = True    Set dic = Nothing    Set dicW = Nothing    Set oFso = Nothing End Sub Private Sub DicMk(ws As Worksheet, dicW As Object)    Dim rng As Range    Dim sAdr As String    Dim i As Long, j As Long, k As Long    Const CMOJI As String = "合計"    Set rng = ws.Cells.Find(CMOJI, LookAt:=xlWhole)    If (Not rng Is Nothing) Then       sAdr = rng.Address       Do          If (rng.MergeArea.Cells.Count > 1) Then             With rng.CurrentRegion                i = .Rows.Count - 1                j = .Columns.Count                k = dicW.Count + 1                With .Cells(i, j)                   dicW(k) = Array(.Row, .Column, .Value)                End With             End With          End If          Set rng = ws.Cells.FindNext(rng)          If (rng Is Nothing) Then Exit Do       Loop While (rng.Address <> sAdr)    End If End Sub
iが最後まで回す。 Private Sub CommandButton1_Click() Dim i As Long i = 1 On Error Resume Next Do With ActiveSheet.QueryTables.Add(Connection:= _ "URL;http://info.finance.xxxxx.co.jp/ranking/?kd=31&tm=d&vl=a&mk=3&p=" & i, _ Destination:=IIf(Range("b3").Value = "", Range("b3"), Range("b" & Cells.Rows.Count).End(xlUp).Offset(1, 0))) .Name = "?kd=31&tm=d&vl=a&mk=3&p=1" .FieldNames = True .RowNumbers = False .FillAdjacentFormulas = False .PreserveFormatting = True .RefreshOnFileOpen = False .BackgroundQuery = True .RefreshStyle = xlInsertDeleteCells .SavePassword = False .SaveData = True .AdjustColumnWidth = True .RefreshPeriod = 0 .WebSelectionType = xlAllTables .WebFormatting = xlWebFormattingNone .WebPreFormattedTextToColumns = True .WebConsecutiveDelimitersAsOne = True .WebSingleBlockTextImport = False .WebDisableDateRecognition = False .WebDisableRedirections = False .Refresh BackgroundQuery:=False End With If Err.Number <> 0 Then Exit Do i = i + 1 Loop On Error GoTo 0 End Sub
こんにちは。 出来る気がしないです ブラウザーのセキュリティ画面の扱いが、スクリプトレベルで出来る気がしません。winAPIが必要だったり、何も見ないでキーコードの送信も、信用ないです 最近では、「クラウド環境」を利用し、クライアント空間に、保存すると、バックグラウンドで、サーバーのファイルを差し替える、という方法があります。 そっちのほうが、現実味はあります。 IE画面でデータをアップさせる、しかし手動ではなく、スクリプトで自動、というのでしたら、自動でデータを集める仕組みをクラウドで考えてみてはどうでしょうか。
TextBox6には何を入力するのですか？（たぶん原価かと思いますが） 一応、上記コードで、 TextBox5 = 100 TextBox6 = 50 と入力した場合、 TextBox7 ＝ 50 TextBox8 ＝ 50.00 となったので、問題ないと思いますが。 val(TextBox7) / val(TextBox5) * 100 で、粗利率○○％という感じで出しているんですよね？ （粗利率＝（売価－原価）/売価で計算でいいんですよね？）
現段階で分からない点が複数あっても、ひとつずつ問題点をクリアしていってください。 １スレに多数質問だと「業者に頼みなさい」という回答が返って来るだけです。 とりあえず、質問回答より先にDBの仕様について逆に質問です。 (１) 1つの大会で複数競技にエントリーしている人がいたらどうしますか？ (２) 年度は現状ではIDが１から新しい年度になっていますが、次回(未来)開催する大会に不都合は出ませんか？ (３) VBAで記述されたSQL文を拝見すると「名簿テーブル」にセットされる大会に関するデータが『名称』になっていますが、あとから名称が変わってしまった(間違っていた・入力ミス)場合はどうしますか？ まずは↓こんなテーブル形態(各ID同士でリレーション)にして再考されたらいかがですか。 「名簿テーブル」 名簿ID : pk 氏名 性別 「参加テーブル」 名簿ID 大会ID 種目ID 賞ID 「大会テーブル」 大会ID : pk 年度 (検索用) 開催日 (開催順ソート用) 大会名 「種目テーブル」 種目ID : pk 種目名 「賞テーブル」 賞ID : pk 賞名
テキストボックスは「MultiLine」プロパティをTrueにすれば複数行の入力が可能になりますよ？
jdljnhdjmebjxjdさん、こんばんは。 22:34:09 の返信を読んで考えると、アクティブセルを含んで右側６個の中に、Cells(x,y)で指定するセルが含まれる場合に、指定する処理をしたい、ということかと理解しました。 お書きのコード意図に従ってIf文を作るなら If ActiveCell.Address = Cells(x,y).Address Then という感じのコードにすればよいかと思います。 あと、If文処理の中にExit For を入れておけば、余分なループを回さずに済みます。 また、ループを回さずにチェックする方法として、 If Not (Intersect(Activecell.Resize(1,6) , Cells(x,y)) Is Nothing) Then とすれば、アクティブセルを左端とする１行６列のセル範囲の中に、Cells(x,y)が含まれる場合を判断させることができます。
以下でどうなりますか E1 ～ の表は事前に作ってあって、その中での結果を埋める････ この辺の処理は、私の中でパターン化しているので、前質問 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1116242487... ここから大きく変わってません 変わっている部分は、 ・春夏･･･ E1 ～の表から入手 ・E2 ～ の集計範囲を事前に求め、一致するものだけを集計するように 今回、Dictionary dic の２段構成は変わりませんが １段目キー：書き出し行番号 ２段目キー：書き出し列番号 もし、E2 ～ は A 列に出現した全部を調査した結果作るのであれば、 Samp1 での >   vC = Array("とてもよい", "よい", "ふつう", "わるい") ↓    vC = Array("AA", "BB", "BC") にして、記号化部分を今回のに変更し 書き出し部分を変更すれば････ パターンを共有できれば、可読性云々関係なくなる様な･･･ Public Sub Samp2()    Dim dic As Object, dicE As Object, dicP As Object    Dim vA As Variant, vE As Variant, v As Variant    Dim vS As Variant, vC As Variant, vK As Variant    Dim sS As String    Dim i As Long, j As Long, k As Long, n As Long    vC = Array("AA", "BB", "BC")    Set dic = CreateObject("Scripting.Dictionary")    Set dicE = CreateObject("Scripting.Dictionary")    Set dicP = CreateObject("Scripting.Dictionary")    With Range("E1").CurrentRegion       vS = .Value       For i = 2 To UBound(vS)          dicP(vS(i, 1)) = i       Next       For j = 2 To UBound(vS, 2)          dicE(vS(1, j)) = j       Next       vA = Range("A1").CurrentRegion.Resize(, 3).Value       For n = 1 To UBound(vA)          If (dicP.Exists(vA(n, 1)) And dicE.Exists(vA(n, 2))) Then             i = dicP(vA(n, 1))             j = dicE(vA(n, 2))             For k = 0 To UBound(vC)                If (vA(n, 3) = vC(k)) Then Exit For             Next             k = k + 1             If (Not dic.Exists(i)) Then                dic.Add i, CreateObject("Scripting.Dictionary")             End If             v = dic(i)(j)             If (Not IsArray(v)) Then                ReDim v(UBound(vC) + 2)                v(0) = 1                v(k) = 1             Else                v(0) = v(0) + 1                v(k) = v(k) + 1             End If             dic(i)(j) = v          End If       Next       For Each vK In dicP.Keys          i = dicP(vK)          If (dic.Exists(i)) Then             For Each vE In dicE.Keys                j = dicE(vE)                sS = "-"                v = dic(i)(j)                If (IsArray(v)) Then                   If (v(1) > 0) Then                      sS = "○"                   ElseIf ((v(2) > 0) Or (v(3) > 0)) Then                      sS = "△"                   Else                      sS = "◎"                   End If                End If                vS(i, j) = sS             Next          Else             sS = "-"             For Each vE In dicE.Keys                j = dicE(vE)                vS(i, j) = sS             Next          End If       Next       .Value = vS    End With    Set dic = Nothing    Set dicE = Nothing    Set dicP = Nothing End Sub
ThisWorkbook.Worksheets(i).Range("o3:s8").Value ↓ ThisWorkbook.Worksheets(CStr(i)).Range("o3:s8").Value 文字列に変換して使いましょう。 いまのままでは、「左から i 番目のシート」という意味になりますよね。
Sub a() Set sh1 = Sheets("Sheet1") Set sh2 = Sheets("Sheet2") 'Sheet1の最終行を取得 sh1_rows = sh1.Cells(Rows.Count, 1).End(xlUp).Row 'Sheet1の最終行までループ For i = 1 To sh1_rows 'Sheet2の最終行を取得 sh2_rows = sh2.Cells(Rows.Count, 1).End(xlUp).Row 'Sheet2に存在したかどうかのフラグ flag = False 'Sheet2の最終行までループ For j = 1 To sh2_rows '同じ名称があった場合 If sh1.Cells(i, 1).Value = sh2.Cells(j, 1).Value Then 'B列の値を設定 sh2.Cells(j, 2).Value = sh1.Cells(i, 2).Value '存在したフラグをTrue flag = True End If Next '存在しなかった場合は、Sheet2の最終行に追加 If flag = False Then sh2.Cells(sh2_rows + 1, 1).Value = sh1.Cells(i, 1).Value sh2.Cells(sh2_rows + 1, 2).Value = sh1.Cells(i, 2).Value End If Next End Sub
コードを全部書いて下さい。 txtGetPath.Value とは？ >WPS Spreadsheets原因でしょうか？ それ以前にこのままではエラーです。 開きたいのはエクセルファイルではないという事ですか？ そうなら、当方はエクセルファイルの処理しかわかりませんが。
Dim ProcessStartInfo1 As New ProcessStartInfo() ProcessStartInfo1.FileName = "C:\Program Files\Internet Explorer\iexplore.exe" ProcessStartInfo1.Arguments = "http://www.yahoo.co.jp" Process.Start(ProcessStartInfo1) とすればIEでYahoo!を開くことができますが？ 開いたIEページに対してなんらかのアクションがしたいのであれば Dim objIE As Object objIE = CreateObject("InternetExplorer.Application") objIE.Visible = True objIE.navigate("http://www.yahoo.co.jp") としたあとでobjIEのメソッドを利用します。 IEオブジェクトで用意されているプロパティ・メソッドについては http://www.vba-ie.net/ieobject/index.html を参考にしてください。
質問① コードの一部分だけを抜き出しても他に部分に原因がある場合もありますので、できれば全体を提示するようにしましょう。 とりあえず提示されている部分だけで、回答しますと。 最初の If の部分は、「大会」フィールドに対してBETWEEN条件、 次の Else If 以降は「賞」フィールドに対して条件を設定していますが、 矛盾してませんか。 まずは、どのフィールドに対して、どのような条件を設定したいのかを明確に説明してください。 あと、「大会」「賞」の各フィールドのデータ型も明示してください。 質問② Null と "" は別物ですので違いをしっかり意識しましょう。 質問①では IsNull で判断していますので、"" を代入したのではIsNullでは判定できません。Nullを代入しましょう。 txtID.Value = Null ～～～～～～～～～～～～～（”～”は省略部分） Me.コンボ1.Value = Null Me.コンボ2.Value = Null
\の位置と *.xisx がおかしいと思います。 fl_name = Dir("C:￥GetPath\" & "*.xlsx") とすれば、ファイルが取得できます。
上のコードだと contorol("checkbox"&１).caption =worksheets("リスト") .cells(4,3).value ・ ・ contorol("checkbox"&１).caption =worksheets("リスト") .cells(28,3).value のあとに contorol("checkbox"&２).caption =worksheets("リスト") .cells(4,3).value ・ ・ contorol("checkbox"&２).caption =worksheets("リスト") .cells(28,3).value となります。 すべてのcheckboxがcells(28,3).value になってるんじゃないでしょうか。 2重のループの場合、中のループが全部終わった後に外のループがnextされるので iとjを同時に動かしたい場合は contorol("checkbox"& i).caption =worksheets("リスト") .cells(i+3,3).value とするか 中のループを外して j=j+1を追加するかですね。
"'[" & ThisWorkbook.Name & "]Sheet1'!R24C31:R130C32" でどうでしょう ThisWorkbook ： マクロが登録されているブック
アラートを出なくするだけであれば Range(.Offset(1, 0), ActiveCell.Offset(3, 5)).Merge を Application.DisplayAlerts = False Range(.Offset(1, 0), ActiveCell.Offset(3, 5)).Merge Application.DisplayAlerts = True とすればよいのですが、 添付画像の状態でコードを実行して意図する結果が得られているとは思えないのですが・・・ ActiveCellがC6であれば zp = .Offset(1, 1).Value は zp = Range("D7").Value と同じですが正しいですか？ adr = .Offset(2, 1).Value は adr = Range("D8").Value と同じですが正しいですか？ .Offset(3, 0).Value = zp & vbLf & adr & vbLf & nm & "さま" は Range("C９").Value = zp & vbLf & adr & vbLf & nm & "さま" と同じが正しいですか？ Range(.Offset(1, 0), ActiveCell.Offset(3, 5)).Merge は Range("C7:H9").Merge と同じですが正しいですか？ ActiveCell.Offset(1).Resize(3).EntireRow.Delete は Rows("7:9").Delete と同じですが正しいですか？ もう一度、初期状態でのデータの設定内容と、 最終的にどのセルにどのようなデータを設定したいのかを きちんと確認したほうがいいかと思います。
同性同名の場合、漢字が違えば、問題有りませんが、全く同じ場合、 判別は不可能です。 この場合、別人にするための記号などを名前に付加する必要があります。 しかし名前をいじるのはまずいので、もう１列、判別用の名前を 作成すれば解決します。 こんなイメージです。 伊藤和夫＿A＿伊藤和夫A 山田俊樹＿ ＿山田俊樹 伊藤和夫＿B＿伊藤和夫B 手入力になりますが、こんな方法しかないでしょう。 回答は、２種類用意しました。 Sheet2では、記号付きの名前を入力し、 １行目の項目をSheet1と同じ項目名を入力すれば、好きな項目を 選べます。 順番も必要ありません。 回答です レイアウト例は画像参照 ＜Sheet1＞ A2:=C2&B2 下方へドラグコピーします。 ＜Sheet2＞ B2:=IFERROR(OFFSET(Sheet1!$A$1,MATCH($A2,Sheet1!$A:$A,0)-1,MATCH(B$1,Sheet1!$1:$1,0)-1),"") 右方と下方へドラグコピーします。 別式 B2:=IFERROR(INDIRECT("Sheet1!"&ADDRESS(MATCH($A2,Sheet1!$A:$A,0),MATCH(B$1,Sheet1!$1:$1,0))),"") 右方と下方へドラグコピーします。
こんなトラブルが出るくらいですから、 できることならフォーム名を変えたほうがいいですね。 Forms![F-フォーム名].Requery
Sub test() Dim i As Long, j As Long, k As Long Dim sh2 As Worksheet j = 2 Set sh2 = Sheets("Sheet2") With Sheets("Sheet1") For i = 2 To .Cells(Rows.Count, 1).End(xlUp).Row For k = 1 To (.Cells(i, Columns.Count).End(xlToLeft).Column - 3) / 2 sh2.Cells(j, 1).Resize(, 3) = .Cells(i, 1).Resize(, 3).Value sh2.Cells(j, 4).Resize(, 2) = .Cells(i, 2 * k + 2).Resize(, 2).Value sh2.Cells(j, 4).NumberFormatLocal = "yyyy/m/d" sh2.Cells(i, 5).NumberFormatLocal = "#,##0" j = j + 1 Next k Next i End With sh2.Cells(1, 1).Resize(, 5) = Array("県名", "食品", "注番", "納期", "数量") End Sub
Forms!売上伝票!名前 = Me!名前 にブレークポイントを設定して Me!名前 の変数内容をチェックしてみて下さい。 多分見れないと思います。 Me.名前 なら見れると思います。
× Sheets(Range("A2").Name).select（セルに入力） ○ Sheets(Range("A2").Value).select
データ>外部データの取り込み>テキストファイル の操作をマクロ記録に録って、手を加えてみました。 C:\AAA\Test\Test.txt が取り込み対象ファイルです。 Sub sample() Const xFile As String = "C:\AAA\cx\Test.txt" ActiveWorkbook.Worksheets.Add With ActiveSheet.QueryTables.Add(Connection:="TEXT;" & xFile, _ Destination:=Range("$A$1")) .FillAdjacentFormulas = False .SaveData = True .AdjustColumnWidth = True .TextFilePromptOnRefresh = False .TextFileParseType = xlDelimited .TextFileTextQualifier = xlTextQualifierDoubleQuote .TextFileConsecutiveDelimiter = True .TextFileSpaceDelimiter = True .TextFileTrailingMinusNumbers = True .Refresh BackgroundQuery:=False End With End Sub
Worksheet_calculateは再計算された時に発生するイベントマクロで どのセルが再計算の対象かは分かりません その為、引数(Target)がないので｢オブジェクトが必要です」のエラーになります 再計算のトリガーとなるセルを対象として Worksheet_Changeを使用すると出来ないかな?
http://excel-ubara.com/excelvba4/EXCEL245.html を使えばできるのではないでしょうか。 わたしは、やったことがありませんし、今後も作る予定はないので、ぐたいてきなものはつくれませんが。
VBA です。 以下の形で如何でしょうか。 Sheet1 のマクロに記述してください。 -- ' マスターシート名 Const MASTER_SHEET_NAME As String = "Sheet2" ' マスターシート User Name 列 Const USER_NAME_COLUMN As Integer = 1 ' マスターシート Sample Name 列 Const SAMPLE_NAME_COLUMN As Integer = 2 ' Sample Name リスト行 Const SAMPLE_NAME_LIST_ROW As Integer = 8 ' Sample Name リスト列 Const SAMPLE_NAME_LIST_COLUMN As Integer = 3 ' セルの値が変更された場合に実行 Private Sub Worksheet_Change(ByVal Target As Range) ' セルの複数選択時は処理しない If Target.Cells.Count <> 1 Then Exit Sub ' User Name（1行目C列）が変更された場合に実行 If Target.Row = 1 And Target.Column = 3 Then ' Sample Name のリスト Dim sample_name_list As String sample_name_list = "" ' リストを作成 Dim i As Integer: i = 2 ' 開始行 With Worksheets(MASTER_SHEET_NAME) Do Until .Cells(i, USER_NAME_COLUMN) = "" If .Cells(i, USER_NAME_COLUMN) = Target.Value Then sample_name_list = sample_name_list + _ .Cells(i, SAMPLE_NAME_COLUMN).Value & " ," End If i = i + 1 Loop End With ' Sample Name リストボックスにリストを設定 Dim snl_cell As Range Set snl_cell = Cells(SAMPLE_NAME_LIST_ROW, SAMPLE_NAME_LIST_COLUMN) snl_cell.ClearContents If sample_name_list = "" Then Exit Sub ' リストが空 snl_cell.Validation.Delete snl_cell.Validation.Add Type:=xlValidateList, _ Formula1:=sample_name_list End If End Sub
添付図が小さくてよく内容が見えないので、考え方、計算の仕方を推定で回答します。 複数の商品が貸し出され、返却された一覧表があり、それをガントチャートにする、 という解釈です。 D9:AH11を選択して条件付き書式、新しいルール、数式を使用して書式設定するセルを決定、 書式、塗りつぶしを設定して数式を =SUM((D$4>=$D$16:$D$23)*(D$4<=$E$16:$E$23)*($A9=$C$16:$C$23)) として、OKを押します。
実戦では１６７行あれば１６７行計算するようなことはないと思うのですが。 よほど配列数式のような重い処理をする以外では１６７行でも２００行とか３００行とかをコピーしておくのではないでしょうか ？ ただしD２にはIF(A2="","",B2*C2）のような数式にすると思います。 Sub Macro2() ' ' Macro2 Macro ' Range("D2").Select Selection.AutoFill Destination:=Range("D2:D300") Range("D2:D300").Select Range("A1").Select End Sub マクロの記録はやたらSelectするのでそれを省略すると Sub Macro2() Range("D2").AutoFill Destination:=Range("D2:D300") End Sub でもいいですね。 最終行（セル）の取得はマクロの記録ではできないことです。A列の最終行は Cells(Rows.Count,1).End(xlUp) で求められるのでその行数を変数に入れます。 n=Cells(Rows.Count,1).End(xlUp).ROW とすると１６７行まである表ならnに１６７が入ります。 Sub Macro2() n=Cells(Rows.Count,1).End(xlUp).ROW Range("D2").AutoFill Destination:=Range("D2:D" & n) End Sub とすればきっちり最終行までコピーします。
ここでどうでしょう。 https://support.office.com/ja-jp/article/%E5%88%86%E6%9E%90%E3%83%8...
1行ずつ削除するなら、下から。 上からだと、行削除することによって、行番号を表す変数の値が、実際の行と違ってきますよね？ あと、なぜ２つのループが必要なんですか？ Sub n() Dim i As Long Dim ss As Variant, s As Variant ss = Array("S1", "S2", "S3") For i = Cells(Rows.Count, 1).End(xlUp).Row To 2 Step -1 For Each s In ss If InStr(Cells(i, 1).Value, s) <> 0 Then Rows(i).Delete Exit For End If Next s Next i End Sub
一般的に最終行を求める場合、下記のように書きます。 Dim MaxRow As Long MaxRow = Worksheets("Sheet1").Range("A" & Rows.Count).End(xlUp).Row このコードはSheet1のＡ列の最終行を求める場合です。
VSTOでExcelを利用して作られてはどうでしょうか? Excel上でワークシートを編集して、最終的には画面のキャプチャを画像として保存するようなイメージ。 「Office の開発」 https://msdn.microsoft.com/ja-jp/library/fp161347.aspx 「画面をキャプチャする」 http://dobon.net/vb/dotnet/graphics/screencapture.html
VBAの場合です。 Sheet1の1行目をSheet2の1行目にコピーします。 Sub sample() Dim ws1 As Worksheet Dim ws2 As Worksheet Dim lastColumn As Integer Dim c As Integer ' Set ws1 = Sheets("Sheet1") Set ws2 = Sheets("Sheet2") lastColumn = ws1.Cells(1, Columns.Count).End(xlToLeft).Column For c = 1 To lastColumn ws2.Cells(1, c * 2 - 1).Value = ws1.Cells(1, c).Value Next End Sub
横1、縦を空白で出したいです。以下コードです。 縦を空白というのは マクロでも 手動でも無理だとおもいます。 貴方の目的が 縦のページ数が 変動で 指定できないという事で 空白にするという事なら 空白ではなく 縦の数値を 予測の倍や１０倍の数値でも 指定しておけば 横幅に合わせて 縮小され 縦のページ数は 必要ページ数のみ印刷されます。
年ブックが"C:\sample\年.xls"で、月フォルダが"C:\sample\月\"の場合で、VBAは別のブックにある場合です。 Sub sample() Dim folder As String Dim wbNen As Workbook Dim wb As Workbook Dim f As String Dim y As String Dim m As String Dim d As String Dim s As String ' Application.ScreenUpdating = False 'ちらつき防止(必要なら) folder = "C:\sample\月\" '月フォルダ(最後に\) Set wbNen = Workbooks.Open("C:\sample\年.xls") '年ブック f = Dir(folder & "D*.xls") 'フォルダ内の、最初が"D"で始まる.xlsファイル名(日報) Do While f <> "" 'ファイルがある間 y = Mid(f, 2, 4) '年の部分(yyyy) m = Mid(f, 6, 2) '月の部分(mm) d = Mid(f, 8, 2) '日の部分(dd) s = Format(DateSerial(y, m, d), "yyyy.m月") '年ブックの月シート名(yyyy.m月)(月の部分が必ず2桁でないので変換する) Set wb = Workbooks.Open(folder & f) '日報を開く wb.Sheets("Sheet3").Range("H12:H35").Copy wbNen.Sheets(s).Cells(3, d + 1) '日報のSheet3のH12:H35を年ブックの対象の月シートの3行目の日+1れつからにコピー wb.Close False '日報を保存せずに閉じる f = Dir '次のファイル名 Loop '繰り返す wbNen.Close True '年ブックを保存して閉じる Application.ScreenUpdating = True 'ちらつき防止解除 End Sub
> OpenFileDialogクラスを使用してできますか? OpenFileDialogクラスはダイアログを表示してファイル名を返すだけです。Streamを使って文書情報を読み書きするコードは自分で書く必要があります。 失礼かもしれませんがy8rj2w9kさん知識レベルではいきなり画像も含めた管理プログラムを組むのは難しいと思います。 まず練習として ①一件の「分類・文書名・文書ファイルのパス」の情報をファイルから読み、編集してファイルに書き出す ②複数の「分類・文書名・文書ファイルのパス」の情報をファイルから読み、編集してファイルに書き出す ③「分類・文書名・文書ファイルのパス」の情報を保持するクラスを作って、その内容をファイルに保存、復元する というように段々レベルを上げていくことをお勧めします。 ③まで出来たら、そのクラスに画像データというプロパティを追加することで画像まで含めた文書管理が出来るようになります。 私は下記のサイトをよく利用しています。 http://dobon.net/vb/dotnet/index.html
Visual Basicの話なら、シリアル通信で調べてシリアルモニター相当品を作り、ARDUINOから受信した内容を"filename.csv"と言うFILEに保存したければそのファイル名でFILEをOPENして保存するだけ、そのようなシリアル通信を解説したHPはいくらでもある。 あとはEXCELのVBAで作れば？こっちの方が簡単かな、 http://homepage2.nifty.com/nonnon/Chinamini/20100001/20100302.html ここみてみなさい
数式自体は間違っていません。 適用先が違うのではありませんか。 ルールの管理のダイアログボックスで、違っていたら書き換えましょう。 （別に「1列ずつ個々に」設定する必要はありません。またそうするなら$マークは冗長と言うものです。）
(vbs) エクセルVBAで "MsgBox xlUp" とすれば "-4162" が返ります。 xlUp はエクセルから実行中、又はエクセル参照設定を行った アクセスVBAやパワポVBAから指定可能です。 そのためVBS や javascript などエクセル外部からエクセルを利用 する場合は xlUp 部分は "-4162" としなければエラーとなります。 ◆参考1 Set xlSh = xlBK.Sheets(1) Msgbox xlSh.Cells(xlSh.Rows.Count, 1).End(-4162).Row ◆参考2 xlUp, xlWhole ⇒ "xl" で始まる場合はエクセルのみで利用可能定数 acNormal, acEntire ⇒ "ac" スタートはアクセスのみ olMailItem ⇒ "ol" スタートはアウトルックのみ vbYellow, vbNarrow ⇒ "vb" スタートはVB系共通 adOpenStatic ⇒ "ad" スタートはVBAからADO外部参照している場合 上記は一例ですが、xlUp ～ adOpenStatic などは VBS からは数値 指定が必要です。
こんにちは。 なぜか、 ヘルプに記載があるからです。 指定されたドライブの準備ができている場合は真 (true) を返します。準備ができてない場合は偽 (false) を返します。 object.IsReady object には、Drive オブジェクトの名前を指定します。 解説 リムーバブル ディスク ドライブおよび CD-ROM ドライブの場合は、ドライブにメディアがセットされており、アクセスできる状態にある場合にだけ真 (true) になります。 次のコードは、IsReady プロパティの使用例です。 [JScript] function ShowDriveInfo(drvpath) { var fso, d, s, t; fso = new ActiveXObject("Scripting.FileSystemObject") d = fso.GetDrive(drvpath) switch (d.DriveType) { case 0:t = "不明"; break; case 1:t = "リムーバブル ディスク"; break; case 2:t = "ハード ディスク"; break; case 3:t = "ネットワーク ドライブ"; break; case 4:t = "CD-ROM"; break; case 5:t = "RAM ディスク"; break; } s = "ドライブ " + d.DriveLetter + ": - " + t; if (d.IsReady) s += "<BR>" + "ドライブの準備ができています。"; else s += "<BR>" + "ドライブの準備ができていません。"; return(s); } [VBScript] Function ShowDriveInfo(drvpath) Dim fso, d, s, t Set fso = CreateObject("Scripting.FileSystemObject") Set d = fso.GetDrive(drvpath) Select Case d.DriveType Case 0: t = "不明" Case 1: t = "リムーバブル ディスク" Case 2: t = "ハード ディスク" Case 3: t = "ネットワーク ドライブ" Case 4: t = "CD-ROM" Case 5: t = "RAM ディスク" End Select s = "Drive " & d.DriveLetter & ": - " & t If d.IsReady Then s = s & "<BR>" & "ドライブの準備ができています。" Else s = s & "<BR>" & "ドライブの準備ができていません。" End If ShowDriveInfo = s End Function 主様、こんなにわかりやすいヘルプですよ、手元に無いのでしたら、 MSのスクリプトセンターとダウンロードのファイルを取得して、じっくり読んでください。 質問が変化するでしょうから、そのときまた。
ExcelのVBAの場合、文字列変数に格納できる文字列は最大約20億文字まで、という制限があります。 ＣＳＶファイルが全部半角文字だとすると2Gバイトです。全角混じりならもっと少なくなります。 itxt = ts.ReadAll でCSVファイルのすべてを一気に文字列変数に読み込んでいるからではないですか？
名前を変更しないものとします。 UserForm1にTextBox11を入れてVisible=Falseにプロパティで設定しておきます。 以下UserForm1 Private Sub CommandButton1_Click() TextBox11.Value = 1 UserForm2.Show End Sub Private Sub CommandButton2_Click() TextBox11.Value = 2 UserForm2.Show End Sub ・ ・ ・ Private Sub CommandButton10_Click() TextBox11.Value = 10 UserForm2.Show End Sub 以下UserForm２ Private Sub ListBox1_Click() UserForm1.Controls("textbox" & UserForm1.TextBox11.Value).Value = Me.ListBox1.Value End Sub ほかに Private Sub UserForm_Initialize()などは不明ですが設定してあるものとします。
[コンピュータテクノロジー ＞プログラミング ＞Visual Basic]カテゴリへ 投稿されてますよ。
>skylavelさん2016/7/2220:40:44 >繰り返し処理の一部を手動で行うようなプログラムを書くことは可能ですか？ 繰り返しは可能ですが、業務作業で使えるかは別の話になります。
同じ質問を繰り返してますね。 まず、簡単なことから調べてやってみましょう。 最初から大きな家は建てられません。 小さな物からつくるんです。 たとえば、Ａシートの"A2"からＢシートの”A2"にデータをコピーする。 (1) Worksheets("Ｂシート").Range("A2").Value=Worksheets("Ａシート").Range("A2").Value (2) Dim Ws1 As WorkSheet,Ws2 As WorkSheet,Y As Long,X As Long Set Ws1 = Worksheets("Aシート") Set Ws2 = Worksheets("Bシート") Y=2 X=1 Ws2.Cells(Y,X).Value = Ws1.Cells(Y,X).Value (1)と(2)は、同じ結果になります。ただ、(2)の方が、 (3)A列の2行目から10行目をコピーしたいときに応用がききます。 (3) X=1 For Y = 2 To 10 Ws2.Cells(Y,X).Value = Ws1.Cells(Y,X).Value Next ということで、VBAの1行1行の意味を理解して行くことが大切です。 「千里の道も1歩から」です。
そのＤＧＶと言う物が、DataGridViewで環境がVisual Basic 2010のような.net系だという前提でお話しします。 普通にCellValueChangedイベントで計算すりゃ良いんじゃないですかね？ https://msdn.microsoft.com/ja-jp/library/system.windows.forms.datag... 気になって調べたら、CellFormatting イベントが適正な模様。 http://www.itlab51.com/?p=3657
【回答になっていない蛇足】 Cells(K, L) = i And K = K + 1 と書くと、 Cells(K, L) = (i And k = (K + 1)) になってしまいます。最初の = は代入、 二番目の = は等値比較[代入では無い]です。 (k = k + 1) は必ず 0 [False]になるので、 (i And 0) も必ず 0 、よって Cells(K, L) = 0 と書いたのと同じ意味になってしまいます。 VBAでマルチステートメントにしたい場合、 Cells(K, L) = i : K = K + 1 のようにコロンで区切ります。しかし、 If ～ Then の後でコレを書くと紛らわしくて 見辛いので、基本的にはブロックIfにすべきかと。 If ～ Then   Cells(K, L) = i   K = K + 1 End If ＞nagato_blue_noahさん >>AndはIf文の条件判定の中だけでしか使えません。 イヤ、VBA/VBScriptのAndはビット演算子なので 通常の数式内で使えますよ。Ｃ言語でいう & で && では無い[VBAには && 相当機能は無い]ですが。 >>Cellsは極力つかわずにRangeを使うように Cellsでも Range("B" & Rows.Count)   ''↓↓'' Cells(Rows.Count, "B") は使えます。まあ範囲指定だと少しカッタルイのは 確かなので、Cells(～).Resize(～)などと使い分けた 方が便利ですが。後、Rangeは多分少し遅くて便利 な奴なので、「極力つかわず」は言い過ぎかも。 Range("A1:C3,D4:F6,G7:I9")みたいな指定もあって、 Rangeはコレを翻訳しながら動作するのでCells(数値, 数値)に比べると不利な面があるので。
＞Set sheetobj = Workbooks(2).Worksheets(1) ＞が ＞Set sheetobj = Workbooks(1).Worksheets(1) ＞となって作業が進められてしまいます。 Workbooks(1)というのは、 「現在開かれたブックのなかで、1番最初に開かれたブック」 と言う意味なのは、ご存じなのですよね？ もし、「開かれた順番」でなく、「ブック名」でよければ、 Set sheetobj = Workbooks("Book1.xlsx").Worksheets(1) といった書き方をすれば、良いです。 「開かれた順番」をこれからも続けたいのなら、開く順番に注意するしかないでしょうね。
ComboboxのDisplayMemberとValueMemberプロパティを設定して 表示する値と、使用する値を別々にすることが出来ます。 例えば、DisplayMemberを商品名に、ValueMemberを在庫数にすれば、Comboboxで選択した商品の在庫数を取得することが出来ます。 http://dobon.net/vb/dotnet/control/tbdisplaymember.html http://www.r-nakai.com/archives/29
ＯＳはもしかしてＷｉｎ１０に無料ＵＰ品ですか？
このSQLをどこに設定するのか次第です。 クエリの抽出条件に記述するなら、 Between [Forms]![フォーム名]![コンボ1] And [Forms]![フォーム名]![コンボ2] というようにどのフォームにあるのか分かるように記述します。 この場合、データ型意識する必要はないです。クエリの方で適切に変換してくれます。 ただ、クエリの「クエリパラメータ」プロパティでデータ型を明確に指定しておいた方かベターですが（下記リンク先参照）。 ■T'sWare Access Tips #542 ～パラメータクエリのパラメータのデータ型を限定するには？～ http://tsware.jp/tips/tips_542.htm VBAでFilterプロパティ等に設定する条件式を生成する場合は、 対象フィールドのデータ型によって記述が変わってきます。 さらにVBAコード中でSQL条件式は文字列として扱うことになるということの理解も必要です。 (VBAのコードと SQL文は別物なので） 自分自身のフォームのFilterプロパティに設定する場合のコード例 対象フィールドが数値型の場合 Me.Filter = "フィールド名 Between " & Me.コンボ1 & " And " & Me.コンボ2 対象フィールドがテキスト型の場合 Me.Filter = "フィールド名 Between '" & Me.コンボ1 & "' And '" & Me.コンボ2 & "'" 対象フィールドが日付/時刻型の場合 Me.Filter = "フィールド名 Between #" & Me.コンボ1 & "# And #" & Me.コンボ2 & "#" ちなみに型変換関数はVBA内でデータ型を変換する場合に使いますが、VBAコード中のSQL条件式の場合は不必要な場合がほとんどです。
以下でどうなりますか まず、新規ファイルを開いて、 ・以下全部転記して、 ・Sheet1 / Sheet2 があることを確認後、 ・testData で確認用データを作り、 ・Samp1 を実行してみます 良さそうなら、testData 以外を転記して確認してみます 各文字数がわかりませんが、どうなりますか Public Sub Samp1()    Dim dic As Object, dicW As Object    Dim vA As Variant, vB As Variant    Dim vK As Variant, v As Variant    Dim vWs As Variant, vW As Variant    Dim i As Long, j As Long    Set dic = CreateObject("Scripting.Dictionary")    Set dicW = CreateObject("Scripting.Dictionary")    With Worksheets("Sheet2")       With .Range("G1", .Cells(Rows.Count, "G").End(xlUp))          vB = .Value          For i = 1 To UBound(vB)             dicW(vB(i, 1)) = i          Next          vB = .Offset(, Range("C1").Column - .Column).Value       End With    End With    With Worksheets("Sheet1")       With .Range("F1", .Cells(Rows.Count, "F").End(xlUp))          vA = .Value          For i = 1 To UBound(vA)             If (Not dic.Exists(vA(i, 1))) Then                dic.Add vA(i, 1), CreateObject("Scripting.Dictionary")             End If             dic(vA(i, 1))(i) = Empty          Next          With .Offset(, Range("E1").Column - .Column)             vA = .Value             vWs = dic.Keys             For Each vW In mySort(dicW.Keys)                j = 0                For Each vK In Filter(vWs, vW, , vbTextCompare)                   For Each v In dic(vK).Keys                      vA(v, 1) = vB(dicW(vW), 1)                   Next                   dic.Remove vK                   j = j + 1                Next                If (j > 0) Then vWs = dic.Keys             Next             .Value = vA          End With       End With    End With    Set dic = Nothing    Set dicW = Nothing End Sub Private Function mySort(ByVal vA As Variant) As Variant    Dim v As Variant    Dim i As Long, k As Long    k = 0    v = "Go"    While (Not IsEmpty(v))       v = Empty       k = k + 1       For i = LBound(vA) To UBound(vA) - k          If (Len(vA(i)) < Len(vA(i + 1))) Then             v = vA(i)             vA(i) = vA(i + 1)             vA(i + 1) = v          ElseIf (Len(vA(i)) = Len(vA(i + 1))) Then             If (vA(i) < vA(i + 1)) Then                v = vA(i)                vA(i) = vA(i + 1)                vA(i + 1) = v             End If          End If       Next    Wend    mySort = vA End Function ' 確認用簡易データ作成 Public Sub testData()    Dim dic As Object    Dim vK As Variant    Dim sS As Variant    Dim i As Long, j As Long, k As Long    Const CCNT As Long = 50    Const CRH As Long = 300    Randomize    Set dic = CreateObject("Scripting.Dictionary")    While (dic.Count < CCNT)       sS = ""       For i = 0 To Int(10 * Rnd())          sS = sS & Chr(Asc("A") + Int(26 * Rnd()))       Next       dic(sS) = Empty       dic(sS & sS) = Empty    Wend    vK = dic.Keys    k = UBound(vK)    Set dic = Nothing    Application.ScreenUpdating = False    With Worksheets("Sheet2")       .Cells.Delete       For i = 0 To k          .Cells(i + 1, "G").Value = vK(i)          .Cells(i + 1, "C").Value = "G" & i + 1       Next       .Columns.AutoFit    End With    With Worksheets("Sheet1")       .Cells.Delete       .Columns("F").NumberFormatLocal = "@"       For i = 1 To CRH          sS = ""          For j = 0 To Int(5 * Rnd())             sS = sS & j          Next          If (Rnd() > 0.75) Then             sS = sS & vK(Int((k + 1) * Rnd()))          End If          For j = 0 To Int(5 * Rnd())             sS = sS & j          Next          If (Rnd() > 0.9) Then             sS = sS & vK(Int((k + 1) * Rnd()))          End If          .Cells(i, "F").Value = sS          .Cells(i, "E").Value = i       Next       .Columns.AutoFit    End With    Application.ScreenUpdating = True End Sub
＞の部分を自分なりにかきかえてみたのですがうまくいきません。 どの様に書き換えたのか？だが 処理する時のシート名を変えると出来ると思うが 一旦差分用のシートを削除する 差分用のシートを新規に作成する の2つの部分を削除する その際オブジェクト変数 st(0)～st(2)が作成されないので それぞれを Worksheets(DelSheet） Worksheets(AddSheet) Worksheets(ChgSheet) に変更する?
以下のコードでいかがでしょうか。 条件を満たしているときは該当セルの背景色を消すようにしています。 Option Explicit Sub Sample() Dim r As Long, c As Long For r = 1 To Range("D" & Rows.Count).End(xlUp).Row Select Case Range("D" & r).Value Case "山" With Range("O" & r) .Interior.Color = IIf(.Value Like "*川*", xlNone, 255) End With Case "ゴンドラ" For c = 5 To 9 Step 2 With Cells(r, c) .Interior.Color = IIf((.Value <> "" And .Offset(, 1).Value = "○") Or (.Value = "" And .Offset(, 1).Value = "×"), xlNone, 255) End With Next c End Select Next r End Sub
> Dim idx As Integer > Dim frmPage, toPage を次のように。 Dim idx As Long Dim frmPage As Long Dim toPage As Long
1-AブックのSheet１のボタンクリック 2-同一フォルダにAブックをコピー保存（ブックの名前はSheet１のセルA1） 3-コピーしたブックを開く のプログラム例です。 Sheet１のセルA1は、拡張子を付けたブック名が入力されているものとします。 Sub ボタン1_Click() Dim xAfter As String With ThisWorkbook xAfter = .Path & "\" & .Worksheets("Sheet1").Range("A1") .SaveCopyAs xAfter End With Workbooks.Open xAfter End Sub
音が鳴る前に、イベントを処理させればよいでしょう。 [ユーザーフォーム上に文字列を表示]する処理 DoEvents PlaySound ActiveWorkbook.Path & "\sound\complete.wav", 0, 0
「自分から6列左の3行目から13行目の間で、A列が自分の行のG列に等しい行を合計しろ」ですよね。だからsumif関数一撃 H3: =sumif($A$3:$A$13, $G3, B$3:B$13)
VB.NET系（VB2015やVB2013他） の場合、Timerコントロールは不要。 System.Threading.Thread.Sleep(500) で、0.5秒（500ミリ秒）止まります。 質問内容が曖昧で、どこに、どんな画像を表示させるのか分かりませんが、 画像を表示させる System.Threading.Thread.Sleep(500) 次の画像を表示させる で、目的のことが出来るかと思います。
二丁目と入力した場合はどうするのでしょうか？ 一番地と入力した場合はどうするのでしょうか？ 十一丁目と入力した場合はどうするのでしょうか？
クラス名.イベント名 += とやっていませんか？ Formクラス内に書くなら、 this.イベント名 += もしくは、 イベント名 += のみで記述できるかと思います。
どのようなコードを書いたのか判りませんが、下記のサイトを参考にしてみて下さい。 どぼん - GZIPやデフレートでファイルを圧縮する http://dobon.net/vb/dotnet/file/compressfile.html
これでいいかな？ if テキストボックスB.value = "" Then me.テキストボックスB.value = テキストボックスA.Value end if
どのような症状でお困りなのですか？ 「記述したい場所に上手く記入できません」 では、説明としてはあまりに貧弱。 「ＸＸの場所に転記したいのだが、〇〇のところになってしまう」 といったような具体的な説明が必要ですね。 とりあえず気が付いた事を一言。 >Set myRange = Cells(Rows.Count, 1).End(xlUp).Offset(0, 1) で転記先を決定しているのですよね？ そして、myRangeの参照先が変わるのは、この↑ステップだけ。 転記元のセルは、 >For i = 1 To 100 Step 1 >・・・= Worksheets("生産量計算シート").Cells(i + 1, 1).Value >・・・= Worksheets("生産量計算シート").Cells(i + 1, 4).Value といったような感じで、100行のデータから転記されるようになってます。 ところが、 >myRange.Offset(0, 15).Value = ・・・ >myRange.Offset(0, 16).Value = ・・・ >myRange.Offset(0, 17).Value = ・・・ といったように、転記元が変われど、転記先は、変わりません。 上書きし続けることになってますね。 まずはこの不具合を改善する必要がありそう。
If m < a に引っかかるとIf b > aに行きません なのでelseにせずそれぞれif-endifで独立した条件にする inputboxが返すのはstringです なので上記IF文を分けて、所持金で100と入れてもIf b > aにたぶん引っかかりません inputboxで受けたnとかaは数値に変換（cintｔとか）にしてあげないとだめだと思います
Console.Write()及びConsole.WriteLine()はコンソールアプリケーション・IO向けのプロージャで、そのままではフォームアプリケーションでは使えません。 なので、書き出したものをテキストファイルに出力する命令を書きましょう。 次のコードをShared Sub Main()の次の行に挿入してください。 Dim ResultIO As New System.IO.StreamWriter("%appdata%\QUIZAPP\result.txt", False, System.Text.Encoding.GetEncoding("utf-8")) ResultIO.AutoFlush = True Dim Writer As System.IO.TextWriter = System.IO.TextWriter.Synchronized(ResultIO) Console.SetOut(Writer) その後デバッグでちゃんとMain()プロージャが呼び出せていたら%appdata%\QUIZAPPディレクトリにresult.txtが生成されているはずです。 (エクスプローラのアドレス欄に%appdata%\QUIZAPPと入力してあげると参照できます。このディレクトリはアプリケーションがデータを保存したりする目的で使われます。先にディレクトリを作成しておくと無難かも。) エラーが吐かれたなどあればまたご質問ください。
>ID非公開さん2016/7/2200:45:28 >どなたか、修正箇所をお教え頂けませんでしょうか？ それは外注レベルの話しになるので、無償の場で教われるようなものではないので、できなければ断るか無理な事を伝えるべきです。
下記のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim rng As Range Dim pos As Long Dim ch As String Dim buf As String Application.ScreenUpdating = False For Each rng In Range(Range("A6"), Cells(Rows.Count, "ZZ").SpecialCells(xlLastCell, 2)) buf = "" For pos = 1 To Len(rng.Value) ch = Mid(rng.Value, pos, 1) If ch = "ヴ" Then buf = buf & "ｳﾞ" ElseIf ch = "ヮ" Then buf = buf & "ﾜ" ElseIf ch Like "[ァ-ン]" Then buf = buf & StrConv(ch, vbNarrow) Else buf = buf & Mid(rng.Value, pos, 1) End If Next pos rng.Value = buf DoEvents Next rng Application.ScreenUpdating = True End Sub ワークシート関数のASCを使うとカナだけでなく英数字も半角になってしまいます。 ですので半角カタカナへの変換はhdumpさんの回答のようにすべてのセルを１文字ずつ調べてカナカナだけをStrConvを使って半角に変換していくしかありません。 ただしStrConvを使っても「ヴ」は半角「ｳﾞ」になってくれませんので、その対応も必要です。 また、「ヮ」（小さいワ）は相当する半角カタカナが存在しないので、便宜上半角のふつうの「ﾜ」にしています。 ちなみにエクセルの最大行は1,048,576行なので、現実にはほとんどあり得ませんが、A6:ZZ1048576までをすべて調べるとなると下手をすると数時間かかります。 （私のPCでA6:ZZ1048576のすべてに「アイウエオ」を入れてテストしたら1時間以上かかりました）
データベースの抽出で複数条件であれば、フィルタを用いるとコードも短く処理も速いと思いますよ。 AdvancedFilterメソッドを使うことで、フィルタの結果を別シートに転記できます。 細かなセル情報がないので概要だけ説明すると・・。 まず、Sheet1にデータベース（表）、Sheet2は条件を入力する表、Sheet3に結果を表示するようなシート構成にします。 ユーザーフォームで入力条件を作るなら、各テキストボックスのデータがSheet2の条件欄のセルに代入するように設定をしておきます。コマンドボタンを押すとAdvancedFilterメソッドが実行され、結果をSheet3に表示して、その結果をユーザフォームのリストボックスに表示するように設定する流れの処理を作れば良いのでは。
For Each sh In Sheets sh.Name = sh.Range("E4").MergeArea(1, 1).Value Next 全てのシートに対して繰り返し(For Each)E4を先頭とした結合セルの値（MergeArea(1,1).value)を、シート名（sh.Name)に設定します。
こんにちは。 フォームの再表示が必要です me.repaint をフォームのコードペインにて実行してください
こんにちは。 1) a.jpgが、エクセルシートに貼り付けた状態のブックを準備 2) マクロの自動記録を開始。 3) コントロールを選択し、B.jpgのファイルの色設定をする操作をします。 4) bの図が張り付いたときに、「マクロの自動記録」の停止 5) 出来上がったコードで、ファイルを指定する部分に、「ファイルを選択するコード」 におきかえ という流れで、設定します。 図の設定では、エクセルバージョンの影響がある部分です。 主様の考えているものが、バージョンが何でもできる、というのは、最初からダメということも、覚悟してください。 (まずは、バージョンが2013でなかったら、動作しません、というものを作成するということです
可読性の良い回答がなかったら･･･ 参考になりそうなら、やってみても良いかな程度で Dictionary の２段構成にします １段目キー：A列の都道府県？ ２段目キー：何列目に書き出すのか（列番号） 値は配列で持ち >   vC = Array("とてもよい", "よい", "ふつう", "わるい") で定義したものが 配列添え字 1 ～ になるように 配列は添え字 0 ～ とし、0 には全体個数を･･･ 変数 v がそうだとしたら、 v(0)： 全体個数 v(1)： とてもよい の個数 v(2)： よい の個数 v(3)： ふつう の個数 v(4)： わるい の個数 v(5)： 上記の文字列と一致しなかった個数 雰囲気以下でどうなりますか？ なお、◎、●、○ の判別が理解できなかったので、 記述内、★～ ～★ 間の変更要 Option Explicit Public Sub Samp1()    Dim dic As Object, dicE As Object    Dim vA As Variant, vE As Variant, v As Variant    Dim vS As Variant, vC As Variant, vK As Variant    Dim sS As String    Dim i As Long, j As Long, k As Long    vS = Array("春", "夏", "秋", "冬")    vC = Array("とてもよい", "よい", "ふつう", "わるい")    Set dic = CreateObject("Scripting.Dictionary")    Set dicE = CreateObject("Scripting.Dictionary")    For i = 0 To UBound(vS)       dicE(vS(i)) = i + 2    Next    vA = Range("A1").CurrentRegion.Resize(, 3).Value    For i = 1 To UBound(vA)       If (dicE.Exists(vA(i, 2))) Then          j = dicE(vA(i, 2))          For k = 0 To UBound(vC)             If (vA(i, 3) = vC(k)) Then Exit For          Next          k = k + 1          If (Not dic.Exists(vA(i, 1))) Then             dic.Add vA(i, 1), CreateObject("Scripting.Dictionary")          End If          v = dic(vA(i, 1))(j)          If (Not IsArray(v)) Then             ReDim v(UBound(vC) + 2)             v(0) = 1             v(k) = 1          Else             v(0) = v(0) + 1             v(k) = v(k) + 1          End If          dic(vA(i, 1))(j) = v       End If    Next    ReDim vA(1 To dic.Count + 1, 1 To dicE.Count + 1)    For Each vE In dicE.Keys       vA(1, dicE(vE)) = vE    Next    i = 1    For Each vK In dic.Keys       i = i + 1       vA(i, 1) = vK       For Each vE In dicE.Keys          j = dicE(vE)          sS = "-"          v = dic(vK)(j)          If (IsArray(v)) Then             ' ★～             If (v(0) = v(1)) Then                sS = "◎"             ElseIf ((v(1) > 0) Or (v(2) > 0)) Then                sS = "●"             Else             End If             ' ～★          End If          vA(i, j) = sS       Next    Next    Application.ScreenUpdating = False    With Worksheets.Add       With .Range("A1").Resize(i, UBound(vA, 2))          .Value = vA          With .Offset(1).Resize(.Rows.Count - 1)             .Sort .Cells(1), xlAscending, Header:=xlNo          End With          .HorizontalAlignment = xlCenter       End With    End With    Application.ScreenUpdating = True    Set dic = Nothing    Set dicE = Nothing End Sub ' 確認用簡易データ作成 Public Sub testData()    Dim dic As Object    Dim vS As Variant, vC As Variant, vK As Variant    Dim sS As String    Dim i As Long, j As Long    Const CCNT As Long = 50    Const CRH As Long = 10000    vS = Array("春", "夏", "秋", "冬", "正月")    vC = Array("とてもよい", "よい", "ふつう", "わるい", "無回答")    Set dic = CreateObject("Scripting.Dictionary")    Randomize    While (dic.Count < CCNT)       sS = Chr(Asc("A") + Int(26 * Rnd()))       sS = sS & Format(Int(99 * Rnd()) + 1, "00")       dic(sS) = Empty    Wend    vK = dic.Keys    Application.ScreenUpdating = False    Cells.Delete    For i = 1 To CRH       Cells(i, "A").Value = vK((Int(dic.Count * Rnd())))       Cells(i, "B").Value = vS(Int((UBound(vS) + 1) * Rnd()))       Cells(i, "C").Value = vC(Int((UBound(vC) + 1) * Rnd()))    Next    Columns.AutoFit    Application.ScreenUpdating = True    Set dic = Nothing End Sub
TimeValueは時間の部分しか取り出さないので、日付も取り出す必要があります。 それから表示形式を "[h]:mm" にしなくてはなりませんが、 Formatでは出来ませんので下記のようにします。 Private Sub CommandButton2_Click() Dim T1 As Date, T2 As Date TextBox2.Text = Now() T1 = DateValue(TextBox1.Text) + TimeValue(TextBox1.Text) T2 = DateValue(TextBox2.Text) + TimeValue(TextBox2.Text) TextBox3.Value = WorksheetFunction.Text(T2 - T1, "[h]:mm") End Sub
入力フォーム内にある「開始」ボタンに記載するコードです。 Private Sub CommandButton1_Click() Dim sh As Worksheet Dim i As Long, imax As Long Dim cnt As Integer Application.ScreenUpdating = False Set sh = Worksheets("SheetB") For cnt = 1 To 20 If Me("TextBox" & cnt).Value <> "" Then With sh imax = .Cells(Rows.Count, 1).End(xlUp).Row For i = imax To 1 Step -1 If InStr(.Range("A" & i).Value, Me("TextBox" & cnt).Value) > 0 Then .Rows(i).Delete End If Next i End With End If Next Application.ScreenUpdating = True End Sub
イベントをQueryCloseではなくUserForm_Terminateにしてみてください。
えーと、やりたい事としては、 ・結果シートを削除する ・結果シート以外はクリアする でいいんでしょうか？ （プログラム見た限りではそんな感じに見えます） で、 結果シートを削除するだけでしたら、 For Each sh In Sheets If sh.Name = "結果" Then Application.DisplayAlerts = False sh.Delete Application.DisplayAlerts = True Exit For End If Next これだけでダイアログなしで削除できます。 結果シート以外のシートをクリアする処理を追加するんでしたら、 Exit forとEnd Ifの間に、 Else sh.Cells.Clear を追加します。
Private Sub Workbook_Open() Sheets("Sheet1").Activate End Sub Workbook_Open()イベントに開きたいSheetをActivateするコードを書きます。
クリップボードを経由すれば、そういった操作が可能です。また、Open命令、Input命令では全ての文字をまとめて読み込めないので、別な方法を使います。 Sub test() fpath = "テキストデータフォルダパス\" Set fso = CreateObject("Scripting.FileSystemObject") Set txt = fso.OpenTextFile(fpath & "ファイル名") '全文字列をまとめて読み込み msg = txt.readAll() txt.Close 'ここがクリップボードとの通信 Dim clip As New DataObject clip.SetText msg clip.PutInClipboard '貼り付け Range("A1").PasteSpecial End Sub
デスクトップのフォルダーは、 Sub sample() Dim xPath As String xPath = CreateObject("WScript.Shell").SpecialFolders("Desktop") & "\見積りver2\設備DB.xlsx" Workbooks.Open xPath End Sub といった感じで取得できます。 http://officetanaka.net/excel/vba/tips/tips107.htm
http://excelvba.pc-users.net/fol4/4_2.html Workbooks.Open メソッドのパラメータでパスワード指定ができます。
AddPicture にして下さい。 Sub PictFit() Dim PicFile As String Dim Pic As Shape PicFile = Application.GetOpenFilename() If PicFile = "False" Then Exit Sub Set Pic = ActiveSheet.Shapes.AddPicture(PicFile, False, True, 0, 0, -1, -1) With Pic .Height = ActiveCell.MergeArea.Height .Top = ActiveCell.Top .Left = ActiveCell.Left + (ActiveCell.MergeArea.Width - .Width) / 2 End With End Sub
説明不足で根本的にわからないことだらけですが。。。 まず VBScript とは どこで使われる VBScript の話でしょうか？ WSH の「VBS」ファイルで使われる VBScript もあれば HTML や HTA で使われる VBScript もあれば ASP で使われる VBScript もあります。 同じ VBScript でも使い方が全然違います。 「VBScript - Wikipedia」 https://ja.wikipedia.org/wiki/VBScript 私は個人的に， WSH の「VBS」ファイルで使われる VBScript と HTML や HTA で使われる VBScript であればある程度わかりますが ASP で使われる VBScript など全くわかりません。 次に， 「TSV(タブ区切り)ファイルの上下を反転させる」 という意味がわかりません。 タブ区切りのデータには上下などなく タブをはさんでひたすら左右に並ぶだけではないでしょうか？ もし「改行」が入れば， データは「改行」を区切りとして縦に並びますね。 この「改行」区切りの場合であれば 「上下を反転させる」という意味も(意味だけは)わかりますが， タブ区切りのデータには上下の意味がわかりません。 また仮に「改行」区切りだとしても VB系的な書き方をすれば vbCrLf も「改行」ですし， vbLf も「改行」ですし， vbCr も「改行」です。 データの中にはどの改行が入っているのかもわかりません。 さらに， 仮に「上下を反転させたデータ」ができたとして， そのデータをどうするのかもわかりません。 === === === === === === === とにかく不明なことだらけですが， 「タブ」か「改行」か知りませんが 何かの「区切り」を挟んだ文字列データの順を 逆順にしたいのでしたら ArrayList クラスの Reverse() メソッドを使えば簡単かもしれません。 (※ これを使うには .NET Framework が必要かもしれません) 「ArrayList クラス (System.Collections)」 https://msdn.microsoft.com/ja-jp/library/system.collections.arrayli... とにかく 反転させたいデータの「区切り」が何であるのかわからないので， 下のコードでは「↓」という文字を「区切り」として データの順を反転させる例を挙げます。 一応， WSH の「VBS」ファイルで使われると想定した書いた VBScript コード例です。 '------------------------------ '「↓」入りの適当な文字列 MyStr を作成 MyStr = "あいう↓かきく↓さしす↓たちつ↓なにぬ" '文字列 MyStr を「↓」で区切った配列にする MyArr = Split(MyStr,"↓") 'ArrayList オブジェクト myAL の作成 Set MyAL = CreateObject("System.Collections.ArrayList") '配列 MyArr の要素数分ループ For i = 0 To UBound(MyArr)     'myAL の要素に配列 MyArr の要素を順に追加     MyAL.add MyArr(i) Next 'MyAL 全体の要素の順序を反転 MyAL.Reverse() 'MyAL を再び配列 MyArr に戻す MyArr = MyAL.toArray() 'MyArr の全要素間に「↓」を入れて再文字列化 MyStr = Join(MyArr,"↓") '試しに MyStr を出力表示してみる MsgBox MyStr '(→出力内容「なにぬ↓たちつ↓さしす↓かきく↓あいう」) '------------------------------ 上記コードをメモ帳などにコピペして 「任意のファイル名.vbs」で保存し そのファイルをダブルクリップしてもらえば 動作確認できるのではないかと思います。
myFLDの最後は"\"になってますか？
再帰呼出ロジックは、最後、再帰を抜け出す処理が必要だとおもいますが？ このロジックだと処理が異常終了しない限り再帰を続けると思います。 「プログラムが停止してしまう」症状とは違いますけど。
ワイルドカードを使用すればいいのでは。 c:\hoge\*.*とすると、c:\hoge配下にあるすべてのファイルを対象とすることができます。 ただ、カメラの種類が複数あるということなので、1回1回実行する都度変更するのではなく、カメラの種類分batファイルを作成しておけばいいのではないのでしょうか？ やりたいことを簡潔にbatファイルにしておくほうが、カメラが増えたり、変更したりした際にメンテナンスもしやすくなると思います。
質問文章に、マクロ内容を書き出してみて。 文字が小さすぎて読めませんm(__)m
エラー処理ルーチンに回数制限を追加しては如何でしょうか？ １回の待ち時間は５００ｍｓ程度にし、１０回ほど繰り返してもダメな場合はタイムアウトエラーで停止させる。
一例です。 Private Sub Worksheet_Change(ByVal Target As Range) Dim r As Range Set Target = Intersect(Target, Range("B1:B20000")) If Target Is Nothing Then Exit Sub Application.EnableEvents = False For Each r In Target Cells(r.Row, "AO") = Now If Cells(r.Row, "AN") = 0 Then Cells(r.Row, "AN") = Now Next Application.EnableEvents = True End Sub
システム設計など必要ありません。 画像の通り作ればそれでよいです。
その方法で良いと思いますよ。考え方はシンプルな方が良いですし、それでコードが複雑化するならともかく、そうなるとも思えませんので・・・。 変に奇をてらう必要はないと思います。 ちなみに、最新ファイルならば、DateLastModifiedの方ではありませんか？ DateCreatedだと作成日になります。
CheckBox1の状態にかかわらず状況列に日付が入っていたらスキップするのであれば、 ’↓ここを変えたい！ '状況列が「削除」のときはスキップする If CheckBox1.Value = True And .Offset(, 1).Value = "削除" Then を '状況列に日付が入っていたらスキップする If IsDate(.Offset(, 1).Value) Then としてみて下さい。
サーバ側で、ログイン処理時のレスポンスでワンタイムトークンを発行して、DBに保存。 それ以降、WEB APIには必ずパラメータとして、token=xxxxみたいなパラメータを付加させて、トークンが一致しない場合はAPIを無効にする ような感じですかね？ クライアント側をWinアプリにするなら、サーバ側をLAMPで構築して、PHPあたりでRESTサーバーにしちゃえば簡単かと。（クライアントへの戻り値はJSONやXML）
よくない箇所があったので、訂正しました。 確認お願いします。 Sub 整列() Dim i As Long, j As Long, k As Long, kk As Long, cc As Long Dim vv As Variant Dim dat() As Double, ddd() As Variant Const 分割 As Long = 5000 Const 制限 As Double = -1 ' 消去 Columns("D:NTT").ClearContents Range("A1").Select ' データを得る ([B1]から下方へのデータ) vv = Range(Range("B1"), Range("B1").End(xlDown)) ' 制限除外 j = -1 For i = 1 To UBound(vv) If 制限 > vv(i, 1) Then ' 除外 Else j = j + 1: ReDim Preserve dat(j) dat(j) = vv(i, 1) '該当データ保持 End If Next ' データを配列に埋める cc = Application.WorksheetFunction.RoundUp(j / 分割, 0) ReDim ddd(分割, cc) i = 0: k = 0: kk = 1 Do ddd(k, Int(i / 分割)) = dat(i) i = i + 1 If i Mod 分割 = 0 Then kk = -kk Else k = k + kk End If Loop While (i <= j) ' 出力 ([D1]を左角に出力) Range(Range("D1"), Range("D1").Offset(分割 - 1, cc - 1)) = ddd End Sub
終了、開始に代入されているのは時刻の文字列表現ですので、そのまま引き算の計算はできません。
fz4wi さん、こんばんは。 VBA の基本機能に、カレントフォルダを変更する機能はないので、外部オブジェクトを利用します。 次の例は、デスクトップフォルダ下の "123" フォルダをカレントフォルダに変更します。 With CreateObject("WScript.Shell") .CurrentDirectory = .SpecialFolders("Desktop") & "\123" End With
参考にって提示されたコードは、何が何を表しているのか解読が大変そう 単に足し算の結果をテキストボックスに表示するようには感じられない →私の解読不足かもしれないですが
というかもう2016年度からないと思いますが…。 http://www.dnc.ac.jp/data/kakomondai.html ↑大学入試センターが掲載している3年分のセンター試験過去問です。 平成27年度は旧課程者用にありますが、平成28年度からは新課程者用の問題だけになったので問題はありません。 https://akahon.net/shinkatei/math/ 新課程 数学の変更点です。 新課程では「数値計算とコンピュータ」がなくなったので、当然教科書を元に問題を作るセンター試験からも問題はなくなります。
こんにちは。 if WScript.Arguments.count = 0 then msgbox "ひきすうがないです" wscript.quit end if v1 = WScript.Arguments(0) msgbox v1 set xla = createobject("excel.application") xla.visible = true set w1 = xla.workbooks.open(v1) v1 = w1.sheets(1).Range("A1").value Set fso = CreateObject("Scripting.FileSystemObject") Set MyFile = fso.CreateTextFile("c:\testfile.txt", True) MyFile.writeline v1 MyFile.close これで、テキストファイルまではできます。 主様、「メモ帳に書き込む」という言い方は、スクリプトコードではいいません。 どんなテキストファイル、と言ってください。 スクリプトは、画面に書くのは、出来ません。メモ帳は、とくに。
Resizeという便利なプロパティを使いましょう。 Sub sample() Dim i As Long Application.DisplayAlerts = False For i = 5 To 100 Step 2 Cells(i, 1).Resize(2).Merge Next i Application.DisplayAlerts = True End Sub
あまり高い教育を受けられなかったからではないでしょうか。
ヘルプ。 https://msdn.microsoft.com/ja-jp/library/office/ff198302.aspx
Withやオブジェクト変数を使用して、プログラムを全体的に纏めましょう。 ThisworkbookやWorksheetsなどのコードがプログラム全体に散乱している感じで、将来仕様変更が発生したとき変更作業が大変になりそうです。 あと、シートのコピーは、「重複有無を確認する」のではなく、「とにかく削除をしてみる」という考えのほうが簡単じゃないですか？ ↓は一例。 Sub テスト() Dim FName As String, wb As Workbook, myPath As String, wsname As String Dim ws0 As Worksheet, ws1 As Worksheet With ThisWorkbook myPath = .Path & "\" With .Worksheets Set ws0 = .Item("sheet1") FName = Dir(myPath & "*" & ws0.Range("A1").Value & "*.*") If FName <> "" Then Set wb = Workbooks.Open(myPath & FName) Set ws1 = wb.Worksheets("入力シート") wsname = ws1.Range("B6").Value & "入力シート" On Error Resume Next Application.DisplayAlerts = False .Item(wsname).Delete Application.DisplayAlerts = True On Error GoTo 0 ws1.Copy after:=ws0 ActiveSheet.Name = wsname End If End With End With End Sub
まず、ThisWorkBook.SaveAs strSaveNameをした時点で、新しいファイル名になったBookで動作している状態となります。（★スズキ...は閉じている） ですので、OnTimeを使用せずとも、SaveAsの後に、Killするだけで 旧ファイルを削除できます。 [参考] Sub ファイ名を変えて消す() '自分自身のパス myPath = ThisWorkbook.FullName 'パスからファイル名 myFileName = ThisWorkbook.Name 'ファイル名から★を抜く newFileName = Replace(myFileName, "★", "") '保存先 newFilePath = "c:\テスト\" & newFileName '新ファイル名で保存(この時点で、bookは新しいファイル名） ThisWorkbook.SaveAs newFilePath '旧ファイルを削除 Kill myPath End Sub
そのままVBAで表すと = WorksheetFunction.SumIf(Range("D6:K40"), ComboBox1.Text, Range("K6:K40")) ですが、あなたがやりたいことは、本当にその数式で合っているのでしょうか？
こんにちは。 System.Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) これが、文字列部分です。 ' ユーザーのプロファイルを開く System.Diagnostics.Process.Start("file://%USERPROFILE%") は ' ユーザーのプロファイルを開く System.Diagnostics.Process.Start("file://" & System.Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) ) で、確認してみてください
vbsで書いておきます。お好きなように編集してください。 ' Button1のクリックイベント dim x0, x1, y0, y1, dn, dx, s x0 = 0 ' ここから x1 = 1 ' ここまで dn = 1000 ' 分割数 dx = ( x1 - x0 ) / dn ' 微小台形高さ s = 0 y0 = fx(x0) ' 台形の(上下)底 for i = 1 to dn ' 分割回数分を処理 y1 = fx(x0 + dx * i) ' 台形の(上下)底 s = s + (y0+y1) * dx / 2 ' 台形面積累計 y0 = y1 ' 台形の底を置き換え next msgbox s WScript.Quit function fx(x) fx = x^7 end function
もっと簡単に書けそうですね。 とりあえずB,C列用。 列が増えるのなら、★の数字をふやしてください。 Sub sample() Dim rng, i As Long Const ie As Long = 2 '★ For Each rng In Range("A2", Cells(Rows.Count, 1).End(xlUp)) _ .SpecialCells(xlCellTypeConstants) Application.DisplayAlerts = False With rng.MergeArea For i = 1 To ie .Offset(, i).Resize(.Rows.Count).Merge Next i End With Application.DisplayAlerts = True Next rng End Sub
cccalaur さん、こんにちは。 ４つの列のコピー～貼り付けを、繰り返し処理にしたい、という要望ですね。 一番簡単な方法は、ast.Range()の引数と、wst.Range()の引数を、それぞれ配列変数に放り込んで、For ループで回す方法かと思います。
Range("C4:C8").Formula = "=B4*C4" を Range("D4:D8").Formula = "=B4*C4" に変更すればＯＫです。 ここが間違っていたので、数量がすべて０で表示されてました。
参照設定でmicrosoft active data object library・・にチェックしてください
画像では何か見えません。 ソースとエラー内容を詳しく書いてください。
そのとうり、 まずはArdinoのポートと速度を求める、シリアルモニタで使ってるよね、わからなければ、 速度はSETUPのSerial.begin(19200);なら19200だよね、 ポートはIDEのツール＞ポートでわかるだろ、 VB側は２３２ｃのシリアル通信だよ、これで検索すればわかるとおもいます。
エクセル2010で回答します。 シートに「ユーザーフォームのチェックボックス」を４つ配置します。 そうすると「チェック 1」～「チェック 4」という名前が付けられます。 配置したチェックボックスを１つずつ右クリックし、右クリックメニューから 「マクロの登録」にて「Macro1」を登録します。 その状態でのVBAのソースコードを以下に記載します。 Public Sub Macro1() Dim vntCheckboxs As Variant Dim lngIndex As Long Dim strText As String With Worksheets("Sheet1") vntCheckboxs = Array(.Shapes("チェック 1"), .Shapes("チェック 2"), .Shapes("チェック 3"), .Shapes("チェック 4")) End With For lngIndex = LBound(vntCheckboxs) To UBound(vntCheckboxs) If vntCheckboxs(lngIndex).OLEFormat.Object.Value > 0 Then If Len(strText) > 0 Then strText = strText & "／" End If strText = strText & vntCheckboxs(lngIndex).OLEFormat.Object.Text End If Next Worksheets("Sheet1").Range("A1").Value = strText End Sub
「うまく動作しません」はすべてあなたの勘違いかスペルミスが原因でした。 InputBoxを使う場合は「キャンセル」が押された時の対処のコードを必ず書くようにしてください。 Sub 関数の値() Set MyWs = Worksheets("数学関数") MyWs.Select Cells.Clear Set MyRange = Range("A1:E1") With MyRange .Value = Array("X", "X*X", "√X", "sin(X)", "cos(X)") .HorizontalAlignment = xlCenter .Interior.ColorIndex = 35 End With For i = 2 To 33 Cells(i, 1) = (i - 1) / 10 Next i Range("B2:B33") = "=A2 *A2 " Range("C2:C33") = "=sqrt(A2)" Range("D2:D33") = "= sin(A2)" Range("E2:E33") = "=cos(A2) " End Sub Sub グラフ描画() Set MyWs = Worksheets("数学関数") For Each MyCharts In MyWs.ChartObjects MyCharts.Delete Next px = Columns("F").Left + 20 py = Rows("1").Top + 10 Set MyRange = MyWs.Range("A1:E33") Set MyChart = MyWs.ChartObjects.Add(px, py, 300, 200) MyChart.Activate MyChart.Name = "MatchGraph" With ActiveChart .ChartType = xlLine .SetSourceData Source:=MyRange, PlotBy:=xlColumns .HasTitle = True .ChartTitle.Characters.Text = "関数のグラフ" .Axes(xlCategory, xlPrimary).HasTitle = False .Axes(xlCategory).TickLabels.Orientation = xlHorizontal End With MyRange.Select MsgBox "描画完了" End Sub Sub グラフ更新1() Set MyWs = Worksheets("数学関数") MyWs.Select Set MyRange = Nothing On Error Resume Next Set MyRange = Application.InputBox(prompt:="範囲を選択してください", Type:=8) On Error GoTo 0 If MyRange Is Nothing Then Exit Sub MyWs.ChartObjects("MatchGraph").Activate ActiveChart.SetSourceData Source:=MyRange, PlotBy:=xlColumns MyRange.Select MsgBox "描画完了" End Sub Private Sub CommandButton1_Click() Set MyWs = Worksheets("数学関数") Call 関数の値 Call グラフ描画 End Sub Private Sub CommandButton2_Click() Call グラフ更新1 End Sub Sub グラフ更新2() Set MyWs = Worksheets("数学関数") MyWs.Select Set MyChart = MyWs.ChartObjects("MatchGraph") With MyWs n = .ComboBox1.ListIndex + 1 Select Case (n) Case 1: Set MyRange = .Range("A1:A33") Case 2: Set MyRange = .Range("B1:B33") Case 3: Set MyRange = .Range("C1:C33") Case 4: Set MyRange = .Range("D1:D33") Case 5: Set MyRange = .Range("E1:E33") End Select MyChart.Activate ActiveChart.SetSourceData Source:=MyRange If .OptionButton1.Value = True Then ActiveChart.ChartType = xlLine Elself.OptionButton2.Value = TrueThen ActiveChart.ChartType = xlColumnClustered End If If .CheckBox1.Value = True Then ActiveChart.HasTitle = True Else ActiveChart.HasTitle = False End If If .CheckBox2.Value = True Then ActiveChart.HasLegend = True Else ActiveChart.HasLegend = False End If End With MyRange.Select MsgBox "描画完了" End Sub Sub Auto_Open() Set MyWs = Worksheets("数学関数") With MyWs.ComboBox1 .Clear For Each r In Range("A1:E1") .AddItem r.Value Next r .ListIndex = 3 End With MyWs.OptionButton1 = True MyWs.CheckBox1 = True MyWs.CheckBox2 = True End Sub Private Sub CommandButton3_Click() Call グラフ更新2 End Sub
こちらで回答したんですけどね。 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1416050570... ちょっと言葉が足りなかったかな。 デザインビューで イメージコントロールの「コントロールソース」に = "\\123.456.78.90\MainMenu\QA検査結果記録システム\QA検査画像" & "\" & [Forms]![詳細検索フォーム]![詳細画像ID2] & ".JPG" と記述しておくだけです。 VBA は必要ありませんし、 何のエラーも表示されません。 表示できない画像は表示されない、というだけのことです。
＞たとえば、現状の1行目開始ではなく7行目からデータの cnt = cnt + 1 この行に始めてきた時、ｃｎｔの値は０なので、この命令が実行されるとｃｎｔは１になります。 続けて Cells(cnt, 1) = f.Name この行では、ｃｎｔが１になっているので、初めてこの行が実行される時には Cells(cnt, 1)はCells(1,1)となります。 よって、 cnt = cnt + 1 の前に、ｃｎｔを６としておけば、最初に実行される時にはｃｎｔが７になり 続けて Cells(cnt, 1) = f.Name この行では、ｃｎｔが７になっているので、初めてこの行が実行される時には Cells(cnt, 1)はCells(7,1)となります。 よって With CreateObject("Scripting.FileSystemObject") の前に cnt=６ の命令を追記すれば、最初は７行目からとなります。 cnt=６ '開始行－１ を指定する と注釈文付きで追加すれば、「７行目から」となりますよ。
Formアプリケーションのコンテキストメニューは上下に表示されるスクロールバー(?)しか出せなかったと思います。 WPFなら横にスクロールバーを出すことができますし、様々なコントロールを作ることができるので便利です
二次元配列でいいですが、 可変にするにはListの入れ子にしておきます。 Public Class Form1 Private Gname As List(Of List(Of String)) Private Sub Form1_Load(sender As Object, e As System.EventArgs) Handles Me.Load //CSVから読み込んだデータの作成 Gname = New List(Of List(Of String)) Dim gList As List(Of String) = New List(Of String) gList.Add("Group1") gList.Add("Name1-1") gList.Add("Name1-2") Gname.Add(gList) gList = New List(Of String) gList.Add("Group2") gList.Add("Name2-1") gList.Add("Name2-2") gList.Add("Name2-3") Gname.Add(gList) gList = New List(Of String) gList.Add("Group3") gList.Add("Name3-1") gList.Add("Name3-2") Gname.Add(gList) ComboBox1.Items.Clear() For i As Integer = 0 To Gname.Count - 1 ComboBox1.Items.Add(Gname(i)(0)) Next ComboBox1.SelectedIndex = 0 End Sub Private Sub ComboBox1_SelectedIndexChanged(sender As System.Object, e As System.EventArgs) Handles ComboBox1.SelectedIndexChanged Dim idx As Integer = ComboBox1.SelectedIndex ComboBox2.Items.Clear() For i As Integer = 1 To Gname(idx).Count - 1 ComboBox2.Items.Add(Gname(idx)(i)) Next ComboBox2.SelectedIndex = 0 End Sub
はい、ヘッダーの内容はなんでもいいです 何でもいい、というのはC++の文法に従っている必要もないという意味です ファイル名もなんでもいいです .hや.hppで無くても構いません #include ファイルパス と書けばどんなものでもそこに展開されます 展開する場所もどこでも構いません 例えば //header.h std::printf("Hello world"); //main.cpp #include <cstdio> int main(void) { #include "header.h" } のようにヘッダーの内容を関数内に唐突に登場させたりすることも可能です
purpledreama さん、こんばんは。 例えば、 Set r = Selection を、 Set r = Cells(Rows.Count, "H").End(xlUp).Offset(-14).Resize(15, 7) とすればどうでしょうか？ H列で最下行セルを探し、そこから１５行上に移動してから、セル範囲を１５行７列に拡張する、という処理をしています。
アクティブシート以外のセル範囲を指定したいのであれば、RangeやCellsの前にシートを明記しましょう。 rowMax = Range(col & Rows.Count).End(xlUp).Row ↓ rowMax = ws.Range(col & Rows.Count).End(xlUp).Row With Range(Cells(10, col), Cells(rowMax, col)) ↓ With Range(ws.ells(10, col), ws.Cells(rowMax, col))
B1は何も入っていなくても 最終行になるから 手間が必要ですね？ Sub test() If Worksheets("sheet2").Range("B1") = "" And Worksheets("sheet2").Cells(Rows.Count, 2).End(xlUp).Row = 1 Then Worksheets("sheet1").Range("B2").Copy Destination:=Worksheets("sheet2").Range("B1") Else Worksheets("sheet1").Range("B2").Copy Destination:=Worksheets("sheet2").Cells(Rows.Count, 2).End(xlUp).Offset(1, 0) End If End Sub
VBA関連書籍のタイトルで「逆引き～」とかありますよね。 正引き Findメソッドの機能や使い方を調べる 名前はわかっているけど、詳しい使い方を調べたいなら、正引きつまり「VBA Find」で検索します。 逆引き シート内で文字列検索をする方法を調べる シート内の文字列検索したいんだけど、何か方法あるのか？と思ったら逆引き「VBA シート 検索」で調べます。 逆引きにはもうひとつあります。 エクセルの手動操作は知ってるんだけど、名前が分からない場合、記録マクロで調べたりします。 結局、自分の今の状態、どこまで知ってるかで正引き逆引きが決まります。
Dim x(100) As Double x(0) から x(100) の101個 x(k + 2) = 1.999 * x(k + 1) - 0.99905 * x(k) + 0.00098 ｋは、0 から 100 まで k=99 のとき、 k + 2=101 k + 1=100 k=99 k=100 のとき、 k + 2=102 k + 1=101 k=100 100まで回したいなら x(102)にすれば回る。（異常終了はしない） 意味的に正しいのかは、解らない。
消費税を計算するタイミングが示されていないので、TextBox1の内容が変更される都度計算しています。 Private Sub TextBox1_Change() 'イベントの発生を抑止する Application.EnableEvents = False 'TextBox1をカンマ付きに直す TextBox1.Text = Format(CCur(TextBox1.Text), "#,##0") '消費税を計算する TextBox2.Text = Int(CCur(TextBox1.Text) * 0.08) 'TextBox2をカンマ付きに直す TextBox2.Text = Format(CCur(TextBox2.Text), "#,##0") 'イベントの発生を再開する Application.EnableEvents = True End Sub
VLOOKUP(C13,[★★一覧★★.xlsm]現場一覧!$B$5:$C$70,2,FALSE) を IF(ISBLANK(C13)=TRUE, "", VLOOKUP(C13,[★★一覧★★.xlsm]現場一覧!$B$5:$C$70,2,FALSE)) としてみてくださ。 ISBLANK(セル)＝TRUE/FALSE セルが空欄の場合はTRUE、未入力の場合はFALSEとなります。
共通する部分は、前に出して With 文と、Select Case 文を使ったらどうでしょうか？ Range("A1:I100").Select Selection.Copy With Workbooks("一覧").Worksheets("現金") Select Case ComboBox1 Case "4月" .Range("AA16").PasteSpecial Case "5月" .Range("BA16").PasteSpecial Case "6月" .Range("CL16").PasteSpecial Case "7月" .Range("DD16").PasteSpecial ・・・・ End Select End With end sub
こんにちは。 ①1月～12月以外のシートが存在しても処理対象外と しています。 ②ないとは思いますが、空白行があっても処理される ようにしました。 処理起動用のシートを設けて、 挿入タブ→図形→好みの図形を選択し貼り付け。 図形を左クリック→マクロの登録→Sample1を選択 これが簡単でしょう。 Option Explicit Sub Sample1() Dim Tgs As Variant, Ws As Worksheet, I As Long Tgs = Array("1月", "2月", "3月", "4月", "5月", "6月", _ "7月", "8月", "9月", "10月", "11月", "12月") For Each Ws In Worksheets For I = 0 To UBound(Tgs) If Ws.Name = Tgs(I) Then With Sheets(Ws.Name) .Range(.Range("A1"), .Cells(.Rows.Count, 4).End(xlUp) _ .Offset(0, 1)).Sort _ key1:=.Range("D1"), order1:=xlAscending, Header:=xlYes End With End If Next I Next Ws Set Ws = Nothing End Sub
こんにちは。 Sub Sample1() Dim Dt1 As Variant, Dt2 As Variant, Dt3() As String Dim i As Long, J As Long, k As Long Range("C:C").ClearContents Dt1 = Range(Range("A2"), Cells(Rows.Count, 1).End(xlUp)) Dt2 = Range(Range("B2"), Cells(Rows.Count, 2).End(xlUp)) ReDim Dt3(0) For i = 1 To UBound(Dt2) ReDim Preserve Dt3(k) For J = 1 To UBound(Dt1) If Dt2(i, 1) Like "*" & Dt1(J, 1) & "*" Then Dt3(k) = Dt1(J, 1) End If Next J k = k + 1 Next i Range(Range("C2"), Cells(UBound(Dt3) + 1, 3)).Value = _ WorksheetFunction.Transpose(Dt3) End Sub
テキストボックスはActiveXコントロールのテキストボックスですよね。 とりあえず、２こ張り付けて、上記コード書いたらちゃんと移動しました。 If KeyCode = vbKeyTab Or KeyCode = vbKeyReturn Then TextBox2.Activate End If End Sub ですけど、 If KeyCode = vbKeyTab Or KeyCode = vbKeyReturn Then TextBox2.Activate End If End Sub のように、改行されていますか？ あと、デザインモードにして、テキストボックスを右クリック->プロパティで コントロールのプロパティを表示して、（オブジェクト名）が間違ってないか確認してみてください。
条件を変数にするときはBoolean型で定義し、「""」ではなく「()」で値を格納します。 （例） Dim 条件１ as Boolean if ～ then 条件１=(A=0) else 条件１=(B=0) end if また、ループを抜ける条件は必ずしもDoやLoopの後ろに書く必要はなく、「Exit Do」を使えばいつでもループを抜け出すことができます。 （例） Do （処理） If ～ Then Exit Do （処理） Loop
WindowsAPIを使って印刷を行う方法です。 変数strPath にはPDFファイルのパスを。変数strName にはファイル名を（拡張子含み）。 'WindowsAPIの宣言 Declare Function ShellExecute Lib "SHELL32" Alias "ShellExecuteA" _ (ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, _ ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long 'PDFファイルの印刷 Sub PDFPrint() Dim strPath As String Dim strName As String strPath = "C:\Users\kojin\Desktop\製造工程\図面\" strName = "123.pdf " Call ShellExecute(Application.hwnd, "print", strPath & strName, vbNullString, "", 0) End Sub こんな感じでどうでしょう。
変数ｒが他のマクロでRangeで定義されているという事ではないでしょうか。
とりあえず、こんな感じ。 'B列の最終行数取得（B2から始まっているとして） max_row = Range("B2").End(xlDown).Row '行数ループ（i=2の２が開始の行番号） For i = 2 To max_row '全角→半角変換（StrConv(対象の文字, 変換パタン） 'Cells(i,2)のiが行番号、2が列番号（A列から1,2,3...） Cells(i, 2).Value = StrConv(Cells(i, 2).Value, vbNarrow) Next StrConvの引数（変換パタン）はこちらを参照。 http://officetanaka.net/excel/vba/function/StrConv.htm
ActiveChart.SetSourceData Source:=Range("'2016'!$B$1:$N$4") ここで引っかかるのだと思います。 グラフ範囲にA列が入っても構わないので（凡例を後で削除すると同じ） ActiveChart.SetSourceData Source:=Range("A1").CurrentRegion とすればA1:N4の可視セルだけがグラフ範囲になります。 B列から可視セルだけを選択すると面倒なことになります。 以下のようにしてみてはどうでしょう。 Sub グラフの作成01() Dim r As Range Set r = Intersect(Range("A1").CurrentRegion.SpecialCells(xlCellTypeVisible), Columns("B:N")) Range("B1:N4").Select ActiveSheet.Shapes.AddChart.Select ActiveChart.ChartType = xlColumnClustered ActiveChart.SetSourceData Source:=r ActiveChart.Axes(xlValue).Select ActiveChart.Axes(xlValue).ScaleType = xlLogarithmic ActiveChart.Axes(xlCategory).Select ActiveChart.SeriesCollection(3).Select ActiveChart.SeriesCollection(3).ChartType = xlLineMarkers ActiveChart.Axes(xlCategory).Select ActiveChart.SeriesCollection(3).Select ActiveChart.Axes(xlCategory).Select ActiveChart.Axes(xlCategory).Select ActiveChart.Axes(xlCategory).Select ActiveChart.SeriesCollection(3).Select ActiveChart.SeriesCollection(3).AxisGroup = 2 ActiveChart.Axes(xlValue).Select ActiveChart.Axes(xlValue).ScaleType = xlLinear 'グラフの移動 Dim GName As String GName = Mid(ActiveChart.Name, Len(ActiveSheet.Name) + 2) With ActiveSheet.Shapes(GName) .Left = 100 .Top = 150 .Width = 1000 End With End Sub
以下でどうなりますか 項目行は１行目にある前提で････ 新規ファイルに以下を転記して、 testData にて確認用データを作成し、 Samp1 を実行してみます 良さそうなら･･･ Public Sub Samp1()    Dim vA As Variant, vB As Variant    Dim i As Long, j As Long    Const CCHK As String = "elem_value"    Const CREP As String = "/var/jbos"    Const CNON As String = "<N/A>"    Const CAPP As String = "<apply>"    Application.ScreenUpdating = False    With ActiveSheet.UsedRange       .Replace CNON, ""       For j = 1 To .Columns.Count          If (.Cells(j).Value = CCHK) Then Exit For       Next       If (j > .Columns.Count) Then Exit Sub       With .Columns(j)          On Error Resume Next          .SpecialCells(xlCellTypeBlanks).EntireRow.Delete          On Error GoTo 0          vA = .Value       End With       For j = j + 3 To .Columns.Count          If (.Cells(j).Value = CREP) Then             With .Columns(j)                vB = .Value                For i = 2 To UBound(vB)                   If (vB(i, 1) = CAPP) Then                      vB(i, 1) = vA(i, 1)                   End If                Next                .Value = vB             End With          End If       Next    End With    Application.ScreenUpdating = True End Sub ' 確認用データ作成 Public Sub testData()    Dim r As Range    Const CRH As Long = 35    Const CCHK As String = "elem_value"    Const CREP As String = "/var/jbos"    Const CNON As String = "<N/A>"    Const CAPP As String = "<apply>"    Randomize    Application.ScreenUpdating = False    Cells.Delete    For Each r In Range("A1:N1").Resize(CRH)       Select Case r.Row          Case 1             Select Case r.Column                Case Range("C1").Column                   r.Value = CCHK                Case Is >= Range("C1").Offset(, 3).Column                   r.Value = CREP                Case Else                   r.Value = r.Address(False, False)             End Select          Case 2, 3          Case Else             Select Case r.Column                Case Range("C1").Column                   If (Rnd() > 0.75) Then                      r.Value = CNON                   Else                      r.Value = r.Address(False, False)                   End If                Case Is >= Range("C1").Offset(, 3).Column                   If (Rnd() > 0.75) Then                      r.Value = CNON                   Else                      r.Value = CAPP                   End If                Case Else                   r.Value = r.Address(False, False)             End Select       End Select    Next    Columns.AutoFit    Application.ScreenUpdating = True End Sub
説明が足らないのと違いますかね？ やたらとコピー元の説明は詳しいのに、コピー先の説明は皆無に等しい。 コピー先は適当に考えてくれってことですかね？乱暴すぎないですかね？ >月ごとに変わり いったいここでいう「月」とは、どこにある「月」なのでしょうか？ セル内？ 実行時の日付の月？ （↓のプログラムは、実行時のPC日付の月になってます） >この指定範囲はエクセルの関数で出しているので >マクロでなくてokです。 意味不明。 >セルに書かれた文字を使ってのループ処理 前の説明に「セルに書かれた文字」に関する事情は説明されてますか？ されてないようなので、意味不明。 適当にコーディングすると、↓が一例（未実行につき不具合ご容赦） Sub テスト() Dim xRows As Long, xStep As Long Dim i As Long, ii As Long Set sh = Worksheets("集計") ii = 4 xRows = Day(DateSerial(Year(Date), Month(Date) + 1, 0)) xStep = xRows + 5 With Worksheets("元データ") For i = 6 To .Cells(Rows.Count, "R").End(xlUp) Step xStep .Cells(i, "R").Resize(xRows, 4).Copy sh.Cells(ii, "F").PasteSpecial Paste:=xlPasteValues ii = ii + xRows Next i End With End Sub >うまく調べられませんでした。 調べる能力・手段をお持ちなら、↑のプログラムに手を入れるのは、ご自身でできますよね？
「:=」というのは、名前付き引数に使う記号です。例えばFindメソッドでは、検索文字列に「what:=」という名前付き引数を使います。 Set fnd=Columns(1).Find(what:="sample") 他では使わないはずです。オプションというのが何を示しているのかは分かりませんが、省略可能な引数のことでしょうか。
Copyメソッドを例に・・。 Copyメソッドでは、オブジェクトがセルの場合とシートの場合の引数のオプションが異なります。 セルのコピーであれば、 Range("A1").Copy Range("B1") のように、引数は貼り付け先（Destination）です。この場合、貼り付け先となる引数がなければいけません。もちろん、形式を指定して貼り付けでも同じです。 シートのコピーであれば、 Worksheets("Sheet1").Copy After:=Worksheets("Sheet3") のように、コピーするシートの場所を指定します。 この場合、引数は２つありBeforeとAfterです。但し、どちらか１つしか指定できません。また、引数を省略した時は、現在選択されているシートの左側（Before）にコピーされます。 引数には省略不可のものと、省略可のものがあるので、それぞれのメソッドでどの引数が必須なのか、または任意なのかを知っている必要があります。使っていけば、何となく分かってくるはずです。
こんな感じでどうでしょう？ 一行目が項目行、二行目以降にデータがある場合のコードです。 数量・単価・金額の列を自動で探します。 一行目にこれらの文字がないと自動では探せません。 その場合は、 SURYO, TANKA, KINGAKUの値を変えてください。 例えば数量がA列、単価B列、金額C列なら SURYO=1 TANKA=2 KINGAKU=3 といった感じです。 SURYO = WorksheetFunction.Match("数量", Rows(1), 0) TANKA = WorksheetFunction.Match("単価", Rows(1), 0) KINGAKU = WorksheetFunction.Match("金額", Rows(1), 0) この三行は消してください。 ------------------------------------ Sub 数量が抜けている行のフォントカラーを白に() Dim SURYO, TANKA, KINGAKU, LR, T SURYO = WorksheetFunction.Match("数量", Rows(1), 0) TANKA = WorksheetFunction.Match("単価", Rows(1), 0) KINGAKU = WorksheetFunction.Match("金額", Rows(1), 0) LR = Cells(Rows.Count, KINGAKU).End(xlUp).Row For T = 2 To LR If Cells(T, SURYO) = "" Then Union(Cells(T, SURYO), Cells(T, TANKA), Cells(T, KINGAKU)).Font.Color = vbWhite End If Next End Sub
If (Cells(i, 1).Value <> "A") And (Cells(i, 1).Value Like "*B*") Then Cells(i, 1).Value="C" このように記述すれば良いのではないでしょうか。
サンプルです。 データがあるシート名を「データ」としています。 シート「データ」の一行目に[親id][子id][支払い]という項目があり、 2行目からデータが始まっているとします。 結果を抽出するシートを、ワークブックの右端に追加します。 [親id][子id][支払い]の列と、データの最終行を取得して、追加したシートにワークシート関数を入れます。 [親id]1列目 [子id]6列目 [支払い]4列目 この場合、下記の数式が入ります。支払いがない行は、空白が返ります。 空白が返りますが、数式は入っています。 =IF(データ!$D2<>"",データ!$A2,"") =IF(データ!$D2<>"",データ!$F2,"") =IF(データ!$D2<>"",データ!$D2,"") その後、数式の結果を【値】に変換します。 変換後に、空白行を削除します。 ----------------------- Sub macro() Dim sh_data As Worksheet Dim oya, ko, siharai, lr, v Set sh_data = Sheets("データ") Sheets.Add after:=Sheets(Sheets.Count) oya = sh_data.Rows("1:1").Find("親id").Column ko = sh_data.Rows("1:1").Find("子id").Column siharai = sh_data.Rows("1:1").Find("支払い").Column lr = sh_data.Cells(Rows.Count, oya).End(xlUp).Row Cells(1) = "親id" Cells(1, 2) = "子id" Cells(1, 3) = "支払い" Range(Cells(2, 1), Cells(lr, 1)).FormulaR1C1 = _ "=if(データ!rc" & siharai & "<>"""",データ!rc" & oya & ","""")" Range(Cells(2, 2), Cells(lr, 2)).FormulaR1C1 = _ "=if(データ!rc" & siharai & "<>"""",データ!rc" & ko & ","""")" Range(Cells(2, 3), Cells(lr, 3)).FormulaR1C1 = _ "=if(データ!rc" & siharai & "<>"""",データ!rc" & siharai & ","""")" With Range(Cells(1, 1), Cells(lr, 3)) v = .Value .Value = v .SpecialCells(xlCellTypeBlanks).EntireRow.Delete End With End Sub
Sub SheetCopy() With ThisWorkbook .Worksheets("S").Visible = True .Worksheets("S").Copy .Sheets("S").Visible = False End With ActiveSheet.Name = "抽出結果" MsgBox "抽出完了", vbInformation End Sub
If .Show = True Then cFld = .SelectedItems(1) & "\" Else Exit Sub End If Exit Sub → End
ID非公開さんでは前の質問から内容を推測することもできない。せめて前の質問のURLくらいは添付したら？
先週から気にはなっていたのですが、VBAも波動方程式も門外漢なので尻込みしていました。しかし、その後どなたも回答されないようですので、口火を切ります。 最初に気になったのは、uの定義がどうなっているか、です。 あと、newuも配列なのでしょうか？それとも、new uでしょうか？ それから、以下のような連続代入も、コードの見通しを悪くしていると感じます。 u(1, j, 0) = u(1, j, LX - 1) = u(1, 0, j) = u(1, LX - 1, j) = 0 newu(i, j - 1, 0) = newu(i, j - 1, LX - 1) = newu(i, 0, j - 1) = newu(i, LX - 1, j - 1) = 0 それぞれ、4行使って= 0を明示していただいた方がと思います。 u(1, j, 0) = 0 u(1, j, LX - 1) = 0 u(1, 0, j) = 0 u(1, LX - 1, j) = 0 newu(i, j - 1, 0) = 0 newu(i, j - 1, LX - 1) = 0 newu(i, 0, j - 1) = 0 newu(i, LX - 1, j - 1) = 0 基本的にエラーメッセージは出ないわけですよね？ とすれば、あとは、デバッグコマンドを仕込んでトレースして問題点をあぶり出すしかないように思います。 あまりお役に立てずスミマセン。何かのヒントになればと思うのですが。
Private Sub Worksheet_Change(ByVal Target As Range) With Worksheets(1) Application.Goto .Range(.Cells(288, 11), .Cells(311, 11)) End With End Sub
こんにちは。 デバッグのイミディェットウィンドで、手で直接、 objIE.Document.getElementById("MonthSelect").SelectedIndex = 0 など、直接操作して、実際にでる様子を確認 手でうまくいったら、cells( 3,10)が怪しいです。 あと、「変化がない」のに、ダメになるとしたら、ブラウザーそのもののセキュリティ関係で出来ていたことが突然だめになる、という可能性はあります。 あと、まさかのOSアップデート。最近は巷もにぎやかです。 とにかく原因がどこかにあるので、主様、地道に頑張ってください
そういうことは、ご教授とは言わずに、「ご教示」と言います。日本語はきちんと使いましょう。
こんにちは。 主様、開きたいファイルは、thisworkbook.pathにある、ということは、「特定の日付」とか、「特定の文字を含んだファイル」とか、特徴がありませんか あと、開かなくていいブックも一緒にある、ということなんでしょうか ということで、開かなくていいブックの特徴があるか、などで、ファイルのfor eachのファイル名に対して処理してください。 set fso = createobject("scriptint.filesystemobject") set f1 = fso.getfolder(thisworkbppk.path) for each f2 in f1.files if f2.name = thsiwrokbook.name then else ここで、日付でしたら、lastdateなど、プロパティを確認 コピー、開く、など、現在のコードを設定 end if next というようになります。 これだと、選択の処理は自動処理になります あ、ファイルを扱うマニュアルをよく見て、コードにしてください。 べたべたに手打ちしてます。 ニュアンスだけ参考に
(vba shape) セレクトオールをした後ではなく、その前に シェイプがあるか確認してはどうですか。 If ActiveSheet.Shapes.Count > 0 Then ActiveSheet.Shapes.SelectAll Selection.Placement = xlFreeFloating
はい、これは、原理的に無理です。 なぜなら、IME の変換イベントで制御しているからです。 全角スペースは、例外で 変換プロセスを筒抜けで、すーすーと入力されるので、 捕まりません。 仕方ないので、 逃げ手を捜します。 今、やってみると、KeyPress イベントで捕まることが、分かりました。 しかし、 何故か、そのままだと、KeyPress イベントが２回来ます。 e.Handled = true; にしてみると、全角スペースも入りません。 そこで、考えたのが、これ！ 試してみてください。 private void TextBox1_KeyPress(object sender, KeyPressEventArgs e) { if (e.KeyChar == ' ') { TextBox1.Text += " "; TextBox1.SelectionStart = TextBox1.Text.Length; TextBox2.Text += " "; e.Handled = true; } } TextBox1.SelectionStart を文字列のおしりにしないと、 何故か、カーソルが先頭になってしまいます。
マスターに入力していないのでは。
こんな感じになります。 Sub シートコピー() Dim Sh, i, t t = Sheets("特定シート").Index + 1 ReDim Sh(t To Sheets.Count) For i = t To Sheets.Count Sh(i) = Sheets(i).Name Next i Sheets(Sh).Copy after:=Workbooks("Bシート.xls").Sheets(1) End Sub
カウントダウンさせるには最初にタイマーを停止する時刻を計算しておくのが定石です。 Public Class Form1 Private StopTime As DateTime Private CountDownTime As TimeSpan Public Sub New() InitializeComponent() 'タイマーをストップさせるまでの時間を保存しておく CountDownTime = New TimeSpan(0, 1, 30) 'タイマーをストップさせる時刻を保存しておく StopTime = DateTime.Now + CountDownTime 'Timer1を有効にする Timer1.Enabled = True End Sub Private Sub Timer1_Tick(sender As System.Object, e As System.EventArgs) Handles Timer1.Tick '残り時間を更新する CountDownTime = StopTime - DateTime.Now '残り時間が0以下になったらタイマーを停止する If CountDownTime.Ticks < 0 Then CountDownTime = New TimeSpan(0) Timer1.Enabled = False End If 'Label1に残り時間を表示する Label1.Text = CountDownTime.ToString("hh\:mm\:ss") End Sub End Class
「TeraTerm」が便利です。 https://osdn.jp/projects/ttssh2/ TeraTermは本来はサーバーにTelnet接続するためのフリーソフトですが、ルーターの中にはシリアル接続して設定を行うものもあるため、シリアル通信にも対応しています。 TeraTermでシリアル通信を行う方法 http://www.j-oosk.com/teraterm/serial/346/
(vba) Removeの引数は指定してますか？ UserForm1.Controls.Remove "Label"
確認ですが，，， 「ｖｂｓ」というのは 拡張子「.vbs」の「VBS」ファイルのことですよね？ そしてそこで使われる VBScript のご質問ですよね？ そもそもからして 書かれていらっしゃる「ｖｂｓ」は "全て全角" になっていて 例えば「.ｖｂｓ」などという拡張子を付けても 無事に動作しないと思いますが。。。 (プログラムは厳格です。キッチリ書くようにしましょう。) > プログラムで、同じウィンドウ（タブ？）を一度に > たくさん表示したいのですがどうすればいいのでしょうか？ 「複数のウインドウ(IEのウィンドウ)を開く」のと 「1つのウィンドウ(IEのウィンドウ)に複数タブを開く」のとでは スクリプトが異なります。 ここら辺もキッチリ(ハッキリ)させましょう。 この知恵袋は http から始まる URL を書くと勝手にリンクが付いてしまう上に， その自動リンクの数制限で ３つの URL までしか書けません。 (自動リンク機能など要らないのに...ブツブツ。。。) したがってまずは回答欄に 「複数のIEウィンドウを開く」スクリプト例を書いて 返信欄に 「1つのIEウィンドウに複数タブを開く」スクリプト例を書くことにします。 ◎「複数のIEウィンドウを開く」スクリプト例↓ 'IEオブジェクト達を作成 Set ObjIE0 = CreateObject("InternetExplorer.Application") Set ObjIE1 = CreateObject("InternetExplorer.Application") Set ObjIE2 = CreateObject("InternetExplorer.Application") 'IE画面達を表示 ObjIE0.Visible = True ObjIE1.Visible = True ObjIE2.Visible = True '「Yahoo!」を表示 ObjIE0.Navigate2 "http://www.yahoo.co.jp/" '「Google」を表示 ObjIE1.Navigate2 "https://www.google.co.jp/" '「goo」を表示 ObjIE2.Navigate2 "http://www.goo.ne.jp/" Set ObjIE0 =Nothing Set ObjIE1 =Nothing Set ObjIE2 =Nothing
引数名のない引数というのはありません。 それを使うか使わないかだけの違いです。 Worksheets.Add の引数の並びは、 Before, After, Count, Type となっています。 引数名Countを省略した場合は、３番目だけを指定するという意味で Worksheets.Add ,,2 （←Beforeと Afterは省略するという意） と記述します。 ところが、これでは２という値が何の引数なのか、パッと見て分かり難いので Worksheets.Add Count:=2 という書き方をするのが一般的です。 また引数名を指定すると、省略するときのように , (カンマ)で区切る必要もないので見やすくなります。 もっともMsgBoxのようなものは、いちいち引数名を指定すると長くなるので、省略することもあります。 引数名を使うか使わないかは、見易さと使いやすさで判断してもいいと思います。
変数も可能なようですよ。 c = 3 Worksheets.Add Count:=c これで、きちんと3シート追加されました。
Worksheets.Add CountはAddメソッドの第一引数BeforeにCountという変数を値として設定しているから VBEのオプションで、「変数の宣言を強制する」に チェックを付けるか モジュールの宣言部（先頭）にOption Explicit を追加してみると・・・
> For i = MaxRow_Z To 3 Step -12 これは For i = MaxRow_Z To 3 Step -2 ですよね MaxRow_Z が偶数なら MaxRow_Z - 1 から For ･･･ MaxRow_Z が奇数なら MaxRow_Z - 0 から For ･･･ ここでの - 1, - 0 を True / False を使って･･･ VBA では、True / False → -1 / 0 なので、 偶数か･･･？ と聞いて True なので -1 することになり奇数に･･･ True / False の -1 / 0 をそのまま演算に使うことはありますね 気持ちが悪いのであれば以下の様な書き方でも If ((MaxRow_Z Mod 2) = 0) Then MaxRow_Z = MaxRow_Z - 1
オプションも引数も同じ意味じゃないのかなぁ Count:=2 の場合Countが引数名で2は値 :=は引数に値を渡す記号 だと思うが
ブレークポイントを配置して診断ツールでミリ秒単位の経過時間を見ることはできます
ツールボックスダイアログ ↓ マルチページボタン 右クリック ↓ その他のコントロールを 左クリック ↓ コントロールの追加ダイアログ 表示される
train_benoistさんではありませんが、 Imports System Imports System.Drawing Imports System.Windows.Forms Public Class Form1 Public Sub New() InitializeComponent() Setting() End Sub Private Sub Setting() Label1.Font = New Font(Label1.Font.FontFamily, 22, Label1.Font.Style) 'ラベルのフォントサイズを変更 'タイマーをスタート Timer1.Start() End Sub Private Sub Timer1_Tick(sender As System.Object, e As System.EventArgs) Handles Timer1.Tick ' 現在時を取得 Dim datetime_now As DateTime = DateTime.Now Dim datetime_set As DateTime = New DateTime(datetime_now.Year, datetime_now.Month, datetime_now.Day, 23, 59, 0) '残り時間を表示 Label1.Text = "残り：" & (((datetime_set.Hour - datetime_now.Hour) * 3600) + ((datetime_set.Minute - datetime_now.Minute) * 60) + (datetime_set.Second - datetime_now.Second)) & "秒" If datetime_now.ToLongTimeString() = datetime_set.ToLongTimeString() Then Label1.Text = "時間です。" 'タイマー停止 Timer1.Stop() End If End Sub End Class
等価(=)はもちろんですが、全く同じ場合という意味です。販売と販売日は文字列として見ると全く同じではありませんよね？ですからIf文はFalseと評価されるので中の処理は実行されません。なので、 If TextBox1.Value = Cells(i, 2) Then の部分を If InStr(Cells(i, 2).Value, TextBox1.Value) > 0 Then とします。InStr関数は対照文字列内に検索文字列が存在する場合は検索文字列の先頭の文字が対照文字列内の何番目かを返し、見つからない場合は0を返します。なので>0とする事で含まれている事を確認する事が出来ます。
最初にどんな名前のシートがあって、 最終的にどんな並びにしたいのでしょうか？
下記のサイトを参考にしてください。 http://www.moug.net/tech/exvba/0020008.html
変数の記載場所とその適用範囲は覚えておきましょうね。 参考 http://officetanaka.net/excel/vba/variable/05.htm 回答は前の方がされているので控えておきます。
Visual BasicにTruckViewなるコントロールはなさそうだし、ライブラリでも無さそうだし、何の事なんですかねぇ。 もう少し詳しく書いていただけると、回答が付くかもしれませんね。
「asp net mvcボタンクリック」で検索してみてはいかがでしょうか？
たぶん、ここでしょう。 >Dim fso As New FileSystemObject Microsoft Scripting Runtime への参照設定が必要です。
vbaはあまりオブジェクト指向にとらわれるとやりにくいかもです。 どのアプリのVBAを勉強したいのかはわかりませんが、エクセルならモーグさん、オフィス田中さんあたりがメジャーだと思います。 基本的にはVB6.0なんで全体的にというならそっちを勉強したほうがいいのかな？
Visual Studioのバージョンアップに合わせて多少なりともランニングコストかかる気がしますが。 Javaから移行となると、完全置き換え（サーバの構成も見直し必要じゃないですか？）になるでしょうから、開発費用が今後のJava運用時のコストを上回らんければいいと思うんですが...
XCOPYということは、ファイルをディレクトリ構造ごとコピーしているんですね。 XCOPYのオプションの後フォルダパス、ファイルパスが記述をダブルクォーテーションでくくってみてください。 もしかするとフォルダ名にスペースが含まれているのでうまく動いていないのかも。 （Program Files (x86)等） 【例】xcopy /Y "C:\hoge\hoge.dll" "C:\hoge\hogehoge\"
↓のような例文は、参考になりますか？ A列の最終行を求め、TextBox1の値を格納します。 Dim i As Long i = Cells(Rows.Count, 1).End(xlUp).Offset(1).Row Cells(i, 1).Value = TextBox1.Value
値の入っていない、という状態が空欄のセルということで良いのであれば、全てのシートのうち、C4に何らかの入力があるシートのみを印刷する場合は、以下のようにできます。 Set wb=Workbooks("ブック名") For Each ws In wb.Worksheets If (ws.Range("C4") <> "") Then ws.PrintOut Next
>規格を満たしていれば というのが、「A1の値が負ならば」ということなら、以下の式 =IF(A1="","",IF(A1<0,"○","Ｘ"))
A3からA7には間違いなく、正しいファイル名が入っていますか？ t_path = "C:\pict\" & Selection.Value & ".JPG" なので、フォルダ抜きで拡張子なしのファイル名でないとならないです。 こちらのテストでは正しく入っていない場合（例えば.jpgまでつけてしまった）のような場合記載されたエラーになりました。 正しいファイル名ですと、図形の中に表示されています。
ぐぐればいっぱいsampleがでてきますよ？ まずは調べることから始めましょうよ・・・。 聞くことから初めて理解できますか？ https://www.google.co.jp/search?q=excel+vba+%E3%83%95%E3%82%A1%E3%8...
以下のコードを試してみてください。 Sub Sample() Dim r(56) Dim i As Long, j As Long For i = 20 To 56 Step 2 If Cells(i, 1) <> "" Then r(j) = Cells(i, 1).Value r(j + 1) = "" j = j + 2 End If Next Range("A20:A57") = WorksheetFunction.Transpose(r) End Sub
ThisWorkBook.Close 自分自身を閉じているので、ここでコード終わっちゃってるんじゃないかな。 Sub a() ThisWorkbook.Save ThisWorkbook.Close MsgBox "aaa" End Sub で、aaaのメッセージボックス出なかったし。
Dim x(k) As Double こういった宣言をする為には、kが定数であることが条件です。変数は使えません。 x(0) = x(1) = 0 代入式に、このような形はありません。きちんと2行に分けて、個別に代入してください。 他は特にミスは見当たりません。Do文と次の行がくっついていますが、投稿時のミスか、システムの問題だと思いますので。
こんな感じでしょうか？ Sub AHO() Dim T, K For T = 1 To 100 If T Mod 3 = 0 Or InStr(1, T, "3") Then K = "アホ" Else K = T End If Debug.Print K Next End Sub
確認するだけなら「form.frm」をメモ帳で見ればいけませんか？ 実は他にファイルがありましたって落ちならばどうにもなりませんが。 exeファイルを逆変換するツールとか探せばあるかもしれませんね。 「8時.vbp」がVB6で編集する時に最初に起動するファイルで 「8時.vbw、Project1.vbw、MSSCCPRJ.SCC」が勝手に出来るファイルだった様な気がします。 exeは実行ファイルだから、消去法的にコードが見れるのは「form.frm」じゃないかと。 あとVB6はVB6の製品が無いと変更出来なかったはずですから フリーソフトで変更は無理だと思います。 見た所１フォームしかない簡単な作りなので excel、vb.netなどで作りなおすのが無難かと。
日付が*で区切られているようにみられるので、 explode関数を使用して、配列に分割するか、 for(explode("*", $trading_day) as $day_str){ echo $day_str . "\n"; // ブラウザ上でみるなら、."<br/>" } str_replace関数を使用して、*を置き換えるかすればいいかと。 $trading_day = str_replace("*", "\n", $trading_day ); // ブラウザ上でみるなら、."<br/>" echo $trading_day;
《ボタンを押したら》とか考えず、テキストファイルへ追加モードで書き込むのを調べてみたら良いと思います →これを新規プロジェクトで一度作ってみて、成功したら組み込めば良い
拗音を除いた文字数とは？ たとえば「あしゅら」は何文字となれば正解ですか？ (1) 「あ」「ら」の２文字 (2) 「あ」「し」「ら」の３文字 拗音は「ゃ」「ゅ」「ょ」が付いた文字なので、この文字数が判れば計算できます。 Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click Dim buf As String, i As Long, cnt As Long Dim t As Integer Dim c As String Dim cnt2 As Long '拗音の個数 buf = Textbox1.text For i = 1 To Len(buf) c = Mid(buf, i, 1) If ("ぁ" <= c) And (c <= "ん") Then cnt = cnt + 1 If (c = "ゃ") Or (c = "ゅ") Or (c = "ょ") Then cnt2 = cnt2 + 1 Ebd If Next i t = cnt - cnt2 * 2 '(1)の個数 t = cnt - cnt2 '(2)の個数 End Sub
こんばんは。 共有モードでは、オブジェクトの挿入・変更作業そのものができない仕様のようです。 参考：http://www.atmarkit.co.jp/ait/articles/1110/14/news152_2.html
1行ずつというのは大変ですし、かえって分かりにくいと思いますので、まずはブロック毎の流れから説明します。 For m = 1 To INT_EM EmName = Worksheets(SHEET2).Cells(1, m).Value endrowEm = Worksheets(SHEET2).Cells(Rows.Count, m).End(xlUp).Row '略 Editrow = 1 Next m ここは、条件シートのセルに記載されている対象シート名を取り出し、そのシート名のシートを対象に処理を行なう、というループを組んでいます。 >EmName = Worksheets(SHEET2).Cells(1, m).Value この行で、シート名を取り出しています。ループ変数mは列番号を表わしており、条件項目列数で定義された数だけ繰り返します。 次に、上記ループ内の処理ですが、順序としては、 1.ブック内に対象シートがあったら削除 2.新規シートを追加して、対象シート名へと変更 3.ツイートDBシートと条件シートのデータを全角で比較し、条件シートのデータがツイートDBに含まれていた場合、ツイートDBの対象行データを対象シートに順番にコピー となっています。 1.シート削除 For Each ws In Worksheets If ws.Name = EmName Then Application.DisplayAlerts = False Worksheets(EmName).Delete Application.DisplayAlerts = True End If Next ws 2.新規シート作成、シート名変更 Set ws = Worksheets.Add() ws.Name = EmName 3.ツイートDBとの比較 For i = 2 To EndrowTw For k = 2 To endrowEm If InStr(StrConv(Worksheets(SHEET1).Cells(i, COL_TW).Value, vbWide), StrConv(Worksheets(SHEET2).Cells(k, m).Value, vbWide)) Then Worksheets(SHEET1).Select Worksheets(SHEET1).Rows(i).Select Worksheets(EmName).Rows(Editrow).Value = Selection.Value Editrow = Editrow + 1 Exit For End If Next k Next i その他、プロシージャ外にあるConstは、共通で使う定数宣言、Dimは使用する変数宣言です。 1行ずつでは、機能把握が大変です。まずはブロックの流れがこうなっていることをご理解ください。 その上で、細かい部分で分からないところを返信してください。 慌てず、順番に行きましょう。
IE制御は、そのページのHTMLソースに合わせる必要があり、ページ毎に異なると言っても良いでしょう。 その為、抽象的な言葉で部分的にページ構成を説明されても、具体的なコードを示しづらいです。もちろん、自身で応用できるのであれば提案のしようもあるのですが、そうではないことは言明されていますね。 とりあえず、アップロード先のURLを開示できるのであればそれを、開示できないのであればHTMLソースをどこかにアップロードしてください。
文字がつぶれて何が何だか、
こんにちは。 このコード、70行を削除してください。 数値70enterとしたら、削除できます それから、listで、すべての行を表示させてください。 画面の様子にいわかんがあります
Androidstudioについてはよく知りませんが、エディタ画面のフォントが「Pゴシック」や「MS UI ゴシック」などになっていませんか？ プロポーショナルフォント（文字ごとに横幅がちがうフォント）だと文字数が同じでもずれて見えます。 フォントを「MS ゴシック」などに変えられるのなら変えてみてください。
ActiveWorkbook.SaveAs では PDFファイルを保存できません。 できているように見えているのは、拡張子が.pdfになっているExcelのファイルです。 pdfで保存する場合は、ExportAsFixedFormatメソッドを使用します。 ActiveWorkbook.ExportAsFixedFormat Type:=xlTypePDF, Filename:=fname パラメータの詳細については、こちらを参照ください。 http://tohoprog.sblo.jp/article/37555963.html https://msdn.microsoft.com/ja-jp/library/microsoft.office.tools.exc...
早い話 年テキスト & "/" & 月コンボ & "/" & 日コンボ が日付データか否かをチェックすればいいのでしょうか。 Dim Dt As Date On Error Resume Next Dt = 年テキスト & "/" & 月コンボ & "/" & 日コンボ If Err.Number <> 0 Then MsgBox "日付が間違っています" Exit Sub End If On Error GoTo 0 With Sheets("操作画面") .Range("B1") = Dt 曜日 = Format(Dt, "aaa") End With 日付データなら、曜日はFormat関数で求めたほうが確実で早いでしょう。
「SR 2種類 1%」「R 6種類 3%」「N 16種類 5%」の最後のパーセントはどういう意味ですか？ のこりの92%は何？ C1:C100に書き出したら次は何をするのですか？ 100回繰り返すといってもそれぞれのシミュレーションの結果はどこにどういう形で残すのですか？ 自分が何をどうしたいのか、赤の他人にも通じるような文章で説明し直してください。
そうですか。 頑張って作ってくださいネ！
下記のサイトは参考になりませんか？ http://oshiete.goo.ne.jp/qa/9232653.html
※元のエクセルはセルの結合等はしていません。 A1～E675の中に 結合セルは ありませんか?
CancellationTokenを使ってみました。 public partial class Form1 : Form { private CancellationTokenSource tokenSource = new CancellationTokenSource(); private Task task = null; public Form1() { InitializeComponent(); } private void Form1_Load(object sender, EventArgs e) { task = taskNagai(tokenSource.Token); } private async void button1_Click(object sender, EventArgs e) { tokenSource.Cancel(); try { await task; } catch (OperationCanceledException) { } } private uint Kansu() { return 10; } private async Task taskNagai(CancellationToken token) { uint uiLv; await Task.Run(() => { while (true) { token.ThrowIfCancellationRequested(); Thread.Sleep(10); uiLv = Kansu(); } }, token); } }
以下でどうなりますか Public Sub Samp1()    Dim v As Variant    v = Split(Range("A2").Value, ".")    With Range("A5").Resize(UBound(v) + 1)       .Value = WorksheetFunction.Transpose(v)       .TextToColumns .Cells(1), xlDelimited _          , Other:=True, OtherChar:="-"    End With End Sub
変更前 Workbooks.Open Filename:=mypath & "\book2.xlsm" 変更後 Workbooks.Open Filename:=mypath & "\book2.xlsm", UpdateLinks:=True https://msdn.microsoft.com/ja-jp/library/office/ff194819.aspx
オブジェクト全てというのが、セルの書式・値・罫線、図形・マクロ用のボタンやチェックボックスなど、まさにシートに存在するすべて、というのであれば、 ①シートをコピーする ②「別シート」を削除する ③コピーしたシートを「別シートの名前」にリネームする という手順がもっとも手っ取り早いと思うのですが？
Function CrossStr(SH3 As Worksheet, StrY As String, StrX As String, OffY As Integer, OffX As Integer) As String Static Rng As Range Static YY As Integer Static XX As Integer Set Rng = SH3.Cells.Find(what:=StrY, lookat:=xlPart, LookIn:=xlValues) If Rng Is Nothing Then CrossStr = "" Exit Function Else YY = Rng.Row + OffY End If Set Rng = SH3.Cells.Find(what:=StrX, lookat:=xlPart, LookIn:=xlValues) If Rng Is Nothing Then CrossStr = "" Exit Function Else XX = Rng.Column + OffX End If Set Rng = Nothing CrossStr = SH3.Cells(YY, XX).Value End Function Function ハイフン(SS As String) As String Static A As String A = StrConv(SS, vbNarrow) A = Replace(A, "―", "-") A = Replace(A, "‐", "-") A = Replace(A, "－", "-") A = Replace(A, "ｰ", "-") A = Replace(A, "￣", "-") ハイフン = A End Function Sub フォルダ名入力() Static DN As String With Application.FileDialog(msoFileDialogFolderPicker) .InitialFileName = ActiveWorkbook.Path If .Show <> 0 Then DN = .SelectedItems(1) Else DN = "" End If End With Worksheets("設定").Range("B1").Value = DN End Sub Sub ファイル名入力() Static Fn As String Fn = Application.GetOpenFilename Worksheets("設定").Range("E19").Value = Right(Fn, Len(Fn) - InStrRev(Fn, "\")) Workbooks.Open Fn End Sub Sub データ転送() Static Fn1 As String Static Fn2 As String Static X(3) As Integer Static Y1 As Integer Static Y2 As Integer Static Str1 As String Static Str2 As String Static Str3 As String Static Str4 As String Static Rng As Variant '設定の値を取得 Fn1 = ThisWorkbook.Name X(0) = Workbooks(Fn1).Worksheets("設定").Range("E20").Value X(1) = Workbooks(Fn1).Worksheets("設定").Range("E21").Value X(2) = Workbooks(Fn1).Worksheets("設定").Range("E22").Value X(3) = Workbooks(Fn1).Worksheets("設定").Range("E23").Value Fn2 = Workbooks(Fn1).Worksheets("設定").Range("E19").Value 'メイン処理 Y2 = 2 Do Until Workbooks(Fn2).ActiveSheet.Cells(Y2, 1).Value = "" '検索キーを取得 Str1 = Workbooks(Fn2).ActiveSheet.Cells(Y2, X(0)).Value Str2 = Workbooks(Fn2).ActiveSheet.Cells(Y2, X(1)).Value Str3 = Workbooks(Fn2).ActiveSheet.Cells(Y2, X(2)).Value Str4 = Str1 & "_" & Str3 & "_" & Str2 '検索キーで検索し行数Y1を取得する。 Set Rng = Workbooks(Fn1).Worksheets("Sheet1").Columns(17).Find(what:=Str4, lookat:=xlPart, LookIn:=xlValues) If Rng Is Nothing Then Else Y1 = Rng.Row '対象のシートに数値を転送する。 Workbooks(Fn2).ActiveSheet.Cells(Y2, X(3) + 0).Value = Workbooks(Fn1).Worksheets("Sheet1").Cells(Y1, 8).Value Workbooks(Fn2).ActiveSheet.Cells(Y2, X(3) + 1).Value = Workbooks(Fn1).Worksheets("Sheet1").Cells(Y1, 9).Value Workbooks(Fn2).ActiveSheet.Cells(Y2, X(3) + 2).Value = Workbooks(Fn1).Worksheets("Sheet1").Cells(Y1, 10).Value Workbooks(Fn2).ActiveSheet.Cells(Y2, X(3) + 3).Value = Workbooks(Fn1).Worksheets("Sheet1").Cells(Y1, 11).Value Workbooks(Fn2).ActiveSheet.Cells(Y2, X(3) + 4).Value = Workbooks(Fn1).Worksheets("Sheet1").Cells(Y1, 12).Value Workbooks(Fn2).ActiveSheet.Cells(Y2, X(3) + 5).Value = Workbooks(Fn1).Worksheets("Sheet1").Cells(Y1, 13).Value Workbooks(Fn2).ActiveSheet.Cells(Y2, X(3) + 6).Value = Workbooks(Fn1).Worksheets("Sheet1").Cells(Y1, 14).Value Workbooks(Fn2).ActiveSheet.Cells(Y2, X(3) + 7).Value = Workbooks(Fn1).Worksheets("Sheet1").Cells(Y1, 15).Value Workbooks(Fn2).ActiveSheet.Cells(Y2, X(3) + 8).Value = Workbooks(Fn1).Worksheets("Sheet1").Cells(Y1, 16).Value End If Y2 = Y2 + 1 Loop Set Rng = Nothing End Sub
Public Sh1 As Worksheet Public F_Row As Integer Public FolderName(99999) As String Public F_No1 As Integer 'フォルダ位置(書出用) Public F_No2 As Integer 'フォルダ位置(現在位置) Public Ken(13) As String '検索キーワード等 Sub FileName1() Static Pa As String With Application .Calculation = xlCalculationManual .ScreenUpdating = False .DisplayAlerts = False End With '検索キーワード等設定 Ken(0) = Worksheets("設定").Range("E3").Value Ken(1) = Worksheets("設定").Range("F3").Value Ken(2) = Worksheets("設定").Range("E4").Value Ken(3) = Worksheets("設定").Range("E5").Value Ken(4) = Worksheets("設定").Range("E6").Value Ken(5) = Worksheets("設定").Range("E10").Value Ken(6) = Worksheets("設定").Range("F10").Value Ken(7) = Worksheets("設定").Range("D11").Value Ken(8) = Worksheets("設定").Range("D12").Value Ken(9) = Worksheets("設定").Range("D13").Value Ken(10) = Worksheets("設定").Range("D14").Value Ken(11) = Worksheets("設定").Range("G10").Value Ken(12) = Worksheets("設定").Range("E27").Value Ken(13) = Worksheets("設定").Range("E28").Value 'Pa指定 Set Sh1 = ActiveSheet Sh1.Range("A2:Z10000").ClearContents Sh1.Cells.Hyperlinks.Delete Pa = Worksheets("設定").Range("B1").Value 'メイン処理 F_Row = 2 Erase FolderName F_No1 = 1 F_No2 = 0 FileName2 (Pa) Set Sh1 = Nothing With Application .Calculation = xlCalculationAutomatic .ScreenUpdating = True .DisplayAlerts = True End With End Sub Sub FileName2(Pa As String) Static C_Fn As String '現在位置のファイル名またはフォルダ名 Static Sh2 As Worksheet Static Str1 As String Static Str2 As String Static Str3 As String '現在の階層のファイル名とフォルダ名を取得する。 C_Fn = Dir(Pa & "\*.*", vbDirectory) Do Until C_Fn = "" If C_Fn <> "." And C_Fn <> ".." Then If InStr(1, C_Fn, "?") = 0 Then '区分入力、フォルダ名を配列に格納 If GetAttr(Pa & "\" & C_Fn) And vbDirectory Then 'フォルダ名を格納 FolderName(F_No1) = Pa & "\" & C_Fn F_No1 = F_No1 + 1 Else 'Fn2を開く。 Workbooks.Open Pa & "\" & C_Fn For Each Sh2 In Workbooks(C_Fn).Worksheets 'フォルダ名、ファイル名、シート名 Sh1.Cells(F_Row, 1).Value = Pa Sh1.Hyperlinks.Add Anchor:=Sh1.Cells(F_Row, 1), Address:=Pa Sh1.Cells(F_Row, 2).Value = C_Fn Sh1.Hyperlinks.Add Anchor:=Sh1.Cells(F_Row, 2), Address:=Pa & "\" & C_Fn Sh1.Cells(F_Row, 3).Value = Sh2.Name '見出し Sh1.Cells(F_Row, 4).Value = Sh2.Range(Ken(0)).Value & "-" & Sh2.Range(Ken(1)).Value Sh1.Cells(F_Row, 5).Value = Sh2.Range(Ken(2)).Value Sh1.Cells(F_Row, 6).Value = Sh2.Range(Ken(3)).Value Sh1.Cells(F_Row, 7).Value = Sh2.Range(Ken(4)).Value '数値 Sh1.Cells(F_Row, 8).Value = CrossStr(Sh2, Ken(10), Ken(5), 0, 2) Sh1.Cells(F_Row, 9).Value = CrossStr(Sh2, Ken(7), Ken(6), 0, 0) Sh1.Cells(F_Row, 10).Value = CrossStr(Sh2, Ken(8), Ken(6), 0, 0) Sh1.Cells(F_Row, 11).Value = CrossStr(Sh2, Ken(9), Ken(6), 0, 0) Sh1.Cells(F_Row, 12).Value = CrossStr(Sh2, Ken(10), Ken(6), 0, 0) Sh1.Cells(F_Row, 13).Value = CrossStr(Sh2, Ken(7), Ken(11), 0, 0) Sh1.Cells(F_Row, 14).Value = CrossStr(Sh2, Ken(8), Ken(11), 0, 0) Sh1.Cells(F_Row, 15).Value = CrossStr(Sh2, Ken(9), Ken(11), 0, 0) Sh1.Cells(F_Row, 16).Value = CrossStr(Sh2, Ken(10), Ken(11), 0, 0) Str1 = CrossStr(Sh2, Ken(12), Ken(12), 1, 0) Str1 = StrConv(Str1, vbNarrow) Str2 = CrossStr(Sh2, Ken(13), Ken(13), 1, 0) Str2 = Format(Str2, "yyyy/mm/dd") Str3 = Sh2.Range(Ken(3)).Value Str3 = ハイフン(Str3) Sh1.Cells(F_Row, 17).Value = Str2 & "_" & Str1 & "_" & Str3 F_Row = F_Row + 1 Next 'Fn2を閉じる。 Workbooks(C_Fn).Close End If End If End If C_Fn = Dir Loop '次の階層へ以降する。 F_No2 = F_No2 + 1 If FolderName(F_No2) = "" Then Exit Sub FileName2 (FolderName(F_No2)) End Sub
具体的なことが まーーーったく わかりませんが。。。 ご自身でご質問を今読み返してみて 「何をどうしたいのか」がわかりますか？ . 推測混じりですが まずご質問からわかることを書きます。 ◎ どこか任意のフォルダ(サーバ上かローカルかは不明)に    複数の行のタブ区切りのテキストデータファイルがあり    どのファイルも同じ行数である。 【例】任意のフォルダ内のファイル例 ・「果物.tsv」ファイル データ内容例↓ 1   リンゴ      200 2   ブドウ      500 3   バナナ      150 ・「野菜.tsv」ファイル データ内容例↓ 1   キュウリ   200 2   カボチャ   400 3   タマネギ   100 ・「食肉.tsv」ファイル データ内容例↓ 1   トリ         200 2   ブタ         250 3   ウシ         600 ※ 補足    なおココ(HTML)では タブ は表せないので上のデータは    「HTML初心者です。coteditorという... - Yahoo!知恵袋」    http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1312987467...    この方法にて タブ を複数の \U00A0 で代用しています。 推測で想像できるのはこれくらいなものです。 === === === === === > VBScriptでの実装に関して質問です。 まず VBScript とはどこで使われる VBScript の話ですか？ WSH の「VBS」ファイルで使われる VBScript もあれば HTML や HTA で使われる VBScript もあれば ASP で使われる VBScript もあります。 同じ VBScript でも使い方が全然違います。 「VBScript - Wikipedia」 https://ja.wikipedia.org/wiki/VBScript . > なお、一番左の列はＮｏフィールドとなっており、 > ここは連結の起点となる > 最初のリストファイルのものだけを残し、 一番左の列には数字が入っているのはわかります。 そこはわかりますが 「最初のリストファイル」の「最初」とはどのファイルが「最初」なのですか？ 上記ファイル例 「果物.tsv」「野菜.tsv」「食肉.tsv」のファイル順は 私が勝手に思いつきで決めた順です。 もしその「果物.tsv」「野菜.tsv」「食肉.tsv」の順で良いのでしたら 1    リンゴ    200    キュウリ    200    トリ    200 2    ブドウ    500    カボチャ    400    ブタ    250 3    バナナ    150    タマネギ    100    ウシ    600 こんなデータになるのですよ。 もし「食肉.tsv」「果物.tsv」「野菜.tsv」の順が良いのでしたら 1    トリ    200    リンゴ    200    キュウリ    200 2    ブタ    250    ブドウ    500    カボチャ    400 3    ウシ    600    バナナ    150    タマネギ    100 こんなデータになります。 データの形が全然違いますよね。 データの形が違えば 何列が何を表すのか不明になり後の処理が超大変になります。 「何を基準に最初などの順番を決めているのか」がわからなければ 無茶苦茶なデータができるだけです。 もし無茶苦茶な順のデータで良いのでしたら適当に書けるのかもしれませんが。 . さらに 複数行からできているのでしたら 「改行」で行のデータを区切っていると思います。 その「改行コード」は何なのですか？ VB系的な改行の言い方をすれば vbCrLf も改行コード，vbLf も改行コード vbCr も改行コードです。 また 日本語をなどを扱う場合は 文字コード もハッキリさせておいた方が良いでしょう。 また拡張子も 私が勝手に「.tvs」にしていますが「.txt」かもしれません。 この辺も具体的にハッキリさせた方が良いでしょう。 (ファイル選択時やエラー処理に関係するかもしれないので。) . さらにさらに 「希望通り！」かどうかは知りませんが， 仮に次のようなデータができたとしましょうか。 1    キュウリ    200    トリ    200    リンゴ    200 2    カボチャ    400    ブタ    250    ブドウ    500 3    タマネギ    100    ウシ    600    バナナ    150 これをどうするのですか？ 例えば WScript.Echo や MsgBox みたいなので表示させるだけで良いのでしょうか？ . ご質問文からでは 具体的なことが全くわかりませんよね？ 「とりあえず最初に何からすれば良いのか？」も 「できた後最後に何をすれば良いのか？」も判断できません。 唯一，提示できるのは次のページくらいなものです。 「文字列の定数」 https://msdn.microsoft.com/ja-jp/library/cc392241.aspx . なお この回答の【返信】欄で補足説明をされても その【返信】欄では文字数不足になるため十分な回答はできないと思います。 そもそも私は VBScript が専門ではありませんし (ASP の VBScript など私は全くわからない) 具体的なことがわかれば私以外にわかる方もいらっしゃると思います。 ですから 回答の【補足】欄で補足していただくか 最初から質問文を考え直して「VisualBasic」または「ASP系」カテゴリで再質問された方が良いように思います。
これは、とりあえず版です。 シートが、アクティブシートだけでいいのかもわかりません。 これから出かけるので、明日までメンテナンスはできません。 色々なフォルダにデータがあるのなら、それを指定して、一度に行うことも考えられます。 フォルダがどのようになっているのか（１つのフォルダで、サブフォルダまで調べてぜんぶなのか、それとも、処理したいフォルダがあちこちにあるのか）、ご記入ください。 明日でよければ、メンテナンスします。 ' Option Explicit ' Sub Macro1() '     Dim FileName As String '     ChDrive Left(ThisWorkbook.Path, 2)     ChDir ThisWorkbook.Path     FileName = Dir("*.xls*") '     Do While FileName > "" '         If FileName <> ThisWorkbook.Name Then             Workbooks.Open FileName             [A:A].Delete Shift:=xlToLeft             [B:C].Delete Shift:=xlToLeft             ActiveWorkbook.Save             ActiveWorkbook.Close         End If         FileName = Dir     Loop ' End Sub '
前の質問では 「原本シートが原本シートの後ろにコピーされる」 と書いてあるのに一番後ろにコピーされるコードが採用されていますが、その辺はどうなんでしょう？ 原本シートの後ろにコピーされるコードです。一番後ろに持っていくのも前の質問の回答を参考にすればいいのでそこは適当に。原本シートがない場合のエラー処理はしていません。 Sub Tesr() Dim sh As Worksheet Dim fr As Boolean For Each sh In Worksheets If sh.Name = Format(Date, "yyyymmdd") Then fr = True Next If fr = True Then MsgBox "今日の日付のシートは既に作成済みです" Exit Sub End If Sheets("原本").Copy After:=Sheets("原本") With ActiveSheet .Name = Format(Date, "yyyymmdd") .Range("A1") = Date End With End Sub
Sub 一例です() Dim sh As Worksheet, i As Long i = 1 With Worksheets("メイン") For Each sh In Worksheets If sh.Name <> .Name And sh.Name <> "原本" Then i = i + 1 .Cells(i, 1).Value = sh.Name End If Next sh End With End Sub
最初のSCRIPTタグを取得すれば何とかなるのではないでしょうか。 msg=ie.document.getElementsByTagName("script")(0).outerHTML これでSCRIPTタグのHTML記述が取得できますので、後はmsgに対して文字列操作命令(InStr、Mid)で、目的の文字列を切り出せば良いはずです。
With Worksheets.Add Set xRng = .Cells(1, 1).Resize(, 4) End With ↓ With Worksheets.Add .Name = "結果" Set xrng = .Cells(1, 1).Resize(, 4) End With 未実行です。 ひょっとしたら、作者は私？
まぁまず、謎の単語が出てくる仕様じゃどうもならんでしょうが、推測。 ボタンに画像を表示して、押した時に別画像に切り替える。まぁ、これは判る。じゃ、いつ元に戻すのか？これが決まらないと作れないですよ。 トグルボタンみたいにONとOFFを表すのであれば、クリック時に状態を静的に判断してやれば画像のON-OFFが管理できますね。 またはボタンを押しこんでいるときにだけ画像が変わり、ボタンを離すと元に戻るタイプ。マウス操作やタッチパネル操作で処理が判りにくいときなどよくやりますね。 これはMouseDownとMouseUpもしくはMouseLeaveで画像の切り替えをしてやれば良い。 こんぐらいの事なんでwebじゃナカナカ扱っていないかもね。
kuro_neko_g_sanさんが回答された日本郵便のWebサイトのダウンロードデータはパソコンで扱うには全く役に立たないデータです。 （IT業界の人間でも知らない人が多くて困ります） パソコンで扱うのに適したデータは下記のサイトにあります。 http://zipcloud.ibsnet.co.jp/ 「郵便番号データ（加工済バージョン）のダウンロード」からダウンロードして下さい。
コンボボックスの名前が間違っていませんか？
こんな感じ Sub 採番() Dim i As Long Const 始め = 1322 Const 終わり = 1543 Dim cnt As Integer cnt = 1 For i = 始め To 終わり If i Mod 100 <> 0 Then Cells(cnt, 4).Value = Left(i, 2) & "-" & Right(i, 2) cnt = cnt + 1 End If Next i End Sub 連番で振って、下２ケタが００の時は除外する
以下でどうなりますか 新規ファイルを開き、以下を標準モジュールに転記し、 Sheet1 / Sheet2 がある状態で、 testData を実行するとテスト用データが出来上がります その後 Samp1 を実行してみます やっていることは、 Sheet1 の .Cells(i, "A") からの相対として CRNG を参照します .Cells(i, "A").Range(CRNG) すると , 区切り＝領域と解釈でき、 >   Set rng = Worksheets("Sheet2").Range("A1") によって、 A 列指定した rng の Offset と合わせて、データを設定します Sheet2 は前回の続き･･･なら、コメント部分を有効にしてみてください また、必要なら Sheet2 を綺麗にしてからとか･･･ Public Sub Samp1()    Dim rng As Range    Dim i As Long, j As Long, k As Long    Const CRNG As String = _       "B1,C1,D1,E1,F1,F3,G1,G3,H1,H2,H3,I1,J1,K1,L1"    Set rng = Worksheets("Sheet2").Range("A1") '   Set rng = Worksheets("Sheet2") _ '               .Cells(Rows.Count, "B").End(xlUp).Offset(1, -1)    Application.ScreenUpdating = False    With Worksheets("Sheet1")       i = 5       For j = 1 To 15          With .Cells(i, "A").Range(CRNG)             For k = 1 To .Areas.Count                rng.Offset(, k).Value = .Areas(k).Value             Next             Set rng = rng.Offset(1)          End With          i = i + 3       Next    End With    Application.ScreenUpdating = True End Sub ' 確認用データ作成 Public Sub testData()    Dim r As Range    Const CRH As Long = 50    Application.ScreenUpdating = False    With Worksheets("Sheet1")       .Cells.Delete       For Each r In .Range("A1:N1").Resize(CRH)          r.Value = r.Address(False, False)       Next       .Columns.AutoFit       Worksheets("Sheet2").Columns.ColumnWidth = _          .Cells(1).ColumnWidth    End With    Application.ScreenUpdating = True End Sub
(ie) 下記でどうですか。 objIE.document.getElementsByName("logIn")(0).Click
こんばんは。 楽しそうなので、作ってみました。 ただし、楽しくする工夫はここのカテゴリー外の内容なので、VBAプログラムだけ。。。^^; 下のコードを標準モジュールに貼り付けて「問題を出す」ボタンをMondai()プロシージャに、判定ボタンをKotae()プロシージャに紐付けて実行ください。 シートの構造は添付図のようにしました。 Sheet2 の問題データベースは、１行目をタイトルにしたので、データは２行目から入っています。 お試しください。 以下コード========================= Option Explicit Const SH1 As String = "Sheet1" Const SH2 As String = "Sheet2" Const MONDAISU As Long = 100 ’出題ルーチン Sub Mondai() Dim Qnumber As Long Worksheets(SH1).Range("A1,D1").ClearContents Qnumber = Int(Rnd() * MONDAISU) Worksheets(SH1).Range("B1").Value = Worksheets(SH2).Range("B2").Offset(Qnumber).Value Worksheets(SH1).Range("C1").Value = Worksheets(SH2).Range("C2").Offset(Qnumber).Value Worksheets(SH1).Range("E1").Value = Qnumber End Sub '答え合わせルーチン Sub Kotae() Dim Qnumber As Long Qnumber = Worksheets(SH1).Range("E1").Value If Worksheets(SH1).Range("A1").Value = Worksheets(SH2).Range("A2").Offset(Qnumber).Value Then Worksheets(SH1).Range("D1").Value = "正解！" Else Worksheets(SH1).Range("D1").Value = "不正解！残念" End If End Sub
う～む。謎現象ですね...新規Bookでも同じとなると。 ちなみに、複数選択のマクロを Sheets(Array("Sheet1", "Sheet2")).Select と記述してみても、複数選択にならないでしょうか？
過去にこのような質問があるので参考にしてみてください。 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1298068887 画像は、上記の質問で作ったサンプルです。 WebBrowserコントロールにフォーカスがあっていても文字を取得することが出来ています フォーム外にカーソルが出ていても問題ありません。
こんにちは。 ブラウザーの「名前をつけて保存」で、いくつかバリエーションありますので、それで試してください。 大昔のwebページだったら、使えていた方法が、今はサーバーのセキュリティ対策のために、処理ができない、ということです。 スクリプトてんこ盛りだと、確かに厳しいですけどね。
該当DBがWINDOWS認証になっていないなんてオチじゃぁ、無いですよねぇ。
こんにちは。 http://d.hatena.ne.jp/val90/20070227/1172558857 のつぶやきは、役に立ちそうです。
Destination:=Range("$C$3")) ここを Destination:=IIf(Range("C3").Value = "", Range("C3"), Range("C" & Cells.Rows.Count).End(xlUp).Offset(1)) にしてはどうでしょうか。（次の空白セル位置から書き込む）
こんな感じでしょうか？ Sub sample() With Range("B1", Cells(Rows.Count, 1).End(xlUp).Offset(, 1)) .Formula = "=COUNTIF($A$1:A1, A1)" .Copy .PasteSpecial xlPasteValues End With Application.CutCopyMode = False End Sub
ところで、何の話しでしょうか？（開発ソフト名は？） VB6.0系と.NET系で書き方が違います。 >初心者で上手くいかないので教えてください。 どの辺が上手くいかないのでしょうか？ あなたがコーディングしたソースを添付して、具体的に上手くいかない点を書いて下さい。 丸投げしては、あなたのスキルアップにはなりません。
言いたいことは判らないでもないけど、質問は落ち着いて、出来るだけ正しい日本語で書きましょう。 Accessに限った事ではないのですが、文字を範囲で取る場合は、文字コードの比較になります。 文字コードが判らなかったら、まず、そこから調べてください。 文字列を比較する際には、その文字列を形成する文字の文字コード順に並びます。 例えば、例に上がっている「金賞」と「銀賞」ですが、文字コードで比較すると「銀賞」の方が大きくなります。 まず、これが基本。 で、質問の内容なんですが、「文字列を範囲検索する際にはSQL（もしくはDLookupなどの関数の条件部分）では、どう書くべきか。Betweenを使えばよいのか？」という事だとするならば、まさしくその通りです。しかし、その場合上記の文字コードを意識しなければなりません。 例えば、「特賞」「金賞」「銀賞」と言うデータが有り、特賞と金賞の上位2つを取りたい場合、「Between '特賞' and '金賞'」と書きたくなります。しかし、文字コード順で言えば「金賞」「銀賞」「特賞」と、特賞が一番大きくなります。結果、先ほどの条件では上位2件ではなく、全てが取られてしまうことになります。 これを回避するために、普通は範囲で条件に指定したり、大小比較するデータは、数字として保存し、その対応データを別途保持し、表示の際にそのデータを扱うようにします。 こういう別途持つデータを「マスターデータ」等と呼びます。 結論として回答は「文字列の範囲指定はBetweenで指定できる。しかしそれは思った通りの抽出が出来るとは限らない。」と、なります。
マクロを勉強中なのに数式で回答されても困りますよね(笑) 下記のコードでいかがでしょうか？ 出来ればステップ実行(VBEの画面でF8クリック）で一行ずつプログラムの流れと変数の値の変化を追いかけてみるとプログラムの理解が深まります。 Option Explicit Sub Sample() Dim r As Long, r2 As Long Dim str As String, startRow As Long, cnt As Long With Columns("C") '一旦C列をクリアする .ClearContents 'C列の書式を「文字列」にする .NumberFormatLocal = "@" End With '書き出し用の文字列・書き出し開始行・カウンタの初期値を設定する str = Range("B1").Value startRow = 1 cnt = 0 '2行目から最終行まで繰り返す For r = 2 To Range("A" & Rows.Count).End(xlUp).Row '前の行のA列と同じかどうか判定する If Range("A" & r).Value = Range("A" & r - 1).Value Then '同じならカウンタを1増やして書き出し用の文字列を組み立てる cnt = cnt + 1 str = str & "," & Range("B" & r).Value Else '違っていたらstartRowからひとつ手前の行までC列を書き出す For r2 = startRow To r - 1 Range("C" & r2).Value = str Next r2 '書き出し用の文字列・書き出し開始行・カウンタをリセットする str = Range("B" & r).Value startRow = r cnt = 0 End If Next r '最終行のC列が空欄ならC列を書き出す If Range("C" & r - 1).Value = "" Then For r2 = startRow To r - 1 Range("C" & r2).Value = str Next r2 End If 'C列の幅を自動調整する Columns("C").EntireColumn.AutoFit End Sub
マクロ初心者が作れるレベルのものではないです。 VBＡの基礎から勉強が必要です。 １．フォーム(ウィンドウ)を表示し、入力データを取得する。 ２．取得したデータをもとに、シートのデータを計算したり、場所を移動させる。 初心者なら２．のシート内のデータを計算させたり、移動させることを覚えてください。 そうすると、プログラムの感覚が解ります。
以下でどうなりますか Public Sub Samp1()    Dim ws As Worksheet    Dim i As Long, j As Long, k As Long    Application.ScreenUpdating = False    Set ws = Worksheets("Sheet1")    ws.Columns("A:C").Clear    With Worksheets("Sheet2").Range("A1").CurrentRegion       k = 1       For i = 1 To .Rows.Count          For j = 2 To .Columns.Count             If (.Cells(i, j) = "") Then Exit For             .Cells(i, j).Copy ws.Cells(k + j - 2, "B").Resize(, 2)          Next          j = j - 2          If (j > 0) Then             .Cells(i, 1).Copy ws.Cells(k, "A").Resize(j)             k = k + j          End If       Next    End With    Application.ScreenUpdating = True End Sub
マクロが多くても、ボタンに名前を付けているからマクロの多いことは問題にはなりません。
*** VB6.0のヘルプから抜粋 *** PasswordChar プロパティ テキスト ボックス (TextBox) コントロールに入力された文字を表示するか、プレースホルダを表示するかを設定します。値の取得も可能です。また、プレースホルダとして使う文字を設定します。値の取得も可能です。 解説 PasswordChar プロパティはダイアログ ボックスでパスワードの入力を受け付けるインターフェイスを作成するために使います。任意の文字を使用できますが、ほとんどの Windows 用アプリケーションではアスタリスク (*) (Chr(42)) が使われています。 PasswordChar プロパティは Text プロパティには影響を与えません。Text プロパティにはユーザーが入力したとおりの文字列、または、あらかじめプログラムで設定した文字列が格納されます。入力したとおりの文字列を表示するには PasswordChar プロパティを長さ 0 の文字列 ("") に設定します。既定値は長さ 0 の文字列です。 このプロパティには任意の文字列が代入可能ですが、1 バイト目だけが有効です。2 バイト目以降は無視されます。 メモ MultiLine プロパティに真 (True) を設定すると、PasswordChar プロパティは無効になります。
VBAならクラスのメソッドだろうがSubだろうがFunctionだろうが、複数の引数の扱い方は同じですが、何が知りたいのでしょうか？
ボタンの種類が図形なのかActiveXコントロールのコマンドボタンになのかわかりませんが、図形に登録するのでしたら―― Sub Tesr() Dim cnt As Integer cnt = ActiveWorkbook.Sheets.Count Sheets("原本").Copy After:=Sheets(cnt) ActiveSheet.Name = Format(Now, "yyyymmdd") End Sub
hoijujdhuoshdo さん、こんばんは。 ファイル名に連番を付けたいのならば、まず連番の何番目まで使用済みか、検索して、その次の番号を取得するのが常道かと思います。 また、連番前提ならば、１番目のファイルから連番番号を付けておく方が、後々検索などがし易くてよいと思います。(下の例題コードは、連番が(1)からスタートしているものとしています。） ３番目のMacro1()コードをベースに書いてみると、 ======================================= fileName = "【" & Range("M3") & "】" & Range("C3") & "【" & n & "】" 'ファイル名作成 'If MsgBox(fileName & " で保存しますか？", vbYesNo) <> vbYes Then Exit Sub '保存するか確認して保存しない場合は終了 ActiveWorkbook.SaveAs "c:\TEST2\" & fileName If IsError(fileName) Then Else ActiveWorkbook.SaveAs "c:\TEST2\" & fileName & "(" & CStr(i) & ")" '指定フォルダに保存 i = i + 1 End If ======================================= の部分を修正します。 ======================================= fileName = "【" & Range("M3") & "】" & Range("C3") & "【" & n & "】" 'ファイル名作成 i = 1 'Dir 関数でファイルの存在を検索する。 Do While Dir("c:\TEST2\" & fileName & "(" & CStr(i) & ").xls*") <> "" i = i + 1 Loop 'ループを抜けた後の i は、存在する連番の最大値+1の値になっている。 ActiveWorkbook.SaveAs "c:\TEST2\" & fileName & "(" & CStr(i) & ")" '指定フォルダに保存 ======================================= こんな感じでどうですか？
> マクロの記録をしたところ、シート名を全て記述した上でPDF化するコードになりました この部分もマクロでやります。 Sub Sample() Dim ara As Variant Dim i As Integer Dim sh_s As Integer Dim sh_e As Integer sh_s = Sheets("表紙").Index sh_e = Sheets("裏表紙").Index ReDim ara(sh_s To sh_e) For i = sh_s To sh_e ara(i) = Sheets(i).Name Next Sheets(ara).Select ActiveSheet.ExportAsFixedFormat Type:=xlTypePDF, _ Filename:="C:\Sample\Sample.pdf", _ OpenAfterPublish:=True End Sub エラー処理は入れていませんので。
質問者の別アカです。自己解決しました。 shp.TextFrame.Characters("あいうえお"が見つかった位置、"ＡＢＣＤＥ"の長さ）.Text = "ＡＢＣＤＥ" でうまくいきました。 文字列が見つかった位置は InStr(Buf, "あいうえお")で取得できます。
DY4に入った関数を見ましたか? =AVERAGEIFS(S3:MaxRow,S3:MaxRow,">0") 最低でも Cells(4, 129).Formula = "=AVERAGEIFS(S3:" & MaxRow & ",S3:" & MaxRow & ","">0"")" と変数は""の外に書くべきでしょう。 それと Dim MaxRow As long MaxRow = Cells(Rows.Count, 1).End(xlUp).Row として、 Cells(4, 129).Formula = "=AVERAGEIFS(S3:S" & MaxRow & ",S3:S" & MaxRow & ","">0"")" とinitial部分は省略、式に組み込んでしまってもよろしいのでは。 F8キーでステップ実行しながら格納されている変数をマウスオンで確認してみてください。
Sub 抽出3() Range("A2").AutoFilterActiveSheet.Range("$A$3:$A$20000").AutoFilter Field:=1, _ Criteria1:=">=" & CDate(Worksheets("Sheet2").Cells(1, "B").Value), _ Operator:=xlAnd, Criteria2:="<" & CDate(Worksheets("Sheet2").Cells(2, "B").Value) + 1 End Sub Sheet2のB1とB2に開始日、終了日を入力します。終了日は実際には終了日の翌日0:00未満で抽出します。テストしてないから間違えてたらごめんなさい。フィルタを使いたくないというのは前後の文脈から「フィルタのCriteriaに直接日付入力はしたくない」に取りましたが？
この様にやると、きれいに線が引けます。 ------------------------------------------------------------------------ Public Class Form1 Private g As Graphics Private pen1 As Pen = New Pen(Color.Red, 10) Private startX As Integer Private startY As Integer Private Sub Form1_Load(sender As Object, e As EventArgs) Handles MyBase.Load PictureBox1.Image = New Bitmap(PictureBox1.ClientSize.Width, PictureBox1.ClientSize.Height) g = Graphics.FromImage(PictureBox1.Image) End Sub Private Sub PictureBox1_MouseDown(sender As Object, e As MouseEventArgs) Handles PictureBox1.MouseDown startX = e.X '始点座標X startY = e.Y '始点座標Y If e.Button = MouseButtons.Left Then g.FillEllipse(Brushes.Red, e.X - 5, e.Y - 5, 10, 10) End If PictureBox1.Refresh() End Sub Private Sub PictureBox1_MouseMove(sender As Object, e As MouseEventArgs) Handles PictureBox1.MouseMove If e.Button = MouseButtons.Left Then g.DrawLine(pen1, startX, startY, e.X, e.Y) pen1.StartCap = System.Drawing.Drawing2D.LineCap.Round pen1.EndCap = System.Drawing.Drawing2D.LineCap.Round g.SmoothingMode = Drawing2D.SmoothingMode.AntiAlias End If PictureBox1.Refresh() startX = e.X startY = e.Y End Sub End Class ------------------------------------------------------------------------
Union で時間がかかっているようです。 直接削除していった方が断然速かった。 Sub sample() Dim i As Long Dim MaxRow As Long Debug.Print Time$ MaxRow = Cells(Rows.Count, 1).End(xlUp).Row MaxRow = MaxRow + Application.IsEven(MaxRow) For i = MaxRow To 3 Step -2 Rows(i).Delete Next i Debug.Print Time$ End Sub １万行のデータでテスト 直接削除で約２秒 Union してから削除なら約２分。
tutu6464 さん、こんにちは。 お書きのコードでは、 Private Sub 名前で検索_Click() でプロシージャが宣言されていますが、これに対応する End Sub が記述されていないことが原因ですね。
kyuusyuu63 さん、こんにちは。 MergeCells プロパティは、値の参照も設定もできるプロパティです。 お書きのコードでは、 Range(…).MergeCells = True と代入文形式になっているので、参照でなく設定と認識されます。 もしプロパティがTrueかどうかを判断したいならば、If文で If Range(…).MergeCells = True Then とすれば、等号は論理式として扱われ、プロパティは参照と認識されて、True と比較してくれます。
1行の中に「RangeオブジェクトからのFindメソッド」「Rowプロパティ」と、2つの要素が含まれている為、エラーが分かりにくくなっています。作っている途中は、こういった「まとめ記述」は避けた方が無難です。 この場合のエラーは、見つからなかったのに「Rowプロパティ」を参照しようとしたことでしょう。 Set fnd=Worksheets("sheet1").Range("B:B").Find(i) If (fnd Is Nothing) Then Msgbox "見つかりません" Else N=fnd.Row End If こんな感じで、見つからなかった場合のことも考えておきます。On Error構文も時として便利ですが、他のエラーが分からなくなるので、最後の最後に取っておいた方が良いでしょう。
参考にどうぞ http://www.accessclub.jp/samplefile/samplefile_249.htm
普通にコンパイル通りましたよ。EXCELのマクロですよね。 Sub hoge() Dim x As Long Dim i As Long With ActiveSheet x = .UsedRange.Cells(.UsedRange.Count).Column For i = x To 1 Step -1 If Application.CountA(.Columns(i)) = 0 Then .Columns(i).Delete Next End With End Sub
以下でどうなりますか ご質問内容でおかしな？ところがあったので･･･ > このsheet1の内容をA～Eまでが完全に重複しているもの A, B, D, E と H(仕入価格) で文字列を作り一致するか･･･に変更 同じ商品でも仕入価格が異なると･･･？ 仕入価格×売上数量 など、おかしく･･･？ 処理としては、 この文字列で前詰して、どこの行に詰めたかを Dictionary 管理 > 足し合わせて 仕入価格以外の F, G, I, J の所を足し合わせる 修正・変更しやすいようにベタで処理してみました 結果は新規シートに･･･ Public Sub Samp1()    Dim dic As Object    Dim vA As Variant    Dim sS As String    Dim i As Long, j As Long, k As Long, n As Long    Const CSEP As String = vbTab    Const CWIDTH As Long = 10    Set dic = CreateObject("Scripting.Dictionary")    With Worksheets("Sheet1")       With .Range("A1", .Cells(Rows.Count, "A").End(xlUp))          vA = .Resize(, CWIDTH).Value       End With    End With    k = 1    For i = 2 To UBound(vA)       sS = ""       For j = 1 To 8          Select Case j             Case 1, 2, 4, 5, 8 ' 一致判別用文字列を作る列指定                sS = sS & vA(i, j) & CSEP          End Select       Next       n = dic(sS)       If (n > 0) Then          For j = 6 To CWIDTH             Select Case j                Case 6, 7, 9, 10 ' 足し合わせる列指定                   vA(n, j) = vA(n, j) + vA(i, j)             End Select          Next       Else          k = k + 1          n = k          dic(sS) = n          For j = 1 To CWIDTH             vA(n, j) = vA(i, j)          Next       End If    Next    Application.ScreenUpdating = False    With Worksheets.Add       With .Range("A1").Resize(k, CWIDTH)          .Value = vA          For j = 5 To 1 Step -1             If (j <> 3) Then                .Sort .Cells(j), xlAscending, Header:=xlYes             End If          Next       End With    End With    Application.ScreenUpdating = True    Set dic = Nothing End Sub
>Visual Basicの問題です。 Visual Basic のバージョン（種類）が分かりません。 Visual Basic のバージョン（種類）によって書き方が違います。 >わからないので、どなたか教えてください。 どこが分からないのでしょうか？ あなた自身でやってみて、分からない部分をピンポイントで質問しましょう。 問題を丸投げだと、永久にプログラムできません。 ほとんど問題文が答えになっています。 IF分などを使って、問題文通りに判定すれば良いかと思います。
２点とも修正点が多すぎてここでやり取りできる範疇を超えています。 エクセル自体をYahoo!ボックスなどにアップロード出来るのなら回答出来るかもしれません。
実際にはA列とB列にはどんな値が入っているのですか。 たぶんC列にシート関数のSUMIFSをCOUNTIFSで割る式を入れると手動でもできると思いますが、その式をVBAで設定してあげると求めるものはできると思います。 場合によってはDictionaryオブジェクトを使ってループで求める方法も考えられると思います。 それと、データが0.1秒刻みの時 >このとき0~30秒、30.1秒~60秒、60.1秒~90秒・・・・ とありますが、 >このとき0~29.9秒、30秒~59.9秒、60秒~89.9秒・・・・ が一般的だと思うのですが、質問の区切り方がいいのでしょうか。
>Visual Basicの問題です。 Visual Basic のバージョン（種類）が分かりません。 Visual Basic のバージョン（種類）によって書き方が違います。 >わからないので、どなたか教えてください。 どこが分からないのでしょうか？ あなた自身でやってみて、分からない部分をピンポイントで質問しましょう。 問題を丸投げだと、永久にプログラムできません。 ほとんど問題文が答えになっています。 IF分などを使って、問題文通りに判定すれば良いかと思います。 If 条件 Then （偶数） Else （奇数） End If
「期間」といいながら 日付を１日だけ入力させるのは仕様ですか？ また日付のある列が４列目なのは自明ですが、それでも列番号を入力させるのは？ しかもそれで変数に列数を入れながらその変数を使わずField:=3と日付のない列を指定するのは嫌がらせですか？
ID非公開さん ウインドウのプログラムで重要なことはCPUを解放してやること。 普通の書き方 int times;//外部変数 1. ボタンStart timeの関数から今の時刻を取り、変数(例times)に代入し、 終了。(CPUを解放) 2. ボタンStop timeの関数から今の時刻を取り、 時間=今の時刻-times 表示して、終了。(CPUを解放)
「oracle 外部結合」で検索。 http://www.shift-the-oracle.com/sql/left-right-outer-join.html http://www.oracle.com/technetwork/jp/articles/otnj-sql-image1-30862... Aテーブルに有って、Bテー部に無い（無い場合は空白）の結合です。 ①WHERE句で「部門マスタ.担当者コード = 担当者マスタ担当者コード(+)」 ②FROM句で、「LEFT OUTER JOIN」 などを使います。 詳しくはサイトの解説を読んで下さい。
DebugじゃなくてReleaseを使ってみてください。 参考 http://d.hatena.ne.jp/tekk/20120524/1337873495
Sub 加算() Dim 答 As Long Dim I As Long For I = 1 to 10 '10回処理を繰り返します。 答 = 答 + I Next End Sub これは、１から10まで順に加算し、加算の結果は、"答"に入ります。 最初、"答"には、初期状態としてゼロが設定されています。 1回目 答 = 答 + 1 'この処理の結果→ 答=1 2回目 答 = 答 + 2 'この処理の結果結果→ 答=3 ということで、１から10まで加算したことになります。答=55 Dim～の意味、For～の意味をしっかり理解しましょう。 意味が解らない場合、VBAの入門書などを読みましょう。
まず、自分で作成を試みて、分からない部分を質問してください。これではまるで仕事の依頼です(しかも無償で)。 まるっきり、取っ掛かりが掴めないのでしたら、欲張らず、1つずつ分からない点を明らかにするように、順番に分けて質問してください。
>どういう順番で実行されるのでしょうか。 順番とは？ 標準モジュールは、共有な変数、定数、イベントでは無い Sub や Function を書いて、プロジェクト全体で使います。 何度も使うような処理を標準モジュールに書いて、その都度コールして使います。 ※使い方は人それぞれですが・・
こんにちは。 Sub aaa() Dim Path As String Path = "C:\Users\ユーザー\Desktop\*.*" myFileList = "" myFile = Dir(Path) Do While myFile <> "" If Right(myFile, 3) = "lnk" Then Else myFileList = myFileList & Chr(13) & myFile End If myFile = Dir() Loop MsgBox myFileList End Sub こんなかんじです チェックボックスが、というと、使うコントロールを複雑にする必要があります。 1) シートにリストアップ 2) 特定のセルに入力させて、その部分を使って、主様のしたいことをしてください
記述の仕方が判らないのにその値をなぜ変えれば治ると判断が付いたんでしょうか？ もしweb上に有った資料であれば、そのページに書いてなかったんでしょうか？ さらに言えば、WindowlessVideoって何のプロパティなんでしょう？ そのオブジェクトはExcelのVBAから操作できているんでしょうか？
※補足しなくても分かりましたよ。 回答です。 いやあ苦労しました。多分バッチリです。 ただ数式、たーくさんあります。 AE2:国語 AE3:算数 AE4:理科 AE5:社会 AF2:10 AF3:20 AF4:30 AF5:40 AG2:Ａ AG3:Ｂ AG4:Ｃ AH2:1 AH3:2 AH4:3 K2:=IFERROR(MATCH(ROW(A1),A:A,0),"") L2:=IF($K2="","",INDEX(C:C,$K2,1)) M2:=IF($K2="","",INDEX(D:D,$K2,1)) N2:=IF(L2="","",INDEX(AF:AF,MATCH(L2,AE:AE,0),1)) O2:=IF(M2="","",INDEX(AH:AH,MATCH(M2,AG:AG,0),1)) P2:=IFERROR(N2+O2+(1-1/ROW()),"") Q2:=IF(P2="","",RANK(P2,P:P,1)) R2:=IF(Q2="","",MATCH(ROW(A1),Q:Q,0)) S2:=IF(R2="","",INDEX(K:K,R2,1)) T2:=IF($S2="","",INDEX(A:A,$S2,1)) U2:=IF(T2="","",COUNTIF(A:A,T2)) これらを下方へ、空白が出るまでドラグコピーします。 V2:1 V3:=IF(U3="","",U2+V2) これを下方へ、空白が出るまでドラグコピーします。 W2:=COUNTIF(V:V,ROW(A1)) X2:=IF(W2=1,ROW(A1),X1) Y2:=MATCH(X2,V:V,0) Z2:=INDEX(T:T,Y2,1) AA2:=IF(Z1=Z2,AA1+0.001,Z2) AB2:=IF(A1=A2,AB1+0.001,A2) AC2:=MATCH(AA2,AB:AB,0) これらを下方へ、データの有る行までドラグコピーします。 F2:=INDEX(A:A,$AC2,1) これを、右方は I2 、下方はデータの有る行までドラグコピーします。 ↓作業列の画像です。
Selection.Paste ↓ Selection.Pastespecial もしくは、 Activesheet.Paste
サンプルです。AA列に【文字】が入っている場合、Exit Subで処理抜けをします。 次の行:MsgBox "" は実行されません。 ※数値が入っている場合は処理抜けをしません。 Sub sample1() Dim flg flg = WorksheetFunction.CountIf(Range("aa:aa"), "*") If flg > 0 Then Exit Sub MsgBox "" End Sub -------------------------------------- 【文字または数値】が入っている場合に処理抜けをするには Sub sample2() Dim flg flg = WorksheetFunction.CountIf(Range("aa:aa"), "*") flg = flg + WorksheetFunction.CountIf(Range("aa:aa"), ">=" & 0) flg = flg + WorksheetFunction.CountIf(Range("aa:aa"), "<" & 0) If flg > 0 Then Exit Sub MsgBox "" End Sub
Sub Test() Range(Cells(6,"M"),Cells(1000,"M")).Formula="=M6に書くべき関数式" End Sub M6に数式を記入し、掴んで下まで引っ張るのと同じ操作です。 もちろん保護は事前に解除する必要があります。
こんにちは。 Range("A1").Interior.Color としてみて下さい。
＞①Ｂ列を基準に上から下に向かって最下行を取得し、データ範囲 これでやったとしても、データが増えたら「データソースの変更」が必要になってしまい面倒です。 ピボットテーブルを作る前にデータソースを「テーブル」にしてしまえば、 ActiveWorkbook.PivotCaches.Create(SourceType:=xlDatabase, SourceData:= "テーブル1", ・・・ という形でピボットテーブルができます。 こうすると、データ行が増減しても「データソースの変更」をやる必要はありません。 一度、データ部分をテーブルにしてからマクロ記録してみてはどうでしょうか。
こんにちは。 outlookの制御の場合、 1) コードの編集から、コードを直接入力 2) outlook用のアドインファイルを作成し、それをインストール 3) outlookの外部にあるvbscriptとして配布 ぐらいの方法があります。 配布する範囲と管理が必要なのか、など、ありそうですが、 「差し替えの対応」などの部分まで、考えて、一番いい方法を探してください。 パスワードが絡むと、方法の選択は狭いですね 1) はきえます。
考え方としては、 ・数直線上を移動するので、初期値0としてランダムで1を足したり引いたりした結果が、そのまま動いた先の位置と考えられる。 ・1分後というのは1回後と捉え、60分後は60回、ランダムに1を足し引きした結果と考える。 ・上記を行なった結果を1回、これを100回試行し、結果の平均値を計算する。 ということになるのですが、課題として出されているのが問題です。どこまで自由度があるのでしょうか。好きに組んで良いのであれば、どうにでもできると思います。しかし、どこまでの知識を用いて良いのかが分からない状態では、具体的なコードは示しにくいです。 何か制限があれば、返信をお願いします。
システムに求めるものが何かはわかりませんが、残業を管理するなら加算していくのではなく、日毎に行った残業時間をデータとして蓄積するものなのでは？ 質問の《社員を切り替える》とは何なのかも回答者にはわかりませんよね？ 途中までにしろできた物を目の前にされている質問者さんとは違う訳ですし 保存も含めたならExcelを使った方が楽な気がしてきましたけどね
こんにちは。 どうしたら、どうしたもんかのーー まず、visioで、自動記録を試してください。記録を開始し、ターゲットの部品を選択 少し位置をずらす、すぐに、記録は停止 はやってみて、どんなコードが出来るかです。 そしたら、部品の選択に使っている文字列を、エクセルの文字列にするだけでいいことになります。 エクセルのセルを読込みするのは、 set xls = createobject("excel.application") xls.visible = true xls.open "入っているファイルのパス" set sh = xls.activeworkbook.sheets("データのあるシート") 名前 = sh.Range("A1").value 数値 = sh.Range("B1").value これで、名前と数値は読込みできます。 データが複数なら、for nextで行を指定したらいいです
コード例です。 検索したい文字列はArrayの引数に列挙してください。 検索シートと結果出力シートは実際のシート名に書き換えてください。 Sub Sample() Dim Sht1 As Worksheet Dim Sht2 As Worksheet Dim Row As Long Dim i As Long Dim Keywords As Variant Set Sht1 = Worksheets("Sheet1") '←検索対象シート Set Sht2 = Worksheets("Sheet2") '←結果出力シート Keywords = Array("特定文字列1", "特定文字列2", "特定文字列3") '←検索したい文字列を列挙 For i = 1 To UBound(Keywords) For Row = 1 To Sht1.Cells(Rows.Count, "A").End(xlUp).Row If InStr(Sht1.Cells(Row, "A").Value, Keywords(i)) = 1 Then Sht2.Cells(Rows.Count, i).End(xlUp).Offset(1).Value = Sht1.Cells(Row, "B").Value End If Next Next End Sub
GetSaveAsFilenameを使う http://vba-geek.jp/blog-entry-200.html とか
本当に上記のマクロを実行していますか？ 上記のマクロは 「現在アクティブなブックを年月日時分.csvという名前で保存して閉じる」 というマクロですから、 マクロに構文が勝手に追加されることは絶対に有り得ないです。
前回は、間違えてテスト中のものを上げてしまいました。 ipl_is_loadingさんの答えでもいいのですが、いちいちファイルを開いているので、実行速度に問題がある可能性があります。 私の答えを直したものを載せます。どっちが早いかはやってみなければわかりません。 私も気になるので、両方やってみて、どっちが早かったが書いていただければと思います。 ' Sub Macro1() ' Dim EndCell As Range Dim FileName As String Dim IX As Integer ' Application.ScreenUpdating = False Set EndCell = Cells(Rows.Count, Columns.Count) Range([C1], EndCell).ClearContents ' ChDrive Left(ThisWorkbook.Path, 2) ChDir ThisWorkbook.Path FileName = Dir("*.csv") IX = 2 ' Do While FileName > "" IX = IX + 1 Macro1Loop FileName, IX FileName = Dir Loop ' End Sub ' Sub Macro1Loop(FileName As String, IX As Integer) ' Dim IX2 As Integer Dim IY As Long Dim FileData As String ' ins = Len(FileName) Cells(1, IX) = Left(FileName, ins - 4) Open FileName For Input As #1 ' Line Input #1, FileData IY = 1 Do While Not EOF(1) IY = IY + 1 Line Input #1, FileData ins = InStrRev(FileData, ",") ' If ins > 0 And ins < Len(FileData) Then Cells(IY, IX) = Mid(FileData, ins + 1) End If Loop Close ' End Sub '
VBAのイミデイトウィンドウや、適当な関数作って CSng(8556805823) を実行してみましょう。「8.556806E+09」と言う、指数表示される筈です。 それを有効桁数の一番大きいCcurくらいでもどしてみましょう。 Ccur(CSng(8556805823)) さて、どうなりましたかね。 犯人はデータ型。Single型を用いている事だと思います。 VBAはMicrosoftが出来た当初から浮動小数点型（SingleやDouble）は小数点以下を正しく表現できないという問題が有ります。 （2進法で表現しているので、小数点以下は表現できないパターンが有るんです） Single型の場合、基本的に整数部の有効桁数は7桁です。それ以上の場合は小数点をずらして記録します。内部的に「8556805.823*1000」って持ってるんですね。ですんで、再度整数に戻す前に先ほど挙げた小数点以下の罠が発生して整数部が落ちます。 VBAで正しく数値を持とうとするなら長整数型か通貨型をお勧めします。小数点以下の計算は事前に有効桁数まで繰り上げた整数で処理する事をお勧めします。
こんにちは。 これで文字列先頭が田中で始まるものを抽出します。 Sub Sample1() Range("A6").AutoFilter Field:=1, Criteria1:="=" & Range("A2") & "*" End Sub ちなみに次のコードは、とにかく文字列に田中が含まれるものを抽出します。 Sub Sample2() Range("A6").AutoFilter Field:=1, Criteria1:="=*" & Range("A2") & "*" End Sub
直接の回答では有りません。 batファイルでできる事ならＶＢＡで直接できると思うのですが？
C# から、VB に変換するのは、簡単です。 Free のツールがあります。 http://www.tangiblesoftwaresolutions.com/Free_Editions.html それで作ったのがこれ http://nanco.tokyo/Class1.vb
SUMIF関数やCOUNTIF関数を使えばできると思います。 これ以上の回答については、ファイルを添付していただかないと 画像では細かすぎて無理です。
他ブックのデータを参照する以上、そうなるのは必然なのかなとは思います。 オープン時にブック１を開き、クローズ時に両方閉じるようにしておくのが一般的ではないかなと思います。
http://note.chiebukuro.yahoo.co.jp/detail/n294285 ActiveWorkbook.Closeで、見積書ブックをとじちゃってるからかな。
Copy ではなく、Move に変えたら？
If Not IsEmpty(Ws.Range("B3").Value) And IsNumeric(Ws.Range("B3").Value) Then でセルB3に数字が入っているかどうかを判定出来ます。（空欄は「数値が入っていない」と判断されます）
普通は、 同じ機能を持ついくつものボタンを キャプションをかえて表示したりしなかったり というような設計はしませんね。 コマンドボタンは１つ。 リストボックスに「〇」の付いたデータを表示。 リストボックスは、複数データを選択できるので、一括処理も可能 といった設計じゃないですかね。
ここにコード書くだけだと分かりにくいかなと思ったんでサンプル作ってみました。 よければダウンロードしてください。一応コード内に説明記述してありますが説明下手だと思うのでご了承をm(_ _)m http://yahoo.jp/box/f1c6dW
実は結構覚えなければならない知識が沢山あるので下記のサイトを参考にして勉強してみてください。 「WEBデータの取得方法」 http://excel-ubara.com/excelvba5/EXCELVBA222.html
正確には SIer ですかね。 システム開発も幅が広いので、人それぞれだと思いますが SIerって言葉を聞くと、私のイメージではイコール、プロジェクトマネージャーになります。 ユーザーの要望に対してコンピュータを使ったソリューションの提案を行い、 提案したシステムを具現化するため、 人をまとめてシステム開発を遂行させるような人なので、 王道ですが、経済産業省の情報処理試験にある 「基本情報処理」「プロジェクトマネージャー」などを 勉強してはいかがでしょうか？
結論から言えば、作り直しになります。 AccessはExcelと違って、データオリエンテッドのアプリケーションですから、テキストボックスをリストボックスやコンボボックスに変更することは簡単なのでしょう。そのために「コントロールの機種変更」という機能も用意されているものだと思います。 ところがExcelはいわば自由表形式ですから、テキストボックスを使ったデータがコンボボックスで入力したり表示したりできるデータとは限りません。 逆を言えばExcelの方がデータの持ち方の自由度が高いということでしょうか。
下記 回答になってないですね。 このような回答専門なんでしょうね。 再度、質問した方がいいですね。
先頭2文字だったり、末尾2文字だったり、中に2文字だったり、着目する場所が一定してないので出来ません。 何か統一された規則性はないのですか？例文の3種類だけしかないなら可能です。どこでもいいから連続2文字が一致とか。 Likeの使い方 If str1 like "abc*" then ワイルドカードは必ずlikeの後ろ
１行目、２行目のdimはどこで宣言してますか？ 提示されたコードを実行しましたら、「名前が適切でありません」エラーになります。
Visual Studio Communty 2015が正常にインストール出来ていればツールチップは表示されるハズですが？ 私はこれまでに色々なバージョンのVisual Stuidioを色々なPCに何十回とインストールしていますが、ツールチップが表示されないという現象を見たことはありません。
SPREAD for Windows Forms 8.0Jのヘルプを読んで下さい。 fpSpread_ButtonClickedのイベント引数であるEditorNotifyEventArgsクラスには どのセルでイベントが発生したかを示すプロパティがありますよ。 Column エディタがイベントを発生させたセルの列インデックスを取得します。 EditingControl イベントを発生させたControlオブジェクトを取得します。 Row エディタがイベントを発生させたセルの行インデックスを取得します。 View エディタがイベントを発生させたセルを含むビューを取得します。 EditorNotifyEventArgs クラス メンバ http://docs.grapecity.com/help/spread-winforms-8/FarPoint.Win.Sprea...
http://officetanaka.net/excel/vba/tips/tips107.htm https://msdn.microsoft.com/ja-jp/library/cc364490.aspx 基本的な使い方は１つめの参照URL一番下。 あなたが欲しいフォルダがあるかどうかは、２こめの参照URL。
こんな感じ。 Sub Rdel() Dim rc rc = Range("A" & Rows.Count).End(xlUp).Row Do Until rc = 0 With Range("A" & rc) If .Value = 1 Or .Value = 2 Then .EntireRow.Delete rc = rc - 1 End With Loop End Sub
コード例です。 日付はDate型の関数に入れたほうが、いろいろと処理が簡単ですよ。 Dim myDate As Date Dim ErrorDate As Date myDate = DateSerial(Left(b, 4), Mid(b, 5, 2), Right(b, 2)) ErrorDate = DateSerial(Year(DateAdd("d", -5, Date)), Month(DateAdd("d", -5, Date)), 0) If myDate <= ErrorDate Then MsgBox "エラーメッセージ" '←メッセージ内容は適用に変えてください。 Exit Sub End If
お示しのプログラムは、尻切れトンボ。 なので、示されている範囲での議論です。 お示しのものをまとめて、アクティブなシートを対象にすると↓のようなのが一例。 Sub 売上() Dim xRng As Range, xRng10 As Range With ActiveSheet With .Range("A5:AP75") Set xRng = .Cells Set xRng10 = .Columns(10) End With xRng10.Copy xRng10.PasteSpecial Paste:=xlPasteValues With .Sort .SortFields.Clear .SortFields.Add Key:=xRng.Columns(10), SortOn:=xlSortOnValues, _ Order:=xlDescending, DataOption:=xlSortNormal .SortFields.Clear .SetRange xRng .Header = xlYes .MatchCase = False .Orientation = xlTopToBottom .SortMethod = xlPinYin .Apply End With End With End Sub Worksheets("1")～Worksheets("12")まで、一気に面倒見るなら↓。 Sub main() Dim i As Long For i = 1 To 12 Call 売上(Worksheets(CStr(i))) Next i End Sub Sub 売上(sh As Worksheet) Dim xRng As Range, xRng10 As Range With sh With .Range("A5:AP75") Set xRng = .Cells Set xRng10 = .Columns(10) End With xRng10.Copy xRng10.PasteSpecial Paste:=xlPasteValues With .Sort .SortFields.Clear .SortFields.Add Key:=xRng.Columns(10), SortOn:=xlSortOnValues, _ Order:=xlDescending, DataOption:=xlSortNormal .SortFields.Clear .SetRange xRng .Header = xlYes .MatchCase = False .Orientation = xlTopToBottom .SortMethod = xlPinYin .Apply End With End With End Sub いずれも未実行。不具合ご容赦。
下記のコードでいかがでしょうか。 少し長いコードになりますが、 画像名の異なる画像が既に張り付けられている時はその画像を一旦削除し、 同じ名前の画像が既に張り付けられている時は新たには貼り付けないように、 しています。 画像フォルダ名は適宜変更してください。 Option Explicit Sub Sample() Const picFolder As String = "C:\Test" '適宜変更して下さい。 Dim r As Long, filePath As String Dim pic As Shape, pasted As Boolean 'Excelの再描画を一時停止する Application.ScreenUpdating = False 'A列の２行目から最終行まで繰り返す For r = 2 To Range("A" & Rows.Count).End(xlUp).Row With Range("A" & r) 'B列に既に画像が張り付けられているかをチェックする pasted = False For Each pic In ActiveSheet.Shapes '既に画像が張り付けられている場合 If pic.TopLeftCell.Address = .Offset(, 1).Address Then '代替テキストがA列の内容と異なるときはその画像を一旦削除する If pic.Title <> .Value Then pic.Delete Else '代替テキストとA列の内容が一致しているとき '貼り付けをスキップするためのフラグを設定する pasted = True End If End If Next pic '画像ファイルのフルパス名を組み立てる filePath = picFolder & "\" & .Value & ".tif" '画像ファイルが存在し、貼り付けをスキップしないとき If Dir(filePath) <> "" And pasted = False Then '画像ファイルをB列に張り付ける Set pic = ActiveSheet.Shapes.AddPicture(Filename:=filePath, _ LinkToFile:=False, SaveWithDocument:=True, _ Left:=.Offset(, 1).Left, Top:=.Offset(, 1).Top, _ Width:=60, Height:=60) '貼り付けた画像の代替テキストを設定する pic.Title = .Value End If End With Next r 'Excelの再描画を再開する Application.ScreenUpdating = True End Sub
Ret MsgBox(strPhonetic & vbCrLf & vbCrLf … に = がないですね。 Ret = MsgBox(strPhonetic & vbCrLf & vbCrLf … です。 Ret には vbYes/vbNo/vbCancel (6/7/2) のどれかが入ります。 Ret = vbNo のとき、Application.GetPhonetic() が "" なので、 常に "次の候補はありません" が出るのでは？ また、そのあとに Exit Do があるので、 Loop While Ret = vbNo の意味はないのでは？ …とりあえず、こんなところかと。 。。。。。。。。。。。。 なお、ここは英語カテです。 コードが英語なので自動だと英語カテになります。 上記の修正をしてからプログラム関連(VBA)で再質問しましょう。 ............................ I hope this help you.
一例です。Sheet2にボタンを作成して、下のコードを登録してください。 Sub DataCount() Dim cnt As Integer With Worksheets("Sheet2") cnt = WorksheetFunction.CountA(.Range(.Cells(2, "A"), .Cells(Rows.Count, "A"))) If cnt = 0 Then MsgBox "データは0件です" Else MsgBox "データは" & cnt & "件です。" End If End With End Sub
こんばんは。 提出データの文字列中に元データの文字列が含まれる、部分一致判定でよいのであれば、If文を If Instr(1,ws2.Cells(j, 1).Value,ws.Cells(1, 1).Value) > 0 And ws.Cells(7, 1) = ws2.Cells(j, 4) Then のようにすればよいと思います。 Instr()関数で検索すれば、セル内改行があっても問題なく判断してくれます。
例えば ファイルは既に開いてあって、望みの列を選択しマクロ起動すれば削除されるだけとか 例えば フォルダに大量のCSVが保存されていて、フォルダ名/列番号/保存ファイル名を選びマクロ起動すれば次々開いて削除し保存終了とか 例えば 両者の中間とか 使い勝手に応じていろいろあります。そこはあなたが考える部分ですので、使いそうな道具を書いておきます。 ファイルを１個指定する fName=Application.GetOpneFileName("Select File, *") ファイルを開く Workbooks.open filename:=fName 'フルパスファイル名 セル選択された列を削除 Selection.EntireColumn.Delete （例えば）B列を削除 Columns("B").Delete Columns(2).Delete アクティブになってるブックをCSVファイルとして保存 ActiveWorkbook.SaveAs Filename:=fName, FileFormat:=xlCSV フルパスCSVファイル名の末尾に"_1"を付ける fName=Left(fName,Len(fName)-4) & "_1.CSV" アクティブになってるブックを保存せず閉じる（メッセージを省略） Application.DisplayAlart=False ActiveWorkbook.close savechanges:=False Application.DisplayAlart=True 文献を参照すると変数の型宣言Dimがありますが、慣れるまでは無視していいです。 調べ物をするなら、Office田中、mougが有名です。Googleでコマンド検索すると必ずここでヒットします。
もしかしてカカオトーク？ 知恵袋にカテがありますよ。 知恵袋トップ>インターネット、通信>コミュニケーションサービス>カカオトーク
２元１次なら簡単に決まってしまうので、 どうにでもなりそうなものですが・・・ まあ、適当やってみました。 ( x00 でも一発 ) 計算している値をプロットでもすれば意味がわかると思います ' ' 連立方程式を解く ( ※ b1 = 0, b2 = 0 には未対応 ) ' a1 * x + b1 * y + c1 = 0 ' a2 * x + b2 * y + c2 = 0 ' Const a1 As Double = 1 Const b1 As Double = 2 Const c1 As Double = 3 Const a2 As Double = 2 Const b2 As Double = 3 Const c2 As Double = 4 Function Y1(x As Double) As Double Y1 = (-a1 * x - c1) / b1 End Function Function Y2(x As Double) As Double Y2 = (-a2 * x - c2) / b2 End Function Sub 解く() Dim x0 As Double, dx As Double, x00 As Double Dim y01 As Double, y02 As Double, dy0 As Double Dim y11 As Double, y12 As Double, dy1 As Double x0 = 0 ' X初期値, 何でもいい dx = 1 ' X増分, ０以外 ' 適当なXでYを計算 y01 = Y1(x0) y02 = Y2(x0) dy0 = y02 - y01 ' さらに、適当なXでYを計算 y11 = Y1(x0 + dx) y12 = Y2(x0 + dx) dy1 = y12 - y11 ' 重なるか？ If dy0 = 0 And dy1 = 0 Then MsgBox "解は無数" Exit Sub End If ' 平行か？ If dy0 = dy1 Then MsgBox "解なし" Exit Sub End If ' X解 x0 = x0 - dy0 / (dy1 - dy0) * dx ' ------------------------------------- ' ※ もし、x0 = 0, dx = 1 なら ' x0 = - dy0 / (dy1 - dy0) ' = - (Y2(0)-Y1(0))/((Y2(1)-Y1(1))-(Y2(0)-Y1(0))) ' = ((c2/b2)-(c1/b1))/((((-a2-c2)/b2)+((a1+c1)/b1))+((c2/b2)-(c1/b1))) ' = (c2*b1 - c1*b2) / (a1*b2 - a2*b1) x00 = (c2 * b1 - c1 * b2) / (a1 * b2 - a2 * b1) ' ------------------------------------- ' 出力 Debug.Print "(" & a1 & ")*X + (" & b1 & ")*Y + (" & c1 & ") = 0 ･･･ (1)" Debug.Print "(" & a2 & ")*X + (" & b2 & ")*Y + (" & c2 & ") = 0 ･･･ (2)" Debug.Print "X = " & x0 & " , " & "Y1 = " & Y1(x0) Debug.Print "X = " & x0 & " , " & "Y2 = " & Y2(x0) Debug.Print "X = " & x00 Debug.Print vbCrLf End Sub
セルの方の型が違うのではありませんか？ B列に"2016/06/12"と見えるセルがある場合です。 Sub sample() Dim Z As Worksheet Dim FoundCell1 As Range Dim target_date As String Set Z = ActiveSheet target_date = "2016/06/12" '日付型で検索(What:=DateValue(target_date)) Set FoundCell1 = Z.Columns("B").Find(What:=DateValue(target_date), After:=Cells(2, 2), LookIn:=xlValues, LookAt:=xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchByte:=False) If FoundCell1 Is Nothing Then MsgBox "見つかりません" Else MsgBox FoundCell1.Address(False, False) End If '文字列型で検索(What:=target_date) Set FoundCell1 = Z.Columns("B").Find(What:=target_date, After:=Cells(2, 2), LookIn:=xlValues, LookAt:=xlPart, SearchOrder:=xlByRows, SearchDirection:=xlNext, MatchByte:=False) If FoundCell1 Is Nothing Then MsgBox "見つかりません" Else MsgBox FoundCell1.Address(False, False) End If End Sub
コレクションからの削除は後ろから、が定石です。 Sub test() Dim i As Integer Dim KeyWord As String KeyWord = "hoge" For i=Workbooks.Count To 1 Step -1 MsgBox Workbooks(i).Name If Workbooks(i).Name Like "*" & KeyWord & "*" then Workbooks(i).Close End If Next End Sub 直書き。間違っていたら後免。
セルのアドレスとみなされるようなシート名は NG です。 回避策はあるかどうか？ TransferSpreadsheet を使わずに オートメーションでやれば可能ですが。
実行時に生成・配置された ではなく、 実行時に生成・配置した になると思いますよ？ なのでコントロール名は生成する際につけてあげなきゃならないし、配置もどこにするかは指定しなければならないと思います 携帯なので具体的回答は出来ませんけど、動的・コントロール等で検索すると見つかるかもしれない
下記のコードはリストボックスに営業所名・期限・顧客を設定します。 Option Explicit Private Sub UserForm_Initialize() ListBox1.ColumnCount = 3 ListBox1.ColumnWidths = "2cm;3cm;2cm" End Sub Private Sub CommandButton1_Click() Dim st1 As Worksheet Dim Area As Range, FoundCell As Range, FirstAddress As String Dim Item As Variant Set st1 = Worksheets("Sheet1") 'テキストボックスが未入力ならメッセージを表示して処理を終了する If TextBox1.Text = "" Then MsgBox "データを入力してください！" Exit Sub End If 'セルを検索する Set Area = st1.Range("A2:H" & st1.Range("A" & Rows.Count).End(xlUp).Row) Set FoundCell = Area.Find(What:=TextBox1.Text, LookIn:=xlValues) '該当セルが見つからなければメッセージを表示して処理を終了する If FoundCell Is Nothing Then MsgBox "見つかりません" Exit Sub End If 'リストボックスをクリアする ListBox1.Clear FirstAddress = FoundCell.Address Do With FoundCell '検索結果が営業所以外のときはスキップする If .Column = 3 Or .Column = 5 Or .Column = 7 Then 'リストボックスに営業所名・期限・顧客を設定する ListBox1.AddItem .Value ListBox1.List(ListBox1.ListCount - 1, 1) = .Offset(, 1).Value ListBox1.List(ListBox1.ListCount - 1, 2) = st1.Range("B" & .Row).Value End If End With '次のセルを検索する Set FoundCell = Area.FindNext(FoundCell) Loop While Not FoundCell Is Nothing And FoundCell.Address <> FirstAddress End Sub
× For l = k To n ○ For l = l To n
これでいかがでしょうか？ Sub MakeHiperLink() Const wkFolder = "C:\A\" Const MaxLine = 1000 Dim wkSheet As Worksheet Dim sWk1 As String Dim sWk2 As String Dim sWk3 As String Dim sWk4 As String Dim sWk5 As String Dim i As Integer Dim fso As Object Set fso = CreateObject("Scripting.FileSystemObject") Set wkSheet = Worksheets("Sheet1") For i = 1 To MaxLine sWk1 = wkSheet.Range("A" & i).Value If sWk1 <> "" Then sWk4 = fso.GetBaseName(sWk1) & "*." sWk4 = sWk4 & fso.GetExtensionName(sWk1) sWk5 = Dir(wkFolder & sWk4) If sWk5 <> "" Then sWk3 = "=HYPERLINK(""" & wkFolder sWk3 = sWk3 & sWk5 & """,""" & sWk5 & """)" wkSheet.Range("B" & i).Value = sWk3 End If End If Next Set fso = Nothing End Sub
可能です、とは答えられますが、あなたが提示した条件が不明瞭すぎて、実際にどのようなコードを書けば実現できるかは回答出来ません。 コンボボックスはユーザーフォーム上にあるのですか？それともシート上にあるのですか？シート上にあるのなら、どのシートにあるのですか？ コンボボックスに設定する内容は「倉庫A-1、倉庫A-2、倉庫A-3、・・・倉庫F-7」で宜しいのですか？ コンボボックスで選択したときの貼り付けのルールが上記の３つだけでは判りません。一定のルールがあるのならそれを明示してください。 こちらが想像しなければならない事が多くなるほど、あなたが望む回答からはかけ離れた回答しか得られないことになります。
タイマーイベントを使ってデータを常時監視するのが一般的です。 Powerpointにタイマーイベントが有るかどうかは不勉強で存じ上げませんが。 EXCELには有りますね。 例えば、PC１でボタン操作した時、PC2の指定フォルダの（テキストでもなんでもいい）ファイルを更新してやる。 PC2のアプリケーションは(たとえば1秒毎に処理する）タイマー処理により、そのファイルの内容を確認して表示処理などをする。 こんな感じです。単純に言えば。
エラーメッセージは何と出ていますか？
出来ないことはありませんが、Win32APIとC++言語についての深い知識が必要になります。
なにをしたいのかよく解っていせんが、一言。 >何故か表ではなく TRUE の文字が表示されてしまいます。 を回避するのなら、 CB1 = Range("A1").CurrentRegion.SpecialCells(xlCellTypeVisible).Copy ↓ Set CB1 = Range("A1").CurrentRegion.SpecialCells(xlCellTypeVisible) とすれば、上手くいくのかもしれません。 ただ、示されたコードは、 「行をクリアされ、表に飛び地ができたとき、コード後半部分が機能しない」 という致命的な欠陥があります。 Tokyo＆Shinagawaの行を削除したいだけなら、クリップボード経由などの複雑なことをしないで簡単なコード（↓）で可能です。 Sub test1() With Worksheets("Sheet1").Range("A1").CurrentRegion .AutoFilter Field:=1, Criteria1:="Tokyo" .AutoFilter Field:=2, Criteria1:="Shinagawa" .Offset(1).Resize(.Rows.Count - 1).SpecialCells(xlCellTypeVisible).EntireRow.Delete .AutoFilter End With End Sub
下記を標準モジュールに記載して下さい。 '起動時自動実行マクロ Sub Auto_Open() Dim i As Long Dim j As Long Dim objITEM As Object Dim objIE As New InternetExplorer objIE.Visible = False objIE.navigate "http://www.resonabank.co.jp/kojin/market/spotrate.html" '完全にページが表示されるまで待機する Do While objIE.Busy = True Or objIE.readyState <> 4 DoEvents Loop Sheets(1).Select Range("A1").CurrentRegion.Offset(1, 0).ClearContents i = 2 j = 1 For Each objITEM In objIE.document.getElementsByTagName("td") Cells(i, j) = objITEM.innerText j = j + 1 If j > 10 Then j = 1 i = i + 1 End If Next Call untilReady(objIE) objIE.Quit Set objITEM = Nothing Set objIE = Nothing MsgBox "処理完了" End Sub Sub untilReady(objIE As Object, Optional ByVal WaitTime As Integer = 10) Dim starttime As Date starttime = Now() Do While objIE.Busy = True Or objIE.readyState <> READYSTATE_COMPLETE DoEvents If Now() > DateAdd("S", WaitTime, starttime) Then Exit Do End If Loop Dim c As Range Sheets(2).Select Sheets(2).Cells(Rows.Count, 1).End(xlUp).Select Set c = Selection c.Offset(1, 0).Select Set c = Selection Sheets(1).Range("C2").Copy Sheets(2).Range(c.Address) End Sub
こちらが参考になるのでは? [SSIS] Excel から型情報を意識せずに確実に読み込む方法 http://blog.sorceryforce.net/?p=373 [PRB] DAO の OpenRecordset を使用すると Excel の値として NULL が返される https://support.microsoft.com/ja-jp/kb/194124
>?DateDiff("yyyy","2000/1/1","2000/12/31") DateDiffは指定した 2 つの日付/時刻の間隔数なので、1/1～12/31では1年にはなりません。 時分まで意識して。2001/1/1 00:00 ～ 2001/12/31 00:00とするとわかりやすいと思います。 |1/1.....|1/2....|..................|12/31| |<----------------------------->| >?DateDiff("yyyy","2000/1/1","2001/1/1")であれば、 |1/1.....|1/2....|..................|12/31...|1/1...| |<--------------------------------------->| 終わり側の日付に意識的に１を足してやってはどうでしょうか？ ? DateDiff("yyyy",CDate("2001/1/1"),DateAdd("d",1,CDate("2001/12/31")))
私もエクセルに慣れていて苦労するがデフォルトでSheet1ではなくシート1,というところで躓きます。（それ以外に考えられないので） =query('シート1'!A2:AG, "select * where B like '%みかん%'") テストしたのはみかんを含むです。
iTextSharpを使った場合はExeだけでなくitextsharp.xmlworker.dllも必要になります。 ライセンスについて Exeについては「Debug」モードでコンパイルした実行形式の配布はMicrosoftのライセンス違反になります。かならず「Release」モードでコンパイルして下さい。 iTextSharpやiTextNetはVer.5からはAGPLライセンスが適用されています。 AGPLライセンスというのは簡単に言えば「ソースコードも一緒に配布しなさい」というライセンスです。ですからExeとDllだけを配布することはライセンス違反になります。
直接のオートフィルでは無理なのがわかっていると思いますし数式で簡単にできるはずです。 何でもVB派、なら数式をコピーすれば？ 数式は A3に ="aaa.bbbb.eee.abc"&TEXT(ROW(A529),"0000")&".eee"&ROW(A39) 下にコピー なので ３行目がスタート地点として Sub test() Range("A3:A" & Cells(Rows.Count, 2).End(xlUp).Row) = _ "=""aaa.bbbb.eee.abc""&TEXT(ROW(A529),""0000"")&"".eee""&ROW(A39)" End Sub
A列で並び替えされている前提で。 Sub sample() Dim xAPP, i As Long, ii As Long, j As Long Set xAPP = Application For i = 1 To Cells(Rows.Count, 1).End(xlUp).Row With Cells(i, 1) ii = xAPP.CountIf(Columns(1), .Value) With .Resize(ii) j = xAPP.CountIf(.Offset(, 2), Cells(1, 4).Value) If j > 0 Then .Interior.Color = vbYellow End If End With End With i = i + ii - 1 Next i End Sub
原則、そういった処理はできません。VBAの制御下にあるのは起動を指示するところまでで、そこから先はChromeの領分になります。 VBAから、起動中のChromeを制御する方法は、基本的にはありませんので、ビジー状態か知ることはできません。 特殊な方法はありますが、ツールの導入が必要であり、マクロ終了と同時にChromeも閉じてしまうので、今回の件には向かないと思います。
objIE.Navigate = strURL でなく objIE.Navigate strURL です。
Range("A1").Select を ActiveSheet.Range("A1").Select としてみて下さい。
10秒ごとにマクロを動かすのはApplication.OnTimeを使えば可能です。 MSDNサイト https://msdn.microsoft.com/ja-jp/library/office/ff196165.aspx 参考 http://yumem.cocolog-nifty.com/excelvba/2010/08/post-44d9.html http://www.excel.studio-kazu.jp/kw/20151005165157.html
一例です。 Range("A2") = Chr(Asc(Range("A1")) + 1)
そんなぼんやりとした質問では的確な回答は得られにくいでしょう。 何のツールで、何の設定なのかさっぱりわかりません。 <add key="AuthType" value="省略"> <!-- 説明？--> 普通に考えれば、この「省略」というのを消して、代わりにそこに書き込むのでしょうけど。 >反応がありません。 エラーか何かが出ていませんか?
一例です。 Sub sample() Dim r As Range, i As Long, st1 As Worksheet, st2 As Worksheet Set st1 = Sheets("sheet1") Set st2 = Sheets("sheet2") For i = 1 To st2.Cells(Rows.Count, "A").End(xlUp).Row Set r = st1.Columns("A").Find _ (what:=st2.Cells(i, "A"), lookat:=xlPart) If Not r Is Nothing Then st1.Cells(r.Row, Columns.Count).End(xlToLeft).Offset(, 1) = _ st2.Cells(i, "A") End If Next End Sub
新規シートに一覧する、一例です。 Dim xRng As Range Sub Sanple_Main() Dim cFld As String, xFld As Object With Application.FileDialog(msoFileDialogFolderPicker) .Title = "対象フォルダー選択" If .Show = True Then cFld = .SelectedItems(1) & "\" Else Exit Sub End If End With Application.ScreenUpdating = False With Worksheets.Add Set xRng = .Cells(2, 2).Resize(, 4) End With xRng.Value = Array("ファイル名", "パス", "ファイル種別", "最終更新日") Set xFld = CreateObject("Scripting.FileSystemObject").GetFolder(cFld) Call Sample_Folder_Proc(xFld) With xRng.CurrentRegion .Columns.AutoFit .Borders.LineStyle = True End With Application.ScreenUpdating = True End Sub Sub Sample_Folder_Proc(xFld As Object) Dim xFile As Object, sh As Worksheet, xSubFld As Object For Each xFile In xFld.Files Set xRng = xRng.Offset(1) With xFile xRng.Value = Array(.Name, xFld.Path, .Type, .DateLastModified) End With Next xFile For Each xSubFld In xFld.subfolders Call Sample_Folder_Proc(xSubFld) Next xSubFld End Sub
あるアクティブな Excel シートの A1セル～A?セルに連続して 例えば 0～10 の任意の半角数字が入力されているものとします。 (半角数字以外はダメ ＆ 途中に空白セルがあってもダメ) 【例】 [A列]    1    1    1    2    2    2    2    3    4    4    :    : そのA1セル～A?セルの 値のみをソートする VBA コードの一例です↓。 Sub MySort()     'ソート開始行の設定     StartRow = 1     '11個の要素全て値が 0 の配列 Arr を作成     '※ Arr(0)=0，Arr(1)=0，…，Arr(10)=0 という意味     Arr = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)     'アクティブなシートの A列最終行 を取得     MaxRow = Cells(Rows.Count, 1).End(xlUp).Row     'アクティブなシートを縦向きにループ走査     For i = StartRow To MaxRow         '配列 Arr の セルの値要素 に 1 を加算         Arr(Cells(i, 1).Value) = Arr(Cells(i, 1).Value) + 1     Next i     '行カウンタ用の変数を用意     RowCnt = StartRow     '配列 Arr の各要素をループ走査     Do While RowCnt <= MaxRow         For j = 0 To UBound(Arr)             'もし走査対象の配列要素の値が 0 でなければ             If Arr(j) > 0 Then                 '配列要素の値から 1 を引く                 Arr(j) = Arr(j) - 1                 'シートに j の値を入力                 Cells(RowCnt, 1).Value = j                 '行カウンタに1を加算                 RowCnt = RowCnt + 1             End If         Next j     Loop End Sub
実際にどのようなクエリを組んでいるのでしょうか。 （クエリをデザインビューで開いて、表示をSQLビューとすれば、SQL文が表示されます） 結局のところ日付型に変換出来ていないのが原因かと思われますので、 検索したいテーブルの該当項目が日付型なのか。 DateTimePickerからわたってくるデータの中身がきちんと日付型なのか。 双方が同じ形でないとエラーになりますよ？ それと日付型といっても複数の日付型があります。 例）日付（標準）や日付（S)、日付(L)等々。 このあたりも含めてもう一度見直してください。 必ずどこかが間違っています。 もう１つ。 クエリとは視覚的にわかりやすくSQL文を作成するためのものです。 どう作成するとどんなSQL文になるか。逆にこんなSQL文を作るにはどうすればいいか。 結局のところSQL文を理解していないとクエリは作成できません。
わかるところだけですが… １、PhotoshopとIllustratorの資格、民間の資格はありますが、ほとんど意味ありません。資格取るのが好き、もしくは取る過程でソフトの使い方を覚える…などの目的が無いなら、取る必要はないでしょう。 大切なのはrio_koringoさんが書かれている通り「感性」です。これは資格がある、ない、の外の話です。 ２、3、4、 もちろん全ての会社ということではないですが、デザイン、web関係の仕事は普通に就職したとすると残業ありきだと思った方がいいです。１時間とかじゃなくて「終電までに帰れたらラッキー」っていう会社も多くなります。納品期日ギリギリは徹夜なんていうこともあるかもしれません。少なくとも４時間半以上は座りっぱなしだと思います。休憩を取る余力も無い日も。 なので、質問者さんはバイトとして入る場合、条件など充分に相談して下さい。 遠回りしているように感じるかも知れませんが、質問者さんはまずは体力作り、腰痛の治療を先にするべきだと思います。普通に元気だった人でも激務で休職を余儀なくされる方もいます。 ビビらせているようで申し訳ないですが、体調をこれ以上悪化させない為にも、まずは体力をつけて下さい。
Sub sample() Range("A1:J1").Value = Split("商品番号,商品名,値段,備考,日付,種別,数量,在庫,区分,時刻", ",") End Sub
>1"と"みかん"が入力されといる行の削除をしたい お示しのデータでは、「大阪」の行だけが残る ということですよね？ Sub 一例です() Dim xCnd, i As Long, ii As Long xCnd = Array("", "みかん", "", "1") With Cells(1).CurrentRegion For i = 1 To 3 Step 2 .Range("B:D").AutoFilter Field:=i, Criteria1:=xCnd(i) If Application.Subtotal(103, .Columns(1)) > 1 Then .Offset(1).Resize(.Rows.Count - 1).SpecialCells(xlCellTypeVisible).Delete Shift:=xlUp End If .AutoFilter Next i End With End Sub
返信を書こうと思ったのですが、文字数オーバーでできませんでした。 仕方なく、回答を取り消して、書き直します。 どのようにテータを展開するかは、最初に書いておいてほしいです。 こうすると、１つのCSV にデータは２列になります。 なお、Ｂ列１行目からデータ展開をする。 CSV にはＣ以降データがない この２点はそのままでいいのですね。 ' Sub Macro1() ' Dim EndCell As Range Dim FileName As String Dim IX As Integer ' Set EndCell = Cells(Rows.Count, Columns.Count) Range([B1], EndCell).ClearContents ' ChDrive Left(ThisWorkbook.Path, 2) ChDir ThisWorkbook.Path FileName = Dir("*.csv") ' Do While FileName > "" IX = IX + 2 Macro1Loop FileName, IX FileName = Dir Loop ' End Sub ' Sub Macro1Loop(FileName As String, IX As Integer) ' Dim IX2 As Integer Dim IY As Long Dim FileData As String ' Open FileName For Input As #1 ' While Not EOF(1) IY = IY - (IX2 = 0) Input #1, FileData Cells(IY, IX + IX2) = FileData Stop IX2 = (IX2 + 1) Mod 2 Wend Close ' End Sub '
A列に日付が日付順に入力されている状態で、今日の日付のセル範囲を割り出す例文です。 Sub sample() Dim i, ii As Long, APP Set APP = Application With Columns(1) ii = APP.CountIf(.Cells, Date) If ii > 0 Then i = APP.Match(CLng(Date), .Cells, 0) MsgBox "今日の日付が入力されている範囲は、" & .Cells(i).Resize(ii).Address(False, False) End If End With End Sub 常套手段のCOUNTIFとMATCHの関数合わせ技。
他回答のMatchを使うのがいいでしょうね。既出なのでここではFindを説明します。Matchは検索範囲の何番目か整数が戻ります。Matchの方が速いですが、1列しか検索出来ません。Findはシート全域で可能です。Findはヒットしたセルが戻ります。どちらも「見つからなかった場合の処理」をしないとエラーになります。どちらもうまく設定すれば検索対象が複数個あっても対応可能です。 Sub TestFind() Dim ret As Range Dim Key Key = 100 Set ret = Columns("A").Find(what:=Key) If ret Is Nothing Then Exit Sub MsgBox ret.Row End Sub よくある失敗 Dim ret As Variant ret=Columns("A").Find(what:=Key).Row セルが戻るのだから.Rowを付ければ行番号でしょ？１行で済むじゃん！ 見つかれば確かにセルが戻りますが、見つからない場合はNothingが戻ります。これはセルではありません。セルでないものに.Rowなど付けたらエラー終了します。Findを使う際は必ず注意するお約束です。 その他の注意 Findを検索すると分かりますが、オプションが多数あります。どこから調べるか、どっち方向に調べるか、etc。その代わり、一旦設定したオプションは保持されます。次回の検索で変えたい時は注意が必要です。さらに、手動で「検索」した際のオプション設定も保持されます（笑） 結論いうと「１列検索の時はMatch使え」です。
どのような症状が起きるのかを書いていただかないと、回答者は戸惑います。 文法的な間違いなら、以下の２つのどちらかに変更すれば解消するはず。 １） Z.Range(Cells(FoundCell1.Row, 1), Cells(FoundCell2.Row, 116)).Copy _ H.Range(Cells(3, 1), Cells(3 + (FoundCell2 - FoundCell1), 116)) ２） Z.Range(Cells(FoundCell1.Row, 1), Cells(FoundCell2.Row, 116)).Copy H.Range(Cells(3, 1), Cells(3 + (FoundCell2 - FoundCell1), 116)).PasteSpecial あとは、 １） コピー元とコピー先のセル範囲が、コピーの規則に合う正しい形をしているのか を確認する必要があります。 ２） 「FoundCell2 - FoundCell1」は、2つのセル（なんですよね？）の「値の差」を求めてます。 意図したものなら良いのですが・・・。
テキストボックスの名前が AdvMaskEd ならば Private Sub AdvMaskEd_Change() End Sub で、数字キーを打鍵した時にイベントが発生するはずです。 もちろん Click イベントは Private Sub AdvMaskEd_Click() End Sub です。 例えば Private Sub AdvMaskEd_Change() MsgBox "Change" End Sub Private Sub AdvMaskEd_Click() MsgBox "Click" End Sub で、AdvMaskEdをクリックした時と、数字または文字で内容が変更された時にイベントが発生しませんか? ただ Click では打鍵した結果のテキストボックスの内容はわかりますが、どんなキーを打鍵したかはわかりません。 Clickイベントは発生してChangeイベントが発生しないプログラムを教えてください。 また Private Sub AdvMaskEd_Change() MsgBox "Change" End Sub Private Sub AdvMaskEd_Click() MsgBox "Click" End Sub ではどうでしょうか。
http://wtakemo.hatenablog.com/entry/2014/03/10/025526
Sub Sample() Range("A2,A5:A" & Range("A" & Rows.Count).End(xlUp).Row).ClearContents End Sub です。 いちいちセル範囲をSelectやActivateする必要はありませんし、Rangeオブジェクトへのセル範囲の指定の仕方を工夫すれば「.Address」は不必要になります。
こんな感じですかね？ 3万行×200種類だと200回抽出じゃなくて600万回ですよ。 ループすると時間かかりそうなのでオートフィルタにしました。 試してないので動かなかったらごめんなさいｗ Dim Endrow as long Dim tmp as string Endrow=worhsheet("sheet1").cells(row.count,4).end(xlup).row Open テキストのフルパス for input as #1 Do until eof(1) Line input #1,tmp worksheets("sheet1").Range("A1:D" & Endrow).AutoFilter _ field:=4,Criteria1:="*" & tmp & "*" worksheets.add.after:=worksheets(worksheets.count) activesheet.name=tmp worksheets("sheet1").Range("A1:D" & Endrow).Copy worksheets(tmp).Range("A1").pastespecial Loop Close #1
Range("C33,D33, E33").value = "同じ文字が入る筈"
ActiveXのコマンドボタンを使うのでしたら、 Private Sub CommandButton1_Click() Dim MTo As String MTo = "Mailto:" & Range("B2").Value CreateObject("WScript.Shell").Run MTo End Sub
ブックのアドレス（ファイル名？）が書かれているセルA1～A10を繰り返すFor～Nextを追加します。 以下は一例ですが、シート名がわかりませんでしたので、アクティブシートのA1～A10を使用するようにしています。 ただし、テストはしておりません。 Sub シート() Dim bk As Workbook 'ファイル名のセル用変数 Dim rng As Range 'アクティブシートのセルA1～A10を繰り返し処理 For Each rng In ActiveSheet.Range("A1:A10") 'セルの値のファイルを開く Set bk = Workbooks.Open(Filename:=rng.Value, ReadOnly:=False, IgnoreReadOnlyRecommended:=True) Application.DisplayAlerts = False bk.Worksheets("リスト").Delete ThisWorkbook.Worksheets("リスト").Copy _ After:=bk.Sheets(bk.Sheets.Count) bk.Save bk.Close Application.DisplayAlerts = True '繰り返しここまで Next End Sub
https://msdn.microsoft.com/ja-jp/library/dd314356.aspx ココを熟読
>と変換するマクロはありますでしょうか？ というより作るしかありません。 ひとつのセルに改行で区切った住所、氏名が入っていて順番を入れ替える （１）セルの内容を改行で区切る→Split関数 （２）内容が５行あって、２行目は「住所」なら該当の形式だと判断 （３）元のせるに、４行目＋改行＋５行目＋改行＋１行目＋"さま" を入れる
こんな感じでどうでしょうか。 Sub Sample() Dim Sh As Worksheet Dim Nm As String For Each Sh In Worksheets Nm = Sh.Name Select Case Nm Case "A-A" Sh.Range("AY1") = 1 Case "A-B" Sh.Range("AY1") = 2 Case "A-C" Sh.Range("AY1") = 3 End Select Next End Sub
エラーが出るのは「For Each sht・・」の部分を１回目に通過する時ですか。 それとも何度目かですか。 cp wb(i), sht.Name, TextBox1.Text, i でどんな処理を行っているのかわかりませんが、wb(0)のシートを途中で消したり他のbookに移動したりしていませんか。 （参考）変数が削除または移動したシートを参照するときに [xl97]: エラー https://support.microsoft.com/ja-jp/kb/158997
いくつか方法はあると思いますが、単純な方法が分かり易いと思います。 Sub test() endrow = Cells(Rows.Count, 1).End(xlUp).Row msg = "" For r = 5 To endrow msg = msg & Cells(r, 1).Value & "," Next msg = Left(msg, Len(msg) - 1) Range("A2").Value = msg End Sub 「End(xlUp)」というのは、「Ctrl+↑」を押した結果の移動先を示しています。それを「Cells(Rows.Count, 1)」つまりA列の最終行番号のセルに適用していますので、そのセルから「Ctrl+↑」を押した結果が得られます。後はRowプロパティが付いていますので、得られた移動先の行番号を取得しています。 特殊なのは上記の点ぐらいです。後は、範囲内のセルを順番に取り出し、変数「msg」にカンマ付きで付け足していきます。ただし、これだと末尾に余計なカンマが残りますので、Leftを使って、切り取っています。 これをボタンに登録してみてください。
え、商品名のトコにif文かましてやればいいんじゃない？
まず何の質問なのか？ つまり動作環境や言語が不明ですが。。。 > VBScriptは現在勉強中でほぼ初心者です。 ということは 「Windows のローカル環境で動作する VBS ファイル内で使われる VBScript の質問」 と解釈して良いのでしょうか？ (ASP の VBScript や HTML や HTA 内の VBScript は無視。) そういうこととして以下を続けます。 まず，Cドライブの直下に 「A」というフォルダ C:\A と 「B」というフォルダ C:\B があるとします。 さらに， C:\A の "直下" には 20160629-0001.jpg 20160629-0002.jpg 20160629-0003.jpg というファイルがあり C:\B の "直下" には 20160629-0001.jpg 20160629-0012.jpg 20160629-0013.jpg というファイルがあったとする場合 その差分(不一致ファイル名)である 20160629-0002.jpg 20160629-0003.jpg 20160629-0012.jpg 20160629-0013.jpg を出力するものとします。 その場合の VBS ファイルの VBScript コード例です↓。 '-------------------------------------- '比べる２つのフォルダのパスを設定 FolderA = "C:\A" FolderB = "C:\B" 'ファイルシステムオブジェクトを作成 Set FSObj = CreateObject("Scripting.FileSystemObject") 'FolderA のフォルダオブジェクトを取得 Set FldObj = FSObj.GetFolder(FolderA) '連想配列 DicA を作成 Set DicA = WScript.CreateObject("Scripting.Dictionary") 'フォルダオブジェクトの Files から File 名を取得 For Each FilObj In FldObj.Files     '取得したファイル名を DicA のキーに登録     DicA.Add FilObj.Name, True Next 'FolderB のフォルダオブジェクトを取得 Set FldObj = FSObj.GetFolder(FolderB) '連想配列 DicB を作成 Set DicB = WScript.CreateObject("Scripting.Dictionary") 'フォルダオブジェクトの Files から File 名を取得 For Each FilObj In FldObj.Files     '取得したファイル名を DicB のキーに登録     DicB.Add FilObj.Name, True Next 'DicA 内のキーを走査 For Each KeyA In DicA.Keys     'もし DicB キーに DicA のキー があれば     If DicB.Exists(KeyA) Then         'DicA と DicB からそのキーを削除         DicA.Remove KeyA         DicB.Remove KeyA     End If Next '改行をセパレータとした文字列として不一致キーを取得 Sep = vbCrLf DisStr = Join(DicA.Keys, Sep) & Sep & Join(DicB.Keys, Sep) '不一致キー(不一致ファイル名)を表示してみる WScript.Echo DisStr 'オブジェクトの解放 Set DicA = Nothing Set DicB = Nothing Set FldObj = Nothing Set FSObj = Nothing '--------------------------------------
Sub Sample() Const xPath As String = "C:\AAA\" FileCopy xPath & "元のファイル.xls", xPath & Format(Date, "Ammdd") & ".xls" End Sub
手前のシートが、Book1.xlsのSheet1 奥のシートが、Book2.xlsのSheet2 としてプログラミングされています。 Sub 一例です｡() Dim sh As Worksheet, APP, rngx As Range Dim ii As Long, i, j, rng As Range Set sh = Workbooks("Book1.xls").Worksheets("Sheet1") Set APP = Application With Workbooks("Book2.xls").Worksheets("Sheet2") Set rngx = .Cells(3, 1).Resize(9) ii = APP.CountIf(sh.Columns(1), CLng(.Cells(1, 1).Value)) If ii > 1 Then i = APP.Match(CLng(.Cells(1, 1).Value), sh.Columns(1), 0) For Each rng In sh.Cells(i, 2).Resize(ii) j = Application.Match(rng.Value, rngx, 0) If Not IsError(j) Then rng.Offset(, 1).Resize(, 2).Copy rngx.Cells(j).Offset(, 1) End If Next rng End If End With End Sub
ComboBox1とCommandButton1がある場合です。 Private Sub CommandButton1_Click() Select Case ComboBox1.Value Case "セット" Sheets("Sheet2").Range("A2:A8").Copy Sheets("Sheet1").Range("A2:A8") Case "単品" Sheets("Sheet3").Range("A2:A8").Copy Sheets("Sheet1").Range("A2:A8") End Select End Sub 選択しない場合の警告を出す場合です。 Private Sub CommandButton1_Click() Select Case ComboBox1.Value Case "セット" Sheets("Sheet2").Range("A2:A8").Copy Sheets("Sheet1").Range("A2:A8") Case "単品" Sheets("Sheet3").Range("A2:A8").Copy Sheets("Sheet1").Range("A2:A8") Case Else MsgBox "選んでください" End Select End Sub 前もってComboBox1に値が設定している場合です。 例えば下記です。 Sub sample() ComboBox1.Clear ComboBox1.AddItem "セット" ComboBox1.AddItem "単品" End Sub
>ActiveSheet.Range(cells(i,j)).Copy ’ここで実行時エラー は、 ActiveSheet.Range(Cells(i, j).Value).Copy と書くのと同じ。 なので、 Cells(i, j)の値は、セルアドレスを示す値（A1,B1,$A$1など）でないとダメですね。 あと、いくつか指摘。 １） Dim i, j As Integer は、 Dim i As Variant, j As Integer と書いたと見做されます。 あなたの意図と違いますよね？ Dim i As Integer, j As Integer と正しく書きましょう。 あと、行番号は、Long。Integerでは、格納できない行番号がでてきますよね？ ２） SelectやActivateは使わないようにしましょう。 実行速度が落ち、プログラムが読みにくくなります。 全体を見直すなら↓のような感じ。 Sub テスト() Dim ShB As Worksheet Dim i As Long, j As Long Set ShB = ThisWorkbook.Worksheets("B") With ThisWorkbook.Worksheets("A") For j = 5 To .Cells(4, Columns.Count).End(xlToLeft).Column For i = 5 To .Cells(Rows.Count, 3).End(xlUp).Row If .Cells(i, j).Value > 0 Then .Cells(i, j).Copy 'ここで実行時エラー ShB.Cells(Rows.Count, 2).End(xlUp).Offset(1).PasteSpecial xlPasteValues End If Next Next End With Set ShB = Nothing Application.CutCopyMode = False End Sub 未実行につき不具合ご容赦。
こんなでしょうか Sub sample() Dim ws1 As Worksheet Dim ws2 As Worksheet Dim rng As Range Dim c As Integer Dim rngR As Range ' Set ws1 = Sheets("Sheet1") '奥のシート Set ws2 = Sheets("Sheet2") '手前のシート If ws1.Range("A1").Value = "" Then Exit Sub '奥のシートのA1が無ければ終わり Set rng = ws2.Range("2:2").Find(ws1.Range("A1").Text, LookIn:=xlValues, LookAt:=xlWhole) '手前のシートの2行目で、奥のシートのA1の値を探す If rng Is Nothing Then Exit Sub '無ければ終わり c = rng.Column '日付を見つけた列 For Each rng In ws1.Range("A3:A7,I3:I7") '奥のシートのA3:A7,I3:I7を順に調べる Set rngR = ws2.Range("A:A").Find(rng.Value, LookIn:=xlValues, LookAt:=xlWhole) '手前のシートのA列で、注目セルの値を探す If Not rngR Is Nothing Then 'あったら rng.Offset(0, 5).Value = ws2.Cells(rngR.Row, c).Value '注目セルの5セル右に、見つけたセルの行と日付を見つけた列の交点の値を入れる End If Next End Sub
Excel VBAのWorksheet_Changeイベントを使えば自動化できます。 具体的なシートレイアウトが何も判らないのでこれ以上は回答出来ません。
http://m.webry.info/at/89395735/201104/article_1.htm?i=&p=&c=s&guid...
これで、どんなSQLが発行されるかイメージしてください。 ダブルクォートは、VBの文字列部分を括っています。 シングルクォートはSQL内で文字列部分を括っています。 Textbox1に「123」と入力されたとして SELECT * FROM orders WHERE MemberID = '123' このようなSQLが発行されます。「'」は123を括ってるやつです。
「主キーがなく、かつAのセルが2のデータ」に対して「だけ」削除フラグを立てるのですか？ それとも前回の条件に加えて新たに「主キーがなく、かつAのセルが2のデータ」にも削除フラグを立てるのですか？ 「除外したいのはＡのセルが1と9の時です」の意味が判りません。
誤） "C:\Users\TOYOJI\前のPCﾃﾞｰﾀ\&l" 正） "C:\Users\TOYOJI\前のPCﾃﾞｰﾀ\" & l です。 提示されたコードはそれ以外にも非常に危険なコードです。 コード例を示します。 Option Explicit Sub sample() Dim l As String Dim newFolder As String l = InputBox("氏名", "新人追加", "") If l <> "" Then '新しいフォルダ名を組み立てる newFolder = "C:\Users\TOYOJI\前のPCﾃﾞｰﾀ\" & l 'エラーを無視して次の行を実行する On Error Resume Next 'フォルダを作成する MkDir newFolder 'フォルダ作成に成功していたとき If Err = 0 Then 'カレントディレクトリを作成したフォルダに変更する ChDir newFolder End If 'エラートラップを再開する On Error GoTo 0 End If End Sub ポイントは ①VBAではダブルクォーテーションでくくられた範囲を文字列と見なします。 ②InputBoxを使うときは「キャンセル」が押された時のことを考慮しましょう。 ③フォルダ作成に失敗してしまうとエラーが発生してプログラムがそこで止まってしまうので、きちんとエラー対策をしましょう。 ④同じ文字列を扱うときは文字列変数に格納して使いましょう。 ⑤プログラムの先頭には必ず「Option Explicit」という一行を記述しましょう。（変数のスペルミスによるプログラム動作不良を防ぐことが出来ます） です。
既に別の回答者さんからも指摘されていますが「IF構文を使うと、連続した命令が出せなく」という文章が理解出来ません。 あなたがしたいと思っていることを具体的な例を示して補足していただけますか？
自動でというのは、どのタイミングででしょうか？ ページを表示したとき？ 一定の時間がたった時？ なにか別のところをクリックしたとき？ 自動で実行するタイミングがいつかによって、処理が変わってきますので、 教えていただけますか？
Sub sample() Range("A1").Select Do While Selection.Value <> "" Selection.Hyperlinks(1).Follow NewWindow:=False, AddHistory:=True Call 処理 Selection.Offset(1).Select Loop End Sub ということですかね？
こんにちは。 Sub Test() If DateValue(Date) + TimeValue(Now + TimeValue("00:03:00")) < Now Then ResTime = DateValue(Date + 1) + TimeValue(Now + TimeValue("00:03:00")) Else ResTime = DateValue(Date) + TimeValue(Now + TimeValue("00:03:00")) End If Cells(2, 1) = Now Cells(1, 1) = ResTime Application.OnTime ResTime, "Test", TimeValue("00:01:00") Cells(3, 1) = "" End Sub は Sub Test() ResTime = Now + TimeValue("00:03:00") Cells(2, 1) = Now Cells(1, 1) = ResTime Application.OnTime ResTime, "Test", TimeValue("00:01:00") Cells(3, 1) = "" End Sub ですね。ontimeに、「日と時を指定して、命令を出してください。 timevalueは、「日」の部分は、データとしてカットします。 パソコンの電源は、カットできませんし、これで、深夜23時50ぐらいから、挙動を確認してください。
プロテクトする時にUserInterfaceOnlyをTrueにすると、手作業はプロテクトされるけれど、VBAはプロテクトされません。 Sub sample() Range("A1").Locked = False Range("A2").Locked = True ActiveSheet.Protect UserInterfaceOnly:=True Range("A2").Value = "abc" 'Protect後もLockedされてるA2に書き込める End Sub
そこの動作は変更できないですね。 リボンの「検索」クリックまたは Ctrl+F で出る検索ダイアログなら 特定フィールドのみ対象にしたり、完全一致か部分一致などを指定して検索できます。
こんにちは。 >すでにあるものに 主様は、これを、よく理解していない、ということですよね。 そんなに急いでいるのでしたら、ここに乗せたら、答えもつくでしょうに。 マクロのコードで、直接相談なんて、あまり聞きません。
時間と名前が複数列あるようですが、リストボックスにはどのように表示するのでしょうか？ 具体例をあげて説明してください。
Visual Basic6.0 (sp6)ランタイムは一番新しいですが既に古いものです。 ウィンドウズ１０ではインストール中に「VB６ランタイムがセキュリティのめんで危険です。」ような表示出ませんでしたか？ そのため、VB6ランタイムの必要なソフトは使用をやめました。
> 最終的なゴールは、VBAにより、 > 選択されている画像を抽出したい この意味(関連性)が全くわかりませんが とりあえず無視ということで以下を続けます。 > 現在拡大表示された画像が何であるか > ～略～ > 選択された画像を把握する方法 「選択(クリック)された画像」と「拡大表示された画像」とは別物ですよ。 また， 「拡大表示された画像」は選択された画像で実行される関数の引数からわかるでしょう？ <img src="小さな画像ファイル名1" onClick="Imgche('大きな画像ファイル名1')"> 「小さな画像ファイル名1」がクリックされたときに 関数 Imgche が実行されその引数で指定された 「大きな画像ファイル名1」の画像が name="space" の部分に表示されるのです。 「小さな画像ファイル名1」がクリックされたときに 「小さな画像ファイル」が何であるかは 現状ではわかりませんね。 ですから 「小さな画像ファイル」が何であるかを知りたいときは それも引数で渡してやれば良いかと思います。 または クリックされたエレメント自体を this として引数で渡し， そのエレメントの src 属性を見るとか。 とにもかくにも 別関数を使うか， 今の関数の引数を変えるかのどちらかになるでしょう。 書かれていらっしゃるサイトのスクリプトを 拝借＆変更 させていただくことにします↓。 . ◎「小さな画像ファイル名」を引数として渡す方法例↓ <html> <head> <title></title> <script type="text/javascript"> <!-- function Imgche(ado, sml) { document.space.src=ado; alert("選択された画像のファイル名…" + sml); alert("拡大された画像のファイル名…" + ado); } // --> </script> </head> <body> <center> <p> <img src="小さな画像ファイル名1" onClick="Imgche('大きな画像ファイル名1','小さな画像ファイル名1')"> <img src="小さな画像ファイル名2" onClick="Imgche('大きな画像ファイル名2','小さな画像ファイル名2')"> <img src="小さな画像ファイル名3" onClick="Imgche('大きな画像ファイル名3','小さな画像ファイル名3')"> <img src="小さな画像ファイル名4" onClick="Imgche('大きな画像ファイル名4','小さな画像ファイル名4')"> <img src="小さな画像ファイル名5" onClick="Imgche('大きな画像ファイル名5','小さな画像ファイル名5')"> </p> 小さな画像をクリックすると額に大きな画像が表示されます。 <p style="border: ridge 10 #cccc66; width: 300; height: 300; background-color: #cccc66; "> <img src="最初に表示されている画像" width="300" height="300" name="space"> </p> </center> </body> </html> . ◎選択されたエレメントを引数として渡す方法例↓ <html> <head> <title></title> <script type="text/javascript"> <!-- function Imgche(ado, elm) { document.space.src=ado; alert("選択された画像のURL…" + decodeURI(elm.src)); alert("拡大された画像のURL…" + decodeURI(document.space.src)); } // --> </script> </head> <body> <center> <p> <img src="小さな画像ファイル名1" onClick="Imgche('大きな画像ファイル名1',this)"> <img src="小さな画像ファイル名2" onClick="Imgche('大きな画像ファイル名2',this)"> <img src="小さな画像ファイル名3" onClick="Imgche('大きな画像ファイル名3',this)"> <img src="小さな画像ファイル名4" onClick="Imgche('大きな画像ファイル名4',this)"> <img src="小さな画像ファイル名5" onClick="Imgche('大きな画像ファイル名5',this)"> </p> 小さな画像をクリックすると額に大きな画像が表示されます。 <p style="border: ridge 10 #cccc66; width: 300; height: 300; background-color: #cccc66; "> <img src="最初に表示されている画像" width="300" height="300" name="space"> </p> </center> </body> </html> ↑実際の画像は用意しなくても 上の HTML のみで，取得動作だけはすると思いますよ。 (画像を用意しなければ画像が表示されないだけのことです。) . または 「現在拡大表示された画像のURL」でしたら クリックするときとかに関わらず 知りたいときに document.space.src を取得すれば良いだけです。 ◎知りたいときに「現在拡大表示された画像のURL」を知る方法例↓ <button id="btn" onclick="alert(decodeURI(document.space.src))"> 拡大表示されている画像のURLを表示</button> <br> <button id="btn" onclick="alert(decodeURI(document.space.src.match('.+/(.+?)([\?#;].*)?$')[1]))"> 拡大表示されている画像のファイル名を表示</button> ↑コレを HTML の body 内の好きなところに貼り付ければ良いだけです。
こちらで確認しましたが、正常に読み取れています。 コードは下記です。 static void Main(string[] args) { var doc = new XmlDocument(); doc.LoadXml(@"* * X M L 文 字 列 * *"); foreach (XmlAttribute a in doc.DocumentElement.Attributes) { Console.WriteLine(a.Name + "=" + a.Value); } }
行のロックもチェックボックスのロックも可能です。 ロックはシートを保護しないと有効になりませんが、それは理解していますか？ 行のロックは、たとえば４行目をロックするなら Rows(4).Locked = True です。 シート上に挿入するチェックボックスにはフォームコントロールとActive X コントロールの２種類があります。 どちらもLocked = Trueと同時にEnabled = Falseを設定しないとロックを掛けることは出来ません。 WorkSheet_Changeイベントで 値が変更されたセルの行全体とチェックボックスにロックを掛ける例です。 Private Sub Worksheet_Change(ByVal Target As Range) Dim rng As Range Dim obj As Variant '変更されたすべてのセルを対象とする For Each rng In Target.Cells If rng.Value <> "" Then 'シートの保護を解除する ActiveSheet.Unprotect '変更されたセルの行すべてをロックする Rows(rng.Row).Locked = True '変更されたセルの行に存在する全てのチェックボックス(フォームコントロール)をロックする For Each obj In CheckBoxes If rng.Row >= obj.TopLeftCell.Row And _ rng.Row <= obj.BottomRightCell.Row Then obj.Locked = True obj.Enabled = False End If Next '変更されたセルの行に存在する全てのチェックボックス(ActiveXコントロール)をロックする For Each obj In OLEObjects If TypeOf obj.Object Is MSForms.CheckBox Then If rng.Row >= obj.TopLeftCell.Row And _ rng.Row <= obj.BottomRightCell.Row Then obj.Locked = True obj.Enabled = False End If End If Next obj End If 'シートの保護を設定する ActiveSheet.Protect Next rng End Sub しかし「値を入力したセルの行全体にロックを掛け」てしまうと、シートの保護を解除しないかぎり、修正も出来なくなりますが宜しいのでしょうか？
Sub a() With ActiveSheet 'ハイパーリンククリア .Hyperlinks.Delete 'A列の最終行を取得 max_row = .Cells(Range("A:A").Rows.Count, 1).End(xlUp).Row For i = 1 To max_row 'A列およびD列が存在する場合のみ If .Cells(i, 1).Value <> "" And .Cells(i, 4).Value <> "" Then 'ハイパーリンク追加（Anchorがリンクをつける対象セル、Addressがリンクのアドレス） .Hyperlinks.Add Anchor:=.Cells(i, 4), Address:=.Cells(i, 1).Value End If Next End With End Sub
Accessでは、フォームとレポートは連動はしません。 フォームは、テーブルからフォーム、またはテーブル、クエリ、フォームという流れでデータが関連付けられます。 レポートも同様で、テーブルからレポート、またはテーブル、クエリ、レポートいう流れでデータが関連付けられます。 レポートは出力されるオブジェクトなので、レポートのデータからクエリやテーブルへデータは流れません。 レポートで表示したいフィールド（項目）をまず決めておきます。 その項目を抽出させるために、テーブルを元にクエリを作成し、そのクエリを元にフォームを作成します。フォーム上に必要な条件を指定して、クエリを実行するとレポートが表示されるようにするのが一般的ですね。
以下のコードでいかがでしょうか。 セルのTagプロパティを利用して読み込み済みかそうでないかを判定しています。 Public Class Form1 'ﾎﾞﾀﾝが押されたら Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click 'ｾﾙの内容を取得 Dim list As New List(Of String) With DataGridView1 For r As Integer = 0 To .RowCount - 1 For c As Integer = 0 To .ColumnCount - 1 Dim Cell As DataGridViewCell = .Item(c, r) If Not Cell Is Nothing Then 'セルの内容がNull以外、かつTagプロパティがTrue以外のとき If Not String.IsNullOrEmpty(Cell.Value) And CBool(Cell.Tag) <> True Then 'コンボボックス追加用のリストにセルの値を追加する list.Add(Cell.Value) 'セルのTagプロパティにTrueをセットする .Item(c, r).Tag = True End If End If Next Next End With 'コンボボックス追加用のリストが空のときは処理を抜ける If list.Count = 0 Then Exit Sub 'ｺﾝﾎﾞﾎﾞｯｸｽに追加 DataGridView2.Columns.Add(New DataGridViewComboBoxColumn() With { .DataSource = list, .DataPropertyName = "CodeAfter", .HeaderText = "コード変更" }) End Sub End Class
求めてる対策かどうかわからんが、、 Sub test() With Worksheets("Sheet1").Range("DN20") .Formula = _ "=MAX(IF($N$20:$N$2000=N20,$L$20:$L$2000))" .FormulaArray = .Formula .AutoFill Destination:=Range("DN20:DN2000") End With 、、とか
当方Ｗｉｎ１０とアクセス２００７ですが、そのような現象は出ていません。 使用不可では無く ・オフ ・半角英数 等では如何でしょうか？
以下でどうなりますか ベタでやってみましたが････ やっていることは、１セルずつ書き出しするのは遅いので････ １度 Const CBUFSZ As Long = 50000 の行数で蓄えます カンマで区切るのは後回しにして、１行の文字列をつなげていきます データを読み終わったら･･･ 読書き行数で、区切り位置にてセル分割します （全行を指定して１回でやった方が速いのかも？？） ※ Const CLMAX As Long = 1000000 行数書き出したら、 A 列を読み込まず、列を進めて書き出しした方が速いかも？ Public Sub Samp1()    Dim ffn As Integer    Dim vA As Variant    Dim sFile As String, sBuf As String, sH As String    Dim i As Long, j As Long    Const CBUFSZ As Long = 50000 ' １回の読書き行数    Const CLMAX As Long = 1000000 ' 折り返し行数    With Application.FileDialog(msoFileDialogFilePicker)       .AllowMultiSelect = False       .Filters.Clear       .Filters.Add "処理対象CSVファイル", "*.csv"       If (Not .Show) Then Exit Sub       sFile = .SelectedItems(1)    End With    Application.ScreenUpdating = False    ffn = FreeFile()    Open sFile For Input As #ffn    sH = ""    i = 1: j = 1    ReDim vA(1 To CBUFSZ, 1 To 1)    While (Not EOF(ffn))       If (i > CBUFSZ) Then          Cells(j, "A").Resize(CBUFSZ).Value = vA          j = j + CBUFSZ          If (j > CLMAX) Then             j = 1             sH = ","          End If          If (Len(sH) > 0) Then             vA = Cells(j, "A").Resize(CBUFSZ).Value          Else             ReDim vA(1 To CBUFSZ, 1 To 1)          End If          i = 1       End If       Line Input #ffn, sBuf       vA(i, 1) = vA(i, 1) & sH & sBuf       i = i + 1    Wend    Cells(j, "A").Resize(CBUFSZ).Value = vA    Close #ffn    j = 1    While (j <= CLMAX)       With Cells(j, "A").Resize(CBUFSZ)          .TextToColumns .Cells(1), xlDelimited, Comma:=True       End With       j = j + CBUFSZ    Wend    Application.ScreenUpdating = True End Sub ' 確認用簡易データ作成 Public Sub testData()    Dim ffn As Integer    Dim vA(2) As Variant    Dim i As Long    Const CLMAX As Long = 3210987    Const CFILE As String = "D:\Moge\Moge.csv" ' ★    Randomize    ffn = FreeFile()    Open CFILE For Output As #ffn    i = 1    While (i <= CLMAX)       vA(0) = i       vA(1) = Format(100 * Rnd(), "0.0")       vA(2) = Format(100 * Rnd(), "0.0")       Print #ffn, Join(vA, ",")       If ((i Mod 10000) = 0) Then          Debug.Print i          DoEvents       End If       i = i + 1    Wend    Close #ffn End Sub
ビルドすると、そのプロジェクトのフォルダにbinフォルダが有るんでその中のDebugもしくはReleaseフォルダにコンパイルされたexeファイルが出来てます。 Releaseでコンパイルした物が配布用だったんだけど、どう切り替えたかは失念。
「お助け下さい」と言われても、具体的なサンプル表がないので、助けようがありません。 どういう「品番と仕入先コード」「商品名と値段」「注番や希望納期など必要な項目」が何処にあるのか？ 「関数も初心者」「適切な参照データ」と言われてもなぁ～
こんちには。 vbaで、画面のハンドルの一覧を取得してリストにするコードとか、いろいろツールを集めてください。 昔やったことはありますが、不安定で、そんなに良くないです。 最近は、IEのセキュリティメッセージが、その方法で、出来なくなったり、と、半ば嫌気がさしてます。 そのターゲットに合わせたニーズで探したほうが、いいですね。
一例です。 Sub PDFファイル保存() Dim fname As String '名前を付けて保存ダイアログ fname = Application.GetSaveAsFilename( _ Title:="保存先を選べ！" _ , InitialFileName:="" & Range("B10").Text & "様_御見積もり(" & Range("T18").Text & "_" & Range("C18").Text & "KW)" _ , filefilter:="PDF形式だよ,*.pdf,すべてのファイル,*.*") 'キャンセルの場合 If fname = "False" Then Exit Sub 'PDF変換対象のシート Worksheets(Array("見積", "明細", "追加見積", "追加見積もり 明細")).Select '変換 ActiveSheet.ExportAsFixedFormat Type:=xlTypePDF, _ Filename:=fname, Quality:=xlQualityStandard, IncludeDocProperties:=True, _ IgnorePrintAreas:=False, OpenAfterPublish:=False Application.Goto Worksheets("入力フォーム").Range("A2") End Sub 未実行につき不具合ご容赦。
あなたの書いたプログラムを載せてください
Windows(Range("A1").Value & "yyyymm販売.xls").Activate
VBAからUWSCを起動する方法は、以下の方法で可能です。 Set sh=CreateObject("WScript.Shell") 'UWSCのスクリプトを実行 Set objExec=sh.Exec("UWSCパス\uwsc.exe スクリプトフルパス") '実行終了まで待機 Do While (objExec=0) DoEvents Loop ただ、手順5の「Ctrl+V」ですが、VBAで実行するよりは、UWSCで実行した方が遥かに容易ではないかと思います。 後、手順6でブラウザを閉じてしまっていますが、ループのたびに起動し直すのは効率が悪いと思います。また、せっかく値を貼り付けたのに、閉じてしまって良いのでしょうか。何かブラウザ側で操作するのではありませんか？ そして、VBAでのブラウザ操作と言うと、IE操作が連想されるのですが、これで良いのでしょうか。 上記のような疑問点があるのと、手順のうち、どこを理解しているのかが不明だったので、今回はVBAからUWSCを起動する部分のみの回答となりました。 不明な点がはっきりすれば、コードは示せると思います。
基本的には "請求書" & Range("A1").Value でいいです。 ですが、もしA1に入っているのが数字の7で、そこから「請求書０７」にしたい、ということだと、ひと工夫必要になります。
こんなでしょうか。 Sub sample() Dim lastRow As Long Dim r As Long lastRow = Range("K" & Rows.Count).End(xlUp).Row 'K列最終行 For r = 1 To lastRow '注目行を1行目からK列最終行まで If Range("K" & r).Value < 0 Then 'もしK列注目行の値がマイナスの場合 If Range("M" & r).Value = "" Then 'もしM列注目行の値が無い場合 Range("M" & r).Value = -Range("K" & r).Value 'M列注目行の値をK列注目行の値のマイナスの値(マイナスのマイナスでプラス)にする End If End If Next End Sub また、K列の値が数値とは限らない場合は、そのチェックも必要となります。 Sub sample() Dim lastRow As Long Dim r As Long lastRow = Range("K" & Rows.Count).End(xlUp).Row 'K列最終行 For r = 1 To lastRow '注目行を1行目からK列最終行まで If IsNumeric(Range("K" & r).Value) Then 'もしK列注目行の値が数値の場合 If Range("K" & r).Value < 0 Then 'もしK列注目行の値がマイナスの場合 If Range("M" & r).Value = "" Then 'もしM列注目行の値が無い場合 Range("M" & r).Value = -Range("K" & r).Value 'M列注目行の値をK列注目行の値のマイナスの値(マイナスのマイナスでプラス)にする End If End If End If Next End Sub
>コードの問題ではないと思います。 質問するのなら、自身で判断しないですべてをさらけ出すくらいの考えをもたないと問題解決は無理。 どのようなコーディングがされたかが解らないのでは、再現テストさえできませんよね？そのような状態では、アドバイスしようがない というのはお解りですよね？ アドバイスするのなら、こんな事↓しか思いつきません。 相当前から、RefEdit コントロール は、トラブルが多いので有名でした。 http://www.h3.dion.ne.jp/~sakatsu/Excel_Tips08.htm あなたが使っているバージョンでどうなのかは、ご自身で調べる必要があるのかも。
Sub sample() Columns(1).SpecialCells(xlCellTypeBlanks).Delete Shift:=xlUp End Sub
hoijujdhuoshdo さん、こんばんは。 まずアルゴリズムですが、C:\TEST フォルダにあるファイルを開く処理はMacro2で行っているので、削除作業もMacro2 で行う方が良いと思います。 （Macro1 で削除してしまうと、Macro2 に戻った時に、 WB.Close ステートメントでエラーになります。） それから、ファイルを削除する Kill ステートメントの引き数は文字列で指定します。 お書きのコードでは、文字列にWorkbook オブジェクトをひっつけていますので、エラーになります。 従って、お書きののコードを、例えば下のように変更してみてはいかがでしょうか？ Macro1 中 Kill "c:\TEST\" & WB ActiveWindow.Close の２行を削除 Macro2 中 If Range("M3").Value = 201606 Then 'M3値で条件分岐 Call macro1 WB.Close Kill fol & "\" & f 'この行を追加 End If あと、余談ですが、Macro2 でM3の条件分岐にひっかからなかった場合は元ファイルを閉じない仕様になっていますが、そこは問題ないのですかね？ ちょっと気になったので。
BouncyCastleというライブラリを使うと、 PKCS12の読み書きが簡単にできます。 NuGetから「BouncyCastle」をインストールすると使えます。 MITライセンスなので安心です。 下記はC#ですが、鍵生成からPKCS12の生成と 入出力を実験してみたコードです。 ご参考になりましたら。 using System; using System.Collections.Generic; using System.IO; using System.Text; using Org.BouncyCastle.Asn1; using Org.BouncyCastle.Asn1.X509; using Org.BouncyCastle.Crypto; using Org.BouncyCastle.Crypto.Generators; using Org.BouncyCastle.Crypto.Operators; using Org.BouncyCastle.Crypto.Parameters; using Org.BouncyCastle.Crypto.Prng; using Org.BouncyCastle.Math; using Org.BouncyCastle.OpenSsl; using Org.BouncyCastle.Pkcs; using Org.BouncyCastle.Security; using Org.BouncyCastle.X509; namespace ConsoleExample { class Program { static void Main(string[] args) { // 鍵のジェネレータ var randGen = new CryptoApiRandomGenerator(); var rand = new SecureRandom(randGen); var param = new KeyGenerationParameters(rand, 4096); // 鍵生成 var keyGen = new RsaKeyPairGenerator(); keyGen.Init(param); var keyPair = keyGen.GenerateKeyPair(); // 証明書の属性 var attr = new Dictionary<DerObjectIdentifier, string>(); attr.Add(X509Name.CN, "link.studio-ephyra"); attr.Add(X509Name.C, "Japan"); attr.Add(X509Name.ST, "Nagano-Ken"); attr.Add(X509Name.L, "Nagano-Shi"); attr.Add(X509Name.O, "Studio-Ephyra"); attr.Add(X509Name.OU, "None"); var ord = new List<DerObjectIdentifier>(); ord.Add(X509Name.CN); ord.Add(X509Name.C); ord.Add(X509Name.ST); ord.Add(X509Name.L); ord.Add(X509Name.O); ord.Add(X509Name.OU); // 証明書の生成 var name = new X509Name(ord, attr); var certGen = new X509V3CertificateGenerator(); certGen.SetSerialNumber(BigInteger.One); certGen.SetIssuerDN(name); certGen.SetSubjectDN(name); certGen.SetNotBefore(DateTime.Now); certGen.SetNotAfter(DateTime.Now.AddYears(10)); certGen.SetPublicKey(keyPair.Public); var cert = certGen.Generate(new Asn1SignatureFactory("SHA512WITHRSA", keyPair.Private, rand)); // 秘密鍵の出力 using (var writer = new StreamWriter(@"D:\Downloads\privatekey.pem", false, Encoding.ASCII)) { var pemWriter = new PemWriter(writer); pemWriter.WriteObject(keyPair.Private); pemWriter.Writer.Flush(); } // 公開鍵の出力 using (var writer = new StreamWriter(@"D:\Downloads\publickey.pem", false, Encoding.ASCII)) { var pemWriter = new PemWriter(writer); pemWriter.WriteObject(keyPair.Public); pemWriter.Writer.Flush(); } // 証明書の出力 using (var writer = new StreamWriter(@"D:\Downloads\certificate.crt", false, Encoding.ASCII)) { var pemWriter = new PemWriter(writer); pemWriter.WriteObject(cert); pemWriter.Writer.Flush(); } AsymmetricCipherKeyPair privateKey; RsaKeyParameters publicKey; Org.BouncyCastle.X509.X509Certificate readedCert; // 秘密鍵の読み込み using (var reader = new StreamReader(@"D:\Downloads\privatekey.pem", Encoding.ASCII)) { var pemReader = new PemReader(reader); privateKey = (AsymmetricCipherKeyPair)pemReader.ReadObject(); } // 公開鍵の読み込み using (var reader = new StreamReader(@"D:\Downloads\publickey.pem", Encoding.ASCII)) { var pemReader = new PemReader(reader); publicKey = (RsaKeyParameters)pemReader.ReadObject(); } // 証明書の読み込み using (var reader = new StreamReader(@"D:\Downloads\certificate.crt", Encoding.ASCII)) { var pemReader = new PemReader(reader); readedCert = (Org.BouncyCastle.X509.X509Certificate)pemReader.ReadObject(); } // PKCS12の生成 var certEntry = new X509CertificateEntry(cert); var keyEntry = new AsymmetricKeyEntry(privateKey.Private); var p12 = new Pkcs12Store(); p12.SetCertificateEntry(attr[X509Name.CN], new X509CertificateEntry(cert)); p12.SetKeyEntry("tana", keyEntry, new X509CertificateEntry[] { certEntry }); // PKCS12の出力 using (var stream = new FileStream(@"D:\Downloads\pkcs12.p12", FileMode.Create)) { p12.Save(stream, "password".ToCharArray(), rand); stream.Flush(); } Pkcs12Store readedP12; // PKCS12の読み込み using (var stream = new FileStream(@"D:\Downloads\pkcs12.p12", FileMode.Open)) { readedP12 = new Pkcs12Store(stream, "password".ToCharArray()); } // 秘密鍵の取得と書き込み using (var writer = new StreamWriter(@"D:\Downloads\pkcs12privatekey.pem", false, Encoding.ASCII)) { var pemWriter = new PemWriter(writer); pemWriter.WriteObject(readedP12.GetKey("tana").Key); pemWriter.Writer.Flush(); } Console.WriteLine("OK"); Console.ReadLine(); } } }
>日付より大きければ処理をしない ★の行の「Date 」を比較したい日付のセルに、変更してください。 If .Value = "リンゴ" Or .Value = "ミカン" Then i = 1 - .Column ii = 1 - .Row j = j + 1 .Offset(ii).Copy sh.Cells(j, 1) .Offset(, i).Copy sh.Cells(j, 3) .Copy sh.Cells(j, 5) End If ↓ If .Value = "リンゴ" Or .Value = "ミカン" Then ii = 1 - .Row If .Offset(ii).Value >= Date Then '★ i = 1 - .Column j = j + 1 .Offset(ii).Copy sh.Cells(j, 1) .Offset(, i).Copy sh.Cells(j, 3) .Copy sh.Cells(j, 5) End If End If >罫線を引くことを省きたい With sh.Cells(1).CurrentRegion .Borders.LineStyle = True With .Offset(1).Resize(.Rows.Count - 1) ↓ With sh.Cells(1).CurrentRegion With .Offset(1).Resize(.Rows.Count - 1)
あなたのコードを整理すると↓のような感じですかね？ Sub DATA() Dim sh As Worksheets, h As Long, i As Long Application.StatusBar = "処理実行中．．．．" Set sh = Worksheets("Sheet1") With Worksheets("Sheet2") .Range(.Cells(1, 1), .Cells(20000, 5)).Clear i = 5 h = .Cells(Rows.Count, 2).End(xlUp).Row + 1 Do Until sh.Cells(i, 3).Value = "" sh.Cells(i, 14).Copy .Cells(h, 2) .Cells(h, 3) = "AAAA" sh.Cells(i, 13).Copy .Cells(h, 4) sh.Cells(i, 12).Copy .Cells(h, 5) i = i + 1 h = h + 1 Loop End With Application.StatusBar = "" End Sub ただ、コピー対象外の行がないのだから、縦長のセル範囲を割り出して、一気にコピーしたほうが効率的。 Sub sample() Dim sh As Worksheets, i As Long Application.StatusBar = "処理実行中．．．．" Set sh = Worksheets("Sheet2") With sh .Range(.Cells(1, 1), .Cells(20000, 5)).Clear End With With Worksheets("Sheet1") i = .Cells(Rows.Count, 3).End(xlUp).Row .Range(.Cells(5, 14), .Cells(i, 14)).Copy sh.Cells(2, 2) .Range(.Cells(5, 13), .Cells(i, 13)).Copy sh.Cells(2, 4) .Range(.Cells(5, 12), .Cells(i, 12)).Copy sh.Cells(2, 5) sh.Cells(h, 3).Resize(i - 4).Value = "AAAA" End With Application.StatusBar = "" End Sub
A、B、Cの各フォルダー内にある集計表が、Masterフォルダの名簿を参照しに行くようにしたいということですか？ >この部分で,Masterフォルダを指定したい ブックは既にオープン済。 フォルダをこの時点で指定することは出来ません。 やるなら、↓の変更でしょう。。 mypath = ThisWorkbook.Path Workbooks.Open Filename:=mypath & "￥名簿.xlsm" ↓ With CreateObject("Scripting.FileSystemObject") mypath = .GetFolder(ThisWorkbook.Path).ParentFolder & "\Master" End With Workbooks.Open Filename:=mypath & "￥名簿.xlsm" 未実行につき不具合ご容赦。
ワイルドカードのように扱う場合は、1行では無理です。全ての開いているブックの名前を調べて、該当するものをアクティブにする、という方法ぐらいしかとれないと思います。 Sub test() For Each wb In Workbooks If (wb.Name Like "chiebukuro*.csv") Then wb.Activate Exit For End If Next End Sub
最近、workSheet.select (False)で動かない質問が出てますね。同じ質問者ですか？ひょっとして古い方法でバージョンアップで使えなくなった？ 普通は名前を全部配列に代入して、 WorkSheets(Arr).select とかします。でも、面倒だから私ならまとめないで1個ずつ消しますけどね。大量にあるのですか？
その差分 40分をセルA4:B4に着色させたい この文章じゃ意味が取れないと思うのですが、 コードを見るとどうもE1が２０分より小さい値ならA4セルだけを赤に塗りつぶす。 ４０分より小さい値ならA4:B4を赤でぬりつぶす、 という意味かな？と思います。ただ２０分より小さい、は、４０分より小さいに含まれてしまうので ２０分より小さい値ならA4セルだけを赤に塗りつぶす。 ２０分以上、４０分より小さいならA4:B4を赤に塗りつぶす。 ということかな？とも考えられます。 VBAでは TimeValue("0:20:00") > eTime >= TimeValue("0:00:00") のような書き方はできません。 これは数式でも同じです。 VBAでは TimeValue("0:20:00") > eTime And TimeValue("0:00:00")<=eTime 数式だと AND(TimeValue("0:20:00") > eTime,TimeValue("0:00:00")<=eTime) です。 また時刻はマイナスの値にすることはできないので TimeValue("0:00:00")<=eTimeは考慮する必要がないです。マイナスの値の時はE1が＃で埋め尽くされ意味がないので 上の解釈であっていれば Sub test() Dim eTime As Single eTime = Range("E1").Value If eTime >= 0 Then If TimeValue("0:20:00") > eTime Then Range("A4").Select With Selection.Interior .Pattern = xlSolid .PatternColorIndex = xlAutomatic .Color = 255 .TintAndShade = 0 .PatternTintAndShade = 0 End With ElseIf TimeValue("0:40:00") > eTime Then Range("A4:B4").Select With Selection.Interior .Pattern = xlSolid .PatternColorIndex = xlAutomatic .Color = 255 .TintAndShade = 0 .PatternTintAndShade = 0 End With End If End If End Sub という感じです。ひとつのIF構文の中に条件を入れると先に書いたほうから判定され実行されるのは一つです。２つに分けると２つとも実行されてしまいます。 ただコードが冗長なのと、繰り返しこのコードを実行することがあるなら１回塗りつぶしを解除してから実行したほうがいいので Sub test() Dim eTime As Single Range("A4:B4").ClearFormats'A４:B4の塗りつぶしを「なし」にする eTime = Range("E1").Value If eTime >= 0 Then If TimeValue("0:20") > eTime Then Range("A4").Interior.Color = 255 ElseIf TimeValue("0:40") > eTime Then Range("A4:B4").Interior.Color = 255 End If End If End Sub としても内容は同じです。
chielien_d7123e24c7f735ca60c2bcfdさん、こんばんは。 お書きのコードは、B3セルの値で処理を分岐する構造かと思いますので、select文を使って書けば、すっきりすると思いますが、いかがでしょうか？ コードとしては、こんな感じです。 Select Case Range("B3").Value Case "X207","X980","X981","X982","X983" myRange.Offset(2, 15) = Worksheets("生産量計算シート").Cells("A2").Value myRange.Offset(2, 16) = Worksheets("生産量計算シート").Cells("D2").Value Case "222" myRange.Offset(2, 17).Value = Worksheets("生産量計算シート").Cells("A2").Value myRange.Offset(2, 18).Value = Worksheets("生産量計算シート").Cells("D2").Value Case "210","211","212","213","216" '・・・以下同様 myRange.Offset(2, 19).Value = Worksheets("生産量計算シート").Cells("A2").Value myRange.Offset(2, 20).Value = Worksheets("生産量計算シート").Cells("D2").Value Case ・・・・ ・・・・ End Select セルB3の値が整数ならば、連続数は範囲指定できます。 Case 210,211,212,213 -> Case 210 To 213 オンラインヘルプでSelect Case 構文を調べてもらえばわかると思います。
With Selection .Value = .Value .NumberFormatLocal = "yyyy/mm/dd" End With だけでいいんじゃないのと思いますけど……
マクロを使用する場合のコードを示します。 Option Explicit Sub Sample() Dim st1 As Worksheet, st2 As Worksheet Dim r1 As Long, data As String, r2 As Long Set st1 = Worksheets("削除データ") Set st2 = Worksheets("除外リスト") For r1 = 1 To st1.Range("B" & Rows.Count).End(xlUp).Row data = st1.Range("B" & r1).Value If Len(data) = 11 Then r2 = st2.Range("A" & Rows.Count).End(xlUp).Offset(1).Row st2.Range("A" & r2).Value = Mid(data, 1, 3) st2.Range("B" & r2).Value = Mid(data, 4, 8) End If Next End Sub
他のパソコンも当然同じ環境になっていますか。 >フォルダAに、エクセルBとフォルダCをいれてます。 >フォルダCは画像を保管している場所です。 この二点です。 貴方のパソコンにしか画像が入っていなければ、当然表示されませんね。 画像を色々なパソコンに入れたく（ばらまきたく）ないのであれば 貴方のパソコンを共有で他のパソコンから見えるようにするとか、皆が見えるサーバーがあるなら、サーバーに画像を入れるかして下さい。 それから、補足ですが Pictures.Insert では画像の保存場所が替わったりした時、次にファイルが表示されなくなっています。 一時的に表示するだけならいいのですが、エクセルブックに取り込んでおきたいのであれば AddPicture にした方がいいです。
コード例です。 Sub Sample() Dim Rng As Range For Each Rng In ActiveSheet.UsedRange If IsDate(Format(Rng.Value, "h:nn")) Then Select Case Format(Rng.Value, "hnn") Case 0 To 700 Rng.Value = "●" Case 701 To 1030 Rng.Value = "○" Case 1031 To 1530 Rng.Value = "△" Case 1531 To 2359 Rng.Value = "●" End Select Else Select Case Rng.Value Case "有給" Rng.Value = "□" Case "公休" Rng.Value = "■" End Select End If Next End Sub
LOOKUP関数 次式で検証していただけますか。 =LOOKUP(10^10,T:T) ＞=IFERROR(IF(L15+K16=L15,"",L15+K16),"") 提示された数式は次式で同意ですね。 =IFERROR(IF(K16,L15+K16,""),"")
なぜ解決済みにした質問を全く同じ文面で何度も何度も繰り返すのですか？ 2014年からこんなことを繰り返しているのに「プログラミングは初心者です」とはどういうことでしょう？ あなたはとことん悪質ですね。ブラックリストに入れておきます。 http://chiebukuro.yahoo.co.jp/my/myspace_quedetail.php?writer=nnryh... 同じ質問の繰り返し 2016/7/20 13:12:14 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1416188539... 2016/7/19 11:59:20 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1416184330... これも同じ質問の繰り返し 2015/7/10 16:21:38 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1314768516... 2015/7/10 16:20:10 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1314768512... これも同じ質問の繰り返し 2015/6/23 22:00:02 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1114679336... 2015/6/23 16:00:01 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1214678143... 2015/6/16 21:08:19 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1414679343... 2015/6/16 12:34:57 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1014677717... これも同じ質問の繰り返し 2014/9/14 08:57:42 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1013552604... 2014/9/12 08:38:45 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1213543773... 2014/9/11 16:41:06 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1013540683... 2014/9/10 18:38:46 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1213536713...
５行目の記述が抜けてる。  50   sum=sum+ary(cnt) 11行目の else print"" は不要では？ 110   if ary(cnt)>=avg then print ary(cnt)
A3 =IF(A2="","",IF(A1,IF(A2>=32400,648,IF(A2>=10800,432,324)),"")) ＞③A2のセルが「10800」以下のとき、A3のセルに「324」 以上 以下は その数値含みます ③A2のセルが「10800」未満のとき、A3のセルに「324」 の式です
こんにちは。 コードに大きな問題は見当たりませんが、 もし、ターゲットフォルダが、「ネットワークでみんなが使う」という空間だった場合、話は変わります。 もしそうなら、 1) ターゲットフォルダを指定したら、dirのファイル一覧表を、自分のシートに 全部書き出しする。 2) 上記にあるブックを開いて転記して閉じるのループを実行 としてください あと、workbook.close は、 close savechanges:=false を追加して、なにもしないで保存、を明示してください。 もし、ネットワークタイプのコードで、ローカルパソコンでも変化したら、 原因はOSのエクスプローラです。
BASIC言語については分かりませんが、合計値をなにで割ればいいかに関しては 「数を入力した回数」 です
パソコンだと、画像の拡大できないんですよねー。 スマホではできるんですが、文章くらいは、質問者に書いて欲しいところと、前々から思っているのですが、プログラミングの宿題ですよね？ プログラミングって、同じものでも、いろいろな書き方があるので、宿題だとすると、提出した後で、「お前そこ、まだ教えてない部分だけど、誰かにやってもらっただろ？」的なことにならんかなー？と。 仕事ならそれでもいいんですが、宿題だと、正確な回答にはならないかなー？と。 Q1.耳が2つあります。ウサギが3羽いるときに、耳はぜんぶでいくつ え、2ｘ3は正解で、3ｘ2はバツにする先生もいるようです。 アホな話なんですが、教えられた範疇の物事を使って回答するという宿題なら、どこまでを勉強したのか？を教えてくれないと、正解が出せないことに。＾＾； どうなんですかね？と、逆に質問を。ｗ
Sub 一例です() Dim xFSO, buf As String, moji As String, xPath As String Set xFSO = CreateObject("Scripting.FileSystemObject") buf = Application.GetOpenFilename(FileFilter:="ライブラリファイル,*.lib", Title:="ファイルの指定") If buf = "False" Then Exit Sub With xFSO.GetFile(buf) xPath = .ParentFolder & "\" With .OpenAsTextStream(1) moji = .ReadAll .Close End With '（ここで文字列mojiの内容の修正） With xFSO.OpenTextFile(xPath & "別名のファイル名.lib", 2, True) .Write moji .Close End With .Delete End With End Sub
たしかに、Excel 2010 と 2013 では VBA のバージョンも違います（2010は7.0, 2013は7.1）が、VBAのバージョンの違いではなくて、Excelのバージョンの違いによる速度の差ではないでしょうか。 たとえばシートの保護の設定・解除というような処理とか、シートを選択するような処理、あるいはクリップボードを介したコピー＆ペースト（特にシート間）といった処理は、Excel 2010 より 2013 の方が時間がかかるようです。（セキュリティの強化の影響ということらしいです。） 手動操作ではそれほど気にならなくても、マクロのループ内で多数回処理するような場合には、大きく影響している可能性がありますね。 特にありそうなのはコピー＆ペーストの処理です。 該当するような場合には、別の処理に置き換える（CopyやCut,Pasteは使わず、セルの値を変数に入れて処理するなど）、などすれば、改善するかもしれません。 該当しそうにもないなら、画面更新、自動再計算、イベント割り込みを停止するため Application.ScreenUpdating = False Application.Calculation = xlCalculationManual Application.EnableEvents = False としてから処理を行い、処理後に Application.EnableEvents = true Application.Calculation = xlCalculationAutomatic Application.ScreenUpdating = true と戻すような事でも、マシになるかもしれません。
方法としては、検索結果の画面からAタグを全て取得、その中から「ラブライブ！Official Web Site」というテキストを含むものを選んでClickメソッドを発行する、というものです。 Set atags=objIE.document.getElementsByTagName("a") For Each a In atags If (a.InnerText="ラブライブ！Official Web Site") Then a.Click Exit For End If Next クリック後の部分には、きちんと表示終了待ち処理を追加しておいてください。 ただ、他への応用を考えるならば、タグを見つけ出す過程での考え方をきちんと理解しておいてください。このコードを雛形にして、というのは無理があると思います。HTMLソースコードはページ毎に違うものですから。
こんにちは。 コードが出来ない原因は、ユーザーフォームに正しいコントロールがあるのか、確認してください。 14ある、という部分ですが、 If CheckBox1.Value = True Then が変化するということでしょうか。 印刷したいシート名は変化しますか、それとも、印刷の範囲でしょうか。 1) 印刷の範囲は、変化しない、という場合 シートの印刷範囲は、一度設定して保持できます。コードにする必要はありません。 チェックと「印刷したいシート名」が関連している、というのでしたら、 シート名を縦に並べた場所を作業のシートとして用意して、vlookupのように使うことでしてください。 例えば、「印刷作業」というシートのA1は、チェックコントロールのcontrolsourceに設定 コントロール2はA2セル、と順番に設定し、14はA14セルとします。 B列は、「印刷したいシート名」を設定。 (もし、セル範囲が可変でしたら、B列は、セル範囲の文字列とします。 C1セルには =if(A1,1,0)の関数を設定し、C14までコピーです。 C15は=sum(C1:C14)としてください。 チェックコンとロールのgroupプロパティにグループ名を設定したら、選択はいずれかひとつだけとなります コードの最初のながい部分は、C15セルの数値が0の場合、選択していないことになります。普通は、ディフォルトを設定します。 全部指定したら、全部印刷したい、ということなら、groupは空欄でいいです 状況がわからないので、まずは、整理してください
まず、「””」内部に表記してしまったら、「Cells」という命令とは認識されません。単なる文字列になってしまいます。「””」からくくり出して、外側でCellsの値を表記し、文字列結合で表現します。 後、SUM関数はアドレスで指定するのですが、単にCellsを表記すると、暗黙の約束で「Value」を付記したものと見なされます。つまり、Cells(3, 2)は「32500」となってしまいます。 従って、以下のように記述してみてください。 Cells(i, 3).Formula = "=SUM(B3:" & Cells(i,2).Address(0,0) & ")"
お示しのマクロを格納したブックのSheet22のA1セルに、「完了」が入力されているのであれば、 If .Cells(i, 1).Value = "誤記" Then ↓ If .Cells(i, 1).Value = MySh.Cells(1, 1).Value Then あと、本論には関係ないですが、↓の変更もしたほうが良いですね。 For Each Wb In Workbooks If Wb.Name <> ThisWorkbook.Name Then Set MySh = ThisWorkbook.Worksheets("Sheet22") ↓ Set MySh = ThisWorkbook.Worksheets("Sheet22") For Each Wb In Workbooks If Wb.Name <> ThisWorkbook.Name Then
>③取得したファイル名から必要な機器のファイルを選び、そのファイルに入って>いるシートを >機器仕様書としてまとめるExcelファイルに挿入する。 どんな（形式、内容）ファイルをどのように挿入するのか、 大事な部分が抜けてるのでみなさん返事しにくいと思いますよ。
http://www.nsdn.co.jp/AutoCAD/index.shtml 結構いじれるみたいです。
こんにちは。 wordのvbaのことでいいんでしょうか。 msワードは、ドキュメントを開く構文が、あります。 主様のコードは、インテリセンスで表示したものですか？ set wdapp = createobject(”word.apprecateon”) set doc = wdapp. に、ワードでvbe画面で作成したコードを貼り付けるなどして、ください。 参照設置を有効につかうなら、変数の定義が、不足してます
未テストなので確信ありませんが、 ×c = MyDat.Column ○c = MyDat(1).Column MyDatはセル範囲つまり複数セルなので、そのままcolumnを得ようとするとエラーだと思います。MyDatの先頭セルを指定するなら大丈夫です。
こんにちは。 おしかったですね、最後の部分 Range("D4:D8").Formula = "=B4*C4" が正解 Range("C4:C8").Formula = "=SUM(Sheet1:Sheet3!C4)" Range("C4:C8").Formula = "=B4*C4" これ、うわがきしてますよね。
状況がよく分かりません。 一旦読み込んだレコードセットは途中で更新しても 再読込しないかぎり並び順がかわることはないです。 もう少し具体的にやっていること、 どのような検索条件でどのような更新をしているかを説明 してください。 あるいは、実際のコードを提示したほうが間違いを指摘しやすいですね。 以下はアドバイスですが 通常は、 検索条件にあうレコードを更新する場合、 FindFirst, FindNext で更新するより、 開くときに抽出条件を設定して開いて、 全件更新するほうが効率的で高速です。 可能なら更新クエリで更新するのが一番高速です。
こんな感じです。 With Range("AV" & Rows.Count).End(xlUp) .AutoFill Destination:=.Resize(2), Type:=xlFillDefault End With
結合セル内の横線は以下部分で消しているので >   For i = 1 To r.Offset(, -1).MergeArea.Cells.Count - 1 >      With r.Offset(i - 1).Resize(, 2) >         .Borders(xlEdgeBottom).LineStyle = xlLineStyleNone >      End With >   Next ↓ 上記を削除し、代わりに、その場所に以下を記述してみてください    i = r.Offset(, -1).MergeArea.Cells.Count ※ なお、赤色にしないのなら .ColorIndex = 3 の部分は削除してみてください
考え方をお教えします。 FileSystemObject(FSO)を使って、さらに「再帰処理」で配下のサブフォルダ全てを探索してファイル名を取得し、それを利用してExcelを加工すればできます。 参考としては http://www.asahi-net.or.jp/~ef2o-inue/vba_o/sub05_110_080.html のFileSystemObject欄を見ていただければいけるはずです。 注意しなくてはいけないのが、ファイル名だけではEXCELは開けません。 ファイルパス＋ファイル名が必要になるので、そのあたりは調べてもらえれば 色々でてきますよ。 例） c:\hoge\hoge.xlsx c:\hogeがファイルパス hoge.xlsxがファイル名 ファイルパス＋ファイル名をフルパスといいます。
用語の使い方が間違っています。 「メモ帳の名前は(shibuya_soku.txt)です」という使い方はしません。 「メモ帳で開こうとしているファイルの名前は(shibuya_soku.txt)です」と言います。 「tank_kanonが飼っている犬の名前はポチです」 と言わなければいけないところを 「tank_kanonの名前はポチです」 と言っているのと同じです。 「NOTEPAD」ではなく「NOTEPAD.EXE」としてみて下さい。 それから 「C:\.shibuya_soku.txt」これも正しくありません。 shibuya_soku.txtはどこに保存されているのでしょうか？ 「絶対パス」と「相対パス」をもう一度きちんと理解し直してください。
下記のようになります。 もしもシート1のM列・N列・O列の中で最終行まで必ず何らかの値が入っている列があるのなら、コードはもう少しシンプルにすることが出来ます。 Option Explicit Sub Sample() Dim st1 As Worksheet, st2 As Worksheet Dim r1 As Long, r2 As Long Dim rD As Long, rE As Long, rF As Long Set st1 = Worksheets("Sheet1") Set st2 = Worksheets("Sheet2") 'シート2へ転記する際の最初の行番号を設定する 'D6が空白なら6行目、空白でないならD列の最終行+1を設定する rD = IIf(st2.Range("D6").Value = "", 6, st2.Range("D" & Rows.Count).End(xlUp).Row + 1) 'E6が空白なら6行目、空白でないならE列の最終行+1を設定する rE = IIf(st2.Range("E6").Value = "", 6, st2.Range("E" & Rows.Count).End(xlUp).Row + 1) 'F6が空白なら6行目、空白でないならF列の最終行+1を設定する rF = IIf(st2.Range("F6").Value = "", 6, st2.Range("F" & Rows.Count).End(xlUp).Row + 1) 'rD,rE,rFの３つのうちでもっとも大きい値をシート2へのコピー先の行番号とする r2 = rD If rE > r2 Then r2 = rE If rF > r2 Then r2 = rF 'シート1のコピー元の行番号を設定する r1 = 2 'シート1のM列・N列・O列のいずれかが空白でないあいだ繰り返す Do While st1.Range("M" & r1).Value <> "" Or st1.Range("N" & r1).Value <> "" Or st1.Range("O" & r1).Value <> "" 'シート1のM列・N列・O列をそれぞれシート2のD列,E列,F列へコピーする st2.Range("D" & r2).Value = st1.Range("M" & r1).Value st2.Range("E" & r2).Value = st1.Range("N" & r1).Value st2.Range("F" & r2).Value = st1.Range("O" & r1).Value 'シート2のコピー先の行番号を1行下にする r2 = r2 + 1 'シート1のコピー元の行番号を1行下にする r1 = r1 + 1 Loop End Sub
> HIJの列も同様に、 > 内容が同じであればK列に回避せす緑にも塗らない処理 この点は、気になってました･･･ 例えば、以下部分の ★の2か所削除すると、 ・E 列 ～ 一致なら、色は付きません ・H 列～、K 列～ の一致の時には色は付きますが、 データのコピーは行われません 今回のデータは、E 列～ ではありませんよ･･･という意味なら ★２行を削除するだけもありかな？と思います > If (rf.Column = Range("E1").Column) Then ' ★ >    For i = 1 To .Areas.Count >       If (rf.Offset(, i - 1).Value <> .Areas(i).Value) Then >          Exit For >       End If >    Next >    If (i > .Areas.Count) Then Exit Do > End If ' ★ でも、E 列～ でない所にコピーした･･･これを色で示すのなら 上記の ★行を削除し、３つとも一致したら色なしを設定して Do を抜ける ただ、今回のデータは E 列～、H 列～、K 列～ ･･･の何処にあった？ か、わからない･･･ ↓ For i = 1 To .Areas.Count    If (rf.Offset(, i - 1).Value <> .Areas(i).Value) Then       Exit For    End If Next If (i > .Areas.Count) Then    iC = xlNone    Exit Do End If どのような色付けが良いんでしょうね？ ※ データがどのように変わっていくかわからないので、私が考えることでもないと思いますが･･･ 全体を記述してみると Public Sub Samp8()    Dim rng As Range, rf As Range, r As Range    Dim iC As Long, i As Long    Const CCR As Long = 36    Const CCR2 As Long = 35    Const CRNGS As String = "B1,E1,F1"    Set rng = Worksheets("Sheet2").Columns("D") ' mシート★    Set r = Worksheets("Sheet1").Range("E3") ' Bシート★    Application.ScreenUpdating = False    While (r.Value <> "")       Set rf = rng.Find(r.Value, LookAt:=xlWhole)       With r          iC = xlNone          If (rf Is Nothing) Then             iC = CCR          Else             Set rf = rf.Offset(, Range("E1").Column - rf.Column)             With .Offset(, 1 - .Column).Range(CRNGS)                Do While (rf.Value <> "")                   For i = 1 To .Areas.Count                      If (rf.Offset(, i - 1).Value <> .Areas(i).Value) Then                         Exit For                      End If                   Next                   If (i > .Areas.Count) Then                      iC = xlNone                      Exit Do                   End If                   Set rf = rf.Offset(, 3)                   iC = CCR2                Loop                If (rf.Value = "") Then                   For i = 1 To .Areas.Count                      rf.Offset(, i - 1).Value = .Areas(i).Value                   Next                End If             End With          End If          .Interior.ColorIndex = iC       End With       Set r = r.Offset(1)    Wend    Application.ScreenUpdating = True End Sub ※ もし、コピーした/一致するものがあったその場所に色を付けるのなら >               If (rf.Value = "") Then >                  For i = 1 To .Areas.Count >                     rf.Offset(, i - 1).Value = .Areas(i).Value >                  Next >               End If                rf.Resize(,.Areas.Count) _                   .Interior.ColorIndex = 34 とかしてみる？ これをする時には、E 列～ 色なしを事前に･･･処理を追加しないと･･･
Dim i As Integer, n As Integer n = 10 do until i = n Debug.print Format(i,"00")&String(i,"*") i = i + 1 loop
以下でどうなりますか 処理の行範囲は B 列でやってみました また、罫線の太さが必要なら追加してみてください Public Sub Samp1()    Dim r As Range    Dim i As Long    Application.ScreenUpdating = False    Set r = Range("B1")    While (r.Value <> "")       If (r.Row = 1) Then          With r.Resize(, 2).Borders(xlEdgeTop)             .LineStyle = _                r.Offset(, -1).MergeArea.Borders(xlEdgeTop).LineStyle             .ColorIndex = 3          End With       End If       For i = 1 To r.Offset(, -1).MergeArea.Cells.Count - 1          With r.Offset(i - 1).Resize(, 2)             .Borders(xlEdgeBottom).LineStyle = xlLineStyleNone          End With       Next       With r.Offset(i - 1).Resize(, 2).Borders(xlEdgeBottom)          .LineStyle = _             r.Offset(, -1).MergeArea.Borders(xlEdgeBottom).LineStyle          .ColorIndex = 3       End With       Set r = r.Offset(i)    Wend    Application.ScreenUpdating = True End Sub
>③までは、うまくいった なぜそのコードを載せないのですか？ そのコードに追加すれば、あなたの苦労が１つ減ると思いますがね・・・。 以下は、アクティブセル行の一つ上の行のE列および、J列のデータを一つ下にオートフィルさせる例です。 Sub 一例です() i = ActiveCell.Row - 1 If i > 0 Then With Cells(i, "E") .AutoFill Destination:=.Cells.Resize(2), Type:=xlFillDefault End With With Cells(i, "J") .AutoFill Destination:=.Cells.Resize(2), Type:=xlFillDefault End With Application.CutCopyMode = False End If End Sub
左の表がシート1に右上の表がシート2に右下のシートがシート3にあるとします。 シート1の表はお示しの通りであるとします。 シート2やシート3はB1セルから右横方向に月が、A2セルから下方にはお示しのようなデータが入力されているとします。 そこでシート2は収入ですからシート2のB2セルには次の式を入力して右横方向にドラッグコピーしたのちに下方にもドラッグコピーすればよいでしょう。 =IF(OR(B$1="",$A2=""),"",SUMIFS(Sheet1!$C:$C,Sheet1!$A:$A,B$1,Sheet1!$B:$B,$A2)) シート3は支出ですからシート3のB2セルには次の式を入力して右横方向にドラッグコピーしたのちに下方にもドラッグコピーすればよいでしょう。 =IF(OR(B$1="",$A2=""),"",SUMIFS(Sheet1!$D:$D,Sheet1!$A:$A,B$1,Sheet1!$B:$B,$A2))
Sub test() With ThisWorkbook.ActiveSheet 'book1です Workbooks("book2.xlsx").Activate Range("B2").Select End With End Sub 上のコードを実行したところ、Book2.xlsxのセルB２が選択されていますよ。 book1.xlsm、book2.xlsxとも同じディレクトリ内に保存されていますか？
If Target.hani = "完了" Then Call MAKE_MAIL_ITEM_TEST_NG Exit Sub End If を、 If Not Application.Intersect(Target, Range("H:H")) Is Nothing Then If Target.value = "完了" Then Call MAKE_MAIL_ITEM_TEST_NG Exit Sub End If End If とすることで、列Hの時のみになります。 同行の別列のデータを取得する場合は、 If Not Application.Intersect(Target, Range("H:H")) Is Nothing Then If Target.value = "完了" Then Call MAKE_MAIL_ITEM_TEST_NG 'A列からH列にコピー Cells(Target.Row, 8).value = Cells(Target.Row, 1).value Exit Sub End If End If のように、Targetから行（Row)を取得し、Cells()を使用します
気になるのは、現状のリーダーで制御文字が含むデータを読み込むことができますか？ メーカー、機種にもよりますが、出来るのであれば 読み込んだ文字列を1文字ずつ調べ、制御文字であればそれまでの文字列を区切って 配列やテキストボックス等に入れる。 制御文字じゃなければそのままループさせる。 というやり方をすれば処理できると思います。 例としてですが以下のページに文字列から制御コードを除去する方法が 記載されています。 http://tsware.jp/tips/tips_406.htm これを改変すればお望みの処理が可能かと。
B3 =HYPERLINK("X:\納品書"&TEXT(ROW(A1),"00000")&".pdf",ROW(A1)) として、下へコピーです。
vbaによるIE制御では、HTMLを解釈することしかできません。 ですので、ご質問のサイトがflashやJavaなどの動的コンテンツで株価を表示している場合は、抜き出すことはできません。
開発したマシンに登録する場合は、VisualStudio上で作榮したプログラムをビルドまたは実行（どちらのタイミングか忘れました）すれば自マシンにＣＯＭが登録されたと思います。 他のマシンへの配布はかなり調べましたが、ClickOnceやインストーラーでの配布しかなかった気がします。 私は下記のサイトを参考に作成したExcelのVSTOアドインをインストーラーで配布しました。 ・Visual Studio 2010でVSTOアドインのインストーラー(msi)を作成する https://goo.gl/rfgKNq ・VisualStudio2013でVSTOのインストーラーを作成 http://goo.gl/l8bprz ※レジストリの登録はサイトの記述どおりでは動きませんでした。 誤）HKEY_CURRENT_USER\Software\Microsoft\Office\Excel\Addins\ ↓ 正）HKEY_CURRENT_USER\Software\Microsoft\Office\Excel\Addins\プロジェクト名 ・VSTO アドインのパフォーマンスの向上 https://goo.gl/l6zwq4 ※ここもポイントでExcelの起動が遅くなったため、登録するレジストリの値を LoadBehavior:x03→x10(DWORD) に変更しました。 また、配布先にはVSTOのランタイムのインストールが必要です。 ・「Visual Studio Tools for Office の再頒布可能なランタイムをインストールする」で検索してください。
Cells(30 + i, 2 + j + i).Value = Cells(2 + i, 2 + j).Value でいかがでしょうか？
kou08110さんはプログラミングの経験はお有りなのでしょうか？ 初心者の方がいきなりシリアル通信でモーターの制御を行うことは100%モーターを壊してしまう結果になります。 まずは「Windows フォーム アプリケーション」の作り方から勉強されることをお勧めします。 勉強されるときには書店へ行って「Visual Basic入門」のような本を購入されることをお勧めします。ネットの入門サイトより書籍を使う方が確実です。
３つの課題点について個人的な考えをお答えします。 ①ほかの条件も同時に満たす検索をするのではなく、１つ１つ検索していき、それぞれの結果を１つにまとめればいいです。 例えば1つ目の条件で検索をし、結果があればシート１に書く。 その後続けて2つ目の条件で検索を行い、結果があればシート１に追加する。 さらに3つ目の条件で検索を行い、結果があればシート１に追加。 ②結果が１００件あるなら１００シートに・・・。 これは１００シートも必要なのでしょうか？ 元々の仕様を理解していないためですが、そもそもそのあたりも整理したほうがいいのでは。 ③可能です。 それぞれの画面を作るという手間が増えますが、それほうが見やすいかと。
シート名が全角／半角文字による相違、又は空白が混入でしょうね。
文字をどのタイミングで、どの様に数えているか判りませんが、 拗音を数えなければいいんじゃないですか？
DAOを使った例です。 Sub sample() Dim max1 As Long Dim max2 As Long Dim db As DAO.Database Dim rs As DAO.Recordset max1 = DMax("項目01", "テーブル01") max2 = DMax("項目02", "テーブル01") Set db = CurrentDb Set rs = db.OpenRecordset("テーブル02", dbOpenDynaset) 'Set rs = db.OpenRecordset("SELECT * FROM テーブル02 ORDER BY 項目03", dbOpenDynaset) '順序が保証されたクエリで開く Do Until rs.EOF rs.Edit rs("項目01").Value = max1 rs("項目02").Value = max2 max1 = max1 + 1 max2 = max2 + 1 rs.Update rs.MoveNext Loop End Sub AccessではExcelと違い、"テーブル02"の項目03の ＡＡＡ ＢＢＢ ＣＣＣ ＤＤＤ の順序は保証されていません。 そのため、プログラム中の Set rs = db.OpenRecordset("テーブル02", dbOpenDynaset) では、レコードの順序は保証されていないので、順序を保証するクエリを使う必要がある場合もあります。 例えば、プログラム中の Set rs = db.OpenRecordset("SELECT * FROM テーブル02 ORDER BY 項目 などです。
SQLをテキストで開いて、全部読み込んで、SQL実行してやれば良いんじゃない？ どんなDBなのかどんなスクリプトか説明が無いからこうしか言えないなぁ。
最初のFor文の意図はわかりませんが、 For i = 2 To 10 For j = 0 To 19 Worksheets("○●").Cells(i, j + 7).Value = _ objIE.document.getElementsByClassName("○○")(j).outerText Next j Next i でどうでしょうか。
Sub 一例です() Dim i As Long, sh As Worksheet Set sh = ActiveWorkbook.Worksheets("Sheet1") With Workbooks("DATA1.xlsx").Worksheets For i = 1 To .Count sh.Cells(1, 1).Offset(i).Value = .Item(i).Name Next i End With End Sub 未実行に付き、不具合ご容赦。
Sub 一例です() Dim rngs As Range, rng As Range On Error Resume Next Set rngs = Range("C1", Cells(Rows.Count, 3).End(xlUp)) _ .Offset(, 2).SpecialCells(xlCellTypeBlanks) On Error GoTo 0 If Not rngs Is Nothing Then For Each rng In rngs With rng .Value = Abs(.Offset(, -2).Value) End With Next rng End If End Sub
(vba) isnull(ListBox1.list(0, 1)) でないですか？
①hoというtxtファイルはDドライブのどこのフォルダにあるのですか？ ②「カンマ、タブで区切り」は「個々のデータはカンマまたはタブで区切られている」という意味ですか？それとも「カンマで区切られたデータのタブを取り除き」という意味ですか？ ③「複数回取込ため、シート名は2..3..4と」というのは２回目は「ho2」、3回目は「ho3」というシート名、という意味ですか？ 類似する質問の場合に「ID非公開」回答する側にとってはとても不便です。前回あなたが質問した内容に関連するのであれば、その質問へのリンクを貼り付けるようにしてください。
1) st1.Range("E2", Cells(Rows.Count, 1).End(xlUp)).Copy ↓ st1.Range("E2", Cells(Rows.Count, "E").End(xlUp)).Copy 2) st1.Range("AD2", Cells(Rows.Count, 1).End(xlUp)).Copy ↓ st1.Range("AD2", Cells(Rows.Count, "AD").End(xlUp)).Copy 3) st1.Range("AC2", Cells(Rows.Count, 1).End(xlUp)).Copy ↓ st1.Range("AC2", Cells(Rows.Count, "AC").End(xlUp)).Copy A列の最終行をいつも探していた、ということです。
イメージとしてはこのような感じかな・・。 Sub Sample() Dim i As Long, j As Long, EndRow As Long, cnt As Integer Dim FC As Range, Hani As Range, MaxRow As Long EndRow = Range("A" & Rows.Count).Offset(-1).End(xlUp).Row MaxRow = Range("G" & Rows.Count).End(xlUp).Row Set Hani = Range("G3:G" & MaxRow) For i = 3 To EndRow Set FC = Hani.Find(Range("A" & i).Value, LookAt:=xlWhole) If Not FC Is Nothing Then cnt = Range("B" & i) Mod Range("H" & FC.Row) Range("C" & i) = Range("B" & i) \ Range("H" & FC.Row) If cnt > 0 Then Range("C" & i) = Range("C" & i) + 1 End If Next i End Sub ※A列の合計が一番最後の行にあるとしています。
時間を出力しているシートに入力しているため、入力の間、出力が待っている状態だと思います。 ユーザフォームを作成して時間を表示するか、画面左下のステータスバーに時間を表示すればよいと思います。 ステータスバーへの出力は、下記になります。 ＜変更前＞ Cells(1, 1) = Int((Timer - dblTimer) * 100) / 100 ↓ ＜変更後＞ Application.StatusBar = Int((Timer - dblTimer) * 100) / 100
If Not Intersect(Target, Range("C5:C14")) Is Nothing Then If Target.Value = "No" Then MsgBox "アプリケーションは入力必須です" End If Exit Sub End If を If Target.Count > 1 Then Exit Sub If Intersect(Target, Range("E5:E14")) Is Nothing Then Exit Sub の間に入れてみてはどうでしょうか。
下記のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim st1 As Worksheet, st2 As Worksheet Dim r As Long, c As Long Set st1 = Worksheets("Sheet1") Set st2 = Worksheets("Sheet2") '一旦Sheet2のA列をクリアする st2.Columns("A").Clear 'Sheet1のB列の最終行まで繰り返す For r = 1 To st1.Range("B" & Rows.Count).End(xlUp).Row With st2.Range("A" & r) c = st1.Cells(r, Columns.Count).End(xlToLeft).Column 'Sheet1のC列以降にデータが存在するとき If c > 2 Then 'Sheet2のA列に入力規則を設定する With .Validation .Delete .Add Type:=xlValidateList, _ Formula1:="=Sheet1!B" & r & ":" & Cells(r, c).Address End With 'Sheet2のA列を黄色にする .Interior.Color = RGB(255, 255, 0) End If 'Sheet1のB列の値をSheet2のA列にコピーする .Value = st1.Range("B" & r).Value End With Next r End Sub
amsmath.sty を使うのが一般的です。 (1) 単純に改行するなら multline (2) 改行してかつ揃えるなら split / align (3) 複数の数式を（揃えずに）列挙するなら gather 等 具体的な使い方は公式ガイド（下記）の通りです。 ftp://ftp.ams.org/pub/tex/doc/amsmath/amsldoc.pdf#page=8 なお、amsmath が提供している環境で不足する場合（multline で改行しつつ、align で揃える等）は、mathtools で補うことになります。
コード例です。 あまり難しいことはしていなくて、For～Nextと配列が理解できていれば、このコードは理解できると思います。 Sub Sample() Dim Sums(999999) As Long Dim Cnts(999999) As Long Dim Row As Long Dim Code As Long For Row = 2 To Cells(Rows.Count, "A").End(xlUp).Row Code = Left(Cells(Row, "A").Value, 6) Sums(Code) = Sums(Code) + Cells(Row, "B").Value Cnts(Code) = Cnts(Code) + 1 Next For Row = 2 To Cells(Rows.Count, "A").End(xlUp).Row Code = Left(Cells(Row, "A").Value, 6) Cells(Row, "C").Value = Sums(Code) / Cnts(Code) Next End Sub
組み合わせの最適化ですので、簡単なものでしたらソルバーで可能です。 図が全然読めませんので、条件などを書いてもらえれば、考えてみます。 ソルバーをこのような目的に使うにはちょっとしたコツがあります。
＞A2へ貼り付けし シート１の３行目の値は常にシート２のA2に張り付けるものと解釈しました。 'シートオブジェクト取得 Set sh1 = Sheets("Sheet1") Set sh2 = Sheets("Sheet2") For i = 0 To 20 'シート２A2にコピー sh2.Range("A2").Value = sh1.Cells(3, 2 + i).Value 'シート２の結果をシート１にコピー For j = 0 To 20 sh1.Cells(15 + i, 2 + j).Value = sh2.Cells(3 + j, 21).Value Next Next
とりあえず、差分データを「削除データ」「追加データ」「変更データ」というシートに書き出すコードです。 書き出すシートはマクロの中で新規に追加しています。（既に同名のシートが存在する場合はそのシートを削除してから新規に追加しています） 数万件を突き合わせることになるので数分から十数分かかると思います。 Option Explicit Sub Sample() '以下のシート名は適宜変更してください。 Const DelSheet As String = "削除データ" Const AddSheet As String = "追加データ" Const ChgSheet As String = "変更データ" Dim stName As Variant, i As Integer Dim st1 As Worksheet, st2 As Worksheet Dim st(2) As Worksheet Dim rSrc As Long, rDst As Variant 'Excelの再描画を一時停止する Application.ScreenUpdating = False Set st1 = Worksheets("Sheet1") Set st2 = Worksheets("Sheet2") '一旦差分用のシートを削除する Application.DisplayAlerts = False On Error Resume Next Worksheets(DelSheet).Delete Worksheets(AddSheet).Delete Worksheets(ChgSheet).Delete On Error GoTo 0 Application.DisplayAlerts = True '差分用のシートを新規に作成する For Each stName In Array(DelSheet, AddSheet, ChgSheet) Set st(i) = Worksheets.Add(After:=Worksheets(Worksheets.Count)) st(i).Name = stName st1.Rows(1).Copy st(i).Range("A1") i = i + 1 Next stName '削除データ抽出（注文番号がSheet1にあってSheet2にないものを抽出する） 'Sheet1を全件調べる For rSrc = 2 To st1.Range("A" & Rows.Count).End(xlUp).Row '注文番号がSheet2にあるかどうかを判定する rDst = Application.Match(st1.Range("A" & rSrc), st2.Columns("A"), 0) '注文番号が存在しない場合は削除データシートに書き出す If VarType(rDst) = vbError Then st1.Rows(rSrc).Copy st(0).Rows(st(0).Range("A" & Rows.Count).End(xlUp).Offset(1).Row) End If DoEvents Next rSrc '追加データ・変更データ抽出 '注文番号がSheet2にあってSheet1にないものは追加データ '注文番号がSheet2にもSheet1にもあって、注文品・顧客名が異なっているものは変更データ 'Sheet2を全件調べる For rSrc = 2 To st2.Range("A" & Rows.Count).End(xlUp).Row '注文番号がSheet1にあるかどうかを判定する rDst = Application.Match(st2.Range("A" & rSrc), st1.Columns("A"), 0) '注文番号が存在しない場合は追加データシートに書き出す If VarType(rDst) = vbError Then st2.Rows(rSrc).Copy st(1).Rows(st(1).Range("A" & Rows.Count).End(xlUp).Offset(1).Row) Else '注文番号が存在する場合、注文品・顧客名が異なっているかどうかを判定する If st2.Range("B" & rSrc).Value <> st1.Range("B" & rDst).Value Or _ st2.Range("C" & rSrc).Value <> st1.Range("C" & rDst).Value Then '注文品・顧客名が異なっている場合は追加データシートに書き出す st2.Rows(rSrc).Copy st(2).Rows(st(2).Range("A" & Rows.Count).End(xlUp).Offset(1).Row) End If End If DoEvents Next rSrc 'Excelの再描画を再開する Application.ScreenUpdating = False End Sub
> ・・・テム\QA検査画像」フォルダ なら ・・・テム\QA検査画像" & "\" & [詳細検索フォーム]![詳細画像ID] と "\" を間に入れるとか？ ※ 環境テーブルとか持って フィールド ID, 項目1 ・・・ で、ID=1 の 項目1 に \123.456.78.90\・・・テム\QA検査画像\ を入れておいて Me!詳細画像検索イメージ.Picture = _    DLookup("項目1","環境テーブル","ID=1") _    & [詳細検索フォーム]![詳細画像ID] & ".JPG" とかしてみるとか･･･ 画像の置き場が変わっても、テーブル内の変更だけで VBA には影響なし･･･ってのは、どうでしょうか･･･???
チョット無駄があったので回答し直しました Y、AI 列には "小 計" の文字列があるとします なお、最後の "小 計" の後に 合計を作ります Public Sub Samp2()    Dim r As Range    Dim v As Variant    Dim sS As String    Dim i As Long, j As Long, k As Long    Const CROWS As Long = 33    Const CCHK As String = "小 計"    Const CF As String = _       "=IF(RC[{%1}]=""" & CCHK & """,1,"""")"    Const CSUM As String = "=SUM(R[{%2}]C:R[-1]C)"    Const CSUMIF As String = _       "=SUMIF({%1},""" & CCHK & """,R[{%2}]C:R[-1]C)"    Application.ScreenUpdating = False    With ActiveSheet.UsedRange       With .Resize(, .Columns.Count + 1)          With .Columns(.Columns.Count)             For Each v In Array("Y", "AI")                i = Cells(1, v).Column - .Column                sS = Replace(CF, "{%1}", i)                .FormulaR1C1 = sS                .Value = .Value                j = CROWS                For Each r In .SpecialCells(xlCellTypeConstants).Areas                   If (r.Row > j) Then                      k = r.Row                      sS = Replace(CSUM, "{%2}", j - k)                      Cells(k, v).Offset(, 2).Resize(, 7) _                         .FormulaR1C1 = sS                      j = k + 1                   End If                Next                sS = Range(Cells(CROWS, v), Cells(k, v)) _                      .Address(, , xlR1C1)                sS = Replace(CSUMIF, "{%1}", sS)                sS = Replace(sS, "{%2}", CROWS - k - 1)                With Cells(k + 1, v)                   .Value = "合 計"                   .Offset(, 2).Resize(, 7).FormulaR1C1 = sS                End With                .ClearContents             Next          End With       End With    End With    Application.ScreenUpdating = True End Sub
>日付の月日が１桁だったり２桁だったりばらばらなのを2桁に統一する と言うより「１桁の数値と"月"」と「１桁の数値と"日"」の前に"0"を付けてるという正規表現のプログラムで、 "\b(\d(月|日))" も "\b(\d月|\d日)" もマッチするパターンは同じなので、どちらでもいいと思います。
i = Listbox1.Listcount = 1 を i = Listbox1.Listcount - 1 としてみてください。
適当なデータでかまわないので写真やアップローダに サンプルを提示いただけませんか？
マクロ記録で解りませんか？ A1を選択して削除したマクロの記録（XL2010)です。 Range("A1").Select Selection.Delete Shift:=xlToLeft 整形すると Range("A1").Delete Shift:=xlToLeft
i は宣言されてないので、 >Cells(i, 5).NumberFormatLocal = "#0.0 " は間違いだと思いますが、Range("E10:E1000")のセルでは65は青くなると思います。 ちなみに、質問のプログラムは Sub sample() Dim j As Single For j = 10 To 1000 Cells(j, 5).NumberFormatLocal = "#0.0 " Select Case Cells(j, 5).Value Case Is > 0, Is < 180 Cells(j, 5).Interior.Color = RGB(0, 0, 255) Cells(j, 5).Font.Color = RGB(255, 255, 255) Case Is >= 180, Is < 350 Cells(j, 5).Interior.Color = RGB(255, 0, 0) Cells(j, 5).Font.Color = RGB(255, 255, 255) Case Is >= 350, Is <= 1000 Cells(j, 5).Interior.Color = RGB(255, 0, 255) Cells(j, 5).Font.Color = RGB(255, 255, 255) End Select Next End Sub または、 Sub sample() Dim j As Single For j = 10 To 1000 Cells(j, 5).NumberFormatLocal = "#0.0 " Select Case Cells(j, 5).Value Case Is > 0, Is < 180 Cells(j, 5).Interior.Color = RGB(0, 0, 255) Cells(j, 5).Font.Color = RGB(255, 255, 255) Case Is < 350 Cells(j, 5).Interior.Color = RGB(255, 0, 0) Cells(j, 5).Font.Color = RGB(255, 255, 255) Case Is <= 1000 Cells(j, 5).Interior.Color = RGB(255, 0, 255) Cells(j, 5).Font.Color = RGB(255, 255, 255) End Select Next End Sub でいいのではないでしょうか。
左の表から、右の表を作成したい ということですか？ 左の表がSheet1、A1セルから始まっており、右の表は新規シートに作成される例です。 Sub 一例() Dim sh As Worksheet, rng As Range Dim i As Long, ii As Long, j As Long j = 1 With Worksheets Set sh = .Add(after:=.Item(.Count)) sh.Cells(1).Resize(, 4).Value = Split("日付,内容,担当,金額", ",") With .Item("Sheet1").Cells(1).CurrentRegion For Each rng In .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1) With rng If .Value = "リンゴ" Or .Value = "ミカン" Then i = 1 - .Column ii = 1 - .Row j = j + 1 .Offset(ii).Copy sh.Cells(j, 1) .Offset(, i).Copy sh.Cells(j, 3) .Copy sh.Cells(j, 5) End If End With Next rng End With End With With sh.Cells(1).CurrentRegion .Borders.LineStyle = True With .Offset(1).Resize(.Rows.Count - 1) .Columns(2).Value = "果物" .Columns(4).Value = 1000 End With End With End Sub
Dim b As Bitmap = PictureBox.Image Dim color As Color = b.GetPixel(e.X, e.Y) Label8.Text = color.ToString() に続けて Dim bytA As Byte = color.A Dim bytR As Byte = color.R Dim bytG As Byte = color.G Dim bytB As Byte = color.B LabelA.Text = bytA.ToString() LabelR.Text = bytR.ToString() LabelG.Text = bytG.ToString() LabelB.Text = bytB.ToString()
どこに書き出すのでしょうか？
[Forms]![詳細検索フォーム]![詳細開封不良内容]=[開封不良内容] Or [Forms]![詳細検索フォーム]![詳細開封不良内容]=[開封不良内容2] でしょうか？
On Error Gotoについては、使う方が難しいと思います。 Sub test() Do num = InputBox("番号を入力してください") If (IsNumeric(num) = False) Then MsgBox "数字を入力してください" Loop Until (IsNumeric(num) = True) Set fnd = Columns(1).Find(num) If (fnd Is Nothing) Then MsgBox "番号が見つかりません" Else MsgBox fnd.Offset(0, 2).Value End If End Sub
こんにちは。 その画面で、「デバッグ」をクリック 表示したコードの黄色の行と、その上10行程度を、知らせてください。 今の状況だと、まったく話が進みませんよ。
シートモジュールに書かれたプログラムなので、セル参照するコードでシートを指定しない場合、そのシートモジュールが書かれたシートが省略されているとみなされます。 なので、 Worksheets(1).Range(Cells(288, 11), Cells(311, 11)).Select の Cells(288, 11), Cells(311, 11) は、Worksheets(1)ではなく、シートモジュールが書かれたシートを参照しています。 Worksheets(1).Rangeで範囲指定しようとしているWorksheets(1)のセル範囲に他のシートのセルを含めようとしていることになり、エラーが発生します。 Worksheets(1).Range(Worksheets(1).Cells(288, 11), Worksheets(1).Cells(311, 11)).Select と書けば上手くいくはず。 全体を書きかえるなら、 Private Sub Worksheet_Change(ByVal Target As Range) With Worksheets(1) .Activate .Range(.Cells(288, 11), .Cells(311, 11)).Select End With End Sub
私は以前CAD/CAMを作って加工をしていましたけど、操作は慣れだと思います。今は何処のメーカーを使っているのですか？値段から言いますと、そんなに高額ではないと思います。未だに高いメーカーだと1000万ぐらいしますし、安いメーカーだと百万円ぐらいで買えます。三菱製だったら中流クラスだと思いますので、悪くはないと思います。とにかく慣れる事が一番。後は自分にあったパスが出来れば良いと思います。
以下のようになります。 Dim DataRange(1, 1, 1) As Variant Dim i As Long, j As Long For i = 0 To 1 For j = 0 To 1 DataRange(i, j, 0) = Cells(1, 1).Offset(i, j) DataRange(i, j, 1) = Cells(5, 5).Offset(i, j) Next j Next i ですが、VBAでは「DataRange( , , 0) ,DataRange( , , 1)」と数えるよりも「DataRange(0, , ) 、DataRange(1, , , )」と数える方が通例になっています。 なぜかというと以下のような格納の仕方もあるからです。 Dim d(1) As Variant d(0) = Cells(1, 1).Resize(2, 2) d(1) = Cells(5, 5).Resize(2, 2) この書き方の場合、 添付した画像の例でいうと d(0)(1,1) = "A1" d(0)(1,2) = "B1" d(0)(2,1) = "A2" d(0)(2,2) = "B2" d(1)(1,1) = "E1" d(1)(1,2) = "F1" d(1)(2,1) = "E2" d(1)(2,2) = "F2" というように格納されます。 これと同じイメージで考えたほうがプログラム的にはすっきりすると思いませんか？ 格納するためのコードは For i = 0 To 1 For j = 0 To 1 DataRange(0, i, j) = Cells(1, 1).Offset(i, j) DataRange(1, i, j) = Cells(5, 5).Offset(i, j) Next j Next i です。 これであれば DataRange(0, 0, 0) = "A1" DataRange(0, 0, 1) = "B1" DataRange(0, 1, 0) = "A2" DataRange(0, 1, 1) = "B2" DataRange(1, 0, 0) = "E1" DataRange(1, 0, 1) = "F2" DataRange(1, 1, 0) = "E2" DataRange(1, 1, 1) = "F2" と格納されます。
B1セルに「１4」のように1桁目の数字が10の位で必ず含まれる数字が1の位に記載されているなら、例えばC1セルに以下の式を入力して右方向に8つオートフィルします。 =SMALL(((LEFT({1,2,3,4,5,6}*10+{1;2;3;4;5;6})=RIGHT($B$1))+(RIGHT({1,2,3,4,5,6}*10+{1;2;3;4;5;6})=RIGHT($B$1))+((LEFT({1,2,3,4,5,6}*10+{1;2;3;4;5;6})=LEFT($B$1))+(RIGHT({1,2,3,4,5,6}*10+{1;2;3;4;5;6})=LEFT($B$1)))*2<>1)*1000+LEFT($B$1)*100+{1,2,3,4,5,6}*10+{1;2;3;4;5;6},COLUMN(A:A))
そういう時です。下記はmainからgreetingを呼び出し、引数によって挨拶が変わるものです。 Sub main() Call greeting("h") End Sub Sub greeting(byval g as String) If g="m" then msgbox "good morning" If g="h" then msgbox "hello" If g="e" then msgbox "good evening" End Sub
(vba) 該当のエラーは手作業で行った場合、A列からC列など複数列 を範囲選択して、"区切り位置" を実行しようとしているとき に発生するのエラーです。 対処法はそのままですが、1列だけを区切り対象とすればOKです。 1例として、コード2行目を以下に変更などがあります。 selection.texttocolumns ↓ selection.columns(1).texttocolumns または選択範囲の全列に対し1列ずつ繰返しなど。
FileSearch は2003までしか使えないです。 下記を参考に書き直す必要がありますね。 http://kuroeveryday.blogspot.jp/2013/10/FromFileSearchToFileSystemO... 本題ではありませんが、必要のSelectが多いので、この機会に修正しては如何でしょうか。（Selectは処理を遅くします） 例えば Range("K11:L11").Select Kill pathname & "\" & ActiveCell.Value は Kill pathname & "\" & Range("K11").Value ですみます。 K11とL11は結合されているので、このようなコードになったのかと思いますが、結合セルの場合値は先頭のセルに入ります。 また固定セルで11～23までずっと書いてありますが、変数で繰り返しにすれば、ぐっと短いコードになります。
例示のような文字列がA1セルに入力されているなら、以下の式を入力すれば「商品の寸法: 」以降の3つの数字を足すことができます(センチメートルの前に半角スペースがある場合）。 =SUMPRODUCT(TRIM(MID(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(A1," X "," ")," ",REPT(" ",100)),"商品の寸法: ",""),{100,200,300},100))*1)
それができるのは多次元配列(2次元配列)ではなく、ジャグ配列という、配列の要素が配列の場合だと思います。 それと、配列の要素は無指定の場合は0から始まります。 Sub sample() Dim MemberA() As String ReDim MemberA(1 To 3) MemberA(1) = "morita" MemberA(2) = "yamada" MemberA(3) = "kato" Dim MemberB() As String ReDim MemberB(1 To 3) MemberB(1) = "hamada" MemberB(2) = "matsumoto" MemberB(3) = "kato" Dim MemberC() As Variant ReDim MemberC(1 To 2) MemberC(1) = MemberA MemberC(2) = MemberB MsgBox MemberC(1)(1) '<-morita End Sub
何をどこに書き足せば、と言われても、あなたが書いたコードが判らなければ回答できません（;￣O￣）
以下でどうなりますか 手始めに、新規ファイルに以下を記述し、 testData で確認用環境を作って Samp1 を実行してみます Public Sub Samp1()    Dim ws As Worksheet    Dim rng As Range    Dim i As Long    Const CF As String = "=IF(RC6<>"""",1,"""")"    Application.ScreenUpdating = False    For Each ws In Worksheets       With ws.UsedRange          i = 3 - .Cells(1).Row          With .Resize(.Rows.Count - i).Offset(i)             With .Columns(.Columns.Count + 1)                .FormulaR1C1 = CF                .Value = .Value                On Error Resume Next                Set rng = .SpecialCells(xlCellTypeConstants)                On Error GoTo 0             End With             If (Not rng Is Nothing) Then                Intersect(rng.EntireRow, .Cells) _                   .Interior.ColorIndex = 34                rng.ClearContents                Set rng = Nothing             End If          End With       End With    Next    Application.ScreenUpdating = True End Sub ' 確認用簡易データ作成 Public Sub testData()    Dim ws As Worksheet    Dim r As Range    Dim i As Long    Const CRH As Long = 30    Const CSHTCNT As Long = 30    Randomize    Application.ScreenUpdating = False    i = CSHTCNT - Worksheets.Count    If (i > 0) Then Worksheets.Add Count:=i    For Each ws In Worksheets       With ws          .Cells.Delete          For Each r In .Range("A2:Z2").Resize(CRH)             Select Case r.Row                Case 2                   r.Value = r.Address(False, False)                Case Else                   Select Case r.Column                      Case Range("F1").Column                         Select Case Rnd()                            Case Is > 0.75                               r.Formula = "="""""                            Case Is > 0.5                            Case Else                               r.Value = r.Address(False, False)                         End Select                      Case Else                         r.Value = r.Address(False, False)                   End Select             End Select          Next          .Columns.AutoFit       End With    Next    Application.ScreenUpdating = True End Sub
この２つのオプションは再起動しないと有効にならないようです。
日付なのでStringではだめです。 Dim a As Variant Dim i As Long For i = 2 To 700 a = Cells(i, Cells(i, Columns.Count).End(xlToLeft).Column).Value Cells(i, 14) = a Next
要は、C列の容器の数量を入力したのですか？ 右端の表を参照して、B列の数量との商をC列に入力してみたらどうでしょうか。 もし、端数が出た場合はそれは容器数を１つ加えるのか・・ 左の表のセル位置は分かりますが、右の表のセルの位置が分かりづらいので参考なるコードは書きづらいですね。マクロで回答を望む場合は、シート名やセルの位置が明記されたほうが良いでしょうね。
このマクロで挿入した画像を他のパソコンで見ることが出来ればいいのですか。 それとも、他のパソコンでもこのマクロを実行したいのですか。 前者であれば ActiveSheet.Pictures.Insert がまずいです。 ActiveSheet.Shapes.AddPicture という形にすれば図形として画像が貼り付きますので、他のパソコンからでも見えます。
これでどうでしょうか? Dim re Set re = New RegExp re.Pattern = "\b(\d月|\d日)" '修正箇所 re.Global = True MsgBox re.Replace("2016年7月01日、2016年07月1日、2016年10月25日", "0$1") Set re = Nothing
まず、Range("H8:BH17,H23:BH32"........).ClearContents をしたい場合のプログラムは Sub sample() Dim i As Long Dim o As Integer o = 17 For i = 8 To 548 Step 15 Range(Cells(i, "H"), Cells(o, "BH")).ClearContents o = o + 15 Next End Sub または Sub sample() Dim i As Long For i = 8 To 548 Step 15 Range(Cells(i, "H"), Cells(i + 9, "BH")).ClearContents Next End Sub だと思います。 質問のまとめる場合はUnionを使います。 例えば Sub sample() Dim i As Long Dim rng As Range For i = 8 To 548 Step 15 If rng Is Nothing Then Set rng = Range(Cells(i, "H"), Cells(i + 9, "BH")) Else Set rng = Union(rng, Range(Cells(i, "H"), Cells(i + 9, "BH"))) End If rng.ClearContents Next End Sub
Option Explicit Sub Sample() Dim total As Integer, a As String, n As Integer total = 0 a = InputBox("数字を入力して下さい") For n = 1 To Val(a) total = total + n Next n MsgBox "答えは" & total & "です" End Sub 初心者であればこそ、変数の宣言は必ず行うようにしましょう。 VBEの「ツール(&T)」－「オプション(O)」で「変数の宣言を強制する」にチェックを入れておいてください。 そうしないとスペルミスに気付かずに「うまく動かない・・・」と悩みまくることになります。
http://www.osaka-kyoiku.ac.jp/~tomodak/soft/#jun とか…。
VBAではApplication.ScreenUpdatingを用いると「開いていないように見せる」ことが出来ます。 下記のコードでいかがでしょうか。 C:\Test\の下に全く関係のないファイルがあっても大丈夫なようにしてあるので少しだけ冗長なコードになっています。 Option Explicit Sub Sample() Const SavedPath As String = "C:\Test\" Const CheckCells As String = "N1" Dim objFSO As Object Dim SavedF As Object Dim bk As Workbook, st As Worksheet Dim nm1 As String, nm2 As String nm1 = ThisWorkbook.Worksheets("Sheet2").Range(CheckCells).Value Set objFSO = CreateObject("Scripting.FileSystemObject") 'SavedPath下のすべてのファイルを対象とする For Each SavedF In objFSO.GetFolder(SavedPath).Files 'エクセルファイルだけを対象とする If objFSO.GetExtensionName(SavedF.Name) Like "*xls*" Then 'Excelの再描画を停止する Application.ScreenUpdating = False 'エクセルファイルを開く Set bk = Workbooks.Open(SavedF.Path) 'Sheet2のN1セルの値を取得する nm2 = "" On Error Resume Next nm2 = bk.Worksheets("Sheet2").Range(CheckCells).Value On Error GoTo 0 'エクセルファイルを閉じる bk.Close False 'Excelの再描画を再開する Application.ScreenUpdating = True If nm1 = nm2 Then MsgBox "同じ記録のファイルが既にあります。", vbOKOnly Exit Sub End If End If Next 'このブックを保存する ThisWorkbook.SaveAs SavedPath & nm1 End Sub
テキストファイルが書き換え対象ならWorkBooks.Openを使うのは適当ではありません。 全面的に書き換えてみました。 Option Explicit Sub Sample() Dim myPath As String 'フォルダ名用の変数 Dim myFile As String 'ファイル名用の変数 Dim FSO As Object, TextFile As Object, buf As String Set FSO = CreateObject("Scripting.FileSystemObject") myPath = ThisWorkbook.Path & "\1310\" myFile = Dir(myPath & "*.txt") Do While myFile <> "" '対象のファイルをオープンして内容をすべて読み込む Set TextFile = FSO.OpenTextFile(myPath & myFile) buf = TextFile.ReadAll TextFile.Close '書き換えを行う buf = Replace(buf, "http://www43.tok2.com/abcde/", "../../") '対象のファイルを上書きする Set TextFile = FSO.GetFile(myPath & myFile).OpenAsTextStream(2) TextFile.Write buf TextFile.Close myFile = Dir() Loop End Sub
Sub sample() Range("A1").PasteSpecial Selection.TextToColumns Destination:=Range("A1"), _ DataType:=xlDelimited, _ TextQualifier:=xlDoubleQuote, ConsecutiveDelimiter:=False, _ Tab:=True, Semicolon:=False, Comma:=True, Space:=False, _ Other:=False, TrailingMinusNumbers:=True End Sub ↑みたいなことですかね？
(vba) 処理の都度、共有フォルダ配下の約3万ファイルの検索 を行うのではなく、共有フォルダ配下の約3万ファイルパス 情報を、1日1回か2回適当なシートへ書き出し ↓↓ 特定セルのファイルを開く場合、3万ファイルの検索をするの ではなく、上記のようにあらかじめシートに書き出したファイ ルパスにfind 検索を行ってファイル実行を行う処理へ変更 ↓↓ 1日に1回か2回の3万ファイルパス情報を書き出す時のみ時間 がかかりますが、特定セル値を含むファイルを実行するのは 一瞬になると思います。 約3万ファイルのパス情報のシート書き出しは既存コードを 少し修正した以下のようなコードで ①【ファイルリスト】シートをあらかじめ作成 ②コード1行目へ最親フォルダパスを定数指定 ③下記【あらかじめ↑のパス配下のファイル名を取得】実行 Const strFolder As String = "\\hoge\hoge\" Sub あらかじめ↑のパス配下のファイル名を取得() Dim fso As Object Dim vntSpt As Variant Dim strAry() As String Dim strOut() As String Dim lngAry As Long Dim i As Long Set fso = CreateObject("Scripting.FileSystemObject") Call FileSearch(strFolder, strAry(), lngAry, fso) Set fso = Nothing ReDim strOut(lngAry - 1, 1) For i = LBound(strAry) To UBound(strAry) vntSpt = Split(strAry(i), "$") strOut(i, 0) = vntSpt(0) strOut(i, 1) = vntSpt(1) Next i With Sheets("ファイルリスト") .Cells.ClearContents .Range("B3").Resize(lngAry, 2).Value = strOut Erase strOut: Erase strAry .Range("B2:C2").Value = Split("フルパス,ファイル名", ",") End With Application.StatusBar = "" MsgBox "finish", vbInformation End Sub Sub FileSearch(Path As String, strAry() As String _ , lngAry As Long, fso As Object) Dim Folder As Variant, File As Variant For Each Folder In fso.GetFolder(Path).SubFolders Call FileSearch(Folder.Path, strAry(), lngAry, fso) Next Folder For Each File In fso.GetFolder(Path).Files ReDim Preserve strAry(lngAry) strAry(lngAry) = Path & "\" & File.Name & "$" & File.Name lngAry = lngAry + 1 If lngAry Mod 100 = 0 Then Application.StatusBar _ = Format(lngAry, "#,##0") & "ファイル格納済" Next File End Sub
下記のコードでいかがでしょうか。 Option Explicit Sub Sample() Const bk1Name = "test1.xlsx" '適宜変更して下さい。 Const bk2Path = "test2.xlsx" '適宜変更して下さい。 Dim st1 As Worksheet Dim bk2 As Workbook, st2 As Worksheet Dim r As Long Application.ScreenUpdating = False Set st1 = Workbooks(bk1Name).Worksheets("Sheet1") 'test2.xlsxを開く Set bk2 = Workbooks.Open(bk2Path) Set st2 = bk2.Worksheets("Sheet1") For r = 1 To st1.Range("A" & Rows.Count).End(xlUp).Row With st1.Range("A" & r) '一致していたらA列に○を挿入する If .Value = st2.Range("A" & r).Value Then .Insert xlShiftToRight .Offset(, -1).Value = "○" End If End With Next r 'test2.xlsxを閉じる bk2.Close False Application.ScreenUpdating = True End Sub
①フォームにPanelを貼ります。 ②張り付けたPanelの上にチェックボックスを貼ります。 ③Panelを動かせばチェックボックスのレイアウトはそのままで移動させることが出来ます。
Replace関数を使います。 Cells(j, k).Value =Replace(Cells(j,k).value, "http://www43.tok2.com/abcde/", "../../") セルCells(j,k)に書いてある文字列を探し、http～があれば../../に置換し、それを再度Cells(j,k)に代入します。 × If Cells(j, k).Value = "*" & "http://www43.tok2.com/abcde/" & "*" Then ○ If Cells(j, k).Value Like "*" & "http://www43.tok2.com/abcde/" & "*" Then Replace関数は置換文字列が見つからなければ、置換しないまま戻るので、If文は特に必要ありません。あろうがなかろうが全部関数にかければいいのです。 Replace関数とReplaceメソッドと２つあるので間違えないように注意してください。
出来ます。MouseDownイベントとMouseUpイベントを使用します。 Downは押された時、Upは離れた時発生します。
これを試してみてください。 var ss = SpreadsheetApp.getActiveSpreadsheet(); var sh = ss.getActiveSheet(); function onEdit(e) { var row = e.range.getRow(); var col = e.range.getColumn(); var val = e.range.getValue(); if ((row == 1) && (col == 1)) { sh.getRange(2,1,sh.getLastRow(),1).copyTo(sh.getRange(3,1)); sh.getRange(2,1).setValue(val); sh.getRange(1,1).setValue(""); } }
複数のセル範囲の値を一遍には、比較できません。 1セルずつ比較しましょう。 Sub 一例です() Dim y As Long, rng As Range, xNG As Boolean y = 4 With ThisWorkbook.ActiveSheet Workbooks("book2.xlsx").Activate For Each rng In Range(Cells(y, 1), Cells(y, 22)) If rng.Value <> .Range(rng.Address).Value Then xNG = True Exit For End If Next rng End With If Not xNG Then MsgBox "ok" End Sub 未実行につき不具合ご容赦。
下記のコードをSheet1のシートモジュールに記述して下さい。 Private Sub Worksheet_Change(ByVal Target As Range) Dim v As Variant If Target.Column = 1 And Target.Row > 1 Then On Error Resume Next v = WorksheetFunction.VLookup(Target.Value, Worksheets("Sheet2").Range("A:B"), 2, False) Target.Offset(, 1).Value = IIf(Err.Number = 0, v, "") On Error GoTo 0 End If End Sub
色々調べましたけど、引用されたサイトのやり方くらいしかありませんね、空の配列作る方法。 基本的に配列なんて事前にサイズを決めるのが普通だと思っていたんで、こう言う問題にあたった事が無いんですよね。 件数が判らない場合はCollectionやDictionaryを使えばどうにかなっちゃうんで。 因みに、エラーが起きた >arrLNG(UBound(arrLNG)) = 1 この記述ですが、引用されたサイトにも説明有りますように、初期化されUBoundの戻り値が-1になるとあります。存在しないインデックスを指定してるのでエラーが出るのは当たり前じゃないでしょうか。（VBAは基本的に指定しないと添え字は1から始まる） Redimじゃ、いかんのかしらん。
具体的なプログラムを示さなくては正しい回答を得ることは難しいです。
以下でどうなりますか Option Explicit Type recInfo    strTitle As String    intRow As Integer    strLine As String End Type Dim myMusic() As recInfo Public Sub testData()    ReDim myMusic(9) As recInfo ' データは strTitle でまとまっていて、intRow 昇順    myMusic(0).strTitle = "A"    myMusic(1).strTitle = "A"    myMusic(2).strTitle = "A"    myMusic(0).intRow = 6    myMusic(1).intRow = 7    myMusic(2).intRow = 8    myMusic(3).strTitle = "B"    myMusic(4).strTitle = "B"    myMusic(3).intRow = 11    myMusic(4).intRow = 12    myMusic(5).strTitle = "C"    myMusic(6).strTitle = "C"    myMusic(7).strTitle = "C"    myMusic(8).strTitle = "C"    myMusic(9).strTitle = "C"    myMusic(5).intRow = 16    myMusic(6).intRow = 19    myMusic(7).intRow = 23    myMusic(8).intRow = 24    myMusic(9).intRow = 25 End Sub Public Sub Samp1()    Dim sS As String, sR As String    Dim sH As String, sM As String    Dim iNum(1) As Long    Dim i As Long, j As Long, k As Long    Call testData    i = LBound(myMusic)    While (i <= UBound(myMusic))       iNum(0) = myMusic(i).intRow       iNum(1) = iNum(0)       sR = "": sH = "": sS = iNum(0)       j = 1       Do While (i + j <= UBound(myMusic))          If (myMusic(i).strTitle _                <> myMusic(i + j).strTitle) Then Exit Do          k = myMusic(i + j).intRow          If (k = iNum(1) + 1) Then             iNum(1) = k             sM = ","             If (iNum(1) - iNum(0) > 1) Then sM = "～"             sS = iNum(0) & sM & iNum(1)          Else             sR = sR & sH & sS             sH = ","             iNum(0) = k: iNum(1) = k             sS = iNum(0)          End If          j = j + 1       Loop       myMusic(i).strLine = sR & sH & sS       i = i + j    Wend    ' 確認用    For i = 0 To UBound(myMusic)       With myMusic(i)          Debug.Print .strTitle, .intRow, .strLine       End With    Next End Sub
list.Add(Me.DataGridView1(0, 0).Value) を Dim list As New List(Of String) With DataGridView1 For r As Integer = 0 To .RowCount - 1 For c As Integer = 0 To .ColumnCount - 1 Dim Cell As DataGridViewCell = .Item(c, r) If Not Cell Is Nothing Then If Not String.IsNullOrEmpty(Cell.Value) Then list.Add(Cell.Value) End If End If Next Next End With としてみて下さい。
atumu0925さん クリップボードの処理というのではなく、ブック間でコピーすればいいのですよね。 コピー側のブックは何もする必要はありません。 貼り付け側（コピーされて内容が変わる方）のブックのオープンにマクロを書くだけでいいと思います。 2つのブックのフォルダは仮に同じとして、シートは両方Sheet1とします。 元のブックのファイル名を「a.xlsx」としています。 実際のフォルダや名前で変更して下さい。 Private Sub Workbook_Open() Dim wb As Workbook Set wb = Workbooks.Open(ThisWorkbook.Path & "\a.xlsx") ThisWorkbook.Worksheets("Sheet1").Range("A1").Value = wb.Worksheets("Sheet1").Range("A1").Value wb.Close End Sub
こんにちは。 一応、B1からB50までのセルが変化したとき、それぞれのF G 列に相当するセルに対して日付けを打ち込むコードです。 Private Sub Worksheet_Change(ByVal Target As Range) If Intersect(Target, Range("B1:B50")) Is Nothing Then Else For Each t1 In Target If t1.Column = 2 Then Application.EnableEvents = False t1.Offset(0, 4).Value = Now t1.Offset(0, 5).Value = Time Application.EnableEvents = True End If Next End If End Sub changeイベントは、イベント抑制を使わないと、永久ループしてしまうので 組み合わせます。 selectionの場合は、イベント抑制の意味があまりありません。
こんにちわ 前回の質問時に書いたので、投稿します。 'myDic(iRow & "行" & 数値) 行にその数値がいくつ使われているかをセット 'myDic(iCol & "列" & 数値) 列に、その数値が、いくつ使われているかをセット 'myDic("数値" & 数値) その数値が、いくつ使われているかをセット Sub kumiawase() Dim myDic As Object, myKey Dim i As Long, j As Long, 数値 As Long Dim 数値1 As Long, 数値2 As Long Dim iCol As Long, iRow As Long Dim myArray(0 To 14, 0 To 5) As Long Dim jobCount As Long reStart: Cells(1, "A").Resize(15, 6).ClearContents Set myDic = CreateObject("Scripting.Dictionary") For i = 0 To 14 For j = 0 To 5 myArray(i, j) = -1 Next j Next i '一列目に1から9の値をせっと '二列目から六列目までに､0から9をセット For iCol = 0 To 5 For 数値 = 0 To 9 Do iRow = Int(Rnd * 15) If iCol = 0 And 数値 = 0 Then Exit Do ElseIf myDic(iRow & "行" & 数値) > 0 Then Else If myArray(iRow, iCol) = -1 Then myArray(iRow, iCol) = 数値 myDic(iRow & "行" & 数値) = myDic(iRow & "行" & 数値) + 1 myDic(iCol & "列" & 数値) = myDic(iCol & "列" & 数値) + 1 myDic("数値" & 数値) = myDic("数値" & 数値) + 1 Exit Do End If End If Loop Next 数値 Next iCol '上で、セットしていない項目をセット For iCol = 0 To 5 For iRow = 0 To 14 jobCount = 0 Do If myArray(iRow, iCol) <> -1 Then Exit Do 数値 = Int(Rnd * 10) If iRow = 0 Then 数値1 = myArray(iRow + 1, iCol) 数値2 = 数値1 ElseIf iRow = 14 Then 数値2 = myArray(iRow - 1, iCol) 数値1 = 数値2 Else 数値1 = myArray(iRow + 1, iCol) 数値2 = myArray(iRow - 1, iCol) End If If iCol = 0 And 数値 = 0 Then ElseIf myDic(iRow & "行" & 数値) > 0 Then ElseIf myDic(iCol & "列" & 数値) > 2 Then ElseIf 数値 = 数値1 Then ElseIf 数値 = 数値2 Then ElseIf myDic("数値" & 数値) >= 9 Then Else myArray(iRow, iCol) = 数値 myDic(iRow & "行" & 数値) = myDic(iRow & "行" & 数値) + 1 myDic(iCol & "列" & 数値) = myDic(iCol & "列" & 数値) + 1 myDic("数値" & 数値) = myDic("数値" & 数値) + 1 Exit Do End If jobCount = jobCount + 1 If jobCount > 1000 Then Set myDic = Nothing GoTo reStart 'MsgBox "組み合わせができませんでしたので、やり直してください。" 'Exit Sub End If Loop Next iRow Next iCol Cells(1, "A").Resize(15, 6).Value = myArray Set myDic = Nothing End Sub
こんにちは。 for each w1 in application.workbooks debug.print w1.name next としたみたときに、主様の開きたいブックは、どんな名前でしょうか。 不一致だから、エラーということになる、ということと、 たまに、「開き方」によっては、ブックとブックが接続しない場合もあります。 管理されたフォルダ空間の場合、セキュリティがブロックする、という可能性です 確認してみてください
DLookup("ID", "T社員コード", "ID='" & Me.txtID & "'") で取得しているのは、IDじゃないですか？ それとパスワードを比較しているので、一致しないになってるかと。
一例です。 Sub sample() Dim i As Long For i = 1 To Cells(Rows.Count, 2).End(xlUp).Row - 1 With Cells(i, 2) If .Offset(, -1).Value = .Offset(1, -1).Value Then If .Value + 1 <> .Offset(1).Value Then With .Resize(, 4).Borders(xlEdgeBottom) .Color = vbRed End With End If If .Value = .Offset(1).Value Then With .Resize(2, 4).Borders .Color = vbRed .Item(xlInsideVertical).LineStyle = xlNone .Item(xlInsideHorizontal).LineStyle = xlNone End With End If End If End With Next i End Sub
(vba, ctrl) 1つのサンプルです。 ◆仮定 ①フォームはユーザーフォームを使用 ②コンボボックスは上記ユーザーフォーム内に存在、 かつオブジェ名は "ComboBox" ③ImageC のアクティブXオブジェのあるシートがアクティブ ◆上記前提でユーザーフォーム内に下記コード ①コンボからCを選択した場合 ImageCは非表示に、 Dを選択した場合は再表示 Private Sub ComboBox_Change() Select Case Me.ComboBox.Value Case "C": ActiveSheet.OLEObjects("ImageC").Visible = False Case "D": ActiveSheet.OLEObjects("ImageC").Visible = True End Select End Sub ◆状況によりOLEオブジェの表示系は下記にも短縮できるかもしれません ActiveSheet.OLEObjects("ImageC").Visible = False ↓ ActiveSheet.ImageC.Visible = False
＞何が問題なのでしょうか ⇒以下のコードで終了しているからです。 If c.Address = FirstAdd Then Exit Sub If c.Address = FirstAdd Then Exit Sub Loop Until d Is Nothing End If ↓ Loop Until c.Address =Firstadd 以下の処理ブロックも同様で如何でしょうか。
Sub 一例です() Dim rng As Range, ii Set rng = Range("D2:H2") With Range("B2") ii = Application.Match(.Value, rng, 0) If Not IsError(ii) Then .Offset(1).Resize(11).Copy rng(ii).Offset(1) End If End With End Sub
対象サイトのソースを見ましたがgetElementByClassNameでアクセスしようとしているclass=tableというものが存在しないようなので document.getElementsByTagName("table")におきかえると良いかと思います。 Sub ボタン1_Click() Dim ie As Object Dim lastRow As Long Dim r As Long lastRow = Range("B" & Rows.Count).End(xlUp).Row Set ie = CreateObject("InternetExplorer.Application") 'ie ie.Visible = True For r = 1 To lastRow url = "http://sys.web-burger.com/zip/?zipcode=" & Range("B" & r) & "&zipaddress=" & Range("C" & r).Value ie.navigate url Do While ie.Busy Or (ie.readyState <> 4): DoEvents: Loop If ie.document.getElementsByTagName("table").Length >= 7 Then Range("D" & r).Value = ie.document.getElementsByTagName("table").Item(7).innerText End If Next r ie.Quit End Sub
頂点に対して頂点の関連性を保持して座標を持ちたいのですよね？ テーブルの形で持つなら、座標テーブルと座標関連性テーブルに分けて持つしかないんじゃないかしらん。 描画の際には各頂点の座標を舐めて、線を引くときに関連性を見る。 もしくは、座標ではなく、座標の組み合わせでデータを保持するかですね。
↓のような書き方のほうが、スッキリしていると思いますが。。。。。 Dim 行 As Long 行 = 2 With Worksheets("Sheet2") Do Until .Cells(行, 1).Value = "" .Cells(行, 1).Resize(, 5).Copy End With Worksheets("Sheet1").Cells(Rows.Count, 1).End(xlUp).Offset(1).PasteSpecial _ Paste:=xlPasteValues 行 = 行 + 1 Loop End With 未実行につき不具合ご容赦。
VBAはOfficeアプリケーションの操作がメインですので、他社ツールの操作は不得手です。大抵はAPI関数を導入して、ややこしい手順を踏んで操作することになるのですが、ご質問のようなことができるかどうかも怪しいです。 こういったことでしたら、UWSCという自動操作ツールの方が適しています。ウインドウ操作も大抵は可能ですし、いざとなったら力技で対応することもできます。
>ユーザー定義型を配列にしたものは、引数として渡せないのでしょうか。 メソッドの引数としては渡せますが、WorksheetFunction.Transpose の引数としては渡せないです。
DISPLAY '私の学籍番号はこれです。よろしくね' MOVE 9 TO W-NUM DISPLAY '合計は' W-NUM 'です。' この３行の一番後ろに「.」をつけましょう
(xl) リンクアップデートをしないでファイルオープンでどうですか？ Workbooks.Open objBook.Path ↓↓ Workbooks.Open objBook.Path, False ↓↓ 又は Workbooks.Open objBook.Path, UpdateLinks:=False
こうして下さい。 まず、実行ファイル名を取得します。 http://dobon.net/vb/dotnet/vb6/apppath.html そして、そのファイル名をキーにして、 ミューテックスオブジェクトを作って、 ２重起動禁止にします。 http://dobon.net/vb/dotnet/process/checkprevinstance.html mutexName=Path.GetFileName(System.Reflection.Assembly.GetExecutingAssembly().Location) とやったらどうでしょうか？
「If buf = "False" Then Exit Sub」 の次の行のEnd Ifが余計です。 または If buf = "False" Then Exit Sub End If とします。
こんにちは。 ListObjects(1).Range.specialcells(xlCellTypeVisible).Rows.Count これ、見出しこみの行数です。
(vba, ie) 仮にP列に表示させるとして下記ではないですか？ Cells(wRow, "P").Value = GetValue(.responseText, ">配当利回り<") このタイプは html を見る必要があります。 <dt class="title">配当利回り<span class="yjS">（会社予想）</span> html は oHttp.responseText の中身です。 一度スプリット関数などで配列取得するとセルに表示し易いです。 蛇足ですが、大学生でしょうか？ 今の中高生はC言語を学校で学習するのでしょうか？
.DataSource = Data, ここかと思います。 エラーメッセージを見てください。 >IList または IListSource のどちらかを >データソースとして受け入れます。 DataSourceには、IListかIListSourceしか 指定できないのです。 コンボボックスですから、複数の要素が 想定されているというわけですね。
一例としてはこんな感じですかね １．フォルダーを選ばせる。 ２．選んだフォルダー以下に存在するファイル名をすべて取得 ３．既出ファイルを格納しておく変数と出力用のString変数を用意 ４．取得した一覧からFor Eachで1つずつ取り出して既出ファイルの一覧に存在するかを確認し、存在しないなら出力用のString変数に追記して既出ファイル一覧にファイル名を追加。 ５．StreamWriterを使用して出力。 このコードをボタンなり実行させたい部分のプロシージャ内にコピペすれば使えます。 Dim fbd As New FolderBrowserDialog 'フォルダーが選択され、OKが押されたら If fbd.ShowDialog = Windows.Forms.DialogResult.OK Then 'フォルダ内のファイル一覧を一旦すべて取得 Dim files As String() = System.IO.Directory.GetFiles(fbd.SelectedPath, "*", System.IO.SearchOption.AllDirectories) '既出ファイル格納用 Dim existsfiles As New System.Collections.Specialized.StringCollection '出力するファイル一覧の文字列格納用 Dim filelist As String = String.Empty '取得したファイル一覧からFor Eachで1つずつ取り出す For Each file In files file = Path.GetFileName(file) '既出ファイルの一覧の中に存在しない場合 If existsfiles.Contains(file) = False Then '出力用ファイル一覧にファイル名を追記する filelist &= file & Environment.NewLine '既出ファイルに追加 existsfiles.Add(file) End If Next file 'ファイルを出力 Using sw As New StreamWriter("FileList.txt", False, System.Text.Encoding.GetEncoding("shift_jis")) sw.Write(filelist) sw.Close() MsgBox("ファイル一覧を保存しました") End Using End If
B3がAでもBでもないときはどうしたいのでしょうか？
for Windowsならだめですが、for Windows Desktopならできるはずです。 Professionalの機能を使っていたりするとだめかもしれませんが。 また、インストーラーで修復すると直ることもあります。 なお、Expressは商業利用可能です。 https://www.visualstudio.com/ja-jp/products/visual-studio-express-v... >Express 製品の商業目的の使用 >Visual Studio Express 製品は、各製品のライセンス条項に従うことを条件として、無料で商用、製造用に使用できます。 たとえば、Express for Windows を使用してアプリを作成し、Windows ストアで販売することができます。 一方Communityは、従業員数や年間収益に制限がありますので、注意が必要です。
Debugフォルダはデフォルトでは2つあって、 \bin\Debug \obj\Debug ですが、実行用のExeファイルは \bin\Debug の中のファイルでしょうか？ また、ビルド時にフォルダ内へ aaa.exe.config aaa.exe.manifest と言ったファイルが出力される場合は、これも必要です。
Range("H10:Lastrng").Select ↓ Range("H10:H" & Lastrng.Row).Select あるいは Range("H10", Lastrng).Select 結合セルとは関係ないですが・・・。
まずはファイルの拡張子を調べ、該当の拡張子であればファイル属性を取得してその中身を判断するという流れになるかな。 かなり前のものですが、参考になると思うのでどうぞ。 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1133580201 ※基本はWindowsの機能を使うだけで判断できるので頑張ってください。
こんなでしょうか。 「一つ上の値をいれたい」という事はA列の値を入れるのでしょうか。 その場合入れた値がわかるように「追加」の文字を付けています。 Sub sample() Dim lastRow As Long Dim r As Long lastRow = Range("A" & Rows.Count).End(xlUp).Row 'A列最終行 For r = lastRow To 1 Step -1 '注目行をA列最終行から1行目まで逆順で If Range("A" & r).Value <> Range("A" & r + 1).Value Then 'A列注目行の値が1つ下の値と違ったら(注目行が重複の最終行なら) Range("A" & r + 1).EntireRow.Insert '1行下に1行追加 Range("A" & r + 1).Value = Range("A" & r).Value & " 追加" '追加した行のA列に追加した行のA列の値(注目行のA列の値)を代入(追加したデータがわかるように「追加」を付けている) End If Next End Sub
英文のサイトですが、サンプルコードが載っています。 http://stackoverflow.com/questions/10405193/vb-net-hid-setupdigetde... 私自身、10年ほど前にC#でUSB機器の接続判定を行うためにUSB関係のAPIを調べたのですが、あまりに面倒だったのでC言語で判定用のDLLを作って逃げたことがあります。
回答し直してます Samp1 は前回の記述方法を継承し、結果書き出し部分を５列一気に変更 >   v3c = Array("D", "L") として一致判別する Sheet3 の 商品code の列を指定 >   ReDim v3(UBound(v3c)) で、v3c の添え字に対応する結果書き出し表管理 v3(0) で、D 列用の表、v3(1) で、L 列用の表 ※ もし、同じパターンの表数を３つにするのなら    v3c = Array("D", "L", "T") とするだけで対応します 各 v3c の列の処理行範囲がわかった時点で、 >            ReDim v(1 To UBound(vA), 1 To 5) >            v3(k) = v と、領域確保 Dictionary では、商品code をキーとして、どの表の何行目･･･を覚える >      For k = 0 To UBound(v3c) >            For i = 1 To UBound(vA) でループ処理しているので                dic(vA(i, 1)) = Array(k, i) 覚え終わったら、Sheet1 / Sheet2 の解釈処理に 読み書き回数を減らすために、シート単位で、 商品code の行範囲を求めて･･･ その行範囲を継承しつつ、商品code 列からの相対で、発送日、合計を入手 入手したものを解釈していく 商品code を Dictionary に覚えていたら、どの表の何行目かを展開 >               v = dic(vA(j, 1)) >               k = v(0): i = v(1) 発送日がなければ、シート関係なく５列目に加算 発送日があって、それが Sheet3 の D5 と比較して･･･これが >                  Select Case CDate(vD(j, 1)) > ・・・ >                  End Select 間で、切り分け加算していく Sheet3 の D5 の日付 dt との比較で分けているので、内容はわかると思います 不都合あれば修正できますよね？ 処理しきったら、 >   v3c = Array("D", "L") を基準に２列右隣から書き出す ※ 各表、各シートの 商品code は２つ以上ある記述になってます 例えば、１つの場合、変数の値は配列ではなくなります･･･なのでポン 以下でどうなりますか Public Sub Samp1()    Dim dic As Object    Dim dt As Date    Dim vSs As Variant, vS As Variant    Dim v3c As Variant, v3 As Variant    Dim vA As Variant, vD As Variant, vN As Variant    Dim v As Variant    Dim i As Long, j As Long, k As Long    Const CSHT2 As String = "Sheet2"    v3c = Array("D", "L")    ReDim v3(UBound(v3c))    vSs = Array( _          Array("Sheet1", "F", "C", "AJ"), _          Array(CSHT2, "B", "A", "R") _       )    With Worksheets("Sheet3")       v = Split(.Range("D5").Text & "(", "(", , vbTextCompare)(0)       If (Not IsDate(v)) Then Exit Sub       dt = CDate(v)       Set dic = CreateObject("Scripting.Dictionary")       For k = 0 To UBound(v3c)          With Range(.Cells(11, v3c(k)) _                   , .Cells(Rows.Count, v3c(k)).End(xlUp))             vA = .Value             For i = 1 To UBound(vA)                dic(vA(i, 1)) = Array(k, i)             Next             ReDim v(1 To UBound(vA), 1 To 5)             v3(k) = v          End With       Next       For Each vS In vSs          With Worksheets(vS(0))             With Range(.Cells(2, vS(1)) _                      , .Cells(Rows.Count, vS(1)).End(xlUp))                vA = .Value                i = Cells(1, vS(2)).Column - .Column                vD = .Offset(, i).Value                i = Cells(1, vS(3)).Column - .Column                vN = .Offset(, i).Value             End With          End With          For j = 1 To UBound(vA)             If (dic.Exists(vA(j, 1))) Then                v = dic(vA(j, 1))                k = v(0): i = v(1)                If (IsDate(vD(j, 1))) Then                   Select Case CDate(vD(j, 1))                      Case dt                         If (vS(0) = CSHT2) Then                            v3(k)(i, 1) = v3(k)(i, 1) + vN(j, 1)                            v3(k)(i, 2) = v3(k)(i, 2) + vN(j, 1)                         End If                         v3(k)(i, 3) = v3(k)(i, 3) + vN(j, 1)                         v3(k)(i, 4) = v3(k)(i, 4) + vN(j, 1)                      Case Is < dt                         If (vS(0) = CSHT2) Then                            v3(k)(i, 2) = v3(k)(i, 2) + vN(j, 1)                         End If                         v3(k)(i, 4) = v3(k)(i, 4) + vN(j, 1)                      Case Else                         v3(k)(i, 5) = v3(k)(i, 5) + vN(j, 1)                   End Select                Else                   v3(k)(i, 5) = v3(k)(i, 5) + vN(j, 1)                End If             End If          Next       Next       Application.ScreenUpdating = False       For k = 0 To UBound(v3c)          .Cells(11, v3c(k)).Offset(, 2) _             .Resize(UBound(v3(k)), 5).Value = v3(k)       Next       Application.ScreenUpdating = True       Set dic = Nothing    End With End Sub Sheet1 / Sheet2 のデータを入手する際に、読み込み回数を減らすために > 商品code の行範囲を求めて･･･ > その行範囲を継承しつつ、商品code 列からの相対で、発送日、合計を入手 していましたが、読み込みで回数が増えてもそんなに遅くならない？？？ 各変数を２次元配列で扱うより、その値で扱いたい･･･ その例が Samp2 各シートの列定義を >   vSs = Array( _ >         Array("Sheet1", "F1,C1,AJ1"), _ >         Array(CSHT2, "B1,A1,R1") _ >      ) に変更して >            j = 2 >            Do While (1) >               With .Rows(j).Range(vS(1)) >                  vA = .Areas(1).Value >                  vD = .Areas(2).Value >                  vN = .Areas(3).Value >               End With これで、各変数は配列ではなくなります "F1,C1,AJ1" を .Rows(j).Range(vS(1)) すると .Rows(j).Range("F1,C1,AJ1") になり ある行･･･そこを基準とした相対の場所 F1,C1,AJ1 を･･･ カンマ区切りが領域扱いになり、その領域には１つのセルしかないので･･･ Samp1 と違い、以降、 vA, vD, vN は値そのもの扱いに･･･ Public Sub Samp2()    Dim dic As Object    Dim dt As Date    Dim vSs As Variant, vS As Variant    Dim v3c As Variant, v3 As Variant    Dim vA As Variant, vD As Variant, vN As Variant    Dim v As Variant    Dim i As Long, j As Long, k As Long    Const CSHT2 As String = "Sheet2"    v3c = Array("D", "L")    ReDim v3(UBound(v3c))    vSs = Array( _          Array("Sheet1", "F1,C1,AJ1"), _          Array(CSHT2, "B1,A1,R1") _       )    With Worksheets("Sheet3")       v = Split(.Range("D5").Text & "(", "(", , vbTextCompare)(0)       If (Not IsDate(v)) Then Exit Sub       dt = CDate(v)       Set dic = CreateObject("Scripting.Dictionary")       For k = 0 To UBound(v3c)          With Range(.Cells(11, v3c(k)) _                   , .Cells(Rows.Count, v3c(k)).End(xlUp))             vA = .Value             For i = 1 To UBound(vA)                dic(vA(i, 1)) = Array(k, i)             Next             ReDim v(1 To UBound(vA), 1 To 5)             v3(k) = v          End With       Next       For Each vS In vSs          With Worksheets(vS(0))             j = 2             Do While (1)                With .Rows(j).Range(vS(1))                   vA = .Areas(1).Value                   vD = .Areas(2).Value                   vN = .Areas(3).Value                End With                j = j + 1                If (vA = "") Then Exit Do                If (dic.Exists(vA)) Then                   v = dic(vA)                   k = v(0): i = v(1)                   If (IsDate(vD)) Then                      Select Case CDate(vD)                         Case dt                            If (vS(0) = CSHT2) Then                               v3(k)(i, 1) = v3(k)(i, 1) + vN                               v3(k)(i, 2) = v3(k)(i, 2) + vN                            End If                            v3(k)(i, 3) = v3(k)(i, 3) + vN                            v3(k)(i, 4) = v3(k)(i, 4) + vN                         Case Is < dt                            If (vS(0) = CSHT2) Then                               v3(k)(i, 2) = v3(k)(i, 2) + vN                            End If                            v3(k)(i, 4) = v3(k)(i, 4) + vN                         Case Else                            v3(k)(i, 5) = v3(k)(i, 5) + vN                      End Select                   Else                      v3(k)(i, 5) = v3(k)(i, 5) + vN                   End If                End If             Loop          End With       Next       Application.ScreenUpdating = False       For k = 0 To UBound(v3c)          .Cells(11, v3c(k)).Offset(, 2) _             .Resize(UBound(v3(k)), 5).Value = v3(k)       Next       Application.ScreenUpdating = True       Set dic = Nothing    End With End Sub
値を入れたいなら Sub Macro1() Worksheets("Sheet1").Range("A1").Value= _ Worksheets("Sheet2").Range("A1").Value _ +Worksheets("Sheet2").Range("B1").Value End Sub 「 _」は１行が長くなった場合に途中で切るための記号です。 関数式を入れたいなら Sub Macro2() Worksheets("Sheet1").Range("A1").Formula="=Sheet2!A1+Sheet2!B1" End Sub Range("A1")はCells(1,"A")と書くことも出来ます。
Userformからシートに転記するとふりがな情報は空白になります。 ですのでシート転記した時にふりがなの設定をしてから並べ替えをする必要があるでしょう。 http://officetanaka.net/excel/vba/tips/tips49.htm 並べ替えができない文字列でShift+Alt+↑キーの同時押しをする、=PHONETIC関数で表示、リボンメニューのフォント内でふりがなの表示、などで存在を調べてみてください。
条件2の時は普通という事は、条件1の時だけそのままTextBox6にフォーカスすればいいという事でしょうか。 その場合です。 TextBox6のBeforeUpdateイベントかExitイベントでCancelを使って制御します。 条件1が成立する場合と、TextBox6が変更されて条件1が成立する場合とで、BeforeUpdateイベントとExitイベントを使い分けます。 [条件1が成立する場合] Private Sub TextBox6_Exit(ByVal Cancel As MSForms.ReturnBoolean) If TextBox6.Value = 1 Then Cancel = True End Sub [TextBox6が変更されて条件1が成立する場合] Private Sub TextBox6_BeforeUpdate(ByVal Cancel As MSForms.ReturnBoolean) If TextBox6.Value = 1 Then Cancel = True End Sub
以下でどうなりますか マクロボタンをクリックされたら Samp1 を実行してみます Option Explicit Public Sub Samp1()    Const CRH As Long = 56 - 3    Const CRNGS As String = "C1,B1,M1"    Dim dic As Object    Dim rng As Range    Dim vA(1 To CRH, 1 To 4) As Variant    Dim vK As Variant, v As Variant    Dim i As Long, j As Long    Set dic = CreateObject("Scripting.Dictionary")    Set rng = Worksheets("Sheet1").Range("B3")    While (rng.Value <> "")       With rng.Offset(, 1 - rng.Column).Range(CRNGS)          dic(Trim(.Areas(1).Value)) = _             Array(.Areas(2).Value, .Areas(3).Value)       End With       Set rng = rng.Offset(1)    Wend    Application.ScreenUpdating = False    Set rng = Worksheets("Sheet2").Range("B4")    i = 1    For Each vK In mySort(dic.Keys)       If (i > CRH) Then          With rng.Resize(CRH, 4)             .Value = vA             With .Columns(1)                .TextToColumns .Cells(1), xlDelimited _                   , Space:=True, ConsecutiveDelimiter:=True             End With          End With          Set rng = rng.Offset(, 10)          Erase vA          i = 1       End If       v = dic(vK)       vA(i, 1) = vK       vA(i, 3) = v(0)       vA(i, 4) = v(1)       i = i + 1    Next    With rng.Resize(CRH, 4)       .Value = vA       With .Columns(1)          .TextToColumns .Cells(1), xlDelimited _             , Space:=True, ConsecutiveDelimiter:=True       End With    End With    Application.ScreenUpdating = True    Set dic = Nothing End Sub Private Function mySort(ByVal vA As Variant) As Variant    Dim v As Variant    Dim i As Long, k As Long    k = 0    v = "Go"    While (Not IsEmpty(v))       k = k + 1       v = Empty       For i = LBound(vA) To UBound(vA) - k          If (vA(i) > vA(i + 1)) Then             v = vA(i)             vA(i) = vA(i + 1)             vA(i + 1) = v          End If       Next    Wend    mySort = vA End Function ' 確認用簡易データ作成 Public Sub testData()    Dim r As Range    Const CRH As Long = 80    With Worksheets("Sheet1")       .Cells.Delete       For Each r In .Range("A1:N1").Resize(CRH)          Select Case r.Column             Case Range("B1").Column                r.Value = r.Address(False, False) & " " _                   & LCase(r.Address(False, False))             Case Range("C1").Column                r.Value = r.Address(False, False) & " " _                   & r.Offset(, 1).Address(False, False)             Case Else                r.Value = r.Address(False, False)          End Select       Next       .Columns.AutoFit    End With End Sub ※ 解説が必要であれば、返信いただければと････
画像の文字が小さすぎて、PCのブラウザでは確認できません。（あなたはこの画像で、文字が認識できますか？） ソースをコピペして、質問文に貼り付けて下さい。 >①１科目でも50点未満があれば失格 >②３科目とも50点以上で平均点が70点以上であれば合格 >そうでなければ不 合格と判定する （ヒント） If ①の条件 Then （失格） ElseIf ②の条件 Then （合格） Else （不合格） End If ①の条件は、それぞれ「Or」で結合 ②の条件は、それぞれ「And」で結合
とりあえず私なら こうするかなぁ。 set ymdtmp=%DATE:/=% set yyyymmdd=%DATE:/=% set n=1 :LOOP01 IF not EXIST %ymdtmp% goto NEXT01 set /a n+=1 set ymdtmp=%yyyymmdd%_%n% goto LOOP01 :NEXT01 md %ymdtmp%
Sub sample() ActiveCell.Offset(1).Resize(3).EntireRow.Delete End Sub
下記のようにするのは、どうでしょうか。 ie.document.getElementsByClassName("yt-uix-button yt-uix-button-size-default yt-uix-button-primary")(0).Click あるいは、 Set tmp=ie.document.getElementsByTagName("button") For Each t In tmp If (t.InnerText="ログイン") Then t.Click Exit For End If Next このようにしてみる等。
長いのでコードを先に載せます。 C#ではなくC++/CLIですのでご注意を。 #define _CRT_SECURE_NO_WARNINGS #define APPLINK_STDIN 1 #define APPLINK_STDOUT 2 #define APPLINK_STDERR 3 #define APPLINK_FPRINTF 4 #define APPLINK_FGETS 5 #define APPLINK_FREAD 6 #define APPLINK_FWRITE 7 #define APPLINK_FSETMOD 8 #define APPLINK_FEOF 9 #define APPLINK_FCLOSE 10 /* should not be used */ #define APPLINK_FOPEN 11 /* solely for completeness */ #define APPLINK_FSEEK 12 #define APPLINK_FTELL 13 #define APPLINK_FFLUSH 14 #define APPLINK_FERROR 15 #define APPLINK_CLEARERR 16 #define APPLINK_FILENO 17 /* to be used with below */ #define APPLINK_OPEN 18 /* formally can't be used, as flags can vary */ #define APPLINK_READ 19 #define APPLINK_WRITE 20 #define APPLINK_LSEEK 21 #define APPLINK_CLOSE 22 #define APPLINK_MAX 22 /* always same as last macro */ #ifndef APPMACROS_ONLY # include <stdio.h> # include <io.h> # include <fcntl.h> static void *app_stdin(void) { return stdin; } static void *app_stdout(void) { return stdout; } static void *app_stderr(void) { return stderr; } static int app_feof(FILE *fp) { return feof(fp); } static int app_ferror(FILE *fp) { return ferror(fp); } static void app_clearerr(FILE *fp) { clearerr(fp); } static int app_fileno(FILE *fp) { return _fileno(fp); } static int app_fsetmod(FILE *fp, char mod) { return _setmode(_fileno(fp), mod == 'b' ? _O_BINARY : _O_TEXT); } #ifdef __cplusplus extern "C" { #endif __declspec(dllexport) void ** # if defined(__BORLANDC__) /* * __stdcall appears to be the only way to get the name * decoration right with Borland C. Otherwise it works * purely incidentally, as we pass no parameters. */ __stdcall # else __cdecl # endif OPENSSL_Applink(void) { static int once = 1; static void *OPENSSL_ApplinkTable[APPLINK_MAX + 1] = { (void *)APPLINK_MAX }; if (once) { OPENSSL_ApplinkTable[APPLINK_STDIN] = app_stdin; OPENSSL_ApplinkTable[APPLINK_STDOUT] = app_stdout; OPENSSL_ApplinkTable[APPLINK_STDERR] = app_stderr; OPENSSL_ApplinkTable[APPLINK_FPRINTF] = fprintf; OPENSSL_ApplinkTable[APPLINK_FGETS] = fgets; OPENSSL_ApplinkTable[APPLINK_FREAD] = fread; OPENSSL_ApplinkTable[APPLINK_FWRITE] = fwrite; OPENSSL_ApplinkTable[APPLINK_FSETMOD] = app_fsetmod; OPENSSL_ApplinkTable[APPLINK_FEOF] = app_feof; OPENSSL_ApplinkTable[APPLINK_FCLOSE] = fclose; OPENSSL_ApplinkTable[APPLINK_FOPEN] = fopen; OPENSSL_ApplinkTable[APPLINK_FSEEK] = fseek; OPENSSL_ApplinkTable[APPLINK_FTELL] = ftell; OPENSSL_ApplinkTable[APPLINK_FFLUSH] = fflush; OPENSSL_ApplinkTable[APPLINK_FERROR] = app_ferror; OPENSSL_ApplinkTable[APPLINK_CLEARERR] = app_clearerr; OPENSSL_ApplinkTable[APPLINK_FILENO] = app_fileno; OPENSSL_ApplinkTable[APPLINK_OPEN] = _open; OPENSSL_ApplinkTable[APPLINK_READ] = _read; OPENSSL_ApplinkTable[APPLINK_WRITE] = _write; OPENSSL_ApplinkTable[APPLINK_LSEEK] = _lseek; OPENSSL_ApplinkTable[APPLINK_CLOSE] = _close; once = 0; } return OPENSSL_ApplinkTable; } #ifdef __cplusplus } #endif #endif #include <cstdio> using namespace std; using namespace System; using namespace System::IO; using namespace System::Runtime::InteropServices; using namespace OpenSSL::Core; using namespace OpenSSL::Crypto; using namespace OpenSSL::X509; value class ExternFunc { public: [DllImport("x86\\libeay32.dll", CallingConvention = CallingConvention::Cdecl)] static bool PKCS12_parse(IntPtr p12, String^ password, IntPtr* pkey, IntPtr* crt, IntPtr* ca); [DllImport("x86\\libeay32.dll", CallingConvention = CallingConvention::Cdecl)] static IntPtr EVP_PKEY_get1_RSA(IntPtr pkey); [DllImport("x86\\libeay32.dll", CallingConvention = CallingConvention::Cdecl)] static bool PEM_write_RSAPrivateKey(IntPtr fp, IntPtr rsa, IntPtr enc, String^ kstr, int klen, IntPtr cb, IntPtr u); [DllImport("x86\\libeay32.dll", CallingConvention = CallingConvention::Cdecl)] static void EVP_PKEY_free(IntPtr rsa); [DllImport("x86\\libeay32.dll", CallingConvention = CallingConvention::Cdecl)] static void X509_free(IntPtr crt); [DllImport("x86\\libeay32.dll", CallingConvention = CallingConvention::Cdecl)] static void sk_free(IntPtr stack); [DllImport("x86\\libeay32.dll", CallingConvention = CallingConvention::Cdecl)] static void RSA_free(IntPtr rsa); }; int main(array<System::String^>^ args) { String^ privateKey = nullptr; // 秘密鍵 String^ publicKey = nullptr; // 公開鍵 String^ crtPem = nullptr; // 証明書 RSA^ rsa = nullptr; // RSA鍵 CryptoKey^ key = nullptr; // 鍵情報 X509Name^ sbj = nullptr; // Subject X509Request^ csr = nullptr; // CSR X509Certificate^ crt = nullptr; // 証明書 Stack<X509Certificate^>^ ca = nullptr; // CA PKCS12^ p12 = nullptr; // PKCS12 BIO^ bio = nullptr; // 入出力 try { rsa = gcnew RSA(); rsa->GenerateKeys(1024, 65537, nullptr, nullptr); // RSA鍵の生成 privateKey = rsa->PrivateKeyAsPEM; publicKey = rsa->PublicKeyAsPEM; key = gcnew CryptoKey(rsa); sbj = gcnew X509Name(); // Subjectの生成 sbj->Country = "JP"; sbj->StateOrProvince = "Nagano-Ken"; sbj->Locality = "Nagano-Shi"; sbj->Organization = "Studio-Ephyra"; sbj->OrganizationUnit = "None"; sbj->Common = "studio-ephyra.link"; csr = gcnew X509Request(); // CSRの生成 csr->Version = 1; csr->Subject = sbj; csr->PublicKey = key; crt = csr->CreateCertificate(3650, key); // 証明書の生成 crt->SerialNumber = 100; crtPem = crt->PEM; ca = gcnew Stack<X509Certificate ^>(); bio = BIO::File("test_pkcs12.p12", "wb"); p12 = gcnew PKCS12("password", key, crt, ca); // PKCS12の生成 p12->Write(bio); } finally { delete bio; delete p12; delete ca; delete crt; delete csr; delete sbj; delete key; delete rsa; } File::WriteAllText("test_privatekey.pem", privateKey); File::WriteAllText("test_publickey.pem", publicKey); File::WriteAllText("test_certificate.crt", crtPem); String^ crtPemDecoded = nullptr; // PKCS12からデコードした証明書 IntPtr p_pkey; // PKCS12からデコードした秘密鍵 IntPtr p_crt; IntPtr p_ca; IntPtr p_rsa; FILE* p_fp; try { bio = BIO::File("test_pkcs12.p12", "rb"); p12 = gcnew PKCS12(bio, "password"); crtPemDecoded = p12->Certificate->PEM; ExternFunc::PKCS12_parse(p12->Handle, "password", &p_pkey, &p_crt, &p_ca); p_rsa = ExternFunc::EVP_PKEY_get1_RSA(p_pkey); fopen_s(&p_fp, "test_decodedprivatekey.pem", "w"); ExternFunc::PEM_write_RSAPrivateKey(IntPtr(p_fp), p_rsa, IntPtr(), nullptr, 0, IntPtr(), IntPtr()); } finally { fclose(p_fp); ExternFunc::RSA_free(p_rsa); ExternFunc::sk_free(p_ca); ExternFunc::X509_free(p_crt); ExternFunc::EVP_PKEY_free(p_pkey); delete p12; delete bio; } File::WriteAllText("test_decodedcertificate.crt", crtPem); Console::ReadLine(); return 0; }
こんなでしょうか。 Private Sub Workbook_BeforePrint(Cancel As Boolean) Dim ws As Worksheet For Each ws In Worksheets '全シートを順に調べる If ws.Range("B5").Value = "NG" Then '注目シートのB5がNGなら ws.Select '対象シート表示(必要なら) MsgBox ws.Name & "にNG判定があるので印刷できません。再度確認してください！", vbCritical '警告 Cancel = True '印刷キャンセル Exit Sub '終了 End If Next End Sub
下記のコードでいかがでしょうか？ Option Explicit Sub Sample() Dim nm As String, zp As String, adr As String With ActiveCell 'アクティブセルがA列以外なら何もしない If .Column <> 1 Then Exit Sub '姓名を取得する nm = .Value '郵便番号を取得する zp = .Offset(1, 1).Value '住所を取得する adr = .Offset(2, 1).Value '名前・郵便番号・住所のいずれかが空欄なら何もしない If nm = "" Or zp = "" Or adr = "" Then Exit Sub '転記する .Offset(4, 0).Value = zp & vbLf & adr & vbLf & nm & "さま" End With End Sub
下記のコードでいかがでしょうか？ Private Sub OptionButton1_Click() If OptionButton1.Value Then Worksheets("Sheet1").Range("B" & Day(Now)).Value = "V" End If End Sub
Int(Rnd() * ２) で、0 か 1 が得られます。 Sub test() Dim i As Integer Randomize For i = 1 To 10 Debug.Print Int(Rnd() * ２) Next End Sub
あなたが書いたコードを提示して下さい。
微妙な個所が間違ってます。 細心の注意を払ってください。 Sub 表のスタイル() With Range("A2").CurrentRegion .Borders(xlInsideHorizontal).LineStyle = xlDot .BorderAround LineStyle:=xlContinuous, Weight:=xlThick .EntireRow.RowHeight = 25 .ColumnWidth = 10 End With With Range("A2", Range("A2").End(xlToRight)) .Font.Bold = True .Interior.ColorIndex = 16 .HorizontalAlignment = xlCenter .Borders(xlEdgeBottom).LineStyle = xlDouble End With End Sub
こんな感じで、VBAの中で直接HTMLを受け取る方が、なにかと便利かもしれません。 http://oshiete.goo.ne.jp/qa/1044759.html あと、知恵袋トップ> 教養と学問、サイエンス> 言葉、語学> 英語 は、カテゴリ違いでは?
シーケンス図のような図に書き出すと読みやすいというか、動作を理解しやすいです。
試してみたいんですが、どのイベントですか？
こんにちは。 二つ目のプロシージャの 全てのWorkbookをWorkbooks としてください。
私のPCで試しましたがキャンセルしてもエラーは出ませんでした。 参考までに多少作り直したコードを提示しておきます。 Option Explicit Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Dim myAreas As Variant, myArea As Variant Dim myRange As Range Dim myPic As Variant Dim myShp As Shape, Shp As Shape myAreas = Array( _ "B11:B20", "B22:B31", "B33:B42", "B44:B53", _ "B56:B65", "B67:B76", "B78:B87", "B89:B98", _ "B100:B109", "M11:M20", "M22:M31", "M33:M42", _ "M44:M53", "M56:M65", "M67:M76", "M78:M87" _ ) For Each myArea In myAreas Set myRange = Range(myArea) If Not Intersect(Target, myRange) Is Nothing Then myRange.Select myPic = Application.GetOpenFilename("画像ファイル,*.jpg;*.jpeg;*.mpeg;*.mpg;*.png") If VarType(myPic) <> vbBoolean Then Application.ScreenUpdating = False For Each myShp In Me.Shapes If myShp.Name = "画像" & Selection.Address Then myShp.Delete End If Next Set Shp = Me.Shapes.AddPicture(Filename:=myPic, _ LinkToFile:=False, _ SaveWithDocument:=True, _ Left:=Selection.Left, _ Top:=Selection.Top, _ Width:=0, _ Height:=0) With Shp .ScaleHeight 1!, msoTrue .ScaleWidth 1!, msoTrue .LockAspectRatio = msoFalse .Top = Selection.Top .Left = Selection.Left .Height = Selection.Height .Width = Selection.Width .Rotation = 0 .Name = "画像" & Selection.Address End With Application.ScreenUpdating = True End If Cancel = True Exit Sub End If Next End Sub
置換をすればいいと思います。 こちらがすごく参考になるはずです。 https://technet.microsoft.com/ja-jp/library/ee692875.aspx
６４ビットのＣＰＵで動作しているなら、byte も long も速度は変わりません。 ３２ビットなら、少しは違いが出るかもしれません。 ただ、メモリーは余計に使うので、大量のデータを扱う時だけ考えて使いましょう。
ちょっと長いですが、、、 RangeやCellsなどセルを指定する際は、前にワークシートの指定が必要です。Worksheets("Sheet1").Cells(1,1)のように。省略は可能ですが、その際はアクティブシートとみなされます。RangeもCellsも両方です。このことを頭に入れて質問文のコードを見ると、 Worksheets("Sheet2").Range(Cells(行, 1), Cells(行, 5)).Copy Rangeについては確かにシート指定がなされてますが、続くCellsでは省略されてるのでアクティブシートと見なされます。もし、アクティブシートがSheet1だったらどうなるでしょう？Sheet2のセル範囲を指定するのにSheet1のセルを使ってることになり、エラーとなります。つづくdestinationでも同じ書き方になってます。 対策： 素直に書くとシート指定すればいいのだから Worksheets("Sheet2").Range(Worksheets("Sheet2").Cells(行, 1), Worksheets("Sheet2").Cells(行, 5)).Copy これでもOKです。が、パッと見、読みにくいですよね。 Withという便利なものがあります。 With Worksheets("Sheet2") .Range(.Cells(行, 1), .Cells(行, 5)).Copy Destination:=Worksheets("Sheet1").Cells(行 + 2, 1) End With 見た目で大体わかりますよね？Worksheets("Sheet2")をくくり出しておくと、中ではピリオド「.」を付けるだけに省略出来るのです。もうひとつ、コピー先は先頭セルだけでもいいので、そのように書いてます。 Dim 行 As Integer 行 = 2 with Worksheets("Sheet2") Do Until .Cells(行, 1).Value = "" .Range(.Cells(行, 1), .Cells(行, 5)).Copy Destination:=Worksheets("Sheet1").Cells(行 + 2, 1) 行 = 行 + 1 Loop End With
それがどんなデータベースにつながっているか判りませんが。 Math.Floorって関数があるデータベースなんですか？ なんかVBのMathクラスに見えるんですけど。SQL ServerもOracleも普通にFloorだし、、、その辺りですかね。 後、SQL文中にFromと思われるんですがFLOM と記述されている所が有ります。
理屈としては合っているはずですが、下記のようなことがあるようです。 https://social.msdn.microsoft.com/Forums/ja-JP/5effeccb-93af-483e-8... つまり、既に閉じられているIEタブが何故か居残っていて、それを拾ってしまうと、ドキュメントが操作できずにエラーになるという理屈のようです。 とりあえず、CreateObjectでIE起動直後の、どこにもつながっていない状態で実験したところ、LocationURLプロパティは読み取れたので、これを利用してみるのはどうでしょうか。 'まずは、有効なURLを持っているかどうかを確認 If (w.LocationURL <> "") Then '有効なURLを持っていれば、生きているウインドウと判断 If (TypeName(w.document) = "HTMLDocument") Then 最初のFor文内のIf文を、上記のように2重にしてみてください。 後、その中のIf文の処理ですが、 Set ie=w Exit For のように変更してください。こうしないと、見つけても、次のウインドウを探しにいってしまいます。先の質問の回答がこうなっていたのでしたら、こちらのミスです。申し訳ありません。
下記のコードでいかがでしょうか。 そんなに難しいコードではありませんが、一行一行が何をしているのか、コメントを参考にしっかり理解して下さい。 Option Explicit Sub Sample() Dim dt As Variant Dim yyyy As String, mm As String Dim fPath As String 'アクティブシートのA6の値を取得する dt = ActiveSheet.Range("A6").Value If Not IsDate(dt) Then MsgBox "A6セルに日付が入力されていません。" ActiveSheet.Range("A6").Select Exit Sub End If dt = Format(dt, "yyyymmdd") yyyy = Mid(dt, 1, 4) mm = Mid(dt, 5, 2) fPath = "D:\" & yyyy 'D:\yyyyが存在しなければ作成する If Dir(fPath, vbDirectory) = "" Then MkDir fPath 'D:\yyyy\mmが存在しなければ作成する fPath = fPath & "\" & mm If Dir(fPath, vbDirectory) = "" Then MkDir fPath 'アクティブシートを新しいブックにコピーする ActiveSheet.Copy With ActiveWorkbook '新しいブックをD:\yyyy\mmに保存する .SaveAs fPath & "\" & dt & ".xlsx" '新しいブックを閉じる .Close False End With End Sub
1行ごとに行を挿入するわけではないので、繰り返し処理は必要ないと思います。 With Worksheets("リスト") .Range("B2:J20").Copy Destination:=.Range("B3") .Range("B2:J2").ClearContents End With
ソリューションの種類を「WPF アプリケーション」にしていませんか？ タイマーコントロールは「Windows フォーム アプリケーション」でないと表示されません。
こんなでしょうか。 Sub sample() Dim file As String file = Sheets("Sheet1").Range("A1").Value & "北海道" '保存ファイルのタイトル(最終的に、Sheet1のA1の値+"北海道201606.xlsm"などになる) file = file & Format(DateAdd("m", -1, Date), "yyyymm") & ".xlsm" 'ファイル名に前月の日付(yyyymm)を付加 If MsgBox(file & vbCrLf & "でデスクトップに保存します", vbOKCancel) <> vbOK Then Exit Sub '確認 file = CreateObject("Wscript.Shell").SpecialFolders("Desktop") & "\" & file 'デスクトップのフルパス ThisWorkbook.SaveCopyAs file 'ファイルのコピーを保存 End Sub
細かいところはともかく、なぜ Set sh = worksheets("sheet1") ではないのですか？？？
VBAは要らないです。マッピング設定するだけで複数のファイルからデータを抽出し一つに纏められます。 下記の1をご参考ください。 http://superdbtool.com/blog/archives/698
最近、フォーム作成に関する質問に回答しまして、すこし似ていますので一度御覧ください。 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1416083667... さてこちらで提示しましたコードで最初にDim r As Long'変数宣言としています。 この、モジュールのトップで宣言された変数はモジュール内のコードで維持されます。ですので、起動ボタンを押したときのアクティブセルの行を格納し、上書きボタンを押した時までその行番号を維持して上書きさせることができます。 データ最終行を取得するのは一般的にはRange("A" & cells.rows.count).end(xlUP).row+1と、なります。これはA列最終行からCtrl+↑を押して移動するセルに1を足してそこが最終行直下空白行、という意味です。 この最終行書き込み動作は先ほどのデータの上書きとは違うボタンで実装されるのですよね？ もしくはフォームで賞品番号のような部分で判定して上書きするか新規書き込みするか判断するとかって方法も取れるんですが、フォームやそのコードの詳細がわからないので回答しかねます。
Sub test() Dim i As Long For i = 1 To Cells(Rows.Count, 3).End(xlUp).Row If Cells(i, 3).Offset(2) = 1 Then Cells(i, 2) = Cells(i, 2).Offset(2) Cells(i + 1, 2) = Cells(i, 2).Offset(2) End If Next End Sub ※００１が数値の場合（文字列でも大して変わりません）
Private Sub CommandButton1_Click() Dim Sh As Worksheet Dim R As Long Dim i As Long Set Sh = Workbooks("ブック1.xlsx").Sheets("シート1") i = 0 With ListBox1 .Clear .ColumnCount = 2 Do While True R = i * 4 + 13 If Sh.Cells(R, 2) <> "" Then .AddItem .List(i, 0) = Sh.Cells(R, 2) .List(i, 1) = Sh.Cells(R, 3) Else Exit Do End If i = i + 1 Loop End With End Sub のような感じで。
VBAでC列のセル値が 空白（””）ならば これは Ｃ列全部が 空白ということでしょうか？ 空白でなければ これは 一つでも空白が なければ ということでしょうか? マクロブックとは 現在ＡＣＴＩＶＥな マクロが組み込んであるこのブックということですね。 シート２をコピーして保存し，どこへ 保存するのでしょうか? この例も意味が わかりません。 KENの新規ブックであれば営業1部という名前のフォルダに。 KEN云々より A列に 部署名が 書いてあり 部署のフォルダーがあるなら 直接Ａ列をフォルダー名にして 保存すれば いい訳ですが 何を保存するのでしょうか このブックですか 同じブックを 担当者別に 分けても意味が無いのでは? また質問のＣ列との関連も無いですが?
SUMPRODUCT(($A$3:$A$8=A12)*($C$1:$G$1=1),$C$3:$G$8) か、 {=SUM(IF(($A$3:$A$8=A12)*($C$1:$G$1=1),$C$3:$G$8))} どちらでもでます。 数式の解説はこちらをどうぞ。 Excel2010： 行・列で条件に合致したものを合計する（SUMPRODUCT関数） http://www.office-qa.com/Excel/ex297.htm
へぇ、AutoCADのマクロってVisual Basicだったんですね。 勉強になりました。 知恵袋トップ>スマートデバイス、PC、家電>ソフトウェア>CAD 位のカテゴリで聞いた方が回答貰えると思いますよ。
変更のみでは対処できません。きちんと、サブフォルダーを走査する仕組みを作る必要があります。 とりあえず現状の処理を生かすのであれば、現在のマクロを引数付きにし、引数をフォルダーとして指定する形にします。そして、指定したフォルダー内のエクセルファイルに「エクセルの作業」をさせるようにしてください。 その上でならば、サブフォルダーを走査する仕組みを追加し易くなります。 Sub Macro2(fpath As String) 略 Path = ～ → これを削る buf=Dir(fpath & "\*.xls") 以下、同じ この変更で、文字列でフォルダーを指定すれば、そのフォルダーのエクセルファイルを処理します。 そして、サブフォルダーの走査ですが、以下のようにできます。 Sub test() fpath = ThisWorkbook.Worksheets("sheet1").Range("A1").Value Set fso = CreateObject("Scripting.FileSystemObject") seek_folder fso.GetFolder(fpath) Macro2 fpath End Sub Private Sub seek_folder(fol As Object) Dim f As Object For Each f In fol.SubFolders If (f.SubFolders.Count > 1) Then seek_folder f Macro2 f.Path Next End Sub 「test」を実行すれば、サブフォルダーに対する処理になります。実際にサブフォルダーを走査しているかどうかを確認するには、 Macro2 fpath ↓ コメントアウト Macro2 f.Path ↓ Cells(Rows.Count, 1).End(xlUp).Offset(1, 0).Value = f.Path このように変更してみてください。アクティブシートのA列にサブフォルダーが列挙されます。
Windows10にしてからでしょうか？ ネット上ではWindows10の不具合として、EXCEL,Wordが開かない又はフリーズする。等の事柄が一杯報告されているようです。 もし、以前のOSではその様な事象が出ていないのであればWindows10が関係しているかも。 それと、ちょっと気になったのが ＞ファイルを開いたときに表示されていた「マクロを有効にしますか？」といった内容の警告文・・・・・・ Excel２００７からセキュリティが強化され、「マクロ」が含まれたファイルを開く際にマクロ無効、有効等々の警告文が出されます。 これを解消しマクロを有効状態で警告文無しで開くには「セキュリティセンター」で設定しなければいけないのですがその手順の乗っている参考サイトを掲載します。参考にして下さい。 https://121ware.com/qasearch/1007/app/servlet/relatedqa?QID=017208
VBAのコードを選択状態（青反転）にして「TAB」キーを押下すると１インデント分右側に移動（左側に空白が出来る）しますが。 ＞整える と言うのが下例のように解りやすく、見やすくするのであれば「TAB」キーを使うことは正解です。 ＜例＞ Dim i As Long Dim e As Long If Target.Column <= 3 Or Target.Column >= 9 Then Exit Sub If Target <> "○" Then Exit Sub Application.ScreenUpdating = False i = Target.Column Select Case i Case 5 '月 Sheets("月").Activate With Sheets("月") e = .Cells(Rows.Count, "A").End(xlUp).Row + 1 .Cells(e, 1).Value = Target.Offset(, -3).Value .Cells(e, 2).Value = "○" End With Case 6 '火 Sheets("火").Activate With Sheets("火") e = .Cells(Rows.Count, "A").End(xlUp).Row + 1 .Cells(e, 1).Value = Target.Offset(, -4).Value .Cells(e, 2).Value = "○" End With ※ショートカットキーについて コードのインデントのショートカットキーは「TAB」キー VBA画面でのメニューからの場合は初期状態では非表示になっていますので、 メニューバーの「表示」ー「ツールバー」ー「編集」にチェックを付けてください。左インデントと右インデントのアイコンが表示されます。 ※上例ですと「Dim i As Long」「Dim e As Long」の2行はインデント無し。 次のIF文行は１インデント。次の「 Application・・・・・」とその次行は２インデント（TABキーを2回押下）その次の「Select Case i」は３インデントと、行単位で選択し設定します。
以下でどうなりますか 標準モジュールに記述し実行してみます ※ ★ 部分のシート名を変更してから Public Sub Samp1()    Dim dic As Object    Dim vA As Variant, vB As Variant, vF As Variant, v As Variant    Dim i As Long, j As Long    Const CSEP As String = ","    Set dic = CreateObject("Scripting.Dictionary")    With Worksheets("Sheet1") ' 作業シート★       With .Range("A1", .Cells(Rows.Count, "A").End(xlUp))          vA = .Value          For i = 1 To UBound(vA)             dic(vA(i, 1)) = dic(vA(i, 1)) & CSEP & i             vA(i, 1) = "なし"          Next          vB = dic.Keys          With Worksheets("Sheet2") ' 別表シート★             With .Range("A1", .Cells(Rows.Count, "A").End(xlUp))                For i = 1 To .Rows.Count                   For Each vF In Filter(vB, .Cells(i).Value)                      For Each v In Split(dic(vF), CSEP)                         j = Val(v)                         If (j > 0) Then vA(j, 1) = "あり"                      Next                   Next                Next             End With          End With          .Offset(, 1).Value = vA       End With    End With    Set dic = Nothing End Sub
Excel 2010ではVBAを使うような方法以外に適当な方法が見当たりません。 Googleスプレッドシートを使ってみませんか。 GoogleスプレッドシートならD列は D2セルに =IMPORTXML("http://mnrate.com/item/aid/"&C2,"//li[@class='quantity used_price_color']") のような数式を入れて必要行までコピーすればいけそうです。
Private Sub CommandButton1_Click() Dim i As Integer For i = 3 To 34 If IsEmpty(Cells(i, "A")) Then Cells(i, "A") = TextBox1.Value Exit For End If Next End Sub Private Sub CommandButton2_Click() Dim i As Integer For i = 3 To 34 If IsEmpty(Cells(i, "F")) Then Cells(i, "F") = ComboBox1.Value Exit For End If Next End Sub '【注意１】「登録ボタン」が１つで両方入力なのか２つあって別々に入力なのか不明でしたので、ボタン２つに分けてAとFの作業を別に切り分けてます。 '【注意２】空白行を想定してません。また34行目まで入力されていた場合のメッセージなど注意を行いません。 '【注意3】その他必要と思われる作業は別途コーディングしてください。あくまで質問者様のニーズにだけ応えるコードです。
コード例です。 フォームにButton,Timer,Labelを貼り付けて下記のコードをForm1.vbにコピペしてください。 Public Class Form1 Private Count As Integer Private Sub Form1_Load(sender As System.Object, e As System.EventArgs) Handles MyBase.Load Label1.Text = "" End Sub Private Sub Button1_Click(sender As System.Object, e As System.EventArgs) Handles Button1.Click Count = 3 Label1.Text = Count.ToString() Timer1.Interval = 1000 Timer1.Enabled = True End Sub Private Sub Timer1_Tick(sender As System.Object, e As System.EventArgs) Handles Timer1.Tick Count = Count - 1 Label1.Text = Count.ToString() If Count = 0 Then Timer1.Enabled = False 処理() End If End Sub Private Sub 処理() MsgBox("時間です") End Sub End Class
セルの値を書き換える、ということですので、前回のソースから色々変更しました。 Option Explicit Dim c As Long, r As Long Private Sub CommandButton1_Click() Dim newData As String, oldData As String Dim rng As Range, i As Integer '修正された内容を取得する newData = TextBox2.Text 'ListBox1で選択されている行からシート上のセル位置と内容を取得する With ListBox1 Set rng = Range(.List(.ListIndex, 1)) oldData = rng.Value 'リストボックスのデータを更新する .List(.ListIndex, 0) = newData End With With rng 'シート上のセルのデータを更新する .Value = newData .Select End With 'ComboBox2のデータを更新する With ComboBox2 For i = 0 To .ListCount - 1 If .List(i, 0) = oldData Then .List(i, 0) = newData Exit For End If Next End With End Sub Private Sub ListBox1_Change() If ListBox1.ListIndex = -1 Then Exit Sub 'ListBox1で選択されたデータをTextBox2に設定する TextBox2.Text = ListBox1.List(ListBox1.ListIndex) End Sub Private Sub ComboBox2_Change() If ComboBox2.ListIndex = -1 Then Exit Sub With ListBox1 .Clear 'ComboBox2で選択されたデータからシート上の列番号を取得する c = Range(ComboBox2.List(ComboBox2.ListIndex, 1)).Column 'ListBox1にComboBox2で選択された列のデータとセル位置を設定する For r = 2 To Cells(Rows.Count, c).End(xlUp).Row .AddItem Cells(r, c).Value .List(.ListCount - 1, 1) = Cells(r, c).Address Next End With End Sub Private Sub ComboBox1_Change() If ComboBox1.ListIndex = -1 Then Exit Sub With ComboBox2 .Clear 'ComboBox1で選択されたデータからシート上の列番号を取得する c = Range(ComboBox1.List(ComboBox1.ListIndex, 1)).Column 'ComboBox2にComboBox1で選択された列のデータとセル位置を設定する For r = 2 To Cells(Rows.Count, c).End(xlUp).Row .AddItem Cells(r, c).Value .List(.ListCount - 1, 1) = Cells(r, c).Address Next End With End Sub Private Sub UserForm_Initialize() Dim rng As Range 'ComboBox1の初期設定を行う With ComboBox1 .ColumnCount = 2 .ColumnWidths = ";0" 'ComboBox1にD1:S1の値とセル位置を設定する For Each rng In Range("D1:S1").Cells .AddItem rng.Value .List(.ListCount - 1, 1) = rng.Address Next End With 'ComboBox2の初期設定を行う With ComboBox2 .ColumnCount = 2 .ColumnWidths = ";0" End With 'ListBox1の初期設定を行う With ListBox1 .ColumnCount = 2 .ColumnWidths = ";0" End With End Sub
さぁ、VBがどのVBか判りませんが、レイヤーと同等の機能は無いですが、実装したことが有りますよ。Visual Basic２０１０ですけど。 透過させたところに描画すれば良いんじゃないかな。 透過イメージを重ねるのはそんなに難しくないです。それをちゃんと内部でイメージとしてやるだけですし。
以下でどうなりますか シートA, B 名は、Sheet1 / Sheet2 として確認してました > vS = Array("Sheet1", "Sheet2") > vF = Array("R_Sheet1.txt", "R_Sheet2.txt", "R_Sheet1_2.txt") vF の記述順は、 vS 左側だけにあるもの、右側だけにあるもの、キーが一致し内容が違うもの これを出力するテキストファイル名 > キーが一致すれば特定列を比較し同じなら何もしない。 > 違うならそのキーを抽出。 より、３つ目のファイルは内容が違うものを･･･ ★ 部分を変更の上、実行してみてどうなりますか なお、各シート、B, C 列で処理しました Public Sub Samp1()    Dim dicA As Object, dicB As Object, dicC As Object    Dim vA As Variant, v As Variant    Dim vS As Variant, vF As Variant, vDic As Variant    Dim ffn As Integer    Dim i As Long    Const CSEP As String = ","    Set dicA = CreateObject("Scripting.Dictionary")    Set dicB = CreateObject("Scripting.Dictionary")    Set dicC = CreateObject("Scripting.Dictionary")    vS = Array("Sheet1", "Sheet2") ' シートA, B の順 ★    vF = Array("R_Sheet1.txt", "R_Sheet2.txt", "R_Sheet1_2.txt") ' ★    For Each v In vS       With Worksheets(v)          With .Range("B1", .Cells(Rows.Count, "B").End(xlUp))             vA = .Resize(, 2).Value          End With       End With       If (dicA.Count = 0) Then          For i = 1 To UBound(vA)             dicA(vA(i, 1)) = vA(i, 2)          Next       Else          For i = 1 To UBound(vA)             If (dicA.Exists(vA(i, 1))) Then                If (dicA(vA(i, 1)) <> vA(i, 2)) Then                   dicC(vA(i, 1)) = dicA(vA(i, 1)) & CSEP & vA(i, 2)                End If                dicA.Remove vA(i, 1)             Else                dicB(vA(i, 1)) = vA(i, 2)             End If          Next       End If    Next    vDic = Array(dicA, dicB, dicC)    ffn = FreeFile()    For i = 0 To 2       If (vDic(i).Count > 0) Then          Open ThisWorkbook.Path & "\" & vF(i) For Output As #ffn          For Each v In vDic(i).Keys             Print #ffn, v & CSEP & vDic(i)(v)          Next          Close #ffn       End If    Next    Set dicA = Nothing    Set dicB = Nothing    Set dicC = Nothing End Sub ※ 提示あったデータで出来上がった内容は以下 R_Sheet1.txt A102,かきくけこ R_Sheet2.txt A107,はひふへほ R_Sheet1_2.txt A106,なにぬねの,ななななな なお、ファイル内はキーだけで良いのなら             Print #ffn, v & CSEP & vDic(i)(v) ↓             Print #ffn, v
IndexOfのヘルプを良く読んでください。 「その文字列が見つかった場合は、 value の 0 から始まるインデックスでの位置。見つからなかった場合は -1。 」 と書いてあります。 ですから「i= str .IndexOf("a")」は3ではなく2が返ります。 そういう意味ではバイト位置は4になります。 下記のコードをステップ実行して確かめてください。 Dim str As String Dim iStr As Long, iByte As Long Dim subStr As String str = "あいa12う3" iStr = str.IndexOf("a") subStr = str.Substring(0, iStr) iByte = System.Text.Encoding.GetEncoding("SHIFT-JIS").GetByteCount(subStr)
承認前というシートのシートモジュールに下記を書いておけば、自動で実行します。 Private Sub Worksheet_Change(ByVal Target As Range) 'mayuvogue If Target.Count > 1 Then Exit Sub If Intersect(Target, Range("C8:C57")) Is Nothing Then Exit Sub If Target.Value = "AC" Then Worksheets("承認後").Range("D" & Target.Row).Value = "確認要" ElseIf Target.Value = "PC" Then Worksheets("承認後").Range("D" & Target.Row).Value = "確認不要" ElseIf Target.Value = "" Then Worksheets("承認後").Range("D" & Target.Row).Value = "" End If End Sub
下記のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim cnt As Integer, r As Long, rd As Long rd = 2 For r = 2 To Range("A" & Rows.Count).End(xlUp).Row For cnt = 0 To DateDiff("d", DateValue(Range("B" & r).Value), DateValue(Range("C" & r).Value)) Range("D" & rd).Value = DateAdd("d", cnt, Range("B" & r).Value) rd = rd + 1 Next cnt Next r End Sub
下記のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim r As Long, c As Integer For r = 1 To Range("A" & Rows.Count).End(xlUp).Row With Range("A" & r) '先頭の文字がアルファベットかどうかを判定する c = Asc(Left(.Value, 1)) If (c >= 65 And c <= 90) Or (c >= 97 And c <= 122) Then 'アルファベットなら一行上のB列に移動させる .Offset(-1, 1).Value = .Value .Value = "" End If End With Next r End Sub
>なぜでしょうか。 プログラムを見ないうちは、原因など解りようが無いのは、ご承知なんですよね？ >同時にマクロを行えるコード 意味不明。 >sheetsBのE12に文字を記入するマクロ Sheets("A").Activate ActiveSheet.Shapes.Range(Array("ボタンA")).Visible = True Worksheets("B").Range("E12").Value = "記入する文字"
範囲が違わないかしらん。因みに別途ロジックの資料ですが。こっちの方が早いかも。 http://www.atmarkit.co.jp/fdotnet/dotnettips/054iskana/iskana.html
「データ統合」 http://www4.synapse.ne.jp/yone/excel2013/excel2013_tougou.html の操作をマクロ記録に録って、手を加えるのが安直・最速でしょう。 Sheet1のB1から始まる表を、新規シートに統合しています。 Private Sub CommandButton1_Click() Const xDta As String = "Sheet1" With Worksheets(xDta).Range("B1") xAdr = "'" & xDta & "'!" & .CurrentRegion.Address(, , xlR1C1) .Copy End With With Worksheets.Add.Range("A1") .PasteSpecial .Consolidate Sources:=xAdr, Function:=xlSum, _ TopRow:=True, LeftColumn:=True, CreateLinks:=False End With End Sub
フォームの Activate イベントに下記で出来ると思います。 Private Sub UserForm_Activate() Dim 先頭文字 As String 先頭文字 = Left(ActiveSheet.Name, 1) With ListBox1 .ColumnCount = 1 Select Case 先頭文字 Case "あ" .RowSource = "リスト!A2:A20" Case "い" .RowSource = "リスト!B2:B20" Case "う" .RowSource = "リスト!C2:C20" Case "え" .RowSource = "リスト!D2:D20" Case "お" .RowSource = "リスト!E2:E20" End Select .ColumnHeads = False End With End Sub
間違いがあったらごめんなさい。 クラスのフィールドとして以下を定義 Private timer As System.Timers.Timer = Nothing Private done_1715 As Boolean = False Private done_1400 As Boolean = False Private done_1215 As Boolean = False Private done_0915 As Boolean = False Loadイベントで以下の処理を記述 Dim time = DateTime.Now.TimeOfDay If time > New TimeSpan(17, 15, 0) Then done_1715 = True done_1400 = True done_1215 = True done_0915 = True ElseIf time > New TimeSpan(14, 0, 0) Then done_1715 = False done_1400 = True done_1215 = True done_0915 = True ElseIf time > New TimeSpan(12, 15, 0) Then done_1715 = False done_1400 = False done_1215 = True done_0915 = True ElseIf time > New TimeSpan(9, 15, 0) Then done_1715 = False done_1400 = False done_1215 = False done_0915 = True Else done_1715 = False done_1400 = False done_1215 = False done_0915 = False End If timer = New System.Timers.Timer(30000.0) AddHandler timer.Elapsed, Sub(s, e) Dim t = e.SignalTime.TimeOfDay If Not done_1715 And t > New TimeSpan(17, 15, 0) Then done_1715 = True ' 17:15の処理 ElseIf Not done_1400 And t > New TimeSpan(14, 0, 0) Then done_1400 = True ' 14:00の処理 ElseIf Not done_1215 And t > New TimeSpan(12, 15, 0) Then done_1215 = True ' 12:15の処理 ElseIf Not done_0915 And t > New TimeSpan(9, 15, 0) Then done_0915 = True ' 09:15の処理 ElseIf t < New TimeSpan(0, 1, 0) Then done_1715 = False done_1400 = False done_1215 = False done_0915 = False End If End Sub timer.Start()
Sub Sample() Dim i As Long For i = 2 To Cells(Rows.Count, 3).End(xlUp).Row Step 2 Range("C" & i & ":P" & i).Copy Destination:=Range("Q" & Int(i / 2)) Next i End Sub
質問です。 ①質問では「現場」というブックを対象とするように書かれていますが、添付された画像では「☆現場ごと台帳☆」という名前になっています。どちらが正しいのでしょうか？ ②もしD列の名前が「現場」ブックのシート名に存在しなかった場合はどのようにすればよいのでしょうか？ ③マクロを２回続けて実行してしまった場合など、既に同一のデータが現場ブックに存在していた場合はどのようにすればよいのでしょうか？
.document.GetElementsById("Email").Value = "アドレス@gmail.com" とした場合はどうなりますか？
＞.ChartObjects(1).Chart.SetSourceData Source:=ThisWorkbook.Worksheets(1).Range("AO4").Resize(suji, 3) グラフのデータが、マクロを書いたブックのAO4～suji3になってます。望みはおそらく開いたブックのシートにあるデータを使いたいのでしょうから、以下のように変更します。 ThisWorkbook→ Workbooks(wbName)
マクロは私はよく判りませんが フォルダを検索ですが その後何をされるのですか？ また複数一致なら？？？ Windowsの 検索機能ではだめなのですか？ http://windows.microsoft.com/ja-jp/windows-10/getstarted-search-for... http://windows.microsoft.com/ja-jp/windows-vista/tips-for-finding-f...
LINQ to SQLを利用すると簡単です。 .NETの標準機能なので、安心して使えます。 まず、 ＞一旦、クラスへ入れてから更新かけようと思うのですが とおっしゃっていたクラスを自動生成します。 プロジェクトを右クリックし、[追加]->[新しい項目]をクリック。 左の[データ]を選択し、[LINQ to SQL クラス]を選択して、 名前をつけ（仮に[xxxx]とします）、追加をクリック。 空白のGUIが開きます。 そうしたら、ツールボックスからクラスをDrag&Dropします。 これでクラスが生成されました。 [Class1]の部分をクリックして、[TableA]とクラス名を つけましょう。 次に、プロパティを追加していきます。 クラスを右クリックし、[追加]->[プロパティ]です。 プロパティはDBの列名にしましょう。 Code、Name、・・・と追加していきましょう。 プロパティを選択すると、右下（もしくは左下？）の プロパティウィンドウに、そのプロパティの情報が 表示されます。 [主キー]、[型]、[Null許容]、あたりを編集しておきましょう。 これでTableAクラスの完成です。 複数のテーブルクラスを作る場合、[関連付け]の設定も 必要ですが、それは参考サイトを見てください。 あとはコーディングですが、 先ほど作ったTableAクラスの他に、xxxxDataContextという クラスが生成されています。（この[xxxx]は先ほどつけた名前です。） このxxxxDataContextを使い、以下のようにDBに接続します。 var db = new xxxxDataContext("[接続文字列]"); [接続文字列]は環境によって変わります。 そして、Insertの仕方は以下のとおりです。 TableA table = new TableA(); table.Code = "0001"; table.Name = "日本太郎"; ・・・ db.TableA.InsertOnSubmit(table); // Insert db.SubmitChanges(); // Commit このように、SQLを使用する必要がなくなります。 これを読んで、いいな、と思ったら使ってみてください。 ここを読めば、LINQ to SQLが一通りわかります。 http://ufcpp.net/study/csharp/sp3_linqtosql.html
inputしたファイル ァイルをoutput input、output、ファイルの それぞれの使いかた間違っていませんか どういう意味かわかりません。 セルに 入力した文字列を そのセルに 縦書きに 表示したいなら わかりますが???
Sheet4から最終シートまでを複数選択して検索ダイアログを表示する例です。 シートの数に自動対応するのであればArrayを使うメリットは全くありません。 Option Explicit Sub Sample() Dim intF As Integer Dim i As Integer intF = 0 For i = 4 To Worksheets.Count If intF = 0 Then Sheets(i).Select intF = 1 Else Sheets(i).Select False End If Next i Worksheets(4).Range("A1").Select SendKeys "^c" SendKeys "^f" SendKeys "^v" SendKeys "{Enter}" End Sub
以下でどうでしょう Dictionary を使います Dictionary オブジェクト https://msdn.microsoft.com/ja-jp/library/cc428065 簡単にいえば、 キーに関連するものを一緒に覚えておく チーム名をキーとして、評価を覚えていきます >          dic(vA(i, 1)) = vA(i, 2) これによって、 ・キーがなかったら新しく覚えて ・キーがあったら更新して覚えます これにより、１つ１つあるかないか判別して･･･ ･･･自分でやる必要はなくなります ※ 旧データ、新データ順に単純に１巡するだけ そして Dictionary に出来上がったものを書き出すだけ チーム名、評価が隣り合った列と仮定して、以下でどうなりますか Public Sub Samp1()    Dim dic As Object    Dim rngOld As Range, rngNew As Range    Dim vA As Variant, v As Variant    Dim i As Long    Set dic = CreateObject("Scripting.Dictionary")    Set rngOld = Worksheets("Sheet1").Range("A1") ' 旧データの左上    Set rngNew = Worksheets("Sheet2").Range("A1") ' 新データの左上    For Each v In Array(rngOld, rngNew)       With v.CurrentRegion          vA = .Resize(, 2).Value       End With       For i = 2 To UBound(vA)          dic(vA(i, 1)) = vA(i, 2)       Next    Next    Application.ScreenUpdating = False    With rngOld.Offset(1).Resize(dic.Count)       .Value = WorksheetFunction.Transpose(dic.Keys)       .Offset(, 1).Value = WorksheetFunction.Transpose(dic.Items)    End With    Application.ScreenUpdating = True    Set dic = Nothing End Sub
こんにちは。 主様、様子を確認してほしいのは、ファイル名の計算の部分です。 半角スペースも、コロンも、やめてください。 logのフォルダ名が存在するのかも、確認です。 エラーが発生しやすいのですから、on errorの処理も、ひとまず、やめてください なにが起こったのか、わからなくなります
VBAでUSBを扱うこと自体が簡単ではありません。 VBAにはUSBに関する機能が一切ありませんので、Windows APIを使って情報を取得することになります。 そのためにはWindows APIの知識、英文のドキュメントを読める根性、プロ並みのVBAのスキルが必要になります。 数年がかりででも実現したいのであれば、まずMicrosoftからVisual StudioとWDKをダウンロードしてください。すべてはそこからです。
失敗時には例外エラーになるようですね。 例外エラー情報を表す Err オブジェクトを参照しているようですが、もしかしたら例外発生時の挙動を指定していないですか？ 例えば以下のようにしたら対処出来るかと思います。 (「Resume Next」で例外発生時にも続行するように指定し、対象範囲が終わったら「GoTo 0」で例外処理を解除する。) On Error Resume Next objFSO.DeleteFile strDelFile, True If Err.Number = 0 Then msgbox "成功時" Else msgbox "失敗時" End If On Error GoTo 0
下記のコードでいかがでしょうか？アクティブなシートで使われているセル範囲すべてを対象にしています。 Sub Sample() Dim Rng As Range For Each Rng In ActiveSheet.UsedRange If Rng.Errors.Item(xlNumberAsText).Value = True Then Rng.Errors(xlNumberAsText).Ignore = True End If Next End Sub
ありますよ。 「データバインド」と言う技術です。 「Windowsフォームにおける「データ・バインディング」」 http://www.atmarkit.co.jp/fdotnet/chushin/introwinform_06/introwinf... 「Part 1. 双方向データバインドの基本的な使い方」 https://blogs.msdn.microsoft.com/nakama/2009/02/26/part-1-2/
Excelですよね。 テーブル1とか言うとAccessかと思ってしまいます。 デーブル1をメインで調べるか、デーブル2をメインで調べるかによって2種類になります。 Sub sample() Dim ws1 As Worksheet Dim ws2 As Worksheet Dim ws3 As Worksheet Dim lastRow As Long Dim r1 As Long Dim r3 As Long Dim rng As Range Dim y() As String Dim i As Integer ' Set ws1 = Sheets("テーブル1") Set ws2 = Sheets("テーブル2") Set ws3 = Sheets("テーブル3") ws3.Cells.Clear ws3.Range("A1:D1").Value = Array("ID", "氏名", "Pass", "役職") r3 = 2 lastRow = ws1.Range("A" & Rows.Count).End(xlUp).Row For r1 = 2 To lastRow Set rng = ws2.Range("A:A").Find(ws1.Range("A" & r1).Value, LookAt:=xlWhole) If Not rng Is Nothing Then y = Split(ws2.Range("B" & rng.Row).Value, ",") For i = 0 To UBound(y) If y(i) <> "" Then ws3.Range("A" & r3).Resize(1, 3).Value = ws1.Range("A" & r1).Resize(1, 3).Value ws3.Range("D" & r3).Value = y(i) r3 = r3 + 1 End If Next End If Next End Sub または Sub sample() Dim ws1 As Worksheet Dim ws2 As Worksheet Dim ws3 As Worksheet Dim lastRow As Long Dim r2 As Long Dim r3 As Long Dim rng As Range Dim y() As String Dim i As Integer ' Set ws1 = Sheets("テーブル1") Set ws2 = Sheets("テーブル2") Set ws3 = Sheets("テーブル3") ws3.Cells.Clear ws3.Range("A1:D1").Value = Array("ID", "氏名", "Pass", "役職") r3 = 2 lastRow = ws2.Range("A" & Rows.Count).End(xlUp).Row For r2 = 2 To lastRow y = Split(ws2.Range("B" & r2).Value, ",") For i = 0 To UBound(y) If y(i) <> "" Then Set rng = ws1.Range("A:A").Find(ws1.Range("A" & r2).Value, LookAt:=xlWhole) If Not rng Is Nothing Then ws3.Range("A" & r3).Resize(1, 3).Value = ws1.Range("A" & rng.Row).Resize(1, 3).Value ws3.Range("D" & r3).Value = y(i) r3 = r3 + 1 End If End If Next Next End Sub
拡張子auxという補助ファイルを削除して、再度処理をしてみてください。
スポンボタン の TabStop を False にすればフォーカス移動の対象から外れます。 マウスでの操作は出来ます。
がぞうあり。。。。。
> “山田太郎”を”山○太○”に変換したい だけで良ければ、雰囲気標準モジュールに以下を記述すれば･･･ Public Function Samp1(vSrc As Variant) As String    Static sS As String    Dim i As Long    Const CL As Long = 4    If (Not IsNull(vSrc)) Then sS = vSrc    If (Len(sS) < CL) Then       sS = sS & String(CL - Len(sS), "み")    End If    For i = 2 To Len(sS) Step 2       Mid(sS, i, 1) = "○"    Next    Samp1 = sS End Function Public Sub test()    Debug.Print Samp1("山田太郎")    Debug.Print Samp1(Null)    Debug.Print Samp1("田太郎")    Debug.Print Samp1(Null)    Debug.Print Samp1("太郎") End Sub クエリからは SELECT 氏名, Samp1(氏名) AS 変換後 FROM テーブル; で表示できると思います > 顧客情報管理の関係で なら、部分的に変更するだけで良いのかわかりませんが･･･ 上記では、余計な処理として Null なら直前で処理したものを使って、 ４文字未満なら "み" を追加して最低４文字にしてから･･･ > 文字列でなく数値データである場合 何が望む形かわかりませんが、 数値を文字列にして、 必要桁数になるように、左側に "0" とか付加して For i = Len(sS) To 1 Step -2 とかで処理すれば･･･???
疑問 ０になるまで 集計するのでが 目的ですか なぜ わざわざ シートで計算するのですか？ コードで ０になるまで マクロ上で 計算して その時の行をＮｏを 出すとかでは ダメなのですか？
範囲の中でカウントしたものから、空白セルの個数と特定の文字が含まれているセルの個数を引けばいい。
名前で指定する時は ActiveSheet.Shapes(”図１”).Select となりますが、インデックス番号で選択するなら、 ActiveSheet.Shapes(1).Select というやりかたでしょうか。 ただし、この方法は、図形を削除したり追加したりすると番号がずれますから名前で指定する方法をお勧めします。
シートを対象とする場合はWorksheet.ExportAsFixedFormat メソッドを使います。 https://msdn.microsoft.com/ja-jp/library/microsoft.office.tools.exc... ブックを対象とする場合はWorkbook.ExportAsFixedFormat メソッドを使います。 https://msdn.microsoft.com/ja-jp/library/office/ff198122.aspx
下記のコードでいかがでしょうか。 レイアウトの微調整は適宜修正をお願いします。 Option Explicit Dim cMax As Long Private Sub UserForm_Initialize() Dim c As Long cMax = Cells(1, Columns.Count).End(xlToLeft).Column '開始コンボボックスの初期設定 ComboBox1.Clear For c = 1 To cMax ComboBox1.AddItem Cells(1, c).Value Next c End Sub Private Sub ComboBox1_Change() Dim c As Long '終了コンボボックスの初期設定 ComboBox2.Clear If ComboBox1.ListIndex = -1 Then Exit Sub For c = ComboBox1.ListIndex + 1 To cMax ComboBox2.AddItem Cells(1, c).Value Next c End Sub Private Sub ComboBox2_Change() If ComboBox2.ListIndex = -1 Then Exit Sub '既存のグラフを一旦削除する Dim ct As Object For Each ct In Worksheets(1).ChartObjects ct.Delete Next 'グラフを挿入する Dim c1 As Long, c2 As Long c1 = ComboBox1.ListIndex + 1 c2 = ComboBox1.ListIndex + ComboBox2.ListIndex + 1 ActiveSheet.Shapes.AddChart2(297, xlColumnStacked).Select With ActiveChart .SetSourceData Source:=Range(Cells(1, c1), Cells(5, c2)) '横軸の調整を行う .FullSeriesCollection(1).Delete .FullSeriesCollection(1).XValues = "=Sheet1!" & Range(Cells(1, c1), Cells(1, c2)).Address '行の上下関係と積み上げ順が一致するようにデータ系列を調整する Dim i As Integer For i = 1 To 4 .FullSeriesCollection(i).Name = "=""データ" & 5 - i & """" .FullSeriesCollection(i).Values = "Sheet1!" & Range(Cells(6 - i, c1), Cells(6 - i, c2)).Address Next i '凡例の位置を調整する .HasLegend = True .Legend.Position = xlCorner .Legend.IncludeInLayout = False 'グラフタイトルを設定する .ChartTitle.Text = Me.Caption 'グラフの位置を調整する ActiveSheet.Shapes(1).Left = Cells(7, c1).Left ActiveSheet.Shapes(1).Top = Cells(7, c1).Top End With Range(Cells(1, c1), Cells(5, c2)).Select End Sub
C3セルに半角小文字のaが含まれているときに3行目の背景色を赤にする例です。 If Range("C3").Value Like "*a*" Then Rows(3).Interior.Color = RGB(255, 0, 0) End If 文字色を変更する場合は「Interior.Color」を「Font.Color」にします。
B列のユニークなデータをZ列に出そうとしている .AdvancedFilter Action:=xlFilterCopy, _ CopyToRange:=Sh.Range("Z1"), Unique:=True は With Sh.Range("B1", Sh.Cells(Rows.Count, 4).End(xlUp)) の範囲なので、B列のユニークデータではなく、B1からD列最終行までのユニークな組み合わせになっています。 なので .AdvancedFilter Action:=xlFilterCopy, _ CopyToRange:=Sh.Range("Z1"), Unique:=True を Sh.Range("B1", Sh.Cells(Rows.Count, 2).End(xlUp)).AdvancedFilter Action:=xlFilterCopy, _ CopyToRange:=Sh.Range("Z1"), Unique:=True で試してみてください。 また、 Sh.Cells(Rows.Count, 4).End(xlUp) では、D列の最終行になるので、D列にデータが無い場合には、B列にデータがあっても対象外になります。 なので、必ずD列もデータがある場合は別ですが、 With Sh.Range("B1", Sh.Cells(Rows.Count, 4).End(xlUp)) ではなく、 With Sh.Range("B1", "D" & Sh.Cells(Rows.Count, 2).End(xlUp).Row) などの方がいいかもしれません。 こうしていると、 lastRow = sh.Range("B" & Rows.Count).End(xlUp).Row 'B列最終行 としてB列最終行を変数に持つ方がプログラムが見えやすくなるかもしれません。 それと別解ですが、Dictionaryオブジェクトを使ってB列でユニークに印刷する例です。 Sub フィルタ印刷() Dim dic As Object Dim sh As Worksheet Dim lastRow As Long Dim r As Long Dim kwd As String ' Set dic = CreateObject("Scripting.Dictionary") Set sh = Worksheets("Sheet1") If sh.FilterMode Then sh.Range("A1").AutoFilter lastRow = sh.Range("B" & Rows.Count).End(xlUp).Row 'B列最終行 For r = 2 To lastRow kwd = sh.Range("B" & r).Value 'B列のデータ If Not dic.exists(kwd) Then 'B列のデータが辞書に無ければ dic.Add kwd, "" '辞書に登録 sh.Range("B1:B" & lastRow).AutoFilter Field:=1, Criteria1:=kwd sh.PrintOut Preview:=True End If Next If sh.FilterMode Then sh.Range("A1").AutoFilter MsgBox "印刷完了", vbInformation Set sh = Nothing End Sub
Sub 一例です() Dim i As Long, rng As Range With Worksheets("Sheet2") i = -2 For Each rng In .Range("A1", .Cells(Rows.Count, 1).End(xlUp)) i = i + 4 rng.Copy Worksheets("Sheet1").Cells(i, 1).Resize(4) Next rng End With End Sub
VB.NET の正規表現で判断したらどうでしょうか？ 参考サイト http://dobon.net/vb/dotnet/string/regex.html#section3 If System.Text.RegularExpressions.Regex.IsMatch( _ TextBox1.Text, "\d\d\d\d/\d\d/\d\d") Then Console.WriteLine("日付けが含まれています") End If
同じ入れ物に最大で２５個入れられるって事ですかね。 また、２５個にならないものは、２５までにしてグループを作るんでか？
プルダウンというのは入力規則の事ですね。 この前と同じ方法でできます。 シートの名前が「山田」や「渡辺」になっているのですね。 選択するセルをA1とします。 違うセルなら、下記コードの If Target.Address <> "$A$1" ここを変更するだけです。 前回でおわかりと思いますが$の位置に気をつけて下さい。$A1$にしないように。 Private Sub Worksheet_Change(ByVal Target As Range) On Error GoTo Err If Target.Count > 1 Then Exit Sub If Target.Address <> "$A$1" Or Target.Value = "" Then Exit Sub Worksheets(Target.Value).Select Exit Sub Err: MsgBox "シートがありません" End Sub
そこには ＞彼を呼び出すにはOffice 2003が必要です(カイル君が搭載されている過去のバージョンであれば2003以外でも大丈夫だと思いますが、私の方では試していません)。 もっと言うならば、彼の実体である「DOLPHIN.ACS」ファイルが必要となります。 と書かれています・・・
下記のコードでいかがでしょうか？ ワークシート関数のMatchを使えばシンプルになります。 Option Explicit Sub Sample() Dim st1 As Worksheet, st2 As Worksheet Dim r1 As Long, r2 As Variant Set st1 = Workbooks("ファイル①.xlsm").Worksheets("シートA") Set st2 = Workbooks("ファイル②.xlsx").Worksheets("シートB") r1 = 10 'シートAのA10から3行おきに空欄になるまで繰り返す While st1.Range("A" & r1).Value <> "" 'シートBのA列に一致する値があるか検索する r2 = Application.Match(st1.Range("A" & r1).Value, st2.Columns("A"), 0) If VarType(r2) <> vbError Then '一致した値があったらその２行下にAK列の値を転記する st2.Range("E" & r2 + 2).Value = st1.Range("AK" & r1 + 2).Value End If r1 = r1 + 3 Wend End Sub
「href="/logout"」となっているのですから、 myIE.Navigate "ドメイン名/logout" とすれば良いのではないでしょうか。
過去に一度ハマったことがありますが、確かExcel経由だと回避できなかったよ記憶が・・・ パスワードを事前に解除したうえで作業を実行するという方向で諦めるほうが良いかと思います。というかそういう手順書で他の方にも利用して頂いていました。
Workbooks.Open ThisWorkbook.Path & "￥D" & f.Cells(i, 5) 上記だと、フォルダＤにある「知恵袋.xls」を開こうとしても Workbooks.Open ThisWorkbook.Path & "￥D\知恵袋.xls" とはならず Workbooks.Open ThisWorkbook.Path & "￥D知恵袋.xls" となりませんか？ 「Ｄフォルダ」内にある「知恵袋.xls」ではなく 「Ｄ知恵袋.xls」というファイルを開こうとすると思います。 f.Cells(i, 5) のセルにはファイル名称はどのようになって書き込まれてますか？
下記のコードでいかがでしょうか。 Option Explicit Private Sub ComboBox1_Change() Dim c As Variant, r As Long If ComboBox1.ListIndex = -1 Then Exit Sub With ComboBox2 .Clear c = Application.Match(ComboBox1.Text, Rows(1), 0) If IsNumeric(c) Then For r = 2 To Cells(Rows.Count, c).End(xlUp).Row .AddItem Cells(r, c).Value Next End If End With End Sub Private Sub UserForm_Initialize() Dim rng As Range For Each rng In Range("D1:S1").Cells ComboBox1.AddItem rng.Value Next End Sub
アクティブなブックのシートを新規ブックに振り分けるプログラム例です。 Sub sample() Dim xDic, sh As Worksheet, xName As String Set xDic = CreateObject("Scripting.Dictionary") For Each sh In ActiveWorkbook.Worksheets xName = Split(sh.Name, "-")(0) If Not xDic.Exists(xName) Then sh.Copy xDic.Add xName, ActiveWorkbook.Name Else With Workbooks(xDic.Item(xName)).Worksheets sh.Copy after:=.Item(.Count) End With End If Next sh End Sub
こんな感じで OK かと。・・・・・・・・・・・・・・・・・ Private Sub CommandButton1_Click() Worksheets("管理表").Select Range("A3").Value = TextBox1.Text End Sub
データーの表の作り方が まずいのでは 普通は シート１：元データ A列 B列 C列 D列 日付----会社名―顧客№―数量 2016/5-ーA社 2016/5---B社 2016/6--A社 こうしておけば 顧客Ｎoで フィルターを掛ければ 各月のデーターが出ますが? あるいは 詳細設定で 検索条件範囲を設定すれば 期間設定もできますが? 只 元データーと 支払額 請求金額との 関連がわかりませんが
>アプリっぽく見せる為 どういう狙いなのか今一つ解りませんが、 アドインプログラムとしてマクロ開発すると、良いのかもしれません。
漢字の文字コードにはシフトJIS、Unicode、UTF-8といろいろな種類があり、どの文字コードを使うかはプログラムで指定できます。 プログラムをどんな開発環境で作っているのかわかりませんが、開発環境でサポートしている文字コードが異なるのでご注意ください。 ExcelならシフトJISは問題なく使えますし、 Visual Basciであれば文字コード変換のクラス・メソッドが用意されているので、これも問題ありません。
=(数式=FALSE) って普通は =not(数式) って書きます。 私も似たようなユーザー定義関数を使ってますが、ちゃんと動作しますよ。違いは、Application.Volatile を宣言して確実に再計算しているところと、返り値を文字列にしてないところかな。空文字列が返ってきたらisblankはFALSEに決まってますからね。
マクロでなく、関数で実現できませんか？ B列：顧客IDを入力する C列：顧客情報が出力される D列：顧客ID群 E列：顧客情報群 として、C列に =IF(B1="", "", VLOOKUP(B1,D:E,2,FALSE)) と入力すればできそうに思えます。
下記のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim st1 As Worksheet, st2 As Worksheet Dim r1 As Long, r2 As Long Dim rng As Range Set st1 = Worksheets("Sheet1") Set st2 = Worksheets("Finish") 'Sheet1の3行目から最終行までを処理する For r1 = 3 To st1.Range("B" & Rows.Count).End(xlUp).Row 'A列に1が入っているか判定する If st1.Range("A" & r1).Value = "1" Then 'Finishシートへの貼り付け位置を取得する r2 = st2.Range("A" & Rows.Count).End(xlUp).Offset(1).Row 'Finishシートへ貼り付ける st1.Range("A" & r1).Resize(, 4).Copy st2.Range("A" & r2) 'Unionを使って削除する行を記録しておく If rng Is Nothing Then Set rng = st1.Rows(r1) Else Set rng = Union(rng, st1.Rows(r1)) End If End If Next r1 '削除対象行があれば削除する If Not rng Is Nothing Then rng.Delete End If End Sub
DataTableをシリアライズして送るとか http://dobon.net/vb/dotnet/file/xmlserializer.html
Range("B2").Value = Range("A1").Value & vbLf & Range("A2").Value これでどうですか。
業務用とかPAとかのパワーアンプに直結するようなかたちでも出ますよ。 楽器をPA機材なりに直接つないで演奏ってのはよくあることだと思います。 っても、特定の機材（特にギターアンプ）の音色を大事にしない場合かとは思いますが； 「ギター用」と考えられる物はやはりギター用機材メーカーが出してる製品でしょうが、 やはり「ギター用」なんで業務用やPA用に比べればW数も小さい物で（５０～１００Wくらい）、キャビネット部の耐圧より小さい物で選んでいくことになります。業務用とかでもその選び方なら安全とはいえますが、問題は業務用機器では「オーディオ」ですので、一般的な楽器に使われるフォーンプラグでの接続に対応していない物が多いです。自作ケーブルなどで対応したりということになるでしょう。 あとギター用なら真空管使用の製品が多くなります（トランジスタも多いですけど）。また「EQ」というほどでもないですが、超低域と超高域を調整できるようになってたり、というものが付いてたりする物もあります。 要するに「ギター用」は、ギターサウンドのためのどこかこだわりの部分が調整できたり、そのための部品を使ってたり、「楽器」としての仕様に作られているわけです。 ギター用でなくても極度にGT-10の音色を阻害する、ということは無いと思います。 もし業務用などをつかわれるのであれば、以上の点を充分吟味したうえで使用されることを勧めます。
> 他の方の質問を見ていて、 > 的確な説明をしていらしたので… それって私(glowfiltan)のことですか？ そもそも私は JavaScript や ActionScript 系が専門で VBS など VB系 の質問には答えられないことが多いですよ。 (他の方の回答が素早く的確なことが多いため私の出る幕などナシ。) (そもそもが遅筆であるため，人口が多いVB系では回答できない。) 今回のご質問に近いご質問と言うと， このご質問↓などでしょうか？？ 「二つのフォルダ内ファイルを比較して、不一致のファイル名...」 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1016105250... 良くわかりませんが， 「C:\Data」というフォルダの直下(直下のみ)に 色々な拡張子のファイルがあったとして その中の「～～.jpg」または「～～.JPG」を 「～～.tif」というファイル名に変更するコード例です↓。 '------------------------------------ 'ファイルシステムオブジェクトを作成 Set FSObj = CreateObject("Scripting.FileSystemObject") 'C:\Data フォルダオブジェクトを取得 Set FldObj = FSObj.GetFolder("C:\Data") 'フォルダオブジェクトのFilesからFile名を取得 For Each FilObj In FldObj.Files     'File名を一時保存     FN = FilObj.Name     'File名の後4文字を小文字にした文字列が「.jpg」であれば     If LCase(Right(FN, 4)) = ".jpg" Then         'File名の拡張子を「.tif」に変更         FilObj.Name = Left(FN,Len(FN)-4) & ".tif"     End If Next '各オブジェクトの解放 Set FldObj = Nothing Set FSObj = Nothing '------------------------------------ なお， わかっていらっしゃると思いますが，，， 上のコードはあくまでも 「拡張子を変更するだけ！」のコードですよ。 つまり， 「.jpg」形式のデータファイルを 「.tif」形式のデータファイルに変更するわけではありません。 たまに， 「拡張子を変更すれば，ファイル形式も変更される。」 と思っていらっしゃる方も見かける(私の職場の課内に２人もいた！) ので，念のための確認です。 ※なお    私の職場の同課には    Excel 2007 で作成した「.xlsx」ファイルの拡張子を    エクスプローラで「.xls」に変えるだけで    Excel 2003 完全対応のファイルになる    と思っていた人が２人もいました(愕然...)。 データ形式を TIFF に変換するのでしたら 例えば Photoshop などの画像処理ソフトを使って 「バッチ処理」などでファイル形式変換をした方が良いと思います。
空の文字列をSplitで処理しようとしたためにエラーとなっています。つまり、TITLEタグを持っていないか、表示完了にならないうちにTITLEタグを取りにいったということになります。 全てのページに確実にTITLEタグがあるのならば、表示終了処理が不十分だったということでしょう。適当な時間、ウエイト処理を追加してください。
まずおっしゃる通り、起動スピードが落ちる可能性が有ります。 最も困るのは、他の端末に持って行ったときに選んだライブラリが無い、ヴァージョンが違うなどが有った時、エラーが出るまで時間がかかるし、出ても利用者は対処できない。と言う本末転倒な問題が有るからです。 ちなみに「初期設定ですべて参照可能にして」ありますよ？EXCELが入っていれば必ず利用できる環境にはチェック入ってるでしょ、
シートの様式がわかりませんので、とりあえず、A1にハイパーリンク設定されている先(URL)をB1に書き出す記述です。 Sub Test() Range("B1").Value = Range("A1").Hyperlinks(1).Address End Sub
こんにちは。 set v1 = nothing set v1 = .Document.all.tags("input").Item(5) if v1 is nothing then else ここでクリック end if ということです
過去QAでは解決しませんでしたか 教えて下さい。 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1116102810... 以下の記述では、 Kシート：Sheet2 mシート：Sheet1 としています 新規ファイルの標準モジュールに以下全部記述し、 Sheet1 / Sheet2 があることを確認の後 testData でデータを作り Samp5 を実行してみます ※ 変更部分は、さほどありません Public Sub Samp5()    Dim rng As Range, rf As Range, r As Range    Dim iC As Long, i As Long    Const CCR As Long = 36    Const CKRNGS As String = "H1,Y1,J1,R1,S1,T1,U1"    Const CMRNGS As String = "E1,F1,G1,H1,I1,K1,L1"    Set rng = Worksheets("Sheet2").Columns("B") ' Kシート★    Set r = Worksheets("Sheet1").Range("A3") ' mシート★    Application.ScreenUpdating = False    While (r.Value <> "")       With rng          Set rf = .Find(r.Value, .Cells(5), LookAt:=xlWhole)          If (rf Is Nothing) Then Set rf = .Cells(5)       End With       With r.Offset(, 1 - r.Column)          iC = xlNone          If (rf.Row < 6) Then             If (.Range("E1").Value <> "") Then iC = CCR          Else             Set rf = rf.Offset(, 1 - rf.Column).Range(CKRNGS)             With .Range(CMRNGS)                For i = 1 To rf.Areas.Count                   rf.Areas(i).Value = .Areas(i).Value                Next             End With          End If          .Interior.ColorIndex = iC       End With       Set r = r.Offset(1)    Wend    Application.ScreenUpdating = True End Sub ' 確認用簡易データ作成 Public Sub testData()    Dim r As Range    Const CRH As Long = 35    Randomize    Application.ScreenUpdating = False    Worksheets("Sheet1").Cells.Delete    With Worksheets("Sheet2")       .Cells.Delete       For Each r In .Range("B1").Resize(CRH)          If (Rnd() < 0.75) Then             r.Value = r.Row          End If       Next       .Columns("B").Copy Worksheets("Sheet1").Columns("B")    End With    With Worksheets("Sheet1")       For Each r In .Range("A1:Z1").Resize(CRH)          Select Case r.Column             Case .Range("A1").Column                r.Value = r.Row             Case .Range("B1").Column             Case Else                r.Value = r.Address(False, False)          End Select       Next       .Columns.AutoFit       Worksheets("Sheet2").Cells.ColumnWidth = _          .Cells(3).ColumnWidth    End With    Application.ScreenUpdating = True End Sub
Rows("〇：" & Range("A1").Value).Hidden=True これでいかがですか。
こんにちは。 '検索語入力 SearchKey = Me.TextNumber.value ということです。
一例です。 Option Explicit Sub Sample() Dim st1 As Worksheet, st2 As Worksheet Dim r1 As Long Set st1 = Worksheets("Sheet1") Set st2 = Worksheets("Sheet2") For r1 = 1 To st1.Range("A" & Rows.Count).End(xlUp).Row With st1.Range("A" & r1) If VarType(Application.Match(.Value, st2.Columns("A"), 0)) = vbError Then st2.Range("A" & st2.Range("A" & st2.Rows.Count).End(xlUp).Offset(1).Row).Value = _ .Value End If End With Next End Sub
クライアント・サーバー通信では、 サーバーはクライアントの接続があるまで待機します。 そのために、TcpListenerというクラスが用意されています。 Dim server = New TcpListener(new IPEndPoint(IPAddress.Parse("0.0.0.0"), 1001)) server.Start() Dim client = server.AcceptTcpClient() server.Stop() 'ストリームを取得 AcceptTcpClient()は、受信するまで 待機し続けることに注意してください。
リソースはどのような手順でプロジェクトに追加したのでしょうか？ VB.Netのプロジェクトにリソースを追加する方法は幾通りかあって、その方法によってリソースの取り出し方に差異があります。
A列を最終行まで検索して、該当するシート名のシートのB1に○を入れるコードです。 Option Explicit Sub Sample() Dim r1 As Long Dim st As Worksheet For r1 = 1 To Worksheets("Sheet1").Range("A" & Worksheets("Sheet1").Rows.Count).End(xlUp).Row For Each st In Worksheets If st.Name = Worksheets("Sheet1").Range("A" & r1).Value Then st.Range("B1").Value = "○" End If Next st Next r1 End Sub
Sub 一例です() Dim xFld0 As String, rng As Range, xAdr As String Const cFld1 As String = "\書類格納フォルダ\@1\@2\@3.pdf" xFld0 = CreateObject("WScript.Shell").SpecialFolders("Desktop") & cFld1 For Each rng In Range("B2:F6") With rng If .Value <> "" Then xAdr = Replace(Replace(xFld0, "@1", Cells(.Row, 1).Value), "@2", Cells(1, .Column).Value) xAdr = Replace(xAdr, "@3", .Value) .Parent.Hyperlinks.Add Anchor:=.Cells, Address:=xAdr, TextToDisplay:=.Value End If End With Next rng End Sub
Sheet2にフォームを作るのは理由があるのでしょうか。不必要です。下記紹介しますが、フォームはブックどこからでも呼び出せるもので単シート上限定ではありません。 画像参照で、フォームを作成します。Alt+F11などで開くVBエディターの左にあると思われるブックやシートリスト上で右クリックし、挿入、ユーザーフォームとします。 ラベルで文字を追加、ほか、アルファベットで書いてる通りtextbox２つとcomboboxとCommandButton2つを追加し、CommandButton1のcaptionを「個体」、同じく2を「OK」としました。 「プロジェクト～」の下にある小さなボタンでフォームの「コードを表示」して下記コードをコピペ。 Dim r As Long'変数宣言。ここに書くことでフォームが開いていれば値を渡せる Private Sub CommandButton1_Click()'個体番号検索ボタン If Not IsError(Application.WorksheetFunction.Match(TextBox1.Value, Range("A:A"), 0)) Then'マッチ関数でヒットしないとエラーを起こすので点検 r = Application.WorksheetFunction.Match(TextBox1.Value, Range("A:A"), 0)'マッチした時行番号rを格納 TextBox1.Value = Cells(r, 1).Value ComboBox1.Value = Cells(r, 2).Value TextBox2.Value = Cells(r, 3).Value End If End Sub Private Sub CommandButton2_Click()'シートに写すボタン Cells(r, 1).Value = TextBox1.Value Cells(r, 2).Value = ComboBox1.Value Cells(r, 3).Value = TextBox2.Value'やろうと思えば日付として有効な値かチェックもできるがしていない End Sub Private Sub UserForm_Initialize() '初期設定 ComboBox1.AddItem "飼育中" ComboBox1.AddItem "出荷済" End Sub あとはフォーム表示のコードですが、簡単なところだとダブルクリックイベントとか。 Sheet1のモジュールに Private Sub Worksheet_BeforeDoubleClick(ByVal target As Range, Cancel As Boolean) Cancel = True 'セルの編集に入らない UserForm1.Show End Sub とかです。 あとフォーム作成画面のフォーム上で右クリックするとタブオーダーを開けますので、順番を並べ替えると、tabや状態によってはEnterでフォーカス(入力のカーソルなど)が移る順番を替えられますので試してみてください。 ざーっと作りながら書いてみましたがいかがでしょうか？
レポートのレコード出力順序は何で決定していますか？ レポートの機能「並べ替え/グループ化」を利用しないと想定外の順序で出てくる場合があります。
以下のコードでいかがでしょうか。 シート名は適宜変更して下さい。 Option Explicit Sub Sample() Dim stA As Worksheet, stB As Worksheet Dim rA As Long, rB As Long Set stA = Worksheets("Aシート") Set stB = Worksheets("Bシート") For rA = 1 To stA.Range("A" & stA.Rows.Count).End(xlUp).Row rB = 0 On Error Resume Next rB = WorksheetFunction.Match(stA.Range("A" & rA), stB.Columns("A"), False) On Error GoTo 0 If rB <> 0 Then stB.Cells(rB, stB.Columns.Count).End(xlToLeft).Offset(, 1).Value = stA.Range("B" & rA).Value End If Next End Sub
１～９９９にするのに何かの変数に１を足し続けているはずです。その時９９９をチェックすればいいんだから、 もしその変数がintNOと言う変数であれば If intNO = 999 Then intNO = 1 Else intNO = intNO + 1 End If みたいな感じの処理に書き換えれば良いわけです。
外しているかもしれませんが、 エクセルのオプション「詳細設定」の「桁区切り記号」がドットになっていませんか？
期待された動作になっているか分かりませんが。。。 Private Sub Worksheet_Change(ByVal target As Range) Dim N As Long N = target.Row If Intersect(target, Sheets("伝票").Range("D" & N)) Is Nothing Then Exit Sub Else Range("F" & N) = Range("P" & N) Range("F" & N + 1) = Range("Q" & N) Range("F" & N + 2) = Range("R" & N) End If End Sub > Range("F" & N) = Range("P" & N) > Range("F" & N + 1) = Range("Q" & N) > Range("F" & N + 2) = Range("R" & N) 質問者さんの場合は上記のコードでセルの値を変更しているため、イベントハンドラ内でイベントを発生させるコードになっています。 そのようなコードは動作が複雑になるうえに、指定セルの値を誤って変更しただけでも動作してしまい、作業に混乱を招きやすいです。 ですので、ボタンクリックなどでコードを実行するようなデザインにした方が良いと思います。
シートが10あるとして11目のシートを用意してそのシートに検索したいデータが含まれる行を表示するようにすればよいでしょう。それでよければ回答しますが？
元ファイルを開き、C3セルの日付を追加した名前で保存終了し、保存先にファイルがあることを確認し、元ファイルを削除します。 削除は少々危険なのでコメントアウトしてます。やるなら自己責任でどうぞ。コーディングミスも含め当方は一切責任を取りません。 Sub Sample() File1= "C:\Work\Sample.xls" Folder2= "C:\Work\保存分\" Workbooks.open filename:=File1 File2=left(activeworkbook.name, len(activeworkbook.name)-4) & Range("C3").Value & ".xls" Activeworkbook.saveas filename:=Folder2 & File2 Application.displayalart=False workbooks(File2).close savechanges:=False Application.displayalart=true 'Buf=Dir(Folder2 & File2) 'If Buf<>"" then 'Kill File1 'End if End Sub
こんにちは。 forで取得する順番が必ず、規則性のある順番になっている、という前提がないと、このコードは、正しく動作しません。 If Left(Obj.Name, Len(myTarget)) = myTarget Then は if instr(1 , Obj.name , "Control" ) <> 0 then i = Val(mid(Obj.Name , 9 , 3)) Cells(i, 1) = Obj.Object.Value End If にして、どんなコントロールでも、Controlで始まるものだったら、 転記する、という構造にして、処理してみてください
号室という文字のあとにスペースが1個という規則が前提です。 エラー処理は入れていません。必要であれば返信して下さい。 A列の文字列を置き換えます。 Sub Sample() Dim i As Long Dim tmp As String For i = 1 To Cells(Rows.Count, "A").End(xlUp).Row tmp = Range("A" & i).Value Range("A" & i).Value = Left(tmp, InStr(tmp, "号室") - 1) & Mid(tmp, InStr(tmp, "号室") + 3, 1) Next i End Sub
こんにちは。 すみません、HTAなんですから、 https://gallery.technet.microsoft.com/scriptcenter/311db492-eadd-4e... の記事にあるような、プログレスバーのオブジェクトをつかったらどうなるのか、 試してみてください。 htmlドキュメントの部分で、プログレス、ということだと、イベント処理を正しくしないと、全然描画してくれませんし。
Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Excel.Range, Cancel As Boolean) ↓ Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Excel.Range, Cancel As Boolean) Dim xRng As Range On Error Resume Next Set xRng = Intersect(Target, Range("F:S,AA:AN")) On Error GoTo 0 If xRng Is Nothing Then Exit Sub
設定→ディスプレイ→ディスプレイのカスタマイズでサイズを100%に下げてから実行してみては？
「入力」シートに入力されている最下行のF列のデータ は Worksheets("入力").Range("F" & Rows.Count).End(xlUp).Value で取得できます。 「データ」シートの、アクティブセルのある行の、B列 は Worksheets("データ").Activate Range("B" & ActiveCell.Row) になります。 そのセルにデータを設定するわけですから、 Worksheets("データ").Activate Range("B" & ActiveCell.Row).Value = Worksheets("入力").Range("F" & Rows.Count).End(xlUp).Value となります。
右に移動したらという事なので 行の説明は 省きます。 C = Cells(1, Columns.Count).End(xlToLeft).Columnで 最終の列数を求めています。 For J = 1 To C Step 2 列が１列（つまりA列から最終列まで ２列おきにという意味です・ If Cells(I, J + 1) = "ok" Then で CELLS(I,J+1) で CELLS(I,2)="OK" ならば Cells(I, J).Select CELLS(I,1)を選択し Selection.Font.ColorIndex = 3 赤で 塗りつぶしなさい という事です。 全体を 右にずらしたなら For J = 1 To C Step 2 Ｊが １列目からではなく ずらした位置の 列数をいれれば 良いと思います。
マクロの記録で作ってみる。 Range("A1").Select Selection.Cut Range("A2").Select ActiveSheet.Paste ActiveCell.FormulaR1C1 = ActiveCell.Value & "様"
型の違う値を配列に入れる方法は一度やったことがあります。 http://officetanaka.net/excel/vba/variable/12.htm あとはやりたいことが理解しかねましたので、失礼します。
記述が変わってしまいますが良いですか？ 以下を標準モジュールに記述して Samp1 を実行してみます 項目シート内の記述順は、条件一致させるものを左側に偏らせて、 条件一致の項目数は >   Const CFCNT As Long = 3 で変更できます 項目シートに記述したものは、他のシート両方にある･･･ なお、処理する行範囲は A 列で求めてました Option Explicit Private Const CSEP As String = " " Public Sub Samp1()    Dim dic As Object    Dim ws As Worksheet, rng As Range    Dim sKou As String, sRngM As String, sRngS As String    Dim sS As String    Dim i As Long, j As Long, k As Long, n As String    Const CFCNT As Long = 3    sKou = GetKou("項目")    sRngM = GetPos("期限管理", sKou)    sRngS = GetPos("システム更新データ", sKou)    If ((Len(sRngM) = 0) Or (Len(sRngS) = 0)) Then Exit Sub    Set dic = CreateObject("Scripting.Dictionary")    Set ws = Worksheets("期限管理")    With ws       With .Range("A1", .Cells(Rows.Count, "A").End(xlUp))          For i = 2 To .Rows.Count             With .Cells(i).Range(sRngM)                sS = ""                For j = 1 To CFCNT                   sS = sS & .Areas(j).Value & CSEP                Next                dic(sS) = i             End With          Next       End With    End With    Application.ScreenUpdating = False    With Worksheets("システム更新データ")       With .Range("A1", .Cells(Rows.Count, "A").End(xlUp))          For i = 2 To .Rows.Count             With .Cells(i).Range(sRngS)                sS = ""                For j = 1 To CFCNT                   sS = sS & .Areas(j).Value & CSEP                Next                If (dic.Exists(sS)) Then                   n = dic(sS)                   k = CFCNT + 1                Else                   n = dic.Count + 2                   dic(sS) = n                   k = 1                End If                Set rng = ws.Cells(n, "A").Range(sRngM)                For j = k To rng.Areas.Count                   rng.Areas(j).Value = .Areas(j).Value                Next             End With          Next       End With    End With    Application.ScreenUpdating = True    Set dic = Nothing End Sub Private Function GetKou(sName As String) As String    Dim sR As String, sS As String    Dim i As Long, j As Long    sR = ""    With Worksheets(sName)       j = .Cells(1, Columns.Count).End(xlToLeft).Column       For i = 1 To j          sS = Trim(.Cells(1, i).Value)          If (Len(sS) > 0) Then sR = sR & CSEP & sS       Next       sR = sR & CSEP    End With    GetKou = sR End Function Private Function GetPos(sName As String, ByVal sKou As String) As String    Dim sS As String    Dim i As Long, j As Long    With Worksheets(sName)       j = .Cells(1, Columns.Count).End(xlToLeft).Column       For i = 1 To j          sS = Trim(.Cells(1, i).Value)          If (Len(sS) > 0) Then             sS = CSEP & sS & CSEP             sKou = Replace(sKou, sS _                , CSEP & .Cells(1, i).Address(False, False) & CSEP)          End If       Next    End With    If (Not sKou Like "*[! 0-9A-Z]*") Then       GetPos = Replace(Trim(sKou), CSEP, ",")    End If End Function
[TCP/IPのIPアドレスとポートについて] ソケット通信と呼ばれる通信は、主にTCP/IPと言うプロトコル（通信の規約）を使った通信です。 これは、クライアントからサーバーに接続して通信します。 すなわち、クライアント用プログラムで、サーバーのIPアドレスとポートを指定して接続して通信します。 すなわち、クライアントののIPアドレスとポートは、不要です。 IPアドレスは、接続相手のマシン（サーバー機）を指定するアドレス（住所）です。 しかし、サーバー機用のマシン（パソコン、又は、ワークステーション）を特定しても、サーバー機用マシン内には、複数のプログラムが存在するので、どのプログラムに接続するのか指定する必要があります。 それが、ポートです。 飛行機が、飛行場内のエアポートで離着陸しますが、そのポートと同じ意味です。 船が、港のポートにつけますが、そのポートと同じ意味です。 サーバー機用マシン内のどの通信用プログラムと接続するのか、それを指定するのがポートです。 [回答本編] サーバ側(IP:192.168.1.10、ポート：1001)だけ必要です。 よって、 client.Connect("localhost", 80) をサーバーのIPアドレスとポート番号を指定して、 client.Connect("192.168.1.10", 1001) とします。 サーバー用プログラムでも、クライアント用プログラムでも、上記の指定をします。 クライアント用プログラムでの指定は、接続するサーバーの指定です。 サーバー用プログラムでの指定は、クライアントが自身（サーバー）を特定するための指定です。 よって、サーバー用プログラムでも、クライアント用プログラムでも、上記のサーバー側の指定をします。
こんにちは。 表示しているwordオブジェクトをgetobjectでアプリを捕捉、 p://www.relief.jp/itnote/archives/word-vba-cursor-position.php にあるような、wordvbaコードを使って、現在のカーソルの位置を確認。 必要だったら、ドキュメントにアンカーを設定しておいて、そこにハイパージャンプ が、一番簡単に処理できそうです。 officeのアプリをsendmessageで扱う、というのが、全然うまく出来る気がしません。
VisualStudioと間違えてませんか？ visual basicはプログラミング言語ですよ
補足要求です。 ・参照元のA14に入力されている内容を、参照先のB5へ【常に】反映させたい。 ・参照先のB5の情報を編集する場合があり B5へ常に反映させるのであれば、B5を編集しても、即A14の内容に反映させるのでしょうか？ それとも何かしらのアクション(ボタンをプッシュ)をしたときだけ、反映させるのでしょうか？
文字列であれば、cdate(range("A2").value)で日付に型変更できると思います。 どうでしょう？
通常は各端末のファイルを取り出していじる、という事は行わない。 配布サーバなどを使って一方的に配布するだけ。
>あるサイトからファイルをダウンロードすると、下記が表示されます。 どのサイトから、どんなファイルをダウンロードして、どのように実行したのか詳細を書かないと、第三者では分かりません。 VBAの話しであれば、ソースを開いて自分でデバッグすれば良いかと思います。 第三者では状況が全く分からないので・・・
表はA1から始まっているものとします。 Sub 一例です() Dim i As Long With Worksheets .Item(1).Copy after:=.Item(.Count) For i = 2 To .Count - 1 With .Item(i) .Range("A2", .Cells(Rows.Count, 1).End(xlUp)).EntireRow.Copy End With .Item(.Count).Cells(Rows.Count, 1).End(xlUp).Offset(1).EntireRow.PasteSpecial Next i End With End Sub
こんにちは。 「出来ますか」と質問されたら、可能かもしれないでしょうけど、 IEのhtmlブラウザーエンジンの仕事を、全部、主様が、設計する、ということでしょうか。 ブラウザーが表示をした、ということは、ドキュメントの持っているjavascriptのスクリプト処理を全部した、ということです。 スクリプトは、ドキュメントにあるものと、srcによって、外部にあるものと、あります。 それらが、全部、読み取ったとして、膨大なスクリプトコードを処理させないと、ドキュメントのタグ構造を全部配置できません。それから、イベントもです。 あとは、サーバーがクライアントの問い合わせします。「あなたはどのブラウザーなのか」という質問をします。そのときに、「xmlhttpです」という意味の返事をするので、「何者？」という挙動をすることだって、可能性十分にあります。 すべてのサイトがそうだ、ということではないのですが、httpの挙動とhttpsの挙動、さらに、セキュリティキーの関係、セッションの概念の問題、など、決まりごとがあるので、うまく出来るきがしません。 極端に言うと、「スクリプトの存在しないページ」だったら、XMLreqで処理できます。
System.Timers.Timerを使えば、 一定間隔でイベントを発生させることができます。 var t = new Timer(1000); t.Elapsed += (s, e) => Console.WriteLine("Done"); t.Start(); Task.Delay(10000).Wait(); t.Stop(); t.Dispose(); C#らしさを求めるなら、Rxライブラリを使えば 以下のようにもできます。 var o = Observable.Interval(new TimeSpan(0, 0, 1)).Subscribe(x => Console.WriteLine("Done : " + x)); Task.Delay(10000).Wait(); o.Dispose();
コード例です。 対象シートのシートモジュールに記述してください。 例ではA1に入力するとB1に反映されます。 Private Sub Worksheet_Change(ByVal Target As Range) If Target.Cells.Count = 1 Then If Not Intersect(Target, Range("A1")) Is Nothing Then If IsNumeric(Target.Value) Then With Range("B1") If Target.Value = "" Then .ClearContents Else If Not IsNumeric(.Value) Then .ClearContents .Value = .Value + Target.Value End If End With End If End If End If End Sub
こんにちは。 再計算の動作は、外部ブックがある対応、 計算式が複雑な場合は、計算される順番を考えて、「計算式を設定して値に定着させる」マクロ処理をすることで、全体の機能を実現、と、 ブックの計算を基本機能でするのか、プログラムでするのか、ということになります。 現在の状況でしたら、再計算が半永久ループになっているという状況だと、計算式を操作させる方式を検討します。 さて、質問の回答ですが、 application.calculateは、再計算の操作であってます。 最初の質問は、雰囲気はわかるのですが、エクセルの再計算とマクロの処理は「同時」ではありません。 マクロの再開、とかのことだと、イベントの処理など、広範囲に確認が必要です
aporioooonさん 書いてみただけ、テストはしていない。 kaisu=1 sum =0 while kaisu > 0 input kaisu sum = sum+kaisu wend print sum end
NuGetにて「LibJpeg.NET-ts」をプロジェクトに インストールしてください。 Jpegには疎いのですが、 以下のコードで目的の形式になるかと思います。 static void Main(string[] args) { var cp = new BitMiracle.LibJpeg.CompressionParameters() { Subsampling = BitMiracle.LibJpeg.Subsampling.HighDetail_4_4_4, YHSamp = 1, YVSamp = 1, CbHSamp = 1, CbVSamp = 1, CrHSamp = 1, CrVSamp = 1, Quality = 100, SmoothingFactor = 0, SimpleProgressive = false, }; new BitMiracle.LibJpeg.JpegHelper().Save(new Bitmap(@"in.jpg"), @"out.jpg", cp); }
テーブル内の文字列“山田太郎”を”山○太○”に変 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1416090232... ここで記述した内容ではわからなかったですか？ 標準モジュールに Public Function Samp1(vSrc As Variant) As String    ・・・    Samp1 = sS End Function と記述していたら、クエリの方では Samp1(氏名) Samp1 部分を XXXX に変更したら Public Function XXXX(vSrc As Variant) As String    ・・・    XXXX = sS End Function クエリの方では XXXX(氏名) この変更の仕方は理解したということで、Samp2 を Public Function Samp2(vSrc As Variant _             , Optional sChg As String = "○") As Variant    Dim sS As String    Dim i As Long    Const CL As Long = 4 ' ★    Samp2 = Null    If (Len(Nz(vSrc)) = 0) Then Exit Function    sS = vSrc    If (Len(sS) < CL) Then ' ★       sS = sS & String(CL - Len(sS), "み") ' ★    End If ' ★    For i = 2 To Len(sS) Step 2       Mid(sS, i, 1) = sChg    Next    Samp2 = sS End Function これを標準モジュールに記述して、クエリの方で Samp2(氏名) と記述すると、偶数文字目を ○ に置き換えます Samp2(フリガナ,"#") と記述すると、偶数文字目を "#" で置き換えます ２番目の引数を省略すると ○ に置き換え 指定すると、その文字で置き換えます ★ 部分は、４文字に満たない時に "み" を追加する処理になってます 不要であれば、行ごと削除してください これでどうなりますか？
①コンボボックスに登録しておく品名をすべて提示していただけますか？ ②登録したデータに簡単な追番をつけたい、とのことですがどのような追番をどこにつけたいのでしょうか？新しく列を追加して1から順に番号を入れる、など具体的に示していただけますか？
for each tmpChk in XXXX if チェックボックスか？ then buf = buf & チェックボックスの名前 end if next A1 = buf みたいな感じで回せばいい ただ、どこに配置したチェックボックスかで書き方も変わるので補足すべし 補足すると誰かが応えてくれる、、かもしれない ＃ユーザーフォーム ＃シートにactiveXのチェックボックス ＃シートにフォームのチェックボックス 一応参考まで http://officetanaka.net/excel/vba/tips/tips44.htm これのbuf","で連結するように変更してそのbuf（最後の","を削って）A1に入れる といい感じかも
回答がついていないのと、ＶＢＡを組むとしても、複雑というかやることが多いので、動作としてできるかどうかだけ回答いたします。 実現可能かどうかというと、可能だと思います。 データはすでに入力されているものを移動させるだけですので。 ただ、工程が多いのと、判断材料がわかりにくい為、組めないです。 やりたいことを一挙に進めようとするよりは、 何回かにわけて、質問をあげるのがよいかと思います。
こんにちは。 scriptcontrol 64bitで、検索すると、64ビットではリリースしない、というようなアナウンスのようで、代替コードありました。 http://www.ka-net.org/office/of32.html にあるように、htmlのコントロールで、urlエンコード処理しましょう。 主様のコード、どの部分だか、わかりますよね。
B1 =IF(A1="","",IF(A1>=80,"A",IF(A1>=70,"B",IF(A1>=60,"C","D")))) 下方向にコピー http://kokoro.kir.jp/excel/if-if.html
こんにちは。 Case elese は Case else です。コンパイルエラーだけでしょうかね。
suryou As String, kingaku As String は前の指摘の通り exitdoを使うという縛りがあるので基本はそのままで ActiveCell.Offset(1, 0).Activate でいいんではないでしょうか 変数やらloopの書き方は（癖や流儀、縛り等）色々あります
１．VBScript の FormatDateTime では環境によって表示される形式が変わる可能性があるので、私は以下のようにしています。 DT = Right("0000" & Year(Now), 4) & Right("00" & Month(Now), 2) & Right("00" & Day(Now), 2) ２．VBScript には Dir 関数は無いので FileSystemObject を使用します。 FileSystemObjectでは、ファイル名のマスクはできないので、ファイル名の一覧を取得し、自分で判断します。 （例） Set FS = CreateObject("Scripting.FileSystemObject") For Each F in FS.GetFolder("C:\TEST").Files If LCase(Right(F.Name, 14)) = "_" & DT & ".xlsx" Then （ここに処理を書きます 例：MsgBox F.Name） End If Next Set FS = Nothing
※Userformを開いたとき Private Sub UserForm_Initialize() '背景色を白に Me.TextBox1.BackColor = RGB(255, 255, 255) End Sub ※Userformに変更が加えられたとき Private Sub TextBox1_Change() With TextBox1 ’あああの文字の時背景赤色 If .Text = "あああ" Then .BackColor = RGB(255, 0, 0) '文字数500バイト以上の時背景青色 ElseIf LenB(.Text) >= 500 Then .BackColor = RGB(0, 0, 255) Else 'あああでもなく、500バイト以上でもないときは背景色白 .BackColor = RGB(255, 255, 255) End If End With End Sub
色々問題あるんだけれど、各行の*の印字回数をAとの比較にして、Aは初期値から1ループ毎に1減らすして0になったら終わりというのが分かりやすい気がする。 10 INPUT "段数は"; DAN 20 A = DAN 30 WHILE A > 0 40 B = 1 50 WHILE B <= A 60 PRINT "*"; 70 B = B + 1 80 WEND 90 PRINT 100 A = A - 1 110 WEND 質問者さんのやり方だともう1つ変数Cを立てないとうまくいかない。 10 INPUT "段数は"; DAN 20 A = 1 25 B = DAN 40 WHILE A <= DAN 50 C = 1 60 WHILE C <= B 70 PRINT "*"; 80 C = C + 1 90 WEND 100 PRINT 110 A = A + 1 120 B = B - 1 130 WEND
４行目をマルチステートメントにすべきでは。 40 if ans=1917 then print "正解":kazu=kazu+1 else print "残念。正解は1917年"
マクロを使用するすべてのワークシートが１番目のであれば ActiveWorkbook.Worksheets("07052016") を ActiveWorkbook.Worksheets(1) とするだけで 他の日でも使用可能となります。
下記のコードでいかがでしょうか。 Imports System.IO Public Class Form1 Private Sub Button1_Click(sender As System.Object, e As System.EventArgs) Handles Button1.Click Dim fPath As String = _ Environment.GetFolderPath(Environment.SpecialFolder.MyPictures) Dim fName As String = Dir(Path.Combine(fPath, "test.*")) Do Until fName = "" Select Case Path.GetExtension(fName).ToLower() 'ファイルの拡張子が下記に該当する場合に画像ファイルを読み込む Case ".bmp", ".jpeg", ".jpg", ".png", ".gif", ".tif", ".tiff" 'FromFileメソッドを使うと表示中の画像ファイルが削除できなくなるので別の方法を取る Dim fs As New FileStream( _ Path.Combine(fPath, fName), _ FileMode.Open, _ FileAccess.Read) PictureBox1.Image = System.Drawing.Image.FromStream(fs) fs.Close() Exit Do End Select fName = Dir() Loop End Sub End Class
ループして監視するしかないかも。 Sub chk() Dim CA As String Do CA = ActiveCell.Address DoEvents If ActiveCell.Address <> CA Then CA = ActiveCell.Address Debug.Print CA End If Loop End Sub
どのようなコードを書いているのか判りませんが、If文のAnd条件で実現できると思うのですが？
少し違うかもしれませんが、以下のサイトに似たようなことが書かれています。 参考になりませんか。 Office TANAKA ： 自動的に画像を切り替える http://officetanaka.net/excel/function/tips/tips14.htm
こんにちは。 最初のマクロの4行の次でいいです。 end subの手前に追加してください Range("C3:J3").copy Destination:=Range("C4:J30") たとえば、4から30行にコピーした場合です。 できあがったら、それぞれの関数を確認してください。 この関数は、1行作成するのは、大変ですが、その行のしたは、セルの行だけが変化しています。 そうでしたら、示したコードでいいんではないかと。
http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1014858978... を参考にしてみて下さい。
Address:="ここにURLの一部を入れています" & Cells(i, 1), _ を Address:=Range("D1") & Cells(i, 1), _ でいけると思います。
特定の文字列から始まる とは たとえばABCで始まる、 ABCあいうえお ABC１２３４５ みたいなことでしょうか？ Sub test() Dim i As Long, j As Long, k As Long: k = 3 Dim sh2 As Worksheet Set sh2 = Sheets("Sheet2") With Sheets("Sheet1") For i = 1 To 2 For j = 2 To .Cells(Rows.Count, 1).End(xlUp).Row If .Cells(j, 1) Like sh2.Cells(1, i) & "*" Then sh2.Cells(k, i) = .Cells(j, 2) k = k + 1 End If Next k = 3 Next End With End Sub オートフィルタを使ってもいいですね。
(xl vba) リストボックスがシートのOLEオブジェであり 該当データをリスト選択している前提で 下記が1列です。 var = Split(ActiveSheet.OLEObjects("ListBox1").Object.Value, " ")(1) MsgBox var ◆ユーザーフォームの場合 var = Split(UserForm1.ListBox1.Value, " ")(1) MsgBox var スペース区切りの2番目を変数 var へ(配列はゼロスタート)
Wordの画像取り込みはShapes.AddPictureを使います。 wdDoc.Shapes.AddPicture "D:\image1.jpeg" （せっかく開いたwdDocに対して取り込みましょうね）
フォントサイズを0.5ずつ変化させるコードです。 Private Sub CommandButton1_Click() Selection.Font.Size = Selection.Font.Size + 0.5 End Sub Private Sub CommandButton2_Click() Selection.Font.Size = Selection.Font.Size - 0.5 End Sub
>iの部分を（10.10）に入れた値が偶数か奇数か判断する >にはどうしたらいいですか？ Private Sub CommandButton1_Click() Dim i As Long i = Cells(10, 10).Value 'J10の値が奇数か偶数かを判定します If (i Mod 2) = 0 Then MsgBox "偶数です" Else MsgBox "奇数です" End If End Sub
date2 はDate型なのに、””という文字型と比較しています。 isNull(date2)とかで、試してみてはどうでしょうか？ VBAは得意ではないので間違ってたらすみません。
VBは全くやってなかったので合ってるかわかりませんし、ケータイからなのでスペルミスがある可能性があるので、もしあった場合、もし間違えていた場合はすいません Private Sub cmdCalc_Click(ByVal sender As Object, _ ByVal e As System.EventArgs) Handles cmdCalc.Click Dim English As Integer =StringToInt32(txt_English.Text) Dim Japanese As Integer =StringToInt32(txt_Japanese.Text) Dim mathemetics As Integer =StringToInt32(txt_Mathematics.Text) Dim average As Integer=Japanese+English+mathemetics/3 If Japanese >=50 || English >= 50 || mathemetics >= 50 Then lbl_Average.Text=average If average >=70 Then lbl_Result.Text="合格" End If Else lbl_Result.Text="不合格" End If End Sub Private Function StringToInt32(String value) Return Integer.Parse(value) End Function
こんにちは。 バナーの場合です。 何も無い空間に Set v1 = ie.document.createelement("table") 'ここに、行のループ Set v2 = v1.insertRow(-1) 'ここに、列のループ Set v3 = v2.Insertcell(-1) Set v6 = ie.document.createelement("A") v6.href = "ハイパージャンプ" v6.Target = "_blank" Set v5 = ie.document.createelement("IMG") v5.src = "イメージソース" v6.appendchild (v5) v3.appendchild (v6) 'これで、ひとつのバナーの設定が、セルに対して行いました。 これを、列の分、行の分をループすると、テーブルができます、 削除は、テーブルのrowsを捕まえて、removeとしたら、そのtrタグを削除できます。 2000年頃に、microsoftがダイナミックhtmlの記事を載せていて、javascriptによるテーブルの生成に、tableタグ、正式には、table bodyなどが無いと、プラウザーによっては表示できません。 insertrowにマイナスの引数だと、最終行に追加する動作のようです。
やってみたら、これで出来ました。 Dim comboc1 As New DataGridViewComboBoxCell comboc1.Items.Add("AAA") comboc1.Items.Add("BBB") comboc1.Items.Add("CCC") comboc1.Value = "AAA" DataGridView1.Rows(0).Cells(0) = comboc1
Dim bb As Workbook Set bb = ActiveWorkbook bb.Close こちらは他に使いまわさないのであれば ActiveWorkbook.Close だけで大丈夫です。 エラーは再現しません。エクセルのバージョンやOSを示してはいかがでしょうか。
VB6のテキストボックスはコントロール配列使ってますか？ 何100個も画面に配置してるならおそらくコントオール配列ですよね？ それなら一層の事、VB.NET側で、もうデザイナ使わずにコードで テキストボックスの配列をNewして、座標指定で配置してやれば どうでしょう？ 例えばVB6でtxtbox(0)～txtbox(11)までの12個が縦３ｘ横４で 画面に配置されてるなら、こんな感じで。 座標とかTextBoxのサイズは調整するとして。 Private txtbox As TextBox() = New TextBox(11) {} Private Sub Form1_Load(sender As Object, e As EventArgs) Handles MyBase.Load For col As Integer = 0 To 3 For row As Integer = 0 To 2 txtbox(row * 4 + col) = New TextBox() Me.Controls.Add(txtbox(row * 4 + col)) txtbox(row * 4 + col).Location = New Point(txtbox(0).Left + (txtbox(0).Width + 10) * col, txtbox(0).Top + (txtbox(0).Height + 5) * row) Next Next End Sub これで画面から dim str as string = txtbox(5).text みたいに使えるよ。
名簿の数だけ繰り返す、ということではないでしょうか。 kazei=Range("B2").Value ↓ kazei=Range("B" & n).Value Range("C2").Value=zei ↓ Range("C" & n).Value=zei このように変更して変数で参照セルが動いていくようにしておき、処理全体をFor～Nextで囲みます。 For n=1 To 4 '処理 Next
ActiveSheet.Paste ↓ ActiveSheet.Range("A1").PasteSpecial Paste:=xlPasteValues
ファンクションキーの割当が変わっているのではないでしょうか？。 vs2010以前とはFキー割当が変わっており、私は設定し直した記憶があります。 下記を参考に設定を確認してみてください。 https://msdn.microsoft.com/ja-jp/library/5zwses53.aspx
まず、CSVファイルはエクセルで開けますが、 エクセル形式とは別物です。 値がカンマ（列）と改行（行）で区切られた データ構造です。 読み取りは以下のようにしましょう。 Dim Lines() As String = File.ReadAllLines("C:\kanri\aaa.csv") Dim Cells()() As String = New String(Lines.Length - 1)() {} For i As Integer = 0 To Lines.Length - 1 Cells(i) = Lines(i).Split(','); Next VBに疎いため、間違っていたらすみません。 パスについてはわかりません。 パス文字列が間違っていないかもう一度ご確認ください。
Sheet1 A列で列挿入 A2 =IF(COUNTIF(Sheet2!A:A,B2),ROW(),"") 下方向にコピー Sheet3 A2 =IFERROR(VLOOKUP(SMALL(Sheet1!$A:$A,ROW(A1)),Sheet1!$A:$D,COLUMN(B1),0),"") 右方向・下方向にコピー
ユーザー名とパスワードをそのまま文字列でコードに書いていたのでは難読化ツールを使っても効果はありません。別ファイルに保存しておくのも手段のひとつですが、そのファイルが外部から簡単に見られてしまうのでは意味がなくなってしまいます。 ごく簡単でいいのであなた独自の暗号を作るのがもっとも簡単です。 例：アルファベットの文字の置き換え nagato → 文字を二つずつずらす → pcicvq
こんにちは。 msの提供する https://support.office.com/ja-jp/article/-accdb-%E3%83%95%E3%82%A1%... の記事の種類になるかと思いますが、 ファイル変換は、単純にファイルを操作によって保存しなおしして、対応できるような作業にはなりません。 パスワードのかかっているmdbというのだと、なおさら、「どのファイルば、どのパスワード」とファイルによって管理していて、それを自動で問い合わせて開く、というのでしたら、意味のあるものになります。 主様は、「パスワードの対策をしている」ということなんですから、機能として実装させないといけない、ということなんですよね。 MSの記事の場合、資産がたくさんあってファイル変換をするか、最初から作るか、まったく変換をしないで使い続けるか、という選択は、ユーザーに決めてもらう、ということなので、「変換」という選択がどうか、というのは、検討の余地があります。 主様が、変換の方針、ということでしたら、ファイルのパスの管理まで含めて、変換処理を設計してください。「ファイルを開く」のヘルプにはパスワードの引数の説明もあるのですが、その確認ということです
If .Cells(i, 5) <> "" Then If .Cells(i, 5) > TimeSerial(9, 0, 0) Then ↓ If .Cells(i, 5) <> "" Then If .Cells(i, 5) > TimeSerial(9, 0, 0) Then If Not (.Cells(i, 2).Value = "土" Or .Cells(i, 2).Value = "日") Then >列を挿入し曜日を入力するマクロを追加しました。 新規列の挿入で列番号がずれる、のは考慮していません。
当方が Sub asd() Dim ad, ac ad = "10/11/12" ad = Replace(ad, "/", "") If IsNumeric(ad) = False Then ac = Split(ad, vbLf) MsgBox ac(0) Else MsgBox ad End If End Sub で検証する限りでは正常に動作しています、 貴方の異常を簡単に再現できるコードを示してください。
「方法 : ホスト プロセスを無効にする」 https://msdn.microsoft.com/ja-jp/library/ms185330(v=vs.80).aspx >記事で紹介されているようなプロパティの[タブ]は表示されず プロパティタブではなく、プロパティ画面の「デバッグ」タブにありますよ。 いちばん下の方。
条件というか書式というか関数というかでいけない？ A列、B列がそれぞれ1行目が始まってるとして =if(or(sheet1!A1="",A1=""),"",if(sheet1!A1=A1,sheet1!b1,"")) をB1に入れて下のほうへドラッグ。
一般的な高速化の手段としては、画面更新の停止と、シート上の関数の再計算の停止と、VBAでのイベントプロシージャの動作停止ですね。 http://thom.hateblo.jp/entry/2015/08/31/063500 ちなみに、マクロの最後には有効に戻して下さいね。あと、デバッグ中の時は途中でプロシージャを停止すると画面更新が停止したままexcelを操作する事になります。と、画面がおかしくなりますの。なので、上記の高速化処理は動作確認が取れたあと、実運用の段階になってから組み込むのがいいでしょう。（まぁ実際に自分でやれば、どういう状態になるか分かります。） あと、今回の例では、繰り返し処理のために、わざわざ最終行の1行下のセルに繰り返しが終わりとなる目印の文字を入れて、対象となるセルをselectして処理しています。 そうではなく、たとえば、最終行の行数をkとかの変数に代入し、RowInsertの値を初期値9として最初に代入しておき、Do while ～ loop で、RowInsertがk以下の間だけループするようにします。それで、分岐処理にて判定し、その結果によりRowInsert = RowInsert +1 か3 にしてやるわけです。これがoffsetの代わりになります。 条件分岐で調べる対象のセルは Cells(RowInsert,17)で指定できます。 こうすれば繰り返し終了目印の文字入力と削除が省略できます。また、selectを使ってActivecellの選択を動かすよりも内部変数の数値を計算により変える方が処理的に速い、はずです。 >Q列の値は”行挿入”もしくは空白です。 挿入処理をするかしないか、という2択でしたら、Select Case よりもIfの方が記述として素直な気がします。まぁそこはそれぞれの人のセンスなのですが。 あ、あと、カテゴリが英語になってますね。通常こういった類の質問は即日回答がつくものですが、別カテゴリの為に人目に付かなかったのでしょう。カテゴリ違いにより違反報告をされると、質問が削除されてライフが減ります。早急に自分でカテゴリ変更をする事をお勧めします。 (直接的なコード回答は避けております。疑問点があり、そういった回答でも良ければ返信ください。コード作成依頼でしたら、これ以上の回答は致しませんので返信不要です。) それでは。
リストアイテムの数がListViewコントロールの枠内に収まらない場合、自動的にスクロールバーが表示されますし、どれかのアイテムが選択されていれば上下カーソルで選択位置を移動できます。 上下移動用のボタンは必要ないのではないでしょうか。 ご質問に対する私の解釈が的外れなのでしょうか。
こんにちは。 variantでいいですけど、問題でも？
下記のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim st1 As Worksheet, st2 As Worksheet Dim c As Long Dim r1 As Long, r2 As Long, nm As String Set st1 = Worksheets("Sheet1") Set st2 = Worksheets("Sheet2") 'Sheet2を一旦クリアする st2.Cells.Clear st2.Range("A1").Value = "品番" st2.Range("B1").Value = "数量" r2 = 2 '列方向はA列から始まって4列ごとに最終列+1列目まで For c = 1 To st1.Range("A2").SpecialCells(xlCellTypeLastCell).Column + 1 Step 4 '行方向は空セルが２行続くまで r1 = 2 Do With st1.Cells(r1, c) '1列目が「品名」のときは2列目の内容を保持しておく If .Value = "品名" Then nm = .Offset(, 1).Value End If '3列目が空白でなく、数値のとき If .Offset(, 2).Value <> "" And IsNumeric(.Offset(, 2).Value) Then 'Sheet2に品番と数量を転記する st2.Range("A" & r2).Value = nm & .Value & .Offset(, 1).Value st2.Range("B" & r2).Value = .Offset(, 2).Value r2 = r2 + 1 End If End With r1 = r1 + 1 Loop Until st1.Cells(r1, c).Value = "" And st1.Cells(r1 + 1, c).Value = "" Next c 'Sheet2の列幅を調整する st2.Columns("A:B").EntireColumn.AutoFit st2.Select st2.Range("A2").Select st1.Select End Sub
こんにちは。 このコード、謎が多すぎ。 Dim pic As jpgPicture Set pic = New jpgPicture ここなんですが、このVBA環境に、classがあって、jpgPictureというオブジェクトが必要です。 tm = "2001/10/31 18:00:00" tugi: b() = Inet1.OpenURL"①") ここ。 Inet1の変数が、newなり、インターネット系のオブジェクトがあることになります。 つぎにあるopenは、VBAのバイナリーはバイナリファイルを作成する標準関数です 主様、大量に、という場合、まずは、「ひとつを正確に」できるコードを作成し、 それをループすることを考えます。 ifで、ループを戻す、というようなコードは、スパゲッティみたいなコードになるので、 使わないで考えることです。 formatで、日付から文字列にしますが、 文字列の特定部分で、取得という場合、instr関数で、区切りを探します。 urlの 1280x960/200110/2001103118.jpgの場合、 v1 = right(url , 21) '200110/2001103118.jpg yy = datevalue(left(v1,4) & "年" & mid(v1,5,2) & "月01日") mm = datevalue(mid(v1,9,4) & "年" & mid(v1,13,2) & "月" & mid(v1,15,2) & "日") + timevalue(mid(v1,17,2) & "時01分") というような、日付変換をします。 仕上げは、ヘルプも見てください。 どんな絵なのか、一般的なurlだったら、見てみたいきもします。
下記のコードでいかがでしょうか？ 最初はテストも兼ねて１０件程度のデータで確かめて下さい。 Option Explicit Sub Sample() Dim s1 As Worksheet, s2 As Worksheet Dim r As Long, r1 As Variant, i As Integer Set s1 = Worksheets("名簿") Set s2 = Worksheets("明細") For r = 2 To s1.Range("A" & s1.Rows.Count).End(xlUp).Row Step 3 i = 0 For Each r1 In Array(1, 18, 36) '明細へコピー With s2.Cells(r1, "B") .Offset(0, 0).Value = s1.Range("A" & r + i).Value '所属ＮＯ .Offset(0, 1).Value = s1.Range("B" & r + i).Value '所属 .Offset(2, 0).Value = s1.Range("C" & r + i).Value '社員ＮＯ .Offset(1, 0).Value = s1.Range("D" & r + i).Value '氏名 .Offset(6, 2).Value = s1.Range("E" & r + i).Value '過去手当 .Offset(7, 2).Value = s1.Range("F" & r + i).Value '6月手当 .Offset(9, 2).Value = s1.Range("G" & r + i).Value '7月手当 .Offset(12, 2).Value = s1.Range("H" & r + i).Value '合計 End With i = i + 1 Next '明細シートを印刷 s2.PrintOut Next r End Sub
マクロ記録のまま実行すると、効率は最悪。 効率の良くなるように手を入れましょう。 >全シートに罫線（下に太線）を引きたい 外枠を細線にして、下の枠だけ太くする、という事ですかね？ Sub sample() Dim ws As Worksheet For Each ws In Workbooks("貼付先").Worksheets With ws If .Name <> "特定シート①" And .Name <> "特定シート②" Then With .Range("A25", .Cells(Rows.Count, 1).End(xlUp)).Resize(, 213).Borders .LineStyle = xlNone .Weight = xlThin .Item(xlInsideVertical).LineStyle = xlNone .Item(xlInsideHorizontal).LineStyle = xlNone .Item(xlEdgeBottom).Weight = xlMedium End With End If End With Next ws End Sub
Workbook.Open を Workbooks.Open としてみてください。 次の行の「CRange」はコピペミスですか？ PSの方ですが、 「2016の6月分だけ」と言われても何をどう判断して何をスルーすればよいのか、フォルダ構成やシート名など具体的なレイアウトが判らないので答えようがないです。
わざわざ作らなくても練習用ならスマホアプリがあります。 iPhone、iPad用 深視力イメージ＋３D https://itunes.apple.com/jp/app/shen-shi-liimeji+3d/id469417281?mt=... Android アプリ 深視力測定 https://play.google.com/store/apps/details?id=com.anoptometer&hl=ja
こんにちは。 まず、trタグが存在していない。これは、不安定になります。 本来は、tbodyなども無いと、表示が出来ないブラウザーもあります。
残念ながらご希望に添えるメソッドはありません。 素直にループでAddItemして下さい。
デスクトップ\管理フォルダに「本日日付.xlsx」という名前で保存する例です。 Dim FilePath As String FilePath = System.IO.Path.Combine( _ Environment.GetFolderPath(Environment.SpecialFolder.Desktop), _ "管理フォルダ", _ Format(Now, "yyyyMMdd") & ".xlsx") Book.SaveAs(FilePath)
C5セルの罫線下は「無い状態」ではなく、「白」の罫線が引かれているのではないですか？ もしそうなら、 If .Borders(xlEdgeBottom).LineStyle = xlNone Or .Borders(xlEdgeBottom).ThemeColor = 1 Then で判定出来ると思います。
あくまで参考に。 自分はオヤジなので(^_^;)VB6から色々やっていますが、 このサイトは、人気あるみたいです。 http://homepage1.nifty.com/rucio/main/main.htm まずは、細かいことは置いといて目を通してみて下さい。
↓の2ヶ所を変更して、どうでしょうかね？ （未実行につき不具合ご容赦） １） For Each h In wbS.Worksheets If wbS.Worksheets(h).Name Like "新規" & "*(*" Then wbS.Worksheets(h).Delete ↓ For Each h In wbS.Worksheets If h.Name Like "新規*(*" Then h.Delete ２） For Each wss In wbS.Worksheets If wss.Name <> "特定シート" And wss.Name <> "新規" Then Range("A25:A" & Range("A1000").End(xlUp).Row).SpecialCells(xlCellTypeBlanks).EntireRow.Delete End If ↓ For Each wss In wbS.Worksheets With wss If .Name <> "特定シート" And .Name <> "新規" Then On Error Resume Next .Range("A25:A1000").SpecialCells(xlCellTypeBlanks).EntireRow.Delete On Error GoTo 0 End If End With 上手く実行できているのかも知れませんが、全体的にたどたどしさが残っているコーディングですね。もっと整理すべきでしょう。
閉じている他のブックを参照するならApplication.ExecuteExcel4Macroを使用します。 まず、Application.Matchの部分は、Application.ExecuteExcel4Macroの中でMATCH関数を書いて値を求めます。 i = Application.ExecuteExcel4Macro("MATCH(" & Range("A1").Value & ",'C:¥users¥desktop¥[book1.xlsx]シート２'!C1, 0)") 次にTextBox2にＢ列の値を返しますが、これもApplication.ExecuteExcel4Macroを使用します TextBox2.Value = Application.ExecuteExcel4Macro("'C:¥users¥desktop¥[book1.xlsx]シート２'!R" & i & "C2") なお、ExecuteExcel4Macroは必ずR1C1形式でアドレスを記述します。 MATCHのほうは「!C1」・・１列目 値を返すのは「!R" & i & "C2"」・・i行、２列目
で、何が知りたいの？
こういうことかと Function Fx(x As Double) Fx = x * x * x - 3 * x * x + 9 * x - 8 End Function Function dFx(x As Double) dFx = 3 * x * x - 6 * x + 9 End Function Sub main() Const Xini As Double = 10 Const Eps As Double = 0.000001 Dim x0 As Double, x1 As Double x1 = Xini Do x0 = x1 x1 = x0 - Fx(x0) / dFx(x0) Debug.Print x0, Abs(x1 - x0) Loop While Abs(x1 - x0) > Eps Debug.Print x1 End Sub
で、何が知りたいの？
こんにちは。 code = 4589 URL = "http://stocks.finance.yahoo.co.jp/stocks/detail/?code=" & code & ".T" Set HTML = CreateObject("MSXML2.XMLHTTP") HTML.Open "GET", URL, False HTML.Send Debug.Print HTML.responsetext こんなデータでいいんでしょうか。 まず、URLが違います。 主様の場合、エラーになります。 対策ですが、主様が表示させたいURLが、本当に正しいのか、確認してください。 手作業で操作したとしても、urlを自動で処理しているような雰囲気です。 つまり、yahooがリカバリーを自動でしたような様子、昔は、それでよかったかもしれませんが、今は、コードで投げたら、エラーになるということです。 だとしたら、手作業でしたときのurlにコードを合わせてください。
ぷろぱてぃではできないんじゃないかな こんなめにゅーなら 'メニュー '├メニュー１ ' _└メニュー１１ ' ___└メニュー１１１ '└メニュー２ load時に 'メニュー直下のShowImageMargin処理（メニュー） ContextMenuStrip1.ShowImageMargin = False←プロパティでもおなじ 'メニュー内各メニューごとのShowImageMargin処理（メニュー１、メニュー２） For Each Item1 As ToolStripMenuItem In ContextMenuStrip1.Items DirectCast(Item1.DropDown,ToolStripDropDownMenu).ShowImageMargin = False ''３段目のメニュー（メニュー１１）があればこんな感じで以降同じ（深さが不明なら再帰で回すべし） 'For Each Item11 As ToolStripMenuItem In Item1.DropDown.Items ' DirectCast(Item11.DropDown,ToolStripDropDownMenu).ShowImageMargin = False 'Next next
マイクロソフトのサイト https://msdn.microsoft.com/ja-jp/library/system.windows.forms.mouse... を見ても理解できませんか？
xxxmegashockさん memory size of elements = 2 byte と表示されると思います。Integer １個分ですから当然２バイトです。 2バイト= 16(ビット) ??? 4バイト= 32(ビット) (C言語のint )32(ビット)CPUで
こんにちは。 For i = 2 To 最終行 市場 = Worksheets("Sheet2").Cells(i, 2) 商品 = Worksheets("Sheet2").Cells(i, 3) 最終行3 = Worksheets("市場").Range("A" & Rows.Count).End(xlUp).Row Set 検索 = Worksheets("市場").Range("A1:B" & 最終行3) On Error Resume Next 地域 = Application.WorksheetFunction.VLookup(市場, 検索, 2, False) On Error GoTo 0 は For i = 2 To 最終行 市場 = Worksheets("Sheet2").Cells(i, 2).value 商品 = Worksheets("Sheet2").Cells(i, 3).value 最終行3 = Worksheets("市場").Range("A" & Rows.Count).End(xlUp).Row Set 検索 = Worksheets("市場").Range("A1:B" & 最終行3) On Error Resume Next 地域 = vbempty 地域 = Application.WorksheetFunction.VLookup(市場, 検索, 2, False) On Error GoTo 0 あと、 answer = .Index(全体範囲, 商品検索結果, 地域検索結果) ですが、 シートの座標がわかっているのですから、cells(行 , 列) で十分かと。 計算させる前に、変数の初期化をしてからです。 エラーを回避する処理をしているのは、意味があるからですよね。 ということは、エラーが発生したとき、変数は、そのまま放置されていることになります
コピー元のセルが結合している場合でもコピー&値貼付でOKです。 結合情報は影響しません(^_^) ******************************************* Sheets(2).Range("T1").Copy Sheets(6).Range("B2").PasteSpecial xlPasteValues
入門サイトなら下記サイトですかね。 Excel VBA 入門講座 http://excelvba.pc-users.net/ ある程度覚えたら下記２サイトが便利です。 モーグのサイト http://www.moug.net/ Office TANAKA http://officetanaka.net/excel/vba/tips/
テーブル1 ・・・ シート1のA1から始まる表 テーブル2 ・・・ シート2のA1から始まる表 目標のテーブル3 ・・・ シート3のA1から始まる表 とすると、↓が1例。 シート3は、上書き。 Sub sample() Const cFormula As String = "=IFERROR(VLOOKUP(A2,Sheet2!A:B,2,FALSE),"""")" With Worksheets("Sheet3") Worksheets("Sheet1").Range("A:C").Copy .Columns(1) Worksheets("Sheet2").Range("B1").Copy .Range("D1") With .Range("D2", .Cells(Rows.Count, 1).End(xlUp).Offset(, 3)) .Formula = cFormula .Copy .PasteSpecial xlPasteValues End With End With Application.CutCopyMode = False End Sub
Excelの開かずに中のセルを検索したりすることは出来ません。 Application.ScreenUpdatingを用いて「開いていないように見せる」ことは可能です。 例） Application.ScreenUpdating = False 'ブックを開く 'シートを検索する ’セルの場所を取得する 'ブックを閉じる Application.ScreenUpdating = True
ファイル名を変更するたび データタブの接続のリンクの編集を押して「リンク元の変更」から変更をエクセルに報告するような形になります。元のフォルダが開くので再確認のような感じです。変更されたファイルを指定してください。
実際に試してはいませんが、 With rs For r = 2 To Range("A" & Rows.Count).End(xlUp).Row .AddNew .Fields("商品コード").Value = Range("A" & r).Value .Fields("商品名").Value = Range("B" & r).Value .Fields("商品区分").Value = Range("C" & r).Value .Fields("単価").Value = Range("D" & r).Value .Update Next r End With としてみて下さい。
フィールドのデータ型はテキスト型になっていますか？
セルの書式が「標準や数値」では一部色付けはできません。 どうしてもという事なら書式を「文字列」にするぐらいでしょうか。
ActiveCellの扱いが悪いのだと思います。 実行する時Activeセルはどこでしょうか。 ActiveCell とはＡ1セルでしょうか？ ここに検索したい名前を入れていて、Ｂ1に件数だったら Dim i As Long, cnt As Long For i = 7 To Cells(Rows.Count, 1).End(xlUp).Row If Cells(i, 1) = ActiveCell.Value Then cnt = cnt + 1 End If Next i Cells(1, 2) = cnt
IIS 上で実行されるアプリケーションがどのユーザーとして実行されるかは認証の設定によって異なります。このユーザーがSQLへのアクセス権を持っていなければ当然アプリケーションはSQLへ接続することはできません。 デバッグ環境ではアプリケーションはデバッガを実行しているユーザー（つまりあなた）として実行されます。あなたはきっとSQLへのアクセス権を持っているので、デバッグ環境ではSQLに接続できるのでしょう。 IIS 上でアプリケーションを実行するユーザーの設定方法は以下で説明されています。 IIS 7 で認証を構成する https://technet.microsoft.com/ja-jp/library/cc733010(v=ws.10).aspx 匿名ユーザーや認証済みユーザー用のアカウントを設定して、そのユーザーに対してSQLのアクセス権を与えれば接続できるようになると思います。IISとSQLが別のサーバーである場合は、アプリケーション実行用のユーザーはローカルアカウントではなくドメインアカウントでなければいけません。ドメインが構成されていない場合は、SQLへの接続をWindows統合認証ではなく、SQL認証にするのもひとつの手です。
#試験用ファイル生成：テキトーな連番ファイル生成# for($z=1; $z -le 22; ++$z){   new-item -type "file" -name (""+$z+"_A.txt") } #ファイル名 先頭の数値で比較する整列# ls *_A.txt | sort { if($_.Name -match "^\d+"){   [int]$Matches[0] }else{$_.Name} } | `   select -last 1 | %{$_.FullName}
マクロであれば出来ます。 社員名簿と選択入力するのが同じシートで、入力を仮にＥ1セルとします。 シートモジュールにこのイベントマクロを書いておけば、 Ｅ1で選択した時、自動で該当行のＡ列が選択されます。 Private Sub Worksheet_Change(ByVal Target As Range) Dim wrow As Variant If Target.Count <> 1 Then Exit Sub If Target.Address <> "$E$1" Or Target.Value = "" Then Exit Sub wrow = Application.Match(Target.Value, Range("A1:A500"), 0) If IsError(wrow) Then MsgBox "該当データがありません" Exit Sub End If Range("A" & wrow).Select End Sub
エクセルではＶＢＡの事をマクロと呼んでいます。
こういうケースは、コードを記載すると解決が速いですよ。 まずは、ダメだったコードを記載してみてください(^_^)
MonthViewコントロールのことは判らないのですが 日付.Value = DateClicked としてみてもダメですか？
A2のセルが任意の伝票番号の入力セルとして A3のセルに =IF(B3="","",IF(B2<>B3,A2+1,IF(MOD(COUNTIF(B$2:B3,B3),4)=1,A2+1,A2))) A3のセルを下にコピー
For i = 1 To date2 - date1 - 1 ActiveCell.EntireColumn.Insert ActiveCell.Value = ActiveCell.Offset(, -1) + 1 ActiveCell.Offset(, 1).Activate Next End If Loop ↓ For i = 1 To date2 - date1 - 1 ActiveCell.EntireColumn.Insert ActiveCell.Value = ActiveCell.Offset(, -1) + 1 ActiveCell.Offset(, 1).Activate Next Else ActiveCell.Offset(, 1).Activate End If Loop
KeyPressイベントを使用すれば 押したキーに対応した文字コードの判定ができます。 http://dobon.net/vb/dotnet/control/tbsuppressbeep.html http://dobon.net/vb/dotnet/control/numerictextbox.html
以下でどうでしょう Dim list(2, 2) As String Dim i As Long list(0, 0) = "あ" list(0, 1) = "い" list(0, 2) = "う" list(1, 0) = "か" list(1, 1) = "き" list(1, 2) = "く" list(2, 0) = "さ" list(2, 1) = "し" list(2, 2) = "す" For i = 0 To 2    Cells(i + 1, "A").Value = _       Join(WorksheetFunction.Index(list, i + 1, 0), ",") Next
Sub 昇順の場合() Dim rng As Range For Each rng In Range("A2", Cells(Rows.Count, 1).End(xlUp)).SpecialCells(xlCellTypeConstants).Areas With rng.CurrentRegion .Sort Key1:=.Columns("E"), Order1:=xlAscending, Header:=xlNo End With Next rng End Sub Sub 降順の場合() Dim rng As Range For Each rng In Range("A2", Cells(Rows.Count, 1).End(xlUp)).SpecialCells(xlCellTypeConstants).Areas With rng.CurrentRegion .Sort Key1:=.Columns("E"), Order1:=xlDescending, Header:=xlNo End With Next rng End Sub
こんばんは(^_^) アクティブブックへのコピーで良かったんですね。 つまり、「産廃用見積書呼出」プロシージャはこのコピー先のブックにあると。 であれば、 Workbooks("新規ファイル.xlsm") を ThisWorkbook に変更すれば解決です。
そのような指定はできません。 一例です。 Sub sample1() Dim sh As Worksheet For Each sh In Worksheets If sh.Name Like "*日" Then sh.Range("A2").ClearContents Next End Sub
例えばform１にテキストボックスが有って、その値を取ってくる方法とまったく同じです。
掲載されたコードはちゃんと動作するようですよ。 少なくともエラーにはなりません。 リンク先ページの内容については未確認です。
Excelの話ですか？Accessの話ですか？ もしExcelの話だとすると、Excel VBAではDoCmdは使えません。 下記のサイトを参考にしてください。 複数のUserFormでデータを受け渡す http://officetanaka.net/excel/vba/tips/tips113.htm
端的に言うと ExcelCreatorは「Excelファイルを新しく作る」ためのツールで、 VBReportは、帳表レイアウトの印刷を行うプログラムを簡単に作るためののツール です。
何か手順が間違っていませんか？ 数式バーで数字部分だけドラッグしておいて、下付きで出来ますが。 ＶＢＡはもう一方の質問で回答します。
質問内容がよく分かりません。 ① SQL.Append の 「SQL」変数は、 Dim SQL As System.Text.StringBuilder と宣言しているかと思いますが、 SQL.Append(" WHERE " & vbNewLine) と「&」で結合せず、 SQL.Append("WHERE").Append(vbNewLine) とした方が良いです。 ② SQL.Append(" BI.ADDRESS IN (DBDATA_1000.AA_CODE) ") は、単なる文字列の結合なので、 If strNo = "1" Then SQL.Append(" BI.ADDRESS IN (DBDATA_1000.AA_CODE) ") End If というように、IFで条件によって内容を変えることも出来ます。 ③ 「データを入れる」とはどのような意味か分かりませんが、他のテーブルにインサートすることであれば、DBの種類や接続方法によって記述は変わります。 ＤＢやテーブルの仕様が全く分からないので、サイトで検索して、自分の使っている環境に応じた記述方法を調べて下さい。
言葉の意味をいくら深めても、プログラムは組めません。 具的なソースだけを見て意味を考えてください。 主に、フレームワークで使用します。 逆に、フレームワークに用がないなら使わなくてもいいのではないでしょうか。
Select Case target.Column ' 1列目の場合 Case 1 ↓ Select Case target.Column ' 1,3,5列目の場合 Case 1, 3, 5
① InStr(hrml.responseText, """"" data-ylk=""slk:history;pos:0"">時系列</a></li>""") = 0 ②と③ Dim bk As Workbook, b As Worksheet Set bk = Workbooks.Add If Not b Is Nothing Then Set b = bk.Worksheets(1) End If
Drop Down 16 というのは、ActiveX コントロールで作成したコンボボックスの名前 という理解で合っていますか。 このコードで、I8 と P26 セルに関しては出来ているのでしょうか。 エクセルのバージョンが違うからかもしれませんが、 やってみたところ実行されませんでした。 回答でないのにすみません。 回答が出ていないので、やってみたのですが。
具体例をもっと詳しく教えてください。 抽象的なので、やりたい事が、よく分かりません。
具体的に、例をあげて説明してください。 抽象的で、やりたい事が、良く分からないです。
si_kun117さんの回答に補足します。 C#とVB.Netで書かれたプログラムで使っているフレームワークは完全に.NET Frameworkしかありません。 C#もVisual BasicもMicrosoftがWindows上で動作するアプリを念頭において開発した言語だからです。 世の中にはMicrosoft以外から出ているC#コンパイラやBasicコンパイラも存在しますが、シェア的にはほぼMicrosoftが独占しています。 一方、JavaScriptで使っているフレームワークは？と聞かれた場合、厳密にはフレームワークではないのですが「JQuery」がそうだ、と言っていいと思います。
テーブル DBADD CODE,KUBUN,DATA 100,120,11 100,120,12 と２件のレコードなら取得できるかと思いますが、その点はどうなってるのでしょうか？ ↓IN句を用いた副問合せ http://www.sql-reference.com/select/subquery_in.html
下記はColorDialogを表示して、選択した色のRGB値を個別に取得する例です。 Dim r As Byte, g As Byte, b As Byte With ColorDialog1 If .ShowDialog(Me) = Windows.Forms.DialogResult.OK Then r = .Color.R g = .Color.G b = .Color.B End If End With ColorDialogのColorプロパティの型はColorクラスです。 ColorクラスにはそれぞれByte型のR,G,Bプロパティがあり、色のRGB値を取得または設定出来ます。 なお、ColorクラスにはRGBの他にByte型のAプロパティがあり、これは色の透明度を表します。
正式版はまだリリースされていないようです。 これまでの例からいくと、正式版をインストールする際は事前にプレビュー版をアンインストールしておくことが推奨されています。
こんにちは。 示しているコードは、全体の一部だけですよね。 確認が必要なのは、batファイルの実行によって、処理されていることが、 正しくない、という可能性です。 変換されたファイルの確認は、メモ帳でしてください。 innerhtmlに、何回も上書きしている動作のコードでは、確認できません。 変換後のデータが1件でも数件あっても、最後のデータしか、書き込みしません。 この方式でやりたいのでしたら、readallのような、全部読み込みさせてください。
２００行でテストしてみましたがそのようなことは起こりませんでした。色を付ける前に色をリセットしてみてはどうでしょうか？テストの繰り返しで色の残骸が残ったのかもしれません。 またFINDは遅い、というのは確かですが http://excel-ubara.com/excelvba4/EXCEL225.html ２００行で差がでるとは考えられません。他のシートで再計算が起きているのでは？ 重複数は同じセルに同じ色を複数回つける可能性があるので改めていろのついたセルをカウントすればいいと思います。 Sub 重複チェック() Dim RetRange As Range, r As Range Dim i As Long, n As Long Range("A2").Select Range(Selection, Selection.End(xlDown)).Select Selection.Interior.ColorIndex = xlNone For i = 2 To Cells(1, 1).End(xlDown).Row Set RetRange = Selection.Find(What:=Cells(i, 1).Value, _ after:=ActiveCell, LookIn:=xlFormulas, _ LookAt:=xlPart, SearchOrder:=xlByRows, _ SearchDirection:=xlNext) If Not RetRange Is Nothing Then If RetRange.Address <> Cells(i, 1).Address Then RetRange.Interior.ColorIndex = 6 Cells(i, 1).Interior.ColorIndex = 6 End If End If Next For Each r In Selection If Not r.Interior.ColorIndex = xlNone Then n = n + 1 Next MsgBox "重複数は" & n & "個でした" End Sub
Columns("A:C").Cut Destination:=Columns("B:D") たぶんこれ1行で済むと思います。
Selection.PasteSpecial Paste:=xlPasteValuesAndNumberFormats, Operation:= _ xlNone, SkipBlanks:=False, Transpose:=False マクロの記録では こうなりました。
これをどこに記載しましたか？ ThisWorkbook に書いてあれば、正しく動作しますが。
この マクロを 見る限り Book（β）にあるSheet1の表に対するコマンドは まったくありませんが？ 別の ところにあるのかもしれませんが For i = 2 To ThisWorkbook.Worksheets.Count では このマクロが 入っている Book（α）の シート数ですよね。
Win10の場合 ピクチャに「カメラ ロール」と「保存済みの写真」と言うフォルダは削除しても自動でまた作られてしまうようですが その他で作られる現象は私のＰＣでは有りません。 もしかして「共有」の設定がされていて他人が作っているのかも知れません。 下記で「共有」の解説がされています、調べて見て下さい。 Windows 10でファイル共有を行う方法 http://www.ask-mswin.com/win10-fileshare/
＞金額があっているが確認するか、 意味不明です、文字を間違えていませんか？
トリッキーな方法（この技に意味が有るかどうか不明）ですが フォーム内にフォームを表示する http://dobon.net/vb/dotnet/form/formwithinform.html
・・懐かしい響きだ。
解決されてましたらスルーしてください 以下の様な処理はどうでしょう 元々のデータの並びを見ると ・B 列の空白の塊に注目して、 ・りんご/みかん は、空白塊先頭の１つ上 ・合計の値は、空白塊最後の右隣 これを Dictionary で集計して、最後に集計内容を書き出し > '   dic.CompareMode = vbTextCompare ' ★ このコメント部分を有効にすると、りんご/リンゴ は同じものとして集計 ' ★～ から ' ★～ 間の４行では、横に書き出し その４行をコメントにして、 ' ★～ から ' ～★ 間の４行を有効にすると、縦に書き出し Public Sub Samp1()    Dim dic As Object    Dim rng As Range    Dim sS As String    Set dic = CreateObject("Scripting.Dictionary") '   dic.CompareMode = vbTextCompare ' ★    With ActiveSheet       With .Range("A1").CurrentRegion          For Each rng In .Columns(2).SpecialCells(xlCellTypeBlanks).Areas             sS = rng(1).Offset(-1).Value             dic(sS) = dic(sS) + rng(rng.Count).Offset(, 1).Value          Next       End With    End With    If (dic.Count > 0) Then       With Worksheets("商品別売上合計") ' ★～          With .Range("A1").Resize(, dic.Count)             .Value = dic.Keys             .Offset(1).Value = dic.Items          End With ' ★～ '         With .Range("A1").Resize(dic.Count) '            .Value = WorksheetFunction.Transpose(dic.Keys) '            .Offset(, 1).Value = WorksheetFunction.Transpose(dic.Items) '         End With ' ～★       End With    End If    Set dic = Nothing End Sub
このアカウントで過去にはうまくいっていたのでしょうか? 他のアカウントは同じサーバにPASV接続で問題ないのでしょうか? >ダウンロードのためにホスト 202.181.97.23 (61163) に接続しています. >ダウンロードのためにホスト 202.181.97.23 (56413) に接続しています. >ダウンロードのためにホスト 202.181.97.23 (60251) に接続しています. このへんのポートをサーバのファイアウォールで開けてないからじゃないですか? FTPをPASVで使うなら、ftpdがデータストリームを待ち受ける範囲のポートは全開にする必要があります。 通常は49152～65534です。
任意.password = "" の前に 任意.Saved = False を入れてみてください。
URLしか情報がないのでしたら、確実に作業する方法は手作業しかないと思います。 結果は保証できないですが、VBAで自動化できる方法を以下に記載しておきます。 方法1も2も、スクレイピングという技術を使います。 <方法1> 企業のホームページの場合、ほとんどの場合はタイトルが会社名になっていると思います。 これを利用して、企業ホームページからタイトルを抽出する。 ただし、タイトルが会社名でない場合や宣伝文句などの余計な文言が入っている可能性があります。 <方法2> 企業のURLを使って、以下のサービスなどを利用してドメイン検索して登録者名を抽出する。 http://tech-unlimited.com/whois.html 方法1よりは確実ですが、法人格や社名変更が反映されていない可能性があります。 また、中小企業などの場合は、ホームページをもっていてもドメインをもっていない場合もあるかもしれません。
3の作業がはっきり定義できるならば、パソコンの操作を記録するソフトを使ってみると良いかもしれません。 UWSCなんかの自動化スクリプトだと、より柔軟な対応が可能かもしれないですね。 スクリプトを作っておいて、CADソフトの外部メニューやOfficeのメニューをカスタムしてユーザコマンドとして呼び出せるようにしておけば、労力もぐっと減ります。
内容的にExcelのオートフィルタ機能やデータベースクエリで対応できそうですが、いかがでしょうか？マクロで一から作らなくても、それらでスピードアップが見込めるのではないでしょうか？
プロジェクトの種類が「クラスライブラリ」になっていませんか？
Visual Studioにはフォームデザイナがあります。 フォームにボタンを貼って、そのボタンをダブルクリックすれば、自動的にクリックイベントハンドラが作成されるので、その中にメソッド呼び出し処理を書けばいいです。 クリックイベント以外の場合は、コントロールを選択すればプロパティウィンドウにそのコントロールのプロパティ一覧が表示されますが、イベント一覧も表示できます。処理したいイベントをダブルクリックすれば、そのイベントハンドラが自動的に作成されます。 イベントとデリゲートについての詳細は、MSDNをご覧になって下さい。 https://msdn.microsoft.com/ja-jp/library/edzehd2t(v=vs.100).aspx
>snnh79さん >お手数ですが、ヒントでも結構なので教えていただけると助かります。 基礎をやらずにヒントをもらっても仕方が無いので、自作するのなら基礎から学習していくと良いと思います。
例えば"C:\sample\Book2.xlsx"にSheet2を追加するなら、最後の「End Sub」の前に以下を追加してみてください。 Workbooks.Open "C:\sample\Book2.xlsx" ThisWorkbook.Sheets("Sheet2").Copy After:=Workbooks("Book2.xlsx").Sheets(Workbooks("Book2.xlsx").Sheets.Count) ActiveWorkbook.Close True
以下のコードで出来ます。 Option Explicit Sub 翌月処理() Dim rng As Range For Each rng In Range("C4：C35").SpecialCells(xlCellTypeConstants, xlNumbers) rng.Value = rng.Value + 1 Next rng Range("A1").Select End Sub RangeオブジェクトのSpecialCells(xlCellTypeConstants, xlNumbers)を用いると数字が入ったセルだけを抽出することが出来ます。
workbookモジュールでセル変更を検知するイベントプロシージャがあるので、それを使えば、どの文字が入力されたかを取得できます。 あとはselectかifを使って、それぞれの文字に対応するオートシェープを指定のセルにコピペする処理を行えばいいと思います。 コピペ処理のコードは、マクロの記録を使えばすぐにわかるでしょう。 参考ＵＲＬ http://vba-geek.jp/blog-entry-224.html
以下でどうなりますか > 一つ下のセルと数値又は文字が > ・一緒であれば選択セルの文字を青に > ・違えば選択セルの文字を赤に > するという条件付き書式 これは、どちらか一方で良いんですよね 範囲がわからないので、選択した範囲ということで 式を作る時には、範囲の左上セルの位置を基本に設定すれば･･･ 以下処理では、 範囲指定された１つ目のセル位置のアドレスと、その１つ下のアドレスで････ 例えば、A1:D20 を範囲指定していたとすると、 "=A1=A2" という文字列を作って条件付き書式を設定します 条件付き書式は ・１度きれいにして ・追加して ・その内容を（以下では、= なら、文字色を赤に） = ではなく、違ったら･･･なら >   Const CF As String = "={%1}={%2}" ↓    Const CF As String = "={%1}<>{%2}" Public Sub Samp1()    Dim sS As String    Const CF As String = "={%1}={%2}"    With Selection       sS = Replace(CF, "{%1}", .Cells(1).Address(False, False))       sS = Replace(sS, "{%2}", .Cells(1).Offset(1).Address(False, False))       With .FormatConditions          .Delete          With .Add(xlExpression, , sS)             .Font.ColorIndex = 3          End With       End With    End With End Sub
D1は =IF(B1>C1,"●","") これだけでいいと思いますが。
> 上手く行きません。 上手く行かなくてどうなるのでしょう？
> ブックを開かずに なぜかはわかりませんが、 やりたいことをやるにはそれなりのスキルが必要です 以下参考にでもなれば 複数のエクセルブックの特定シート・特定行を、 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1315909913... ※ P200 ～ P250 の行/列方向変換する際には、 WorksheetFunction.Transpose 使えば･･･
>>VB6で実現可能か教えて欲しいです。 この質問に回答するような人間にとっては可能でも、こんな質問を何の進歩もなく繰り返し聞くようなお前にとっては無理だろうね。諦めようや。
こちらなどはスピードアップに成功したようです。 http://q.hatena.ne.jp/1377926475 無駄に配列に入れるためにレコード数を取得、 このため より速いと思われる「前方スクロールカーソル」が使えませんね。 データ数が多くて、レコード数を取得する必要がある場合に あらかじめ Select Count("*") ・・・ で取得してから、改めて 「前方スクロールカーソル」で レコードセットを取得した方が速かったりします。 まあ今回はダイレクトにリストボックスに設定すれば レコード数を得る必要がないわけですから。 複数列のリストの追加法はヘルプにもありますが AddItem したのちに List を編集する、という表現でいいのかな？ 例はこちら。 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1116097975... adOpenForwardOnly,adLockReadOnly でレコードセットを開いて確認してみてください。 あと、こんなのもありますね。 ループ内ではフィールドを参照しない方がよい？ http://tsware.jp/labo/labo_12.htm
主様、さきの質問にあるような、6時間の計算のurlを計算したいのでは？？ mmに、時間を計算したら、 v2 = dateadd("H",6,mm) '6時間後を計算 v3 = format(v2,"yyyymm") & "/" & format(v2 , "mm") & ".jpg" '200110/2001103118.jpg b() = Inet1.OpenURL("http://***/" + "yy" + "/" + "mm" + ".jpg", icByteArray b() = Inet1.OpenURL("http://***/" & v3 , icByteArray このコードで、主様のやりたいこと、できませんか。 あ、yyといったら、普通、2016年の16のことを指します。しかし、ダブルクォーツになっているので、yyのままです。 Openするまえに、画面に表示させてください。 文字列の計算を確認する、と、ずっといってますよ。
仕様がいまいち解っていませんが、文章からすると、木構造っぽい感じがするので、再帰プロシージャとかが使えるように思います。 ループが何重にもなってしまう感じがしたら、再帰呼び出しに書き換えられないか、検討してみてください。
そういうのは普通SQL発行する前にVB側でチェックしてやるもんだと思いますが、どうしてもってんならTry~Catchでエラー番号(OracleExceptionのNumberプロパティ)分岐してやれば良いんじゃないでしょうか。 参考 http://otndnld.oracle.co.jp/document/products/oracle10g/102/windows...
プルダウンというのはデータの入力規則のリストのことを指しているのでしょうか？ それともコンボボックス（ユーザーフォーム）のことでしょうか？ あるいはコンボボックス（ActiveX コントロール）のことでしょうか？ 上記３パターンでそれぞれVBAの書き方が違います。
こんなかんじ Dim 元データ as DataTable '取得ロジックはご自身で Dim 先データ as DataTable '作ってください。 For Each MotoRow as DataRow in 元データ.DataRows Dim Tuika As DataRow = 先データ.NewRow() Tuika("◎COL_AAA") = MotoRow("◎COL_AAA") 先データ.Rows.Add(Tuika) Next MotoRow っていうか、ググったら一発です。 http://hiros-dot.net/VBNET2005/Control/DataSet/DataSet12.htm
マクロで可能です。こんな感じです。 Sub Sample() Dim wr As Range For Each wr In Selection Range(wr, wr.Offset(0, 5)).Interior.ColorIndex = 6 wr.Offset(-1, 0).Interior.ColorIndex = 6 Next wr End Sub
ご希望の事はVBAで可能ですが、回答するにあたって疑問点があります。 >「①」には外部からすでにデータが読み込まれている状態で >E～G列のリストも「①」の結果によって >候補の県をVBAにて出力させております。 ここは既に完成しているのですね。 選択したものは、「1：愛知」のような形式になっていて そこから「：」の前の数字だけ取り出せばいいのでしょうか。 その部分だけの質問という事でいいですか？
ChartオブジェクトにRefreshメソッドがあります。 ※ヘルプではRefreshメソッドの説明に「指定されたグラフを直ちに再描画します。」とあります。 これでも早くならなければ、データとグラフを分けるなど、作り方を変えないとダメかも。
Acrobat Readerではできないと思います。 Acrobat Readerには、基本的にPDFを閲覧以外の機能はありません。 それ以上のことをしたい場合には、ちゃんとお金払ってAcrobatを購入してくださいということです。
下の画像は（Excel2016) A1：日付入力 B1：=A1+7 C1：=B1+1 １．A1:C1を選択 ２．[ホーム]タブ → [スタイル]グループ → 条件付き書式 → 新しいルール ３．【数式を使用して、書式設定するセルを決定】 ＿＿【=A1<=TODAY()】 ＿＿【そこの[書式]ボタンから「塗りつぶし」タブで赤色を指定】 ４．A1:C1を下にオートフィルコピー としたものです。
単に引数不足のため異常終了しているだけ・・・ということはないですか？ 「Unload」の後ろに画面名が記載されていない場合、「Unload UserForm2」としてみてください。画面名の省略はできなかったと思うので。
自分が考えたこと ・文字列を１字ずつ区切り、文字列内のアルファベットをカウントする p:1 i:1 z:2 a:1 p:1 i:1 z:1 a:2 ・ｎ、ｍから判断して長い方から短いほうを引く p:1 i:1 z:1 a:2 引く p:1 i:1 z:2 a:1 ＝a:1 自分はpythonでやったのでソース # coding: utf-8 import collections #""" s1 = raw_input().split(" ") n, m = s1[0], s1[1] s = raw_input() t = raw_input() #""" #test case1 """n, m = 5, 5 s = "paiza" t = "pizza" """ #test case2 """ n, m = 3, 5 s = "ant" t = "maven" """ d_s = collections.Counter(s) d_t = collections.Counter(t) if n >= m: d = d_s - d_t else: d = d_t - d_s lack = 0 for key, value in d.items(): lack += value print lack
例えば入力画面シートのシートモジュールで Private Sub Worksheet_Deactivate() If Range("C35").Value = "利用する" And Range("D36").Value = "" Then Worksheets("入力画面").Activate End If End Sub とするのはいかがでしょうか？
A列に列を追加して、追加されたA列に数式を設定する部分だけを実現するマクロです。 Sub 数式設定() Dim ws As Worksheet, r As Long Set ws = Worksheets("集計結果") ws.Columns("A").Insert For r = 2 To ws.Range("B" & ws.Rows.Count).End(xlUp).Row ws.Range("A" & r).Formula = "=CONCATENATE(TEXT(顧客一覧!$I$12,""@""),C" & r & ")" Next r End Sub そもそも最初のマクロでの数式設定は正常に動作していますか？
Excelファイルはあなたが参考にしているページの方法では読み込めません。 授業で指示されたのはExcelファイルですか？CSVファイルですか？
①開始Noの入力位置は表のすぐ隣ではなく、ひと列開けて列幅を調整する ②開始No、終了Noの上の行に「開始Noと終了No」を入力後、印刷ボタンを押してください」などの文言を入れる ③背景色を変えるなどしてどのセルに入力すればよいかが直感的に判るようにする などでどうでしょうか。
>d112kさん2016/6/1516:29:34 >指定した1つのCSVﾌｧｲﾙから指定の文字が含まれたの列のﾃﾞｰﾀのみ取り込みたいです。 TODO?
Dir関数を使うとファイルの存在をチェックできます。 画像をどのように表示してるのか不明ですが、 If Dir("C:\sample\A.xlsx")<>"" Then ’あった時の処理 End If で処理できると思います。
カテ間違ってますよ。 そいから質問が途中でぶったぎれてますよ。 メガーヌのブレーキの事なら自動車系のカテでどうぞ。
まず、普通に商品なんで無償は難しいでしょうね。 現在はバージョンが上がって１１になっているようです。 OSの対応やデバッグで上がっているんでしょう。 どの様な環境で利用されるか判りませんが、最新環境を準備する方が良いと思います。 http://www.softec-inc.net/visualshot/
申し訳ないですが、できるだけやるべきことを明確にしないと、質問に答えられる人はいないと思われます。 ＞1.ファイルBは発注書であり、およそ5行程の入力欄がありますが、全行に記入されているとは限らないので空欄の分は無視したい（ファイルAに転記される時、途中の空白を無くしたい）。 上記であれば、下記の情報がないと私では答えられません。 ①ファイルBの「どのシート」の「どの範囲」が必要なのか 例：ファイルBの「Sheet1」の「A2からA6」 ②ファイルAの「どのシート」の「どこ」へ転記したいのか 例：ファイルAの「Sheet1」の「A列」
一番上のチェックボックスのクリックイベントに下記を書いておけばいいと思います。 Private Sub CheckBox1_Click() Dim i As Integer Dim cnt As Integer Dim start As Integer '--------↓ここを変更--------- cnt = 20 'チェックボックスの数 start = 2 '一番上のリンクセルの行 '--------↑ここを変更--------- For i = start + 1 To start + cnt - 1 Range("C" & i).Value = Range("C" & start).Value Next i End Sub
DropButtonClickが多重にかかるのが問題なので、一番簡単なのは、 >Private Sub ComboBox1_DropButtonClick() を Private Sub UserForm_Initialize() にして、ユーザーフォームの初期化でコンボのリストを更新する方法だと思います。
MID関数を使います。 先頭のvbTabを削除するときは If Mid(str, 1, 1) = vbTab Then str = Mid(str, 2) です。一応先頭の文字がvbTabかどうかを判定してから削除したほうが安全です。 末尾のvbTabを削除するときはLen関数も併用して以下のようにします。 If Mid(str, Len(str), 1) = vbTab Then str = Mid(str, 1, Len(str) - 1)
もしかして、yonnkaku.png という画像を別アプリで開いてませんか？ 排他がかかった場合に出るエラーです。 画像に限らず、何かのファイルを何か別のアプリで使用中なんかで出ます。
その表示させるルールさえ明文化できれば。 そのルールをVBの書き方に沿って再現できれば。 簡単じゃないですかね。 まず、そのルールを言葉にしてみましょう。
２）で実行を一時中断するのではなく、スペースができたら２）の処理を終了 あらためて、全セルが入力されたら３）の処理を行う、としてはどうでしょうか。 以下のサンプルですが、セルＡ１に i （行数）、セルＢ１に j（列数）を入力すると、セルＡ２以下に入力欄を作成します。（罫線を引きます） つぎに、入力欄にすべて入力されたら「計算処理」を実行しますが、そこまで書かれていませんのでMsgBoxを表示するだけにしています。 Option Explicit Dim gyou As Long Dim retu As Long Private Sub Worksheet_Change(ByVal Target As Range) 'セルA1、B1に入力があった場合 If Not Intersect(Target, Range("A1:B1")) Is Nothing Then '行数、列数が数値の場合 If IsNumeric(Range("A1").Value) And IsNumeric(Range("B1").Value) Then 'かつ、行数が1～最大行数-1、列数1～最大列数の範囲の場合 If Range("A1").Value > 0 And Range("A1").Value < (Rows.Count - 1) _ And Range("B1").Value > 0 And Range("B1").Value < Columns.Count Then '入力欄の作成 Application.EnableEvents = False '行数、列数を控える gyou = Range("A1").Value retu = Range("B1").Value '一旦すべてを削除 Cells.Delete 'セルA2から行数、列数分のセルに枠線を付ける Range("A2").Resize(gyou, retu).Borders.LineStyle = xlContinuous Application.EnableEvents = True Exit Sub End If End If End If '入力欄が未定義の場合は終了 If gyou = 0 Or retu = 0 Then Exit Sub '入力欄に入力があった場合 If Not Intersect(Target, Range("A2").Resize(gyou, retu)) Is Nothing Then '入力欄がすべて入力された場合 If Application.WorksheetFunction.CountA(Range("A2").Resize(gyou, retu)) = (gyou * retu) Then '計算を実行 MsgBox "計算を実行" End If End If End Sub
BorlandではなくVCだが c:\C\WindowsAPI>type test.rc // test.rc #include <windows.h> test BITMAP "test.bmp" c:\C\WindowsAPI>rc test.rc Microsoft (R) Windows (R) Resource Compiler Version 6.3.9600.17336 Copyright (C) Microsoft Corporation. All rights reserved. c:\C\WindowsAPI>type test.c // test.c // rc test.rc // cl test.c test.res #pragma comment(lib,"user32.lib") #pragma comment(lib,"gdi32.lib") #include <windows.h> #include <windowsx.h> #define CLASSNAME "SKELETON" #define MENUNAME NULL // "MAINMENU" #define MAINTITLE "LoadBitmap sample" #define CW_WIDTH 800//GetSystemMetrics(SM_CXSCREEN) #define CW_HEIGHT 600//GetSystemMetrics(SM_CYSCREEN) #define CW_LEFT CW_USEDEFAULT//((GetSystemMetrics(SM_CXSCREEN) - CW_WIDTH) / 2) #define CW_TOP CW_USEDEFAULT//((GetSystemMetrics(SM_CYSCREEN) - CW_HEIGHT) / 2) #define BGCOLOR RGB(0xff,0xff,0xff) LRESULT CALLBACK WndProc(HWND wh,UINT ms,WPARAM wp,LPARAM lp) { static BITMAP b; HBITMAP bh; static HDC v; PAINTSTRUCT ps; HDC d; switch (ms) { case WM_CREATE: bh = LoadBitmap(((LPCREATESTRUCT)lp)->hInstance,"test"); GetObject(bh,sizeof(b),(LPSTR)&b); d = GetDC(wh); v = CreateCompatibleDC(d); SelectObject(v,bh); ReleaseDC(wh,d); break; case WM_PAINT: d = BeginPaint(wh,&ps); BitBlt(d,100,100,b.bmWidth,b.bmHeight,v,0,0,SRCCOPY); EndPaint(wh,&ps); break; case WM_DESTROY: DeleteDC(v); PostQuitMessage(0); break; default: return DefWindowProc(wh,ms,wp,lp); } return 0; } int WINAPI WinMain(HINSTANCE lih,HINSTANCE rih,LPSTR argv,int ws) { HWND w; MSG m; WNDCLASS c; c.style = ws; c.lpfnWndProc = WndProc; c.cbClsExtra = 0; c.cbWndExtra = 0; c.hInstance = lih; c.hIcon = LoadIcon(NULL,IDI_APPLICATION); c.hCursor = LoadCursor(NULL,IDC_ARROW); c.hbrBackground = CreateSolidBrush(BGCOLOR); c.lpszMenuName = MENUNAME; c.lpszClassName = CLASSNAME; RegisterClass(&c); w = CreateWindow(CLASSNAME,MAINTITLE,WS_VISIBLE | WS_SYSMENU, CW_LEFT,CW_TOP,CW_WIDTH,CW_HEIGHT, NULL,NULL,lih,NULL); LOOP: switch(GetMessage(&m,NULL,0,0)) { case -1: case 0:return m.wParam; default: DispatchMessage(&m); break; } goto LOOP; } c:\C\WindowsAPI>cl test.c test.res Microsoft(R) C/C++ Optimizing Compiler Version 19.00.23506 for x64 Copyright (C) Microsoft Corporation. All rights reserved. test.c Microsoft (R) Incremental Linker Version 14.00.23506.0 Copyright (C) Microsoft Corporation. All rights reserved. /out:test.exe test.obj test.res Borlandの無料版だと test.bmpは適当に用意してソースと同じフォルダに入れておいて bcc32 -W test.c brc32 test.rc で行けると思うが、もうBorlandは入れていないので確かめてない
シートの値とは？ キチンと用語を使えない人の質問に答えるのは難しいです。 質問自体、何がしたいのかよくわからない。自動的って何をすることを指してるの？ やり直しですなあ。 こう書いても、勝手に想定して回答してしまう人がいるのも問題なんだけどね。
こんな感じで OK ですよ。・・・・・・・・・・・・・ Dim a As Long Sub test() Dim i As Long a = Range("A1").End(xlDown) i = InputBox("挿入する行番号を入れて下さい。") Range("A" & i).Insert Range("A" & i).Value = a + 1 End Sub
大丈夫です。 そのままバグを直して、 どう直したかを、ソースにコメントしてください。 仕様変更ですが、してはいけないという決まりはありません。
上記の仕様だと売上台帳シートには上手く転記されません。 なぜなら、 入力した「日付」の値をA列の最終行のひとつ下（たとえば3行目）に転記したあと、商品IDが未選択だったとします。 その時はメッセージを表示してマクロを中断するんですよね？ じゃぁ、商品IDを選択してボタンを押したら、 入力した日付はA列の最終行のひとつ下ですから4行目に転記されますよね？ 次の商品IDはB列の最終行のひとつ下ですから3行目がに転記されることになります。 本来は行を揃えて転記したいはずなのに、4行目だったり3行目だったり、入力エラーが発生するたびに入力される行がずれていってしまいます。 この仕様を考えた人にその旨を伝えて、もう一度仕様をまとめ直してもらって下さい。
色の合成の基本はRGB各要素（赤、緑、青）の足し算です。 ただし実際には質感を表現するためにカラーバランスを調整したり、輝度（A）を加減したりとかの処理を追加する必要があるかもしれません。
そのフォームのコードはこれだけでしょうか？ コードをすべて入れなおすしかないです。 そのフォームの全イベントコードをメモ帳に退避し、 そのフォームの全イベントコードを一旦すべて削除して フォームを上書きします。 （この時点でイベントコードは何もない） その後、１つずつイベントコードを各コントロールの イベントから作成し、中身はメモ帳から貼り付けて再現します。 これでもエラーが再現するなら、フォーム自体を一旦削除し、 再作成するしかありません。
Sub 登録_終了() Dim rngx As Range, rng As Range, i As Long, xFilename Const xCpy1 As String = "D3,D5,E5,F5,D7,E7,F7,I7,D9,I9,D11,I11,D13,I13,D15,I3" xFilename = Application.GetOpenFilename("Microsoft Excelブック,*.xls?") If Not IsArray(xFilename) Then Exit Sub With ThisWorkbook With .Worksheets("入力") Set rngx = .Range(cCpy1) With Workbooks.Open(Filename:=xFilename) With .Worksheets("受付情報").Range("B" & Rows.Count).End(xlUp).Offset(1) For Each rng In rngx .Offset(, i).Value = rng.Value i = i + 1 Next rng End With .Close SaveChanges:=True End With .Range("D3,I3,D5,F5,D7,F7,D9,I9,D11,I11,D13,I13,D15").ClearContents End With .Close SaveChanges:=True End With End Sub 未実行につき不具合ご容赦。
Set wb2 = Workbooks.Open(ThisWorkbook.Path & "\受付記録情報.xlsx" & Filename) 最後の「& Filename」が余計です。一応、宣言なしの変数を付けているだけなので、動作するかもしれませんが、混乱するだけなので削除した方が良いでしょう。 さて、原因ですが、Cellsの括弧内が「""」で囲まれてしまっています。これでは、囲まれた部分を文字列として指定していることになるので、文法エラーとなります。「""」は取り除いてください。
Node.Checked = False とすればNodeオブジェクトのチェックを外すことは出来ます。 Nodeの子Nodeのチェックボックスを外すのであれば For Each node In Node.Nodes node.Checked = False Next node で出来ます。 他にはどんなことが効きたいのでしょうか？
下記のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim st1 As Worksheet, st2 As Worksheet Dim r1 As Long, r2 As Long Dim msk As Integer, dgw As String Dim ad1 As Integer, ad2 As Integer, ad3 As Integer, ad4 As Integer Set st1 = Worksheets("IP一覧") Set st2 = Worksheets("ルーティング設定") st2.Cells.Clear r2 = 1 For r1 = 2 To st1.Range("O" & st1.Rows.Count).End(xlUp).Row 'サブネットマスクを取得しておく msk = st1.Range("W" & r1).Value 'デフォルトゲートウェイを取得しておく dgw = st1.Range("X" & r1).Value '第1オクテットをループする For ad1 = st1.Range("O" & r1).Value To st1.Range("P" & r1).Value '第2オクテットをループする For ad2 = st1.Range("Q" & r1).Value To st1.Range("R" & r1).Value '第3オクテットをループする For ad3 = st1.Range("S" & r1).Value To st1.Range("T" & r1).Value '第4オクテットをループする For ad4 = st1.Range("U" & r1).Value To st1.Range("V" & r1).Value 'ルーティング設定シートへ書き出す st2.Range("A" & r2).Value = ad1 st2.Range("B" & r2).Value = ad2 st2.Range("C" & r2).Value = ad3 st2.Range("D" & r2).Value = ad4 st2.Range("E" & r2).Value = msk st2.Range("F" & r2).Value = dgw r2 = r2 + 1 Next ad4 Next ad3 Next ad2 Next ad1 Next r1 End Sub
一旦2列に分割して、再度文字を連結しなおしている例です。 一時的に、A,B列が挿入されます。 オートフィルは、10行としました。 Sub sample() With Range("A1") .Resize(, 2).EntireColumn.Insert .Offset(, -2).Resize(, 2).Value = Split(.Value, ".") End With With Range("A1:B1") .AutoFill Destination:=.Resize(10), Type:=xlFillDefault For Each rng In .Resize(10, 3).Rows rng.Cells(3).Value = rng.Cells(1) & "." & rng.Cells(2) Next rng .EntireColumn.Delete End With End Sub
普通の話をしますけど、 普通、トランザクションって1件の追加ごとじゃなくて、複数処理の結果に対して掛けませんか？ だから For id as Interger = 0 Try Catch ex as OracleExcption Catch ex as Exception End Try Next id oTran.Commit() みたいな感じです。 個人的には、例外出たら全体をキャンセルする（＝Rollback）のが正しいと思うんですけどね。 まぁ、処理によるっちゃ、よるんでしょうが。 で、本題。ループの途中で例外を拾ってCommitの実行を判断したい。のであれば For id as Interger = 0 Try (insert) oTran.Commit() Catch ex as OracleExcption oTran.Rollback() Catch ex as Exception oTran.Rollback() End Try Next id こんな感じでしょう。近年のプログラミングであれば処理の途中で別のところに飛ばすのであれば処理ごと別に切り分け関数化しますよね。 同じプロシージャの中で分岐させるのであれば、エラーから飛ぶのではなく、エラー処理が終わった時に次の処理にそのまま進む。のが正しい。 今回は1ループごとにSQLを発行させエラーが出たらそのまま次の行に行きたいのであれば、ループの中でエラーを処理するしかない。
フォームにTextBox1とButton1とTimer1がある場合です。 Public Class Form1 Private counter As Decimal Private Sub Form1_Load(sender As Object, e As EventArgs) Handles MyBase.Load Button1.Text = "start" Timer1.Interval = 100 End Sub Private Sub Timer1_Tick(ByVal sender As Object, ByVal e As System.EventArgs) Handles Timer1.Tick counter += 0.1 TextBox1.Text = counter End Sub Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click If Button1.Text = "start" Then Button1.Text = "stop" counter = 0 Timer1.Enabled = True Else Button1.Text = "start" Timer1.Enabled = False If counter = 8 Then TextBox1.Text = "クリア" Else TextBox1.Text = "失敗" End If End If End Sub End Class
シートの内容がよくわからないので、とりあえず、省略抜きの書き方で。 Private Sub 入力_Click() Dim fm As Object Dim monthcolum As Long Set fm = ActiveSheet.Range("A3:R3").Find(What:=me.textbox1.Value, LookAt:=xlWhole) If fm Is Nothing Then MsgBox "月が正しくありません" Exit Sub Else monthcolum = fm.Column ～
あなたが意図している「該当セル」というのはシート１と休日シートのどちらを指しているのでしょうか？
Me!btn1.Enabled = ((Me!txt1.Value = Null And Me!txt2.Value = Null And Me!txt3.Value = Null) = false) これで行けるはず。 条件式の結果はTrue/Falseで帰ってくることが理解できれば行けるはず。 今回、ボタンが押せないのは全てがNullの時だから、条件式は「全てがNull では無い時」のみ利用可能＝Trueになるような式を書けばいい。
マクロの記録を改変しただけです。 Sub test() Dim rngY As Range Dim rngX As Range Set rngY = Sheets("sheet2").Range("A2:D2") Set rngX = Sheets("sheet2").Range("A1:D1") With ActiveSheet.ChartObjects.Add(50, 50, 300, 200).Chart .HasTitle = True .ChartType = xlLineMarkers .SetSourceData Source:=rngY .Location Where:=xlLocationAsObject, Name:="sheet2" .Axes(xlCategory).AxisBetweenCategories = False .SeriesCollection(1).XValues = rngX End With End Sub あまり綺麗ではありませんが、実行には支障ないと思いますがどうでしょうか？
Book1のSheet1、セル：A1が変換対象。 Book2のSheet1の A1セルに変換前の文字 B1セルに置換え後の文字 が入力されているものとします。 Sub sample() Dim rng As Range Set rng = Workbooks("Book2.xlsx").Worksheets("Sheet1").Range("A1") With Workbooks("Book1.xlsx").Worksheets("Sheet1").Range("A1") .Value = Replace(.Value, rng.Value, rng.Offset(, 1).Value) End With End Sub
With .Range(.Cells(2, 2), .Cells(Rows.Count, 2).End(xlUp)).SpecialCells(xlCellTypeConstants) 上記のコードで可能かもしれません。 基本的には、データの有り無しで判定するのが確実ですから、シートの設計を見直した方が良いと思います。
先ほど貴方の別の質問も拝見、回答したものです。 まず、先ほどリンクつけておいたMsgboxの使い方ページにもありますが、msgbox関数として返り値を求めるなら result = MsgBox ("You do not have a mind to do it?", vbYesNo + vbExclamation, "caution") でなくてはなりません。（質問文のコードではエラーになる） なお質問の件longに関しては、msgbox関数の返り値が整数値であるので、integerでもぶっちゃけ大丈夫です。 そして result=VbYes で比較する際のVbYesは定数として整数値が与えられているので、比較が成立するわけです。
MsgBoxではあらかじめ決められた種類のボタンしか表示させることは出来ません。 任意のボタンを表示させるのであればユーザーフォームでご自分で作る必要があります。
残念ながらUndoLimit プロパティが存在するのはWPF用のRichTextBoxだけです。 Windows フォームアプリケーション用のRichTextBoxには存在しません。 UndoClearメソッドを使ってもダメなのでしょうか？
一例です。 Private Sub CommandButton1_Click() Dim i i = Application.Match(TextBox1.Value, Columns(1), 0) If IsError(i) Then MsgBox "検索できません" TextBox2.Value = "" Else TextBox2.Value = Cells(i, 2).Text End If End Sub
基本的には「6行目のSheet１を変えるのですか？」という考えでいいと思います。 マクロ実行元のセルを指定するには以下の記述 ThisWorkbook.Worksheets("Sheet1").Range ("A1") 他のブックのセルを指定するには以下の記述 Workbooks("Book1.xlsx").Worksheets("Sheet1").Range("A1") こんな感じです。 ただし、この指定方法では参照するブックを予め開いておく必要があります。 つまり、「コマンドボタンを押したら参照するブックをオープンし、検索終了後閉じる」というコードを追加する必要があります。 実行に時間はかかりますが、これが一番確実かつ簡単な方法だと思います。 ブックを開くには Workbooks.Open "C:\Book1.xlsx" ブックを閉じるには Workbooks("Book1.xlsx").Close では頑張ってください。
下記のコードでいかがでしょうか。 マクロを記述したブックと同じフォルダの中のCSVファイルをすべて対象にします。 結合後のブックの名称は適宜修正してください。 Option Explicit Sub Sample() Const CatFileName As String = "結合後.xlsx" '結合後のブックの名称 Dim bkPath As String, bkName As String Dim bk As Workbook, st As Worksheet Dim r As Long, c As Long Dim fn As Integer Dim textLine As String Dim item As Variant Application.ScreenUpdating = False '結合後のブックを新規に作成する Set bk = Workbooks.Add Set st = bk.Worksheets(1) r = 1 'マクロを記述したブックと同じフォルダの中のCSVファイルをすべて対象にする bkPath = ThisWorkbook.Path & "\" bkName = Dir(bkPath & "*.csv") Do While bkName <> "" 'CSVファイルを開く fn = FreeFile Open bkPath & bkName For Input As #fn '一行目は読み飛ばす Line Input #fn, textLine Do While Not EOF(fn) '２行目以降を一行ずつ読み込む Line Input #fn, textLine '結合後のブックに書き出す c = 1 For Each item In Split(textLine, ",") st.Cells(r, c).Value = item c = c + 1 Next r = r + 1 Loop 'CSVファイルを閉じる Close #fn '次のCSVファイルを対象とする bkName = Dir() Loop '結合後のブックを保存する Application.DisplayAlerts = False bk.SaveAs bkPath & CatFileName bk.Close False Application.ScreenUpdating = True End Sub
>各CSVファイルの2行目～最終行までを取り込むようにしたい 取り込んだ直後の1行目を削除するのが簡単。 あと少し整理しています。 Sub putCsv() Dim csvFile As Variant, rng As Range Dim fIdx As Integer csvFile = Application.GetOpenFilename(FileFilter:="ＣＳＶファイル,*.csv", MultiSelect:=True) If IsArray(csvFile) Then For fIdx = LBound(csvFile) To UBound(csvFile) Set rng = Cells(Rows.Count, 1).End(xlUp) If rng.Value <> "" Then Set rng = rng.Offset(1) With ActiveSheet.QueryTables.Add(Connection:="TEXT;" & csvFile(fIdx), Destination:=rng) .TextFileCommaDelimiter = True .Refresh BackgroundQuery:=False rng.EntireRow.Delete End With Next fIdx End If End Sub
①についてはそれほど難しくはありません。 ②についてはやはり内訳表フォーマットのシートを用意したほうがいいですね。少なくとも外部に出す資料であればレイアウトや文字のフォント・色などもそれらしくした方がいいでしょうから。 もちろん、印刷したあとは内訳表フォーマットのシートは別ブックとして保存して、「印刷した証拠」を残すことも必要だと思います。
・項目１から項目9を具体的にどのセルに転記するのかが判らないので暫定的にA1からI1に転記すると仮定しています。 ・ユーザーフォームの項目１から項目９の入力用のテキストボックスはTextBox1からTextBox9という名前だと仮定しています。 ・ユーザーフォームの年月日のテキストボックスはそれぞれTextBoxYear、TextBoxMonth、TextBoxDayという名前だと仮定しています。 ・CommandButton1で「平成aa年n月.xls」を開きます。 ・CommandButton2でユーザーフォームからシートへ転記します。 ・CommandButton3でシートを上書き保存して閉じます。 Option Explicit Dim bkPath As String Dim bk As Workbook Dim st As Worksheet Dim locations() As String 'ユーザーフォームの初期処理 Private Sub UserForm_Initialize() '現在のフォルダ名を保持しておく bkPath = ThisWorkbook.Path & "\" '項目１から項目９の転記位置を設定する SetLocations '各テキストボックスの初期値を設定する InitControls End Sub '各テキストボックスの初期値を設定する Private Sub InitControls() Dim i As Integer '年月日の初期値を設定する TextBoxYear.Text = Year(Now) - 1988 TextBoxMonth.Text = Month(Now) TextBoxDay.Text = Day(Now) '項目１から項目９をクリアする For i = 1 To 9 Me.Controls("TextBox" & i) = "" Next i TextBoxYear.SetFocus End Sub 'シートを開くボタンがクリックされた時の処理 Private Sub CommandButton1_Click() Dim bkName As String '既にブックが開かれていたら何もしない If Not bk Is Nothing Then Exit Sub 'ブックが存在しなければメッセージを表示する bkName = "平成" & TextBoxYear.Text & "年" & TextBoxMonth.Text & "月" & ".xls" If Dir(bkPath & bkName) = "" Then MsgBox bkName & "が見つかりません。" TextBoxYear.SetFocus Exit Sub End If 'ブックを開く Set bk = Workbooks.Add(bkPath & bkName) '日シートをアクティブにする Set st = Nothing On Error Resume Next Set st = bk.Worksheets(Val(TextBoxDay.Text) & "日") On Error GoTo 0 If st Is Nothing Then Set st = bk.Worksheets("メイン") st.Select '入力ブックをアクティブにする ThisWorkbook.Activate 'ユーザーフォームの項目１にフォーカスを設定する TextBox1.SetFocus End Sub 'シートを閉じるボタンがクリックされた時の処理 Private Sub CommandButton3_Click() Dim result '入力ブックをアクティブにする ThisWorkbook.Activate 'ブックが開かれていなければ何もしない If bk Is Nothing Then Exit Sub '確認メッセージを表示する result = MsgBox("保存してよろしいですか？", vbYesNoCancel Or vbDefaultButton2) If result = vbCancel Then 'キャンセルならブックを閉じずに戻る TextBox1.SetFocus Exit Sub Else Application.DisplayAlerts = False 'Yesならブックを上書き保存する（Noなら保存せずに閉じる） bk.Close (result = vbYes) Application.DisplayAlerts = True End If Set st = Nothing Set bk = Nothing '各テキストボックスの初期値を設定する InitControls End Sub '項目入力ボタンがクリックされた時の処理 Private Sub CommandButton2_Click() Dim i As Integer 'ブックが開かれていなければ何もしない If bk Is Nothing Then Exit Sub 'アクティブなシートが日シートでなければ転記しない Set st = bk.ActiveSheet If st.Name = "メイン" Then Exit Sub '項目１から項目９を転記する For i = 1 To 9 SetValue locations(i - 1), Me.Controls("TextBox" & i) Next i 'メッセージを表示する DoEvents MsgBox "転記しました。" CommandButton3.SetFocus End Sub 'テキストボックスの内容をシートに転記する Private Sub SetValue(cell As String, data As String) On Error Resume Next st.Range(cell).Value = data On Error GoTo 0 End Sub '項目１から項目９の転記位置を設定する Private Sub SetLocations() 'ここでの設定は暫定的です。実際の転記位置に修正して下さい。 locations = Split("A1,B1,C1,D1,E1,F1,G1,H1,I1", ",") End Sub
以下のコードでコードを生成できます。 With ThisWorkbook.VBProject.VBComponents("Sheet1").CodeModule .AddFromString "Private Sub Test()" .AddFromString " MsgBox ""sample TEST""" .AddFromString "End Sub" End With ただし、実行するパソコンのExcelのセキュリティの設定を変更しておく必要があります。 ①「ファイル」→「オプション」を選択 ②「セキュリティ センター」を選択 ③「セキュリティ センターの設定」ボタンを押下 ④「マクロの設定」を選択 ⑤「VBA プロジェクト オブジェクト モデルへのアクセスを信頼する」チェックボックスをONにして「OK」ボタンを押下
お示しのコードは上手く実行されるのですよね？ ↓のような変更を行っても、上手くいかないのでしょうか？ Worksheets("P紙発行指示").Range(P数位置).Value _ = Application.RoundUp(画面_生産数 / P当りケース数, 0) ↓ With Worksheets("P紙発行指示").Range(P数位置) .Value = Application.RoundUp(画面_生産数 / P当りケース数, 0) .Value = .Value ＋２ End With 上手くいかないのなら、提示されてない他の部分の処理を疑うべきでしょう。
> 指定した2つの場所 これだけでコードを記述できたら凄いですね A.xlsm B.xlsm a | a a | a | 1 |123 a | a a | a | 2 a | a a | a | 3 b | b b | b | 4 |45 b | b b | b | 5 a | a a | a | 6 なら a | a a | a | 1 |1236 にするということで ・シートは 各ファイルの１つ目 ・比較データは A1 ～ Bxxx ・比較は、同じ行でどうなのか･･･ ・ファイルは開いていてもいなくても ・B ファイルは処理後保存して･･･ ・各ファイルは、開いていなかったら閉じる 以下を新規ファイルの標準モジュールに記述し、 ★ 部分のファイルパスを変更後実行してみます どうなりますか？ Public Sub Samp1()    Dim dic As Object    Dim vA As Variant, vB As Variant    Dim sS As String    Dim bV As Boolean    Dim i As Long, j As Long, k As Long    Const CSEP As String = vbTab    Const CFILE_A As String = "D:\Hoge\Moge_A.xlsm" ' ★    Const CFILE_B As String = "D:\Hoge\Moge_B.xlsm" ' ★    Set dic = CreateObject("Scripting.Dictionary")    Application.ScreenUpdating = False    With GetObject(CFILE_A)       With .Worksheets(1)          With .Range("A1", .Cells(.Rows.Count, "A").End(xlUp))             vA = .Resize(, 2).Value          End With       End With       If (Not .Windows(1).Visible) Then .Close False    End With    With GetObject(CFILE_B)       With .Worksheets(1)          With .Range("A1", .Cells(.Rows.Count, "A").End(xlUp))             k = .Rows.Count             If (k > UBound(vA)) Then k = UBound(vA)             With .Resize(k)                vB = .Resize(, 3).Value                For i = 1 To UBound(vB)                   If ((vA(i, 1) = vB(i, 1)) _                      And (vA(i, 2) = vB(i, 2))) Then                      vB(i, 1) = ""                      sS = vA(i, 1) & CSEP & vA(i, 2)                      j = dic(sS)                      If (j = 0) Then                         dic(sS) = i                         j = i                      End If                      vB(j, 1) = vB(j, 1) & vB(i, 3)                   Else                      vB(i, 1) = ""                   End If                Next                .Offset(, 3).Value = vB             End With          End With       End With       bV = .Windows(1).Visible       .Windows(1).Visible = True       .Save       If (Not bV) Then .Close False    End With    Application.ScreenUpdating = True    Set dic = Nothing End Sub
使い道があるか分かりませんが・・ ---------------------------------- Dim A As New Label A.Text = Label1.Text MessageBox.Show(A.Text) ---------------------------------- のような事ですか？
転記先のセルを行をずらすのでなく、列をずらしていけばいいだけですが？ なにか別に判らないことがあるのでしょうか？
下記でＱ＆Ａされています。 vbaから他のアプリを終了 http://oshiete.goo.ne.jp/qa/7220474.html
下記のコードでいかがでしょうか？ 出来るだけ処理内容が判るようなコメントを入れてありますので、不明点があれば返信してください。 Option Explicit Sub Sample() Dim bkPath As String, bkName As String Dim bk1 As Workbook, st1 As Worksheet Dim bk2 As Workbook, st2 As Worksheet Dim r1 As Long '画面の再描画を一時停止する Application.ScreenUpdating = False '抽出先のブックを新規に作成する Set bk1 = Workbooks.Add Set st1 = Worksheets("Sheet1") r1 = 1 'このブックと同じフォルダ内のすべてのブックを検索対象とする bkPath = ThisWorkbook.Path & "\" bkName = Dir(bkPath & "*.xls?") Do While bkName <> "" 'このブック自身は検索対象から除外する If bkName <> ThisWorkbook.Name Then '検索対象のブックを開く Set bk2 = Workbooks.Open(bkPath & bkName) '調査票シート以外は検索対象から除外する For Each st2 In bk2.Worksheets If st2.Name Like "*調査票*" Then '調査票シートのA1を抽出先のA列に抽出する st1.Range("A" & r1).Value = st2.Range("A1").Value '調査票シートのファイル名を抽出先のB列に抽出する st1.Range("B" & r1).Value = bk2.Name '調査票シートのシート名を抽出先のC列に抽出する st1.Range("C" & r1).Value = st2.Name r1 = r1 + 1 End If Next st2 '検索対象のブックを閉じる bk2.Close False End If bkName = Dir() Loop '画面の再描画を再開する Application.ScreenUpdating = True '抽出先のブックを保存する bk1.Close True End Sub
こんにちは。 確認したいのは、「エラー」になった行の手前で、1秒くらいのapplication.waitを実行したら、どんな変化があるか、です。 もし変化して、エラーにならないようなら、OSの動作に差があることが原因です。
これでどうかな? Sub AlignDataTo1Col() Dim lngRow As Long Dim lngCol As Long Dim strData As String Dim varData As Variant Dim lngLop As Long Dim rngOutPut As Range Dim ArrayOut, i As Long, xRow As Long i = (Selection(Selection.Count).Column - Selection(1).Column + 1) Mod 3 If i <> 0 Then Exit Sub If Selection.Resize(1, 3).Address <> Selection(1).MergeArea.Address Then Exit Sub ReDim ArrayOut(1 To Selection.Count / 3, 1 To 4) xRow = 1 For lngCol = Selection(1).Column To Selection(Selection.Count).Column Step 3 For lngRow = Selection(1).Row To Selection(Selection.Count).Row If Cells(lngRow, lngCol).MergeCells Then ArrayOut(xRow, 1) = Cells(lngRow, lngCol).Value ElseIf WorksheetFunction.CountA(Cells(lngRow, lngCol).Resize(, 3)) > 0 Then ArrayOut(xRow, 2) = Cells(lngRow, lngCol).Value ArrayOut(xRow, 3) = Cells(lngRow, lngCol + 1).Value ArrayOut(xRow, 4) = Cells(lngRow, lngCol + 2).Value xRow = xRow + 1 ArrayOut(xRow, 1) = ArrayOut(xRow - 1, 1) End If Next lngRow Next lngCol Set rngOutPut = Application.InputBox(Prompt:="出力先セルを指定してください。", Type:=8) rngOutPut.Resize(xRow - 1, 4).Value = ArrayOut End Sub 写真のデータで、最初のAが6セルマージされていますが、 3セルのマージに修正して実行してください。
ＰＣが高速化した事でウエイトが必要になったのかも？ エクセルのVBAで、Wait とか Sleep の使い方 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1467582304
エクセルのマクロ機能 毎回毎回お決まりのエクセル作業があって、簡単なんだけど超面倒、超大量、あーカッタルイなんて時に威力を発揮するのがマクロです。 やりたい作業をマクロに登録しておけば、後はマクロを起動するだけで高速かつ正確に処理されます。おおよそ手動で出来る作業は全部マクロに出来ます。 エクセルマクロを記述するために採用された言語が、Visual Basicです。エクセル向けにカスタマイズされてるので、Visual Basic for Applications略してVBAあるいはエクセルVBAと呼ばれてます。 現在のところ、エクセルマクロに用いられる言語はVBAです。近い将来、Javaに変更される可能性はないんじゃないの？推測ですけど。 マイクロソフトは、かつてマクロを止めようとした事があります。猛反発にあい撤回されたそうです。また、パワーポイントの記録マクロ（操作内容をマクロに記録する機能）が数年前に無くなりました。次バージョンで復活しましたが。本音では止めたがってます。要はマイクロソフトがやーメタ！と言ったらハイ終わりなのです。 エクセルにとってマクロは冒頭で述べた様に有用ですが、逆にマクロというかvisual basicにとってもエクセルは便利です。ちょっとかじった人なら誰でも知ってますが、コンピュータの計算は大きく3つに分かれてます。入力、主処理、出力。エクセルマクロでは、入力と出力を全部エクセルで引き受けてくれるので、主処理に集中出来ます。
FindのオプションでLookIn:=xlValuesを追加してみてください
はい、そうです。 以前の ＶＢは、オブジェクト指向とは言い難かったですが、 今の、.NET 系のものは、完全なオブジェクト指向言語になっています。
Findの指定範囲で、Rangeの中のRangeにシートの指定がありません。 そこだけアクティブシートのセルになるので、正しくFindされません。 Worksheets("DB").Range(Worksheets("DB").Range("A2"), mylastrange). _ Find(what:=myno, lookat:=xlWhole) としてみてください。
表示だけやったら、もっと簡単な方法もあるけど、何か加工したいならDIBSectionで、メモリコンテキストを作るのが一般的や http://www.sm.rim.or.jp/~shishido/dibsec.html
マクロを教えてほしいのであれば、ブック・シート・フォルダを正確に提示してください。 重複だと判断するためのルールも正確に提示してください。 そうでないと貴方が望む回答は絶対得られません。
＞どんなパソコンでも実行できる と聞くとJAVAがすぐ思いつきますが、 ＞HTA以外になにかありますでしょうか。 とのことで ＞Windows OS問わず とはWindowsのVerを問わずという意味でしょうか？ HTA参考： http://www.weblio.jp/content/.hta
以下のコードでいかがでしょうか。 Private Sub Worksheet_Change(ByVal Target As Range) If Target.Column = 3 Then L = Range("C" & Rows.Count).End(xlUp).Row If L > 29 Then MsgBox "20行を過ぎ、" & L & "行です" End If End If End Sub
こんな感じでどうでしょうか。 サンプルと同じデータが4つだけなら Sub Sample() Dim i As Long For i = 1 To 4 If Range("A" & i) = "人" Then Range("C" & i) = Range("B" & i) Next End Sub 最終行を自動で見つけて一括処理するなら Sub Sample2() Dim i As Long For i = 1 To Range("A" & Rows.Count).End(xlUp).Row If Range("A" & i) = "人" Then Range("C" & i) = Range("B" & i) Next End Sub
A列の最終行のセルからHA列までを選択すればよいのでしょうか。 Range("A" & Rows.Count).End(xlUp).Resize(,209).Select でどうでしょうか
R1,R2の指定を以下のように書き換えたらどうでしょうか？ With ActiveSheet With .Range(.Cells(2, 2), .Cells(Rows.Count, 2).End(xlUp)) R1 = .Address R2 = .Offset(0, 1).Resize(, 10).Address End With End With B列の2行目から最終行までの範囲を求めて、そのアドレスをR1へ設定。 さらに、その範囲を1列横に移動し、10列に拡張したアドレスをR2へ設定。 こんな感じのコードです。 参考まで。
黄色のセルならばxCntをカウントアップしているところに、別に用意した合計用の変数に値を加算します。 それから、xCntの値をセットしているところで、その右隣に合計用の変数の値をセットします。 （サンプル） Dim xRow As Range, xCnt As Long, i As Long '合計用の変数 Dim xTotal As Long With Range("A1:F5") For Each xRow In .Rows xCnt = 0 With xRow For i = 1 To .Columns.Count - 1 If .Cells(i).Interior.Color = vbYellow Then xCnt = xCnt + 1 '値を加算します xTotal = xTotal + .Cells(i).Value End If Next i .Cells(i).Value = Format(xCnt, "###") '右隣に合計をセットします .Cells(i).Offset(,1).Value = Format(xTotal , "###") End With Next xRow End With End Sub なお、テストはしていません。 セルの値が数値以外の場合の考慮もしていません。
たとえば３つコピーのある先頭の Worksheets("Sheet1").Range("Cells(1,4+num):Cells(MaxRow,4+num)").Copy Worksheets("Sheet2").Range("Cells(1,MaxCol+2+num):Cells(MaxRow,MaxCol+2+num)") ですが、Range()の中が""（ダブルクォーテーション）で括られていますので、文字列として「Cells・・」が認識されます。 それではセルを表す文字列としては正しくありません。 Worksheets("Sheet1").Range("Cells(1,4+num):Cells(MaxRow,4+num)") は Worksheets("Sheet1").Range(Cells(1,4+num), Cells(MaxRow,4+num)) となりますが、これでは中の Cells はアクティブシートのセルを表しているためエラーになる可能性があります Worksheets("Sheet1").Range(Worksheets("Sheet1").Cells(1,4+num), Worksheets("Sheet1").Cells(MaxRow,4+num)) が正しい書き方になりますが、これでは長すぎます Worksheets("Sheet1").Cells(1,4+num).ReSize(MaxRow) と ReSizeを使うことで、かなりシンプルになります。 またコピー先も同様ですが、コピー先は先頭のセルだけ指定すれば良いので Worksheets("Sheet2").Range("Cells(1,MaxCol+2+num):Cells(MaxRow,MaxCol+2+num)") ではなく Worksheets("Sheet2").Cells(1,MaxCol+2+num) で良いはずです。 したがって、３つのコピーを書き直すなら Worksheets("Sheet1").Cells(1, 4 + num).Resize(MaxRow).Copy Worksheets("Sheet2").Cells(1, MaxCol + 2 + num) Worksheets("Sheet1").Cells(1, 7 + num).Resize(MaxRow).Copy Worksheets("Sheet2").Cells(1, MaxCol + 3 + num) Worksheets("Sheet1").Cells(1, 12 + num).Resize(MaxRow, 4).Copy Worksheets("Sheet2").Cells(1, MaxCol + 4 + num) となります。（３つ目は、４列コピーなので ReSize(MaxRow, 4) あと、気になったのですが、MaxRow、MaxColを求めるところと、If で空白かどうかを確認しているところはシートを指定していないので、シート指定しておいたほうが良いと思います。 そして、MaxRow、MaxColを求めるときに最大行、最大列を固定で指定していますが MaxRow = Worksheets("Sheet1").Range("A" & Rows.Count).End(xlUp).Row MaxCol = Worksheets("Sheet1").Cells(1, Columns.Count).End(xlToLeft).Column としたほうが汎用的です （新しい形式では1,048,576行、16,384列（XFD列）まで使用できるので）
FolderFullPath = "C:\" + TreeView1.Text.Length を FolderFullPath = "C:\" + TreeView1.Text とすればエラーは出なくなります。 ですが、FolderFullPathを正しく設定するためには選択されているノードからルートまで辿ってフルパスを組み立てる必要があると思います。 更にコピー元が「C:\Test」と「C:\Test\Test」ではコピー先はどちらもTextBox1.Text\Testになってしまいますよね？ その場合はどうするつもりでしょうか？
単純に書くなら With ActiveSheet.Pictures.Insert(File) .Left = Selection.Left .Top = Selection.Top '幅の指定 .Width = 13.34 '高さの指定 .Height = 10 '最背面に移動 .ShapeRange.ZOrder msoSendToBack End With となります。 幅、高さの単位はポイントなので、13.34ポイント、10ポイントなら上記で良いのですが、他の単位ならば変換が必要になります。 たとえば13.34cm、10ｃｍなら '幅の指定 .Width = Application.CentimetersToPoints(13.34) '高さの指定 .Height = Application.CentimetersToPoints(10)
ちょっとやってみました。 多分、 売上データ読込 という名前のワークシートが見つからないというエラーです。 それから、 Set ws = Sheets("売上データ読込").Select ではなく、 Set ws = Sheets("売上データ読込") ws.Select と書かないと、オブジェクトが必要ですというエラーになります。
まず最初のmsgboxはメッセージを出しただけのステートメントで終了しており、IfのvbYesは一定です。 http://officetanaka.net/excel/vba/function/MsgBox.htm 変数にMsgbox関数としての応答を格納してIfで分岐させなければなりませんよ。 私の環境では質問文のエラーは再現しませんでした。 使用のExcelとOSのバージョンを提示してはいかがでしょうか。
チェックボックスには 3値( True / False / Null )があって、 既定値の設定がない場合 Null で、灰色の四角だったと思います まず、既定値を設定してみます それでもダメなら、Form_Load とかで True / False を設定するとか･･･ チェックを入れると･･･なので、更新後処理を使います 以下雰囲気で Private Sub Ctl1号機_AfterUpdate()    If (Me!Ctl1号機) Then       Me!btn設定1.Caption = "設定"    Else       Me!btn設定1.Caption = "未設定"    End If End Sub
部分的ですが、 解釈する文字列は入手済みということで、雰囲気以下でどうなりますか Public Sub Samp1()    Dim sS As String    Dim v As Variant    Dim i As Long    sS = "<div id='address-box'>" _       & "<div class='formBox ResultBox'>" _       & "<ul class='clearfix'>" _       & "<li class='ResArea'>" _       & "<div class='fs16'>" _       & "<p>〒XXX-YYYY</p>" _       & "<p>東京都●●３丁目</p>" _       & "<p class='Icontel'>03-****-1111</p>" _       & "</div>" _       & "</li>" _       & "<li class='IconArea'>" _       & "<img src='../images/icon_home.png' width='100%'>" _       & "</li></ul>"    v = Split(sS, "</p>")    For i = LBound(v) To UBound(v) - 1       Debug.Print Mid(v(i), InStrRev(v(i), ">") + 1)       Debug.Print Mid(v(i), InStrRev(v(i), "<p")) & "</p>"    Next End Sub
Ｗクリックキャンセルを追加しては如何でしょうか。 Private Sub ～ Cancel = True
RやCは、A1とは異なるセル指定形式です。Rが行、Cが列を表わしており、F5ならば、R5C6と同じとなります。 そして、R[-1]C[3]のような括弧付きで行列数を指定した場合、相対参照となります。前述の例で言えば、記述したセルから上に1行、右に3列進んだ位置になります。
条件があいまいなのでマクロを提示出来ません。 ・対象となるシートはブックに存在するすべてのシートですか？ ・対象となるセルの範囲は？ ・「20項目くらい」と書かれても条件が特定できません。対象となる項目を確実に抽出できる具体的かつ正確な条件を提示して下さい。 ・変換のルールは対象となる項目の末尾の数字を抜き出して「円」を追加する、で本当によろしいのですか？
抽出したい項目がセルで指定できるなら、単純に以下のような関数で対応するのが簡単です。 指定したい項目名をA1セルから右に入力し、B1セルに以下の式を入力し下方向および右方向にオートフィルします。 =INDEX(Sheet1!$A:$CZ,ROW(2:2),MATCH(A$1,Sheet1!$1:$1,0)) Alt、T、Oのショートカット操作でExcelのオプションを表示し「詳細設定」から次にシートで作業するときの表示設定で「ゼロ値のセルにゼロを表示する」のチェックを外します。 １行目の項目を変更すれば自動的に２行目以下にデータが表示されます。
①開発担当者すべてが閲覧・編集できる共有フォルダにアプリケーションAのソリューションフォルダを作成します。 ②ソリューションの下に各自の開発担当のフォームのプロジェクトを作成します。 ③ソリューションの下にアプリケーションAのプロジェクトを作成します。 ④アプリケーションAのプロジェクトに各自のform1、form2、form3を「リンクとして追加」します。
ExcelのVBAではUTF-8で書かれたテキストファイルを扱うことは出来ません。 Excelで処理する前にフリーのテキストツールでUTF-8からShift-JISかUnicodeに変換すればExcelのVBAで扱うことが出来るようになります。 ツールはGoogleなりYahoo!なりで「utf-8 変換ツール」で検索するとたくさんヒットします。
サンプルプログラムはせめてコンパイル通る状態にしましょうよ。 いろいろ抜けがあるため、コレが実際に動くかどうかはわかりませんが MSTTableのデータを全件読み込むという動きを期待してると思います。
こんにちは。 本来は、メールの最初の部分を解析して、必要ならば 文字列の変換が必要です。 basp21では Kconvメソッド 文字列を指定した漢字コードに変換します。 変換前の漢字コードのタイプが不明の場合、自動認識します。 out = bobj.Kconv(instr,outtype[,intype]) 引数 instr [in] : 変換したい文字列（UNICODEの場合）、またはバイト配列。 outtype [in] : 変換後の漢字コードのタイプを数字で指定します。 0 - 変換せずに漢字タイプを数字で返します 1 - SHIFT JIS 2 - EUC 3 - JIS 4 - UNICODE UCS2 5 - UNICODE UTF8 intype [in] : 変換前の漢字コードのタイプが確定しているとき数字で指定します。 0 - 不明（省略値）。自動認識します。 1 - SHIFT JIS 2 - EUC 3 - JIS 4 - UNICODE UCS2 5 - UNICODE UTF8 out [out] : 変換後の漢字コードを文字列（UNICODEの場合）あるいはバイト配列で 返します。 outtype = 0 なら漢字のタイプを数字で返します。 解説 次のような場合、漢字コードの自動認識が失敗することがあります。 o SHIFT JISで半角カナのみ o 漢字文字数が少ない o UNICODE UTF8 使用例 jisarray = bobj.Kconv("馬場",3) ' UNICODE UCS2からJISに変換 outcode = bobj.Kconv(jisarray,4) ' JISからUNICODE UCS2に変換 関連項目 KconvFileメソッド による、変換の関数があるので、これを使って、エクセルのセルに設定してください。 メーラーによって、メールの文字化けが発生するのは、メールの仕様の範囲です。 BASPでも、その対応は、プログラムによる対応でするようになっています。
一例です。 挿入や削除は行降順にした方がよい。 Sub テスト() Dim i As Long With Worksheets("作業シート") Sheets("見出し").Range("A6:AM7").Copy For i = .Cells(Rows.Count, "B").End(xlUp).Row To 1 Step -1 If .Cells(i, "j") = "001" Then Sheets("見出し").Range("A6:AM7").Copy .Cells(i, "j").Insert End If Next End With End Sub
>エラーが出ないようにするにはどこを直した方がいいですか? > >/* ランダム文字列を生成する*/ コンパイル、実行して現象が再現するソースを載せること。 どのような結果を期待して、 何処で、どの様なエラーが出るのか、を書くこと。 エラーメッセージは省略せずにかくこと。
こんにちは。 現在のマクロを知らせてください。 うまく出来ない原因をみてみたほうがいいです
Me!bottom1.Caption=""
Y列だけ自動調整する、ということはできないので、最初に対象行をすべて自動調整してから、34.75未満の行だけ34.75にするという考え方。 Sub RHAdj() Dim St As Worksheet, Lr As Long, C As Long For Each St In Worksheets Lr = Range("A" & Rows.Count).End(xlUp).Row Rows("3:" & Lr).AutoFit For C = 3 To Lr If Rows(C & ":" & C).RowHeight < 34.75 Then Rows(C & ":" & C).RowHeight = 34.75 Next C Next St End Sub
命名規則として Form_f○○ としているのなら、「棚札」フォームには f がありません。 Form_f出庫.GetSyouhin Form_棚札.GetSyouhin
MSDNのLike演算子のヘルプ https://msdn.microsoft.com/ja-jp/library/office/gg251796(v=office.1... 「特殊文字の左角かっこ ([)、疑問符 (?)、シャープ記号 (#)、およびアスタリスク (*) と一致させるには、それらを角かっこで囲みます。」とあります。 If Cells(1, 1).Value Like "*[[]*" Then としてみて下さい。
型指定されていないデータセットへの新しいレコードの挿入 https://msdn.microsoft.com/ja-jp/library/5ycd1034.aspx が参考にならないかな？ 通常はTableAdapterとか使って、型付きデータセットへ入れるけどね https://msdn.microsoft.com/ja-jp/library/ms233822.aspx .NETは、DBへのアプローチのしかたが沢山あって、初心者にはわけがわからんかも。たくさんあるように見えて、高レベルのアプローチは、内部的に低レベルのアプローチでコードが自動生成されているだけなんだけどね。
こんにちは。 ボタンのクリックイベントに v1 = me.textbox1.value 'ファイル名 vpath = thisworkbook.path Me.Image1.Picture = LoadPicture(vpath & "\" & v1) だいたい、こんなかんじです
以下のコードでいかがでしょうか？ 条件にあいまいな点があるので多少冗長な処理になっています。 Option Explicit Sub Sample() Dim st1 As Worksheet, st2 As Worksheet Dim r1 As Long, r2 As Long Set st1 = Worksheets("Sheet1") Set st2 = Worksheets("Sheet2") r2 = IIf(st2.Range("D6").Value = "", 6, st2.Range("D" & Rows.Count).End(xlUp).Row + 1) r1 = 2 Do While st1.Range("M" & r1).Value <> "" Or st1.Range("N" & r1).Value <> "" Or st1.Range("O" & r1).Value <> "" st2.Range("D" & r2).Value = st1.Range("M" & r1).Value & st1.Range("N" & r1).Value & st1.Range("O" & r1).Value r2 = r2 + 1 r1 = r1 + 1 Loop End Sub
アクティブシートならば Range("G5:AI5").Interior.Color = Range("A5").Interior.Color
Sub 一例です() Dim i As Long, xBk As Workbook Const cPath As String = "C:\AAA\BBB\" With ActiveSheet Set xBk = Workbooks.Add For i = 2 To .Cells(Rows.Count, 1).End(xlUp).Row With .Cells(i, 1) xfld = Dir(cPath & .Value, vbDirectory) If xfld = "" Then MkDir cPath & .Value End If Application.DisplayAlerts = False xBk.SaveAs cPath & .Value & "\" & .Offset(, 1).Value Application.DisplayAlerts = True End With Next i xBk.Close End With End Sub
※文字数オーバーの為、再投稿します。 修正しました。試してみてください。 Sub Sample() Dim i As Long Dim j As Long Dim Cnt As Long Dim LastRow As Long Dim Sh As Worksheet Dim NewSh As Worksheet Set Sh = ActiveSheet With Sh LastRow = .Cells(.Rows.Count, "A").End(xlUp).Row If LastRow < 6 Then MsgBox "データがありません。", vbOKOnly + vbCritical Set Sh = Nothing Exit Sub End If End With Application.ScreenUpdating = False With ThisWorkbook Set NewSh = .Worksheets.Add(After:=.Worksheets(.Worksheets.Count)) End With With Sh .Range(.Cells(6, "C"), .Cells(LastRow, "C")).ClearContents NewSh.Range("A1") = "品種" NewSh.Range("B1") = "件数" NewSh.Range("C1") = "番号" For i = 6 To LastRow If .Cells(i, "B") = "生" Then On Error Resume Next j = Application.WorksheetFunction.Match(.Cells(i, "A"), NewSh.Columns("A"), 0) If Err.Number <> 0 Then Err.Clear j = NewSh.Cells(NewSh.Rows.Count, "A").End(xlUp).Row + 1 NewSh.Cells(j, "A") = .Cells(i, "A") End If NewSh.Cells(j, "B") = NewSh.Cells(j, "B") + 1 On Error GoTo 0 End If Next End With With NewSh LastRow = .Cells(.Rows.Count, "A").End(xlUp).Row If LastRow < 2 Then Application.DisplayAlerts = False NewSh.Delete Application.DisplayAlerts = True Sh.Activate Set NewSh = Nothing Set Sh = Nothing Application.ScreenUpdating = True MsgBox "[番号]を付与する品種がありません。", vbOKOnly + vbCritical Exit Sub End If Cnt = 90001 For i = 2 To LastRow If .Cells(i, "B") > 1 Then .Cells(i, "C") = Cnt Cnt = Cnt + 1 End If Next End With With Sh LastRow = .Cells(.Rows.Count, "A").End(xlUp).Row For i = 6 To LastRow If .Cells(i, "B") = "生" Then On Error Resume Next j = Application.WorksheetFunction.Match(.Cells(i, "A"), NewSh.Columns("A"), 0) If Err.Number <> 0 Then Err.Clear Else If NewSh.Cells(j, "C") <> "" Then .Cells(i, "C") = NewSh.Cells(j, "C") End If End If On Error GoTo 0 End If Next End With Application.DisplayAlerts = False NewSh.Delete Application.DisplayAlerts = True Sh.Activate Set Sh = Nothing Set NewSh = Nothing Application.ScreenUpdating = True MsgBox "処理しました。", vbOKOnly + vbInformation End Sub
> App.DoCmd.OpenQuery "クエリ名" この後、表示したものをどうするのでしょうか？ 操作等わかりませんが、 その VBA を記述している側のクエリで、以下記述してみてどうですか？ （クエリの SQL ビューで） SELECT * FROM クエリ名 IN '外部ファイルのパス名'; ※ FROM の後ろの クエリ名 は、外部ファイルにあるクエリ これで良さそうなら、このクエリでサブフォーム組み込みするとか･･･
まず、普通にフォームを作成した場合、フォームの中のコントロールはPrivateなのでForm2.PictureBox1～といった聞き方は出来ません。 PuctureBoxのModifiersプロパティをPublicに設定すれば可能になりますが、オブジェクト指向プログラミングの観点からはあまりお勧めできません。 オブジェクト指向プログラミングではフォームの中のコントロールの判断・操作はフォームクラスの中でだけ行うことが基本です。 画像の有無の判定については If PictureBox1.Image Is Nothing Then でどうでしょうか？ TextBoxの内容判定については 「あ」とだけ書かれているとき、という判定は If TextBox1.Text = "あ" Then 「あ」という文字が含まれているとき If TextBox1.Text.Contains("あ") Then 入力内容が「あ」で始まるとき If TextBox1.Text.StartsWith("あ") Then 他にも判断のパターンはありますが、詳しくはStringクラスのメソッドのヘルプを参照してください。
簡単なところでは、変数を使わずnameプロパティを変更 ’例) Sheets(7).Name = Cells(3,1) & "(" & Cells(3,2) & ")" ただしこのCellsオブジェクトが親を省略しているので、Activesheet依存であることを念頭にしておいてください。別のシートで実行する場合予期せぬ結果を招きかねません。 その２ ループ構文の利用 ループ回数が完全に固定なら固定で、変動するならそれなりになりますが、まずは前者で。 dim i as integer for i = 3 to 33 Sheets(i+4).Name = Cells(i,1) & "(" & Cells(i,2) & ")" next i iには最初3が代入され結果７番シート、セルの行数も3が代入され、ループは指定なしなので1ずつプラスされていきます。 いかがでしょう？
下記のコードでいかがでしょうか。 Option Explicit Private Sub UserForm_Initialize() ListBox1.ColumnCount = 5 ListBox1.ColumnWidths = "1cm;1cm;1cm;1cm;1cm" End Sub Private Sub TextBox1_Change() SetList End Sub Private Sub TextBox2_Change() SetList End Sub Private Sub TextBox3_Change() SetList End Sub Private Sub TextBox4_Change() SetList End Sub Private Sub TextBox5_Change() SetList End Sub Private Sub SetList() ListBox1.Clear ListBox1.AddItem TextBox1.Text ListBox1.List(0, 1) = TextBox2.Text ListBox1.List(0, 2) = TextBox3.Text ListBox1.List(0, 3) = TextBox4.Text ListBox1.List(0, 4) = TextBox5.Text End Sub
>エクセルVBAでマクロ有効シートをコピーして新しいブックを作るマクロ マクロを使っているシートをコピーしたのか、それともマクロ有効ブックそのものをコピーしているのか不明ですね。 仮に、マクロを使っているシートだけを新しいブックにコピーした場合、標準モジュールのプロシージャはコピーされませんが、シートモジュールのプロシージャはコピーされます。 >VBAでマクロ有効シートをコピーする事は出来るのでしょうか？ 丸ごとブックをコピーして、不要なシートを削除すれば済むことです。わざわざマクロを組む必要はないかな。
取得できる場合とそうでない場合があるということであれば、 imgURL = objIE.document.images(25).srcが正しく取得できているかどうかの 結果を事前にMsgbox(imgURL = "http://sample.jpg")などで確認したほうがよいかとおもいます。 またobjIE.document.images.lengthで画像の個数を調べることができるので for i=0 to objIE.document.images.length ･･･画像の判別処理 （objIE.document.images(i).srcを使う） next i などで25番目が存在するかどうかも確認したほうがよいかもしれませんね。 objIEの読み込み処理が完了していない状態であったり、 document.images(25).srcが空白やDOMの構築が正常にされていない状態であったりすると result = URLDownloadToFile(0, imgURL, savePath, 0, 0) を行ってもダウンロードができないことがあるかと思いますが、 不具合が起きる際の resultおよびimgURLの結果は正常でしょうか？
数式の例です。 A1に「=IF(ISBLANK(A1),"",ROW())」とし、下方向へフィル マクロを使った例です。 Sub Sample() Dim i As Long, n As Integer n = 1 For i = 1 To Range("A" & Rows.Count).End(xlUp).Row Range("B" & i).Value = n n = n + 1 Next End Sub
こんにちは。 出来上がったコード、よく確認してください。 「参照設定」が必要というのですと、どこかのオブジェクトで、エクセルが接続してある、ということです。 ユーザーが自分で作成したコードの場合、参照設定を使わないでコードは、作成できます。 一度参照設定で、コードを作成し、オブジェクトブラウザーで数値をさがしたり、newの命令を置き換えるなどで、対応します。 VBSコードを作成する手順で、参照設定の切り離しをするのでそこらの資料も参考になります。 あとは、「システムのお便利、変換機能」を使っているのが原因でしたら、代替コードの作成、などです。 アクセスは単体起動でエクセルの参照設定はありません。 つまり、利用しているオブジェクトが存在しているということですよね。 参照設定は、環境が単一でしたら、トラブルは少ないのですが、バージョンの違いがあると、足かせになってしまうので、設計ではよく注意するものなんです。
C1のセルをアクティブにして 条件付き書式の 数式を使用して、書式設定するセルを決定を選ぶ 式は =C1>D1 とし 書式で青を選択 そして条件付き書式の ルールの管理から適用先を =$C:$C とします。 後は同様です。
画像に[pic1]という名前を付けて、[pic1]を削除しているので画像は残りません。 画像を選択していない時の処理は不要な気がします。やるのであれば、シートに画像を張り付けておき、表示・非表示を切り替えるほうがよい気がします。 また、画像を読み込んで、セル範囲でコピー後元画像を削除するのも不要だと思います。尚、保存時の容量の問題であれば、保存時のオプションで画像の解像度を指定することで回避できると思います。 サンプルコードを示しておきます。 私はOption Explicitを有効にしているので、変数の宣言が必要となっています。 環境によっては、Dimの部分はなくても動きますが、なるべく宣言はしたほうがよいと思います。 以上、参考まで。 Private Sub CommandButton1_Click() Dim x As Single, y As Single '挿入位置座標 Dim x2 As Single, y2 As Single '画像の幅・高さ Dim fName As String '選択画像のパス Dim pName As String 'キャンセル時の画像名 Dim pPath As String 'キャンセル時の画像のパス Dim 画像 As Variant '画像オブジェクト Dim flg As Boolean '画像選択フラグ 'キャンセル時の画像設定 pName = "pic1" pPath = ActiveWorkbook.Path & "\no_photo.jpg" x = ActiveCell.Left y = ActiveCell.Top 'セル範囲 With Range(Cells(4, ActiveCell.Column), Cells(22, ActiveCell.Column)) .Select x2 = .Width y2 = .Height End With fName = Application.GetOpenFilename("画像ファイル,*.gif;*.jpg;*.bmp", 1, "画像ファイルを指定して下さい") flg = True '画像選択あり If fName = "False" Then flg = False '画像選択なし fName = pPath End If On Error Resume Next 'エラー無視 ActiveSheet.Shapes(pName).Delete On Error GoTo 0 Set 画像 = ActiveSheet.Pictures.Insert(Filename:=fName) With 画像 If flg = False Then '画像選択なし .Name = pName End If .ShapeRange.LockAspectRatio = True '比率変換 .Placement = xlFreeFloating .ShapeRange.ScaleHeight 1, True'なくても良いと思う .ShapeRange.ScaleWidth 1, True'なくても良いと思う .Left = x .Top = y .Width = x2 .Height = y2 End With End Sub
質問の中でピポットの部分が不明なので図のシートがアクティブな場合です。 また質問の説明ではComboBox2は変更されても他には影響しません。 'あるコンボボックス内に指定文字列のデータがあるかどうかを判定する関数 Function isExists(combo As ComboBox, str As String) As Boolean Dim i As Integer isExists = True '答えをありにする(あったらすぐ抜けるので) For i = 0 To combo.ListCount - 1 'コンボのデータを順に If combo.List(i) = str Then Exit Function 'リストが指定文字列なら終わり(答えはTrue) Next isExists = False '最後までなかったので答えを無しにする End Function '初期設定(ComboBox1設定) Private Sub UserForm_Initialize() Dim lastRow As Long Dim r As Long lastRow = Range("A" & Rows.Count).End(xlUp).Row 'A列最終行 For r = 4 To lastRow '注目行を4行目からA列最終行まで If Not isExists(ComboBox1, Range("A" & r).Value) Then 'ComboBox1にA列注目行の値が無かったら ComboBox1.AddItem Range("A" & r).Value 'ComboBox1にA列注目行の値を追加 End If Next End Sub 'ComboBox1が変更された時 Private Sub ComboBox1_Change() Dim lastRow As Long Dim r As Long lastRow = Range("A" & Rows.Count).End(xlUp).Row 'A列最終行 ComboBox2.Clear 'ComboBox2クリア ComboBox3.Clear 'ComboBox3クリア(この時ComboBox3_Changeイベントが起こってComboBox4は初期化される) For r = 4 To lastRow '注目行を4行目からA列最終行まで If Range("A" & r).Text = ComboBox1.Value Then 'A列注目行の値がComboBox1の値なら If Not isExists(ComboBox2, Range("B" & r).Value) Then 'ComboBox2にB列注目行の値が無かったら ComboBox2.AddItem Range("B" & r).Value 'ComboBox2にB列注目行の値を追加 End If If Not isExists(ComboBox3, Range("C" & r).Value) Then 'ComboBox3にC列注目行の値が無かったら ComboBox3.AddItem Range("C" & r).Value 'ComboBox3にC列注目行の値を追加 End If End If Next End Sub 'ComboBox3が変更された時 Private Sub ComboBox3_Change() Dim lastRow As Long Dim r As Long lastRow = Range("A" & Rows.Count).End(xlUp).Row 'A列最終行 ComboBox4.Clear 'ComboBox4クリア For r = 4 To lastRow '注目行を4行目からA列最終行まで If Range("A" & r).Text = ComboBox1.Value Then 'A列注目行の値がComboBox1の値なら If Range("C" & r).Text = ComboBox3.Value Then 'C列注目行の値がComboBox3の値なら ComboBox4.AddItem Range("D" & r).Value 'ComboBox4にD列注目行の値を追加 End If End If Next End Sub
こんにちは。 BASP21は、最新のOSの対応、64bitの使い方、など、有料バージョンでサポートありますよね。 「アップデート」が必要というのは、「プログラムの完成度が低い」対策、と、機能を追加する、というのと、理由はあります。 BASPの場合、メーラーの機能として、「ここまでの機能」という部分では、すでに完成していて、脆弱性の問題も、ずっと前に対策したきりです。 それこそ、「機能を追加し続けて、脆弱の危険と向き合っている」という立場のアプリと、「メモ帳」のように、機能はそこそこ、で、脆弱の心配の無いものと、混ぜて考えてはいけないということです。 メーラーのデータ処理でとりわけ、文字コードが複雑なメールの取り扱いは、データを処理する中では大変なんですが、BASP21は、関数は確かに存在するのですけど、ユーザーが期待する、100%間違いの無い変換、というのは、しません。 メールを扱うプログラム側で、「ここからここまでを処理」と、小刻みに処理する必要があります。 一応、仕様ということにしてますけどね。 普通に使っているメーラーでさえ、「エンコードの切り替え」があるくらいですから、提供されるアプリが全部正しく処理してくれる、なんてことは、当分考えられません。 メールプロトコルの仕様では、限界でしょう。 BASPで、もし改善されるとしたら、の話です。 話を戻しますが、BASPの有料版を検討してみてください。 メーカーの会社に、有料サポートしてもらったらいいかと。
.Valueを.Textに変更。 Do While Workbooks("xxxxx.xlsm").Sheets("xxxx").Range("xx").Text = "#VALUE!" And Workbooks("aaaaa.xlsm").Sheets("aaaa").Range("aa").Value <> Workbooks("xxxxx.xlsm").Sheets("xxxx").Range("yy").Value
こんにちは。 このコードは、シートのコードですから、コードを確認して、「別のシート」に使っている部分を、修正し、シート名は指定しないようにしてください。 changeのイベントは、valueが変化したときなので、イベント抑制はしないでやってみてください。 エラー処理ですが、一旦設定しないで作ってみてください
まずは構想を練る？ カードとは何を指すのか？ 仮に３枚のカードから始め正否による処理の違いを決める 等プログラム以前の不明確(あなたがやりたいこと)な部分が多過ぎると感じませんか？
質問文を何度読んでも状況が全く分かりません。 何を回答すれば良いのでしょうか？ >visual studio2015でちゃんと合っているはずなのに沢山のエラーがでてきます ・「Visual Basic」のカテなので「Visual Basic」の言語で良いのでしょうか？ ・何がちゃんと合っているのでしょうか？ ・合っている「はず」とは、どういう事でしょうか？ ・たくさんのエラーとはどんなエラーなのでしょうか？（コードや内容は？） ・あなたは何をやっているのでしょうか？（作業内容不明） >そういう場合どうすればいいですか？ ・そういう場合とは、どういう場合でしょうか？ 状況が全く分かりません。 >拡張とかって関係あるのですか？ ・「拡張」って何ですか？ ※情報がゼロなので回答は不可能かと思います。
こんにちは。 ・a～c or d列までの1行目に記載されている文字と同じ文字を各sample*の1行目で検索し同じものを別excelの2行目以降に貼り付け ここが、全くイメージが伝わりません。 1行目を「見出し」といいます。1行目に記載している文字は、まさに、見出しそのものなんですから、データ部分に、あるはずが無いです。 検索する、ということなんですから、「何の文字」を、どの列から、探す、というような言い方にならないといけません。 テーブルから探す、という場合、「どの列」「どの文字列」をさがし、見つけたときのコピーの範囲を、「どこに」まで、説明が分からないといけません。 もし、そんなふわーーーっとした質問が文章になっている書籍だったら、徹底的に作者に文句をいわないといけません。 もし、それを教材にしている先生がいたら、生徒の読解力をテストしたいんですか、と質問してください シート名を使って、読込みさせるブックを開くまでは、コードにするのは難しくありません。 問題は、開いたブックのシートのデータを扱う部分です。 検索という場合、「検索のキーワード」は、どの列か、見つけた処理、見つけられない処理、そして、「見つけた場合の転記元」と「転記先」をしっかり把握です。 転記先の説明も、ふわーーっとしているんですよ。どのブック、どのシート、どの行、まで、把握してください。 データの説明で、見出しがあるのか、ないのか、も、よく確認してください。
どれがいいとの具体的な書名はありませんが、いわゆる教科書的な本と、辞書のように何でも載ってる本があります。 どちらを求めるのかハッキリしてから探すと、探しやすいです。
I列までですね（確認）。 Sub test() Dim i As Long, j As Long, n As Long Dim Emp(3) As Long For i = 1 To Cells(Rows.Count, 11).End(xlUp).Row For j = 6 To 9 If Cells(i, j) = "" Then Emp(j - 6) = j Else: Emp(j - 6) = 99 End If Next n = WorksheetFunction.Min(Emp) If n <> 99 Then Cells(i, n) = Cells(i, 11) Erase Emp Next End Sub でどうですか？
下記のコードでいかがでしょうか。 Sub Sample() Dim r As Long, n As Integer Dim st As Worksheet n = 1 With Worksheets(1) For r = 1 To .Range("A" & .Rows.Count).End(xlUp).Row Step 35 Set st = Worksheets("案内表" & IIf(n = 1, "", n)) .Range("A" & r).Resize(35, 10).Copy st.Range("A1") n = n + 1 Next End With End Sub
下記のコードはあなたのマクロをSheet1,Sheet2,Sheet3で連続的に実行するものです。 Option Explicit Sub Sample() Dim stNames As Variant, stName As Variant, st As Worksheet stNames = Array("Sheet1", "Sheet2", "Sheet3") For Each stName In stNames Set st = ActiveWorkbook.Worksheets(stName) st.Columns("H:H").Select st.Sort.SortFields.Clear st.Sort.SortFields.Add Key:=st.Range("H1"), _ SortOn:=xlSortOnValues, Order:=xlDescending, DataOption:=xlSortNormal With st.Sort .SetRange st.Range("A1:AN997") .Header = xlNo .MatchCase = False .Orientation = xlTopToBottom .SortMethod = xlPinYin .Apply End With Next End Sub 実行したいシートを変更するときは「stName = Array("Sheet1", "Sheet2", "Sheet3")」を変更して下さい。
>B1 <C1だと時間はくらべられないのでしょうか？ 日付型（シリアル値）のデータ同志なら、問題ないです。 他の型も考慮に入れるなら、 If CDate(Range("B1").Value) < CDate(Range("C1").Value) Then といった操作になりますね。 あと余談ですが、 値を日付変換可能かどうかは、 If IsDate(Range("B1").Value) Then MsgBox "日付に変換できるデータです" End If といった書き方で検査可能です。
テーブルを扱うときはクラスを作ります。 InsertだけでなくSelectの時には返ってくるレコードセットが複数行の時がありますよね？ そういうときはクラスのリストで扱う方がプログラムもすっきりしますし、グリッドへセットするときもシンプルになります。 なによりクラス（構造体）を使ってデータ構造をカプセル化することがオブジェクト指向プログラミングの基本ですから。 蛇足ですが私個人は殆どの場合「配列」ではなく「List( Of T)」を使っています。 Listを使えばReDimする必要はありませんし、ContainsやClearなど便利なメソッドもあるからです。
下記のコードでいかがでしょうか。 ただし ①日付に関しては何がしたいのか理解しきれていないので「システム日付（ただし土日の場合は翌月曜日）」を設定しています。 ②A列がクリアされたときにはB列からD列もクリアしています。 ③C列およびD列は数式を設定しています。 ④「理想は～」については仕様が理解できなかったので実装していません。 Option Explicit Private Sub Worksheet_Change(ByVal Target As Range) Dim rng As Range Dim r As Long Dim dt As Date, wd As Integer For Each rng In Target.Cells '変更されたセルがA列の2行目以降のときだけ実行する If rng.Column = 1 And rng.Row >= 2 Then Application.EnableEvents = False If rng.Value = "" Then 'A列がクリアされたらB:Dもクリアする rng.Offset(, 1).Resize(, 3).ClearContents Else r = rng.Row 'B列にシステム日付を設定する（ただし土日の場合は翌月曜日を設定する） dt = Date wd = Weekday(dt, vbMonday) If wd >= 6 Then dt = DateAdd("d", 8 - wd, dt) End If Range("B" & r).Value = dt 'C列に曜日を表示するための数式を設定する Range("C" & r).FormulaR1C1 = "=TEXT(RC[-1],""aaa"")" 'D列に産地を表示するための数式を設定する Range("D" & r).FormulaR1C1 = "=IFERROR(VLOOKUP(RC[-3],C[2]:C[3],2,FALSE),"""")" End If Application.EnableEvents = True End If Next rng End Sub
「2016.6.25」のようにピリオドで区切る例です。 ActiveSheet.Name = Format(Range("A1").Value, "yyyy.M.d") もし「2016.07.05」のように一桁の月・日を二けたにする場合には ActiveSheet.Name = Format(Range("A1").Value, "yyyy.MM.dd") とします。
Private Sub Worksheet_Change(ByVal Target As Range) Dim rng As Range For Each rng In Target.Cells If rng.Value <> "" Then ーー通常処理ーー End If Next rng End Sub とします。 こうすれば単一セルと複数セルの両方に対応できます。
＞同じ行にある列同士の足し算(D8=F8+G8、D9=F9+G9...) ⇒二重引用符で括るとただの文字列になりますのでエラー。 又、この仕様とコードとが相違していますので、D列に結果表示ならこんな感じです。 セル範囲が決まっているなら「For Each ～ Next」の方が分かり易いと思います。 Sub sample() Dim r As Range For Each r In Range("D8:D18") r = Application.Sum(Cells(r.Row, "F").Resize(, 2)) Next End Sub
一例です。 Private Sub Worksheet_SelectionChange(ByVal Target As Range) If Intersect(Target, Range("B2:I10")) Is Nothing Then Exit Sub If Target.Value = "" Then Target.Value = "○" Else Target.Value = "" End If Dim rng As Range, Hani As Range, buf As String For Each rng In Range(Cells(Target.Row, "B"), Cells(Target.Row, "I")) If rng.Value = "○" Then buf = buf & Cells(1, rng.Column) & "、" End If Next rng Range("J" & Target.Row) = Left(buf, Len(buf) - 1) End Sub
>> Option Explicit Sub main() Dim DirName, FileName, Buf As String Dim TergetBook As Workbook Dim Sale As Long Dim RowCount As Long Application.DisplayAlerts = False ' ファイル登録時の警告を無視 DirName = "C:\Tmp\" ' 処理するファイルが保存されているフォルダ FileName = Dir(DirName & "*.xlsx", vbNormal) ' 最初のファイル名をセット RowCount = 1 Cells.Clear Do While FileName <> "" Set TergetBook = Workbooks.Open(DirName & FileName) TergetBook.Activate ' 読み込むエクセルファイルをアクティブにする Sale = Sheets("売上").Range("E1").Value TergetBook.Close Cells(RowCount, 1) = FileName Cells(RowCount, 2) = Sale RowCount = RowCount + 1 FileName = Dir() ' 次に読み込むファイル名をセット Loop Application.DisplayAlerts = True End Sub << ・シートモジュールに貼り付けてください。
カテゴリー名だけの抽出ならVBAを使ったクローラーなどを開発するよりも、そもそもAmazonの公開しているブラウズツリーガイドを利用するのが良いのではないでしょうか？ https://www.amazon.co.jp/gp/help/customer/display.html/ref=hp_rel_t... Excelデータでダウンロードできます。
>テキストファイルに保存してコンパイルしろ おそらくあなたは「テキストファイルとは何か」から説明せねばならぬような段階だと察しますので、以下のような本を数冊読んでください。 『ワードを捨ててエディタを使おう 第２版』by 鐸木能光 http://takuki.com/edit.html ＊＊＊ また、コマンドラインでの操作にも慣れる必要がありますので、下のようなサイトや本でCUIでの操作に慣れてください。 Tech TIPS：これだけは覚えておきたいWindowsのコマンドプロンプトの使い方 (1/2) - ＠IT http://www.atmarkit.co.jp/ait/articles/1502/13/news147.html
> NetworkDays(Range("L" & 行).Today) ↓ NetworkDays(Range("L" & 行), Today) だと思います また、この記述は Do ～ Loop 内にないとまずいのでは？ Now を使うと、時分秒も有効になるので、 日付だけのものと比較するのは都合悪い？？？ If については、日付が埋まっているか･･･ これだけの判別でやってから、さらに If してみるとか？ 雰囲気以下でどうなりますか Public Sub Samp1()    Dim iRow As Long    Dim v As Variant    iRow = 4    While (Cells(iRow, "P").Value <> "Exit")       v = ""       If (Cells(iRow, "L").Value <> "") Then          If (Cells(iRow, "L").Value < Date) _             And (Cells(iRow, "R").Value = "未着手") Then             v = WorksheetFunction _                   .NetworkDays(Cells(iRow, "L").Value, Date)          End If       End If       Cells(iRow, "P").Value = v       iRow = iRow + 1    Wend End Sub ※ 何行もあるのなら、描画を止めてやると速くなるかと Application.ScreenUpdating = False ～～～ Application.ScreenUpdating = True ※ While ～ Wend は途中抜け出さない時の私の記述なので･･･ Do While ～ Loop とか Do ～ Loop While とか Do ～ Loop Until とか 適宜変更してみてください ※ チョットでも速くしたいのなら Cells(iRow, "P") → Cells(iRow, 16) 等、 列を文字から数値にしてみるとか
＞ＶＢＡを使用して、勤務表を作成したいと思います。 ＞対応できる方がいらっしゃるのなら・・・・ VBAを扱う方であれば、ご存知かと思いますが、 このような抽象的な質問では、 だれも、まともな対応は出来ないと思います。 どのような表になっているのかも提示せず、 どこに何を入力したら良いのかもわからず・・・ 丸投げであれば、そのように記載すれば まだましかと思いますが・・・
こんにちは。 >ＷＥＢページの好きな部分を比較して表示させたい 示しているコードは、エクセルシートにコントロールを設置して、urlを投げた、というところまでです。 比較もそうですが、最初から、専用のシートを作成して、表示させるコードのほうが、楽です。 コードは、あるのか、ないのか、のチェックから始まり、「問題なく表示できそうだ」という状況なら、投げる、 様子が変なら、シートにコントロールを新規追加して、urlを投げる、という動作。 ページのスクロールもありません。 ただ表示しただけです
替えたのはWIndowsのVerだけっすか？ 32bitから64bitに変えたりしてませんか？ もし、替えてたら http://answers.microsoft.com/ja-jp/windows/forum/windows_7-windows_... 参考になるかも。
たぶん、4を完全に使わない事は可能です。ただ、4を使わないことで項数が増えるとしたら、どっちが優先ですか？ 100だろうが10010だろうがデカイだけなら10で全部受け持ってくれます。問題は残った11～14をどうするか？に帰着されるでしょう。どれも4を使わずに出来そうですね。 11=5+6 12=5+7 13=5+8 14=5+9
Vlookupという関数を使えばできます。 ただ、別シートのランク表はこの関数を使うために少し書き換える必要があります。 今のA-E列をB-F列に移動して、空いたA列にはE列と同じ値を入れてあるという前提で、 D4には =vlookup(c4,別シート!a4:f6,2,true) E4には =vlookup(c4,別シート!a4:f6,3,true) としてください。 vlookupの説明はネットで解説を探していただいて、上記と比較して見て頂ければご理解いただけると思います。
>yastak21さん2016/6/1022:49:18 >データベース追加処理が出来ませんでしたとは何でしょうか？ データベースに追加出来なかった。と言う事です。
選択したいだけなら、なぜCommandButton1_Clickでもう一度シートを検索してAddItemしているのでしょうか？ マスターシートの項目数が４つなのに、なぜリストボックスの項目数を３つにしているのでしょうか？ リストボックスの表示内容の「１９９２」や「２００２」はどこから得ているのでしょうか？ 正確な回答が得たければ正確な情報を提示して下さい。
このような感じかな・・・。一例です。 B列の値が複数ある場合は、A列のデータは何かを聞いてきます。 後は、ご自分で応用してください。 Sub Sample() Dim sh1 As Worksheet, sh2 As Worksheet, Key As String Dim cnt As Integer, i As Long, Hani As Range Set sh1 = Worksheets("Sheet1") Set sh2 = Worksheets("Sheet2") With sh2 Set Hani = .Range("B1:B" & .Range("B" & Rows.Count).End(xlUp).Row) cnt = WorksheetFunction.CountIf(Hani, sh1.Range("A1")) If cnt > 1 Then Key = InputBox("複数あるのでA列のデータ入力") For i = 1 To Hani.Rows.Count If sh1.Range("A1") = .Cells(i, "B") And .Cells(i, "A") = Key Then sh1.Range("B1") = .Cells(i, "C") Exit Sub End If Next i End If For i = 1 To Hani.Rows.Count If sh1.Range("A1") = .Cells(i, "B") Then sh1.Range("B1") = .Cells(i, "C") Exit Sub End If Next i End With End Sub
ソースを眺めただけで実行していませんが、 SrcWs.Range(tbl(i) & "2", SrcWs.Range(tbl(i) & Rows.Count).End(xlUp)).Copy を SrcWs.Range(SrcWs.Range(tbl(i) & "2"), SrcWs.Range(tbl(i) & Rows.Count).End(xlUp)).Copy としてみて下さい。
flag= False for r = 2 To Range("A" & Rows.Count).End(xlUp).Row If Range("A" & r).Value <> 0 Then flag = True Exit For End If Next r If flag Then '処理を行う End If この程度のループであれば20000行あっても一瞬です。 100万行でも5秒くらいでしたよ。
下記のコードをThisWorkbookのシートモジュールに設定すると、通常の「上書き保存」を行った際に「保存およびバックアップファイルを別フォルダに移動」を行います。また、編集後に保存せずに終了しようとすると自動的に「上書き保存」を行うようになります。 なお、「dest = "バックアップ先のフォルダ" & "\" & xlkName」は適宜変更して下さい。 Option Explicit Private Sub Workbook_AfterSave(ByVal Success As Boolean) Dim xlkNameWithoutExt As String, xlkName As String Dim sour As String, dest As String 'バックアップファイルの名前を取得する xlkNameWithoutExt = Left(ActiveWorkbook.Name, Len(ActiveWorkbook.Name) - 5) 'バックアップファイルが存在するかどうかを判定する xlkName = Dir(ActiveWorkbook.Path & "\" & xlkNameWithoutExt & "*.xlk") 'バックアップファイルが存在したらバックアップファイルを別フォルダに移動する If xlkName <> "" Then sour = ActiveWorkbook.Path & "\" & xlkName dest = "バックアップ先のフォルダ" & "\" & xlkName On Error Resume Next 'バックアップ先のフォルダにコピーする FileCopy sour, dest 'コピーが成功していたらバックアップファイルを削除する If Err.Number = 0 Then Kill sour End If On Error GoTo 0 End If End Sub Private Sub Workbook_BeforeClose(Cancel As Boolean) If Not ThisWorkbook.Saved Then Application.DisplayAlerts = False ThisWorkbook.Save Application.DisplayAlerts = True End If End Sub
やりたいことがピンときませんが、具体的なコードで示していただけますか？ もし、 CommandButton1_Click() を CommandButton1_Click(ByRef HogeHoge As Integer) などのようにしたい、ということであれば「出来ません」。
このような数式で可能だと思います。 =LEFT(A1, FIND("/", A1))
それですと、 「TEXTBOX2.Hoge」という名前のディレクトリを カレントディレクトリ内に作成せよ。 というコードになっています。 カレントディレクトリはおそらく プロジェクトのフォルダなので、 そこに「TEXTBOX2.Hoge」というディレクトリが 作成されているのではないですか？ TEXTBOX2の内容は、 TEXTBOX2.Text で取得します。 また、TEXTBOX2.Textの内容を 親ディレクトリとしたパスを作成するには、 以下のようにします。 System.IO.Path.Combine(TEXTBOX2.Text, "Hoge") よって、指定のディレクトリを作成するには、 以下のようにします。 System.IO.Directory.CreateDirectory(System.IO.Path.Combine(TEXTBOX2.Text, "Hoge"))
ぐるぐる回す必要はあるのでしょうかね？ Sub 一例です() Dim xFormula As String, rng As Range Const cFormula1 As String = "=SUM(@@)" Const cFormula2 As String = "=@1/@2" With Columns(1).SpecialCells(xlCellTypeConstants) Set rng = .Cells(.Count).Offset(2, 1) rng.Formula = Replace(cFormula1, "@@", .Offset(, 1).Address(False, False)) xFormula = Replace(cFormula2, "@2", rng.Address) xFormula = Replace(xFormula, "@1", .Cells(1).Offset(, 1).Address(False, False)) .Offset(, 2).Formula = xFormula End With End Sub
下記が参考になると思います。 複数のコントロールを操作する http://www.moug.net/tech/exvba/0090067.html
この質問書いてる時間で手作業で終わりますよ。マクロにする理由って何ですか？
gyou＝･･･の前に 変数の型宣言がまず必要です（´∀｀） Dim gyou as long 'long型の gyouを宣言 gyou = Sheets("受付情報").Range("B65536").End(xlUp).Offset(1, 0).Row また値を転記する部分ですが 左辺のSheets("受付情報").Cells(gyou, xxx).Value は文法として問題ないのですが = で指定している 右辺のRange(xxx,yyy)の部分でエラーがでています。 Rangeは範囲を指定するクラスですが、 今回の場合のように 特定のセルを指定する場合はCellsを使うとエラーがでません。 Sheets("受付情報").Cells(gyou, xxx).Value ＝ Cells(yyy,zzz).value
>columns(1),0 は、どのような意味を持ちますか？ 「 Application.Match」でワークシートで使用するMATCH関数が起動されます。 なので、（）内の３つのパラメータは、ExcelのMATCH関数の3つのパラメータと同じ意味です。
クラスで処理する方法は知りません。 もしラベルに連続した番号が振られているのなら下記方法で処理出来ます。 ExcelVBA フォームでコントロール配列（もどき） (4) http://plaza.rakuten.co.jp/puppypc/diary/200905250000/
2行目以降に「□□1□□□赤坂署 □□㈱ホンダ □□千代田区霞が関 □□」がたくさんあるなら VBAでなくて、データの区切り位置で、□が全角空白なら区切り文字に全角空白をしてみたらどうでしょう。 その際に、「連続した区切り文字は..」にチェックを入れてください。 もし、固定長なら、区切り文字で無く最初に「スペースによって..」の方で、区切りの箇所(何文字目か)を指定しても良いと思います。
コピーではなく B.xlsmのＦ１に =Vlookup(A1,[A]Sheet1!A:D,3,0) 同じくＧ１に =Vlookup(A1,[A]Sheet1!A:D,4,0) とし 2行目以降ドラッグすれば A.xlsmの C,Dの 値が 表示されます。 A.xlsmとの リンクを恥じしたければ B.xlsmで 全セルを選択後 値貼り付けをすれば 上の式は消え 値のみ残ります。
こういうことでしょうか Sub 星の表示() Dim i As Integer, n As Integer n = 10 i = 1 Do While i <= n Debug.Print Format(i, "00") & String(i, "*") i = i + 1 Loop End Sub
こういうこと？ For i = 1 To N tokuten = X(i - 1) Select Case tokuten Case 60 To 70 MsgBox tokuten & "点は" & hantei(1) Case 71 To 80 MsgBox tokuten & "点は" & hantei(2) Case 81 To 90 MsgBox tokuten & "点は" & hantei(3) Case 91 To 100 MsgBox tokuten & "点は" & hantei(4) Case Else MsgBox tokuten & "点は" & hantei(0) End Select Next i
ループなので、 Do While cells(i,1).value="" cells(i,1).copy cells(i,2).pastespecial Loop くらいでいいのでは？
とりあえず、下の図のようなパターンで表示したいということでしょうか？ ・画像を見易くするために、上下2段に分けています。 ・D2セルに一つの数式を入れて、後は他のH2,L2,P2,・・へとコピペしています。 下の図のようなパターンの表示でよければ、 ①D2セルに、 ・ =IFERROR(IFERROR(LOOKUP(1,0/((B5:B8=B2)*(C5:C8<>"")*COUNTIF(C2,C5:C8&"*")),D5:D8),INDEX(D5:D8,MIN(INDEX(((B5:B8<>B2)+(C5:C8<>""))*100+ROW(B5:B8)-ROW(B5)+1,)),)),"")&"" の式を入れます。 とりあえずこの画像の表示でよければ、他のご質問の部分は返信で補足します。
再帰処理でいいならこれでどーん （「x:\y\1\1\何かしらのフォルダー\」も対象にしてよいなら） 見にくいと思ったので間にアンダーバーが入れました。 不要な気遣いなら、 set folName=%%~nd_ （このコードはこうなる：x:\y\1\1_aaa.mp4） を set folName=%%~nd としてください。 ――――――――――――――ここから――――――――――――――― @echo off setlocal enabledelayedexpansion set renTargetExt=.txt :MainRoutine for /f "usebackq delims=" %%f in (`dir /s /b /a-d /on *%renTargetExt%`) do ( set fileName=%%f rem フォルダ名を取得して右端の\を消し rem GetFolderNameにファイル名と誤認させて取得する set folName=%%~dpf set folName=!folName:~0,-1! echo --- call :GetFolderName set newFileName=!folName!%%~nxf echo ren "!fileName!" "!newFileName!" ren "!fileName!" "!newFileName!" ) echo --fin-- pause exit :GetFolderName for /f "usebackq delims=" %%d in ('!folName!') do ( rem フォルダー名にデリミタを入れる処理はここでやってます set folName=%%~nd_ ) exit /b ――――――――――――――ここまで――――――――――――――― あとなんか注意事項あったっけ？ たぶんないけど試すときにダミー作りたいときには私の知恵ノート参照してください 以上
train_benoistさんが危惧した通り、複数のセル範囲を一度にコピーすることは出来ませんので、train_benoistさんのソースに少々手を加えました。「ブックA、B、ともに同じフォルダ内」とのことなのでそれも加味しています。 Option Explicit Sub 転記後消去() Dim rng As Range, area As Range Set rng = ThisWorkbook.Worksheets("入力") _ .Range("D3:F3,D5,E5,F5,D7,E7,F7,D9:E9,I9,D11:E11,I11,D13:F13,I13,D15:I19,I3") Application.ScreenUpdating = False Application.DisplayAlerts = False With Workbooks.Open(ThisWorkbook.Path & "\データ.xlsx") With .Worksheets("受付情報").Range("B" & Rows.Count).End(xlUp).Offset(1) For Each area In rng.Areas area.Copy .Offset(area.Row - rng.Row, area.Column - rng.Column) Next area End With .Close True End With rng.ClearContents ThisWorkbook.Close True Application.DisplayAlerts = True Application.ScreenUpdating = True End Sub
osaka_metaboさんも回答されていますが、貴方がやろうとしていることはExcelの範疇を超えて、「CADソフト」のレベルに近くなっています。 最初から全部自動的にやるのではなく、まずエクセルのレベル出来ることを見極めましょう。 パネル・バー・アングルといった部材をすべてマクロで描画させるのでなく、あらかじめエクセルの図形を組み合わせて「パネル」「バー」「アングル」の図形を作るところから始めて下さい。それだけでも手作業の範囲が随分少なくなると思いますよ。
いくつか間違っている箇所があります。 テストランしたバッチを以下に掲載します。 自分の環境でテストするために、DSETフォルダの場所を変えています。適時変更してください。 また、フォルダやファイルに半角スペースがあっても移動出来るようにしました。 --ここから------ @echo off TITLE ファイル移動 rem TEMP\TESTフォルダに作成されたファイル全部を、 rem タイムスタンプ付フォルダを作成して移動するバッチ color 3F set dateStr=%date:/=% set timeStr=%time::=% set timeStr=%timeStr:.=% set timeStr=%timeStr: =% set DEST=C:\A B C\ rem set DEST=C:\Users\USER01\Desktop\ set SOURCE=C:\temp\test\ set nowdir=%DEST%%dateStr%%timeStr% echo dateStr=%dateStr% echo timeStr=%timeStr% echo DEST=%DEST% echo SOURCE=%SOURCE% echo nowdir=%nowdir% pause mkdir "%nowdir%" move "%SOURCE%*.*" "%nowdir%\" rem 以下、検証するために作った不要なバッチ dir "%nowdir%\" echo 元に戻す pause move "%nowdir%\*.*" "%SOURCE%" dir "%SOURCE%" pause --ここまで------ 3つ目のset timeStr=行は不要なような気がします。 後半に検証のための戻しバッチを作ってありますが、動作するようになったら削除してくださいませ。 では
一例です Application.DisplayAlerts = False 'シート数が4以下になるまで繰り返し Do Until Worksheets.Count <= 4 '最後のシートを削除 Worksheets(Worksheets.Count).Delete Loop Application.DisplayAlerts = True
Set a = Workbooks("H28受注業務.xlsx").Worksheets("業務マスター").Range(Cells(1, 1), .Cells(10, 3)) を Set a = Range(Workbooks("H28受注業務.xlsx").Worksheets("業務マスター").Cells(1, 1), Workbooks("H28受注業務.xlsx").Worksheets("業務マスター").Cells(10, 3)) としてみてください。 複数のブック・複数のシートを扱うマクロでRangeおよびCellsを使うときは常に「どのブックのどのシート」を意識したコードを書くように心がけて下さい。 単純にCells(1, 1)と書くと「Activeなシート上の」という意味になってしまいます。
areaIDが1でも2でもないときはnameRngは前のシートの名前のままになります。 つまりシートの名前を既に存在している名前に変更しようとしているのでエラーになってしまいます。 もしかしてマクロの中の削除してしまった部分でareaIDを設定していたりしませんか？
仕様です。 ListBoxの行と列はゼロから始まるので、Variantに格納したときもゼロから始まるようになっています。 つまりListBoxのListとそれを格納したVariant配列とは同じインデックス番号でアクセスできる、ということです。
Singleを使っているから。 浮動小数点型では小数点以下の数値を正しく１０進数で持つことが出来ません。 どうしても小数点以下を正しく保持したいのであれば、小数点以下4桁までならCurrency、それ以外ならLongやIntegerに入れるしかないです。その際も、小数点以下何桁まで保持するか決め、その分１０の累乗を掛ける処理をするしかないです。
下記のコードでtest.csvというファイルが作られます。 Option Explicit Sub Sample() Dim text() As String, lineData As String, lines() As String Dim r As Long, c As Long, cnt As Integer, lineCount As Long ReDim lines(0) lineCount = 0 For r = 1 To Range("A" & Rows.Count).End(xlUp).Row text = Split(Range("A" & r).Value, vbLf) For cnt = 0 To UBound(text) lineData = text(cnt) For c = 2 To Range("A" & r).SpecialCells(xlCellTypeLastCell).Column lineData = lineData & ", " & Cells(r, c).Value Next c ReDim Preserve lines(lineCount) lines(lineCount) = lineData lineCount = lineCount + 1 Next Next Open "text.csv" For Output As #1 For cnt = 0 To UBound(lines) Print #1, lines(cnt) Next Close #1 End Sub
SELECT 日付, 商品番号, DMax("販売数","テーブル1","商品番号=" & [商品番号] & " AND 日付<=" & [日付]) AS 販売数新記録 FROM テーブル1 ORDER BY 日付, 商品番号 「販売数新記録」が DMax のせいで文字列扱いになってしまいますが、 数値にする必要があれば、おまじないで。 DMax("販売数","テーブル1","商品番号=" & [商品番号] & " AND 日付<=" & [日付]) - 0 AS 販売数新記録
バージョンの不整合ですね。 基本的には、表示されているメッセージの通りです。 参照しているモジュールのバージョンを確認して適切なバージョンに置き換えるか、参照方法をバージョンが依存しない形に変更して下さい。 別な言い方をすると、参照設定が適切ではありません。 どこかで論理破綻している（不整合が発生している）可能性があります。 環境やモジュール設計等を見直してみて下さい。 > 恥ずかしながら私はVisual Studioを使用したことが殆どなく、どういう手順で操作を行えば解消できるか記載して頂けると非常に助かります… 手順の前に、構成や構造、あるいは環境を見直す必要があるでしょう。 設計レベルあるいは環境レベルの問題だと思いますので、まずはそれらを見直して下さい。 （それによって、操作の内容が変わってくる可能性があります）
下記のサイトが参考になると思います http://unilab.gbb60166.jp/vbe/vbe.htm
End Select が無い。 ちゃんとIFやSelectCaseをTabで段落とししていたら、すぐわかる筈です。
テキストボックスのValueはStringなので、文字列の比較になります。 文字列の比較ですと左の桁から順に比較されるため、例えば2と10を比較すると、 2のほうが大きいと判定されます。 数値の比較がしたいのであれば、Val関数などを使用して文字列を数値に変換してから比較する必要があります。 修正前） If Me!txt1.Value > Me!txtL2.Value Then 修正後） If Val(Me!txt1.Value) > Val(Me!txtL2.Value) Then
i = Range("G6") + 4 s = Range("H6") + 4 ですが、 管理表シートのG6セルの内容に4を加えた値が開始行 管理表シートのH6セルの内容に4を加えた値が終了行 というコードになっていますが間違いはありませんか？ Do While i = s ではループに入らずに抜けてしまいます。 Do While i <= s としてください。 Worksheets("管理表").PrintOut ですが、これでは管理表シートを印刷することになります。 本社シートを印刷するのなら wa.PrintOut としてください。
Excel VBAの話でしょうか？ マルチページという言い方は聞いたことがないのですが？ Excelではブック、シート、行、列、という言い方が一般的です。
以下のコードでいかがでしょうか。 Private Sub CommandButton2_Click() Dim r As Variant, i As Long On Error Resume Next r = 0 r = WorksheetFunction.Match(TextBox1.Text, Range("A:A"), 0) On Error GoTo 0 If r = 0 Then MsgBox "未登録の購入者です。" TextBox1.SetFocus Else For i = 2 To 5 Controls("TextBox" & i).Text = Cells(r, i).Value Next TextBox2.SetFocus End If End Sub
Sheet1に図形を挿入させたいのであれば With ActiveSheet.Range("G10:H10") を Worksheets("Sheet1").Activate With Selection としてみてください。
Application.displayalart=False Workbooks.open Application.displayalart=true たぶんこれで行けると思います。
Sub StarDisplay() Dim n As Integer n = 1 Do While n <= 10 Debug.Print Format(n, "00") & String(n, "*") n = n + 1 Loop End Sub
不可,可,良,優の判定基準を書いて下さい。
ググっただけだけど、これでできそうな。。。 https://msdn.microsoft.com/ja-jp/library/ms749020.aspx https://msdn.microsoft.com/ja-jp/library/system.drawing.bitmap.aspx https://msdn.microsoft.com/ja-jp/library/system.windows.media.pixel...
取り急ぎ、オブジェクトの親クラスを省略せず、すべて明示的に参照するよう修正してみては如何でしょうか。 Sub Macro1() With Application.ThisWorkbook.ActiveSheet .Range("F7:G10").Copy .Range("I8").Select .Paste End With End Sub
gridview内に配置されたコントロールにアクセスするためにはIDだけでは不十分です。 gridviewのrowに対してFindControlして、コントロールを取得してください。 以下こんな感じでできるはず。 判定等は書いていないので、そこは補ってください。 For Each dR As GridViewRow In grdKyujinList.Rows Dim wkDt As Label = dR.FindControl("Label1") Dim wkImg As Image = dR.FindControl("img1") If Not wkDt Is Nothing AndAlso Not wkImg Is Nothing Then wkImg.Visible = False End If Next
Debug.Print i, Error(i) を If Error(i) <> "アプリケーション定義またはオブジェクト定義のエラーです。" Then Debug.Print i, Error(i) End If としてみて下さい。
↓My.Computer.FileSystem.WriteAllText メソッド https://msdn.microsoft.com/ja-jp/library/27t17sxs%28v=vs.90%29.aspx 「My.Computer.FileSystem.WriteAllText」メソッドに引数を指定すれば良いのでは？
ini ファイルはテキストファイルなので、テキストファイルとして読み込めば良いかと思います。 どのような処理を考えているのか分かりませんが、１行ずつ取り込んで、"[" や "=" 等が有ったら、セクションやキーとして認識すれば良いかと思います。 ↓テキストファイルの読み込み http://officetanaka.net/excel/vba/file/file08b.htm http://www.asahi-net.or.jp/~ef2o-inue/vba_o/sub05_110.html >サンプルプログラムが欲しいです "VBA テキストファイル 読み込み" などで検索すればサンプルはたくさん出てきます。
条件付きの◯◯までコピー、などはDo loop構文を使いましょう。条件にはWhileやUntilを使ってLoopを止めることが出来ますが、変数iを宣言しておいてスタートを１と(i=1)をDo前に記述、ループ内にi=i+1などとカウントアップをする、と使います。 コピーと一口で言ってもセルごとコピーペーストなのか、値だけなのかとか書き方があるので答えにくいですが、Range("B" & i ).Value=Range("A" & i ).Valueでも値の転記くらいはCopyではなくてもできると思ってください。 以上コードを書くのは簡単ですが後学のため自分で調べてみてください。 ブックをまたぐ処理のヒントは、自ブック指定(Thisworkbook)を使う、オブジェクト変数に格納する、Withステートメントを利用する、これらです。 Dim B as object Set B = Workbooks("B").worksheets(1) と書いておけば、後は B.Range("A1")がBブックシート１枚目指定になります。 With Workbooks("B").worksheets(1) .Range("A1") End with これは .～と書くだけでBブックシート１枚目指定になります。 ブック.シート.セルのそれぞれを明示的に書きましょう。 シート指定はインデックス番号以外にシート名"Sheet1"のような文字列も入れられます。 上記を踏まえ、比較はIfで行えばいいでしょう。その後ループを利用されればコピーもできます。
割り当てられる数字とは 1～3 とはべつものですか。 20個が1～3しか種類が無いのを均等とは不可解です。 Sub test() Dim temp As Range Dim i As Long For Each temp In Range("A1:D5") Randomize i = Int(Rnd() * 3 + 1) temp.Value = i Next End Sub
フリーの表計算・統計解析ソフトPAST http://folk.uio.no/ohammer/past/ これを使えば，EXCELのセルデータをコピペして，一挙に全ての組み合わせの相関が行列の形式で出力されます。項目が数十あっても，たぶん，コピペから出力まで10秒かからないかも。。 平均や標準偏差，中央値や四分位，歪みや尖りも，そのセルデータで，一瞬に出力されます。英語ですが，海外の大学生には，よく使われる無料の表計算ソフトです。 私の研究室での，中学生の理科研究の成果 アリの歩く速さと走る速さ http://www.ab.auone-net.jp/~biology/Ant-speed.htm そこでもPASTが使われています。 あくまでEXCELだけで計算するなら，グラフを描くのですから，決定係数を表示させれば，Excelの場合，それは相関係数の二乗なので，符号に注意すれば間接的に相関係数も計算できます。
元データがA1から下にあって、結果をB1から右に表示する場合です。 Sub sample() Dim lastRow As Long Dim ary As Variant Dim str As String ' Range(Range("B1"), Cells(1, Columns.Count)).Clear '結果クリア lastRow = Range("A" & Rows.Count).End(xlUp).Row 'A列最終行 ary = Range("A1:A" & lastRow) '元データ範囲(A1:A3)を配列に取得 ary = WorksheetFunction.Transpose(ary) '2次元配列を縦横を変換して1次元配列に取得 str = Join(ary, " ") '配列を" "区切りで文字列に str = Replace(str, ",", " ") '","(カンマ)を" "に変換 str = WorksheetFunction.Trim(str) '左右の空白を削除と複数の空白を1個に変換(元データでカンマが連続した場合は1個に変換) ary = Split(str, " ") '空白で区切って配列に取得 Range("B1").Resize(1, UBound(ary) + 1).Value = ary 'B1から横に結果を表示 End Sub 2番目の元データ(D,EE,)の最後がカンマですが、その場合の結果は空白セルを入れるのかどうかが不明です。 カンマの繰り返しは1個にしていますが、空白を入れる場合は str = WorksheetFunction.Trim(str) '左右の空白を削除と複数の空白を1個に変換(元データでカンマが連続した場合は1個に変換) を削除してください。
コード例です。 下から4行目のシート名は実際のシート名に書き換えて使用してください。 軽くしか検証していないので、不具合があればご返信ください。 Sub Sample() Dim Row As Long Dim LastRow As Long Dim i As Long Dim j As Long Dim Items() As String Dim Customers() As String LastRow = Cells(Rows.Count, "A").End(xlUp).Row ReDim Items(LastRow - 1) ReDim Customers(LastRow - 1, 2 * LastRow - 1) For Row = 1 To Cells(Rows.Count, "A").End(xlUp).Row If Cells(Row, "D").Value = 1 Then For i = 0 To UBound(Items) If Items(i) = Cells(Row, "A").Value Then Exit For If Items(i) = "" Then Items(i) = Cells(Row, "A").Value Exit For End If Next For j = 0 To UBound(Customers, 2) If Customers(i, j) = "" Then Customers(i, j) = Cells(Row, "B").Value Customers(i, j + 1) = Cells(Row, "C").Value Exit For End If Next End If Next With Worksheets("違うシート") '←実際のシート名に書き換えてください。 .Range("A1").Resize(UBound(Items) + 1).Value = WorksheetFunction.Transpose(Items) .Range("B1").Resize(UBound(Customers, 1) + 1, UBound(Customers, 2) + 1).Value = Customers End With End Sub
変数が「i」なのか「k」なのかよく分かりませんが Chr(Int((i - 1) / 99) Mod 26 + 97) & Format((i - 1) Mod 99 + 1, "00")
描画したものだけを消す方法はありません。 描画前の情報を取っておいて再描画する方法もありますが、どちらかというとデスクトップに対して再描画のシグナルを送る、という方法がウインドウズのルールに則ったやり方になります。 デバイスコンテキストについて学ぶのであればVBAではなくて、C++でMFCアプリケーションを作ってみる方が学びやすいですよ。
http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1416076758... IDが違いますが全く同じ内容の質問ですよね？お知り合いですか？
各シート最終行のB列、F列、I列、J列、K列をSheet1へ転記するコードです。 Option Explicit Sub Sample() Dim st1 As Worksheet, st As Worksheet Dim i As Integer, r1 As Long, r As Long Set st1 = Worksheets("Sheet1") For i = 2 To ThisWorkbook.Worksheets.Count r1 = st1.Range("B" & st1.Rows.Count).End(xlUp).Row + 1 Set st = Worksheets(i) r = st.Range("B" & st.Rows.Count).End(xlUp).Row st1.Range("B" & r1).Value = st.Range("B" & r).Value st1.Range("F" & r1).Value = st.Range("F" & r).Value st1.Range("I" & r1).Value = st.Range("I" & r).Value st1.Range("J" & r1).Value = st.Range("J" & r).Value st1.Range("K" & r1).Value = st.Range("K" & r).Value Next i End Sub
以下のコードでいかがでしょうか。 Sub 翌月処理() Dim rng As Range For Each rng In Range("C4：C35") If rng.Value <> "" Then rng.Value = rng.Value + 1 Next Range("A1").Select End Sub
こんにちは。 プログラムを開発しているとき、「トラブル」が発生したときの情報は、すごくほしいです。 その挙動、主様は、「邪魔だ」なんていっていますが、ゲームが動作していて、理由があって画面が出ていると思っていいです。 つまり、仕様の範囲です。 「自動終了」をさせたいようですが、やめておいたほうがいいです。 いつまでも、プログラム不良の対策が出来ないことになるのですから、結果、主様が不利益になるかと。
End Withがあるのに、それに対応するWithステートメントがありません。 どこかで忘れてませんか？
こんにちは。 このコードで、動作が不定期、というのでしたら、「自動的に送受信しているタイミング」がないかを考えてください。 自分が操作するまで、「送受信しない」という状況のチェックです。 あと、doeventsのコードを追加したときの挙動です。 コードの不良というよりも、OSとアプリの挙動にあわせて、処理をゆっくりさせるということです。
上記の書き方で間違いはないはずですが、ないっていないのであれば何が入っていますか？ 確認ですが、上記のコードはフォームのモジュールに書かれていますか？ コンボ４は、何らかの値が選択されていますか？
確かに、質問者さんが指摘されるとおりに思います。 ただ、何か思いもよらない意図が隠されているとも限らないので一応、前担当者に確認された方がよいと思います。
こんにちは。 検索したいキーワードが、複数ある、というのが、分かっているのでしたら、 準備、 データシートは、キーワードで並び替えをする。 複数一致の処理としては、 1) キーワードの数を、countif(検索するキー列 , 検索するキーワード)で計算 2) match関数で、行を計算 3) match行と、vlookupしたいターゲット列を、 1)のcountifの数だけ、コピーする というコードになります。 通常では、vlookupの関数は、結果が1つですが、主様がしたいことは、 結果が複数になります。 取得してから、どうしたいのかで、コードに合わせるのがいいかと。
Aのエクセルの「Thisworkbook」モジュールに記載してください。 Private Sub Workbook_SheetChange(ByVal Sh As Object, ByVal Target As Range) Target.Copy Workbooks("B.xlsx").Worksheets(Sh.Name).Range(Target.Address) End Sub
if (reader.NodeType == XmlNodeType.Element) { //もし<主菜>タグの子要素に<名>があればそれを取得，なければ<主菜>タグ内テキストを取得 if (reader.Name == "主菜"){/// ここでReadToDecendant("名")を実行すると "</主菜>"へ readerが進む if(reader.ReadToDecendant("名")) lunchList.Add(reader.ReadString()); } /// ここでは "</主菜>"なので ReadStringは""を返す lunchList.Add(reader.ReadString()); reader.Close(); なので if (reader.NodeType == XmlNodeType.Element) { //もし<主菜>タグの子要素に<名>があればそれを取得，なければ<主菜>タグ内テキストを取得 if (reader.Name == "主菜") { /// ここで ReadOuterXmlを実行して <主菜> ... </主菜> を取得 string ss = reader.ReadOuterXml(); /// Xmlのヘッダ、フッタを追加 ss = "<xmlfile>\n<lunch>\n" ss "</lunch></xmlfile>"; /// StringReaderの構築 Sysytem.IO.StringReader srd = new System.IO.StringReader(ss); /// XmlReaderの構築 XmlReader rd = XmlReader.Create(srd, settings); rd.ReadToDecendant("主菜"); // ”肉”、”たまご”、"魚"などを取得 string s1 = rd.ReadString().Trim(); rd.close(); srd.cose(); // XmlReaderの再構築 srd = new System.IO.StringReader(ss); rd = XmlReader.Create(srd, settings); if(rd.ReadToDecendant("名")) ｛ lunchList.Add(rd.ReadString()); } else { lunchList.Add(s1); } reader.Close();
If文で分岐させるのが基本です。 If (InStr(Cells(i, 1).Value, "_") > 0) Then 'Split云々の処理を行なう End If
一番単純な解決法はチェックボックスとテキストをdivて囲ってdisplay:inline-block;とする事です。 スタイルだけで解決するなら、チェックボックスにpadding-right:10em;margin-right:-10em;とすれば良いでしょう。少しトリッキーなので推奨はしませんが。
PasteSpecial でエラーが起きているとの事ですが、copyしてから別のブックを開いているので、クリップボードが消えているのだと思います。 都度オープンさせたりActiveにさせたりというのは効率が悪いです。 ファイルを扱う時はワークブックを変数に持つようにした方がいいです。 全部を直して示したいのですが、長くなるので、その部分だけ。 参考にして修正してみて下さい。 Dim wb1 As Workbook, wb2 As Workbook Application.ScreenUpdating = False Set wb1 = Workbooks.Open("1番ブック") Set wb2 = Workbooks.Open("Target8") wb1.Worksheets("仮集計済みシート").Range("A1:XXXX").Copy wb2.Worksheets(sheetname).Range("A1").PasteSpecial Paste:=xlPasteValues wb2.Worksheets(sheetname).Range("A1").PasteSpecial Paste:=xlPasteFormats Application.ScreenUpdating = True wb1.Save だけで該当のファイルを保存できます。 閉じる時は wb1.Close です。簡単になりますね。 下記は画面の動きを止めるものです。最初に入れます。 Application.ScreenUpdating = False それから、定義（Dim）は都度書くのではなく、コードの先頭にまとめた方がいいです。わかりやすくなります。
数字の範囲とセルの位置が決まっていれば条件付き書式設定で可能です。 図は簡単な例ですが10をMAXとしたものです。 この場合はA1～C10を範囲指定しておいて、条件付き書式 新しいルール、数式 =10-ROW(A1)<A$11 色を設定 で作成しています。
バリアント型の配列を介しているからではなく、Rangeの使い方が間違っているからだと思います。 Worksheets("src").Select ・・・・ Worksheets("dest").Range(Cells(1, 1), Cells(100, 5)) = buf は、標準モジュールでは Worksheets("dest").Range(Worksheets("src").Cells(1, 1), Worksheets("src").Cells(100, 5)) = buf と同じ意味になるので、エラーになるはずです。 と言うわけで、 Worksheets("src").Select ・・・・ Worksheets("dest").Select Worksheets("dest").Range(Cells(1, 1), Cells(100, 5)) = buf にするか、 Worksheets("dest").Range(Worksheets("dest").Cells(1, 1), Worksheets("dest").Cells(100, 5)) = buf にするか、 Dim ws As Worksheet Set ws = Worksheets("dest") ws.Range(ws.Cells(1, 1), ws.Cells(100, 5)) = buf などにする必要がると思います。
QObject::connect( selectDirButton, SIGNAL(clicked()), SelectWindow, SLOT(SelectWindow::selectDirectory())); ではなく QObject::connect( selectDirButton, SIGNAL(clicked()), SelectWindow, SLOT(selectDirectory())); // SelectWindow:: を消すだけ これでうまくいきませんか？
管理する情報は １．月や年など定期的に区切るのか？ ２．仕入れ情報は管理しないのか？ これによって提案できることが変わってくると思います。
End subが必要です。と怒られると思うのだが？（Subが二つでEnd Subがひとつ） シートにコマンドボタンを挿入しているなら Private Sub CommandButton1_Click() Dim c As Range For Each c In Range("A1:C5") If c.Value = 0 Then c.Value = "" Next c End Sub で正常に動きます。
これでいかがでしょうか。 お望みの動作と違うようでしたらすみません。 一応コメントも書いておりますので、変更が必要な場合は変更してみてください。 取り急ぎ、質問内容のファイル名とシート名にしております。 （ファイル形式も.xlsとしてあります。） Sub CopyRows() Dim rowcnt As Long 'コピー元のA列の行数 Dim wbA As Workbook 'コピー元のブック Dim wsA As Worksheet 'コピー元のシート Dim wsB As Worksheet 'コピー先のシート 'コピー元ワークブックセット Set wbA = Application.Workbooks("A.xls") 'コピー元ワークシートセット Set wsA = wbA.Sheets("Sheet1") 'コピー先ワークシートセット Set wsB = ThisWorkbook.Sheets("Sheet2") 'コピー元の最下行を取得してセット rowcnt = wsA.Range("A" & wsA.Rows.Count).End(xlUp).Row 'コピー元のA列4行目から最終行までをコピーして、コピー先のA3にペースト wsA.Range("A4:A" & rowcnt).Copy wsB.Range("A3") End Sub
> wfopen-sをあるファイルを読み込み専用で開いている... が、失敗している(エラー検査せず fgetsしている)のでは？
http://teapipin.blog10.fc2.com/blog-entry-520.html
とりあえず、以下の変更を試してみてください。 Criteria1:="<=数値" ↓ Criteria1:="<=" & 数値 あと >myForm = "00000000" >Range("B2").NumberFormatLocal = myForm は不要に思えます。セル書式自体を変更するのではなく、必要なときに、Format関数で変換すれば良いと思います。
C#を学習し始めて間が無いということであれば、 で、残念ですが・・・ ①FormのサイズをPDFのサイズに調整したい 無理です。AxAcroPDFではPDFのサイズを外部から取り出すことは出来ません。 ②PDFで最初に開くページを指定ページだけ開きたい。 無理です。AxAcroPDFでは表示するページを指定することは出来ません。 ③PDFのナビゲーションは不要 無理です。AxAcroPDFではナビゲーションの表示／非表示の切り替えは出来ません。 ④~⑥ fm上にはpdf.Dock = DockStyle.FillにしたAxAcroPDFが存在しているのですから、fmにはマウスイベントが発生しませんし、AxAcroPDFにはMouseMoveイベントがありません。 ですから④は無理です。 同様にClass2で作ったボタンはAxAcroPDFで隠されてしまうのでClickイベントが発生しません。 ですから⑤も無理です。 ⑥「モーダルにすると、イベントが起きない」モードレスのフォームを表示させるのであればClass1の中でClass2のインスタンスを作るのではなく、mainモジュールでClass1とClass2のインスタンスを作るべきです。 結論から言うとあなたの理解度では自作のフォームを継承して新しいフォームを作ることは時期尚早だと言わざるを得ません。
まず、現状ではリストボックスに表示されたデータがシート上の何行目なのか、という情報がありません。 そこで、 ①mydata2(cn, 3) = mydata(i, 9)の次の行に「myData2(cn, 4) = i」という行を追加します。 ②次にリストボックスの列数を4列（ただし4列目は非表示）にします。 .ColumnCount = 3 .ColumnWidths = "150;30;30" を .ColumnCount = 4 .ColumnWidths = "150;30;30;0" とします。 ③ListBox1_Clickイベントを記述します。 Private Sub ListBox1_Click() If ListBox1.ListIndex = -1 Then Exit Sub Dim selRow As Integer selRow = ListBox1.List(ListBox1.ListIndex, 3) With Worksheets("Sheet1") .Range(Cells(selRow, 1), Cells(selRow, 22)).Select ’この下にフォーム上のテキストボックスに値を設定する処理を入れる End With End Sub ユーザーフォーム上のテキストボックスにリストの値を設定するには、苗字・名前・社名などがシートの何列目にあって、それぞれのテキストボックスがなんという名前なのかが判らないとコードで示すことは出来ません。 ８列目のセルの内容をTextBox3に設定する例です。 TextBox3.Text = .Cells(selRow, 8).Value
いくつか方法があるので 「Excel VBA 画像挿入」で検索してあなたの希望に沿った方法を探してみて下さい。
下記のサイトを参考にしてください。 ADOでMySQLに接続＠Excel マクロ・VBA http://www.cocoaliz.com/excelVBA/index.php/40/ コンボボックスにデータを追加する http://officetanaka.net/excel/vba/tips/tips157.htm
せっかくソースコードを貼り付けていただいているのですが、やりたいことが見えてきません。 何がどうだったらどうしたい、という風に文章で説明してもらえますか？ 「システム更新データ」のレイアウトも提示していただけるとより判りやすいと思います。
ショートカットファイル（拡張子.lnk）をDir関数で取り出します。 WScript.Shellを使い、CreateShortcutでショートカットのオブジェクトを作成し、TargetPath でリンク先のパスを取り出します。 リンク先のパスからファイル名の拡張子が.ppt or .ppt? ならパワーポイントオブジェクトからPresentations.Openでファイルを開き.PrintOutで印刷します。 サンプルです。 印刷の条件的なこと（用紙だの印刷レイアウトだの）は何も設定していません。 Sub Sample() Dim WSH As Object Dim lnkFile As Object Dim fName As String Dim tPath As String Dim PPT As Object Dim Pre As Object tPath = "フォルダA￥" '<=フォルダを指定します、最後に必ず ￥ を付けます Set WSH = CreateObject("WScript.Shell") Set PPT = CreateObject("PowerPoint.Application") 'シートカットファイルに対して処理を行います fName = Dir(tPath & "*.lnk") Do Until fName = "" Set lnkFile = WSH.CreateShortcut(tPath & fName) 'ショートカットのリンク先がpptファイルなら If (lnkFile.TargetPath Like "*.ppt") Or (lnkFile.TargetPath Like "*.ppt?") Then 'ファイルを開きます Set Pre = PPT.Presentations.Open(lnkFile.TargetPath) '印刷 Pre.PrintOut 'ファイルを閉じます Pre.Close Set Pre = Nothing End If Set lnkFile = Nothing '次のファイル fName = Dir() Loop PPT.Quit Set PPT = Nothing Set WSH = Nothing End Sub
CONCATENATE() 関数ではだめでしょうか。
ValueChangedイベントを使いましょう。 private void dateTimePicker1_ValueChanged(object sender, EventArgs e) { if (dateTimePicker1.Value > dateTimePicker2.Value) { dateTimePicker1.Value = dateTimePicker2.Value; } } private void dateTimePicker2_ValueChanged(object sender, EventArgs e) { if (dateTimePicker2.Value < dateTimePicker1.Value) { dateTimePicker2.Value = dateTimePicker1.Value; } } このように記述すればOKです。 あまり褒められたやりかたではない気もしますが、 間違ってはいません。
①について Range ("3:7").Rows.AutoFit を Worksheets("Sheet2").Range("3:7").Rows.AutoFit としてみて下さい。 今回のように複数のシートを扱うマクロでRangeやCellを指定するときは、常に「ターゲットとなるシート」を明示的に指定するように心がけて下さい。 ②について 使用しているメールソフトがOutlookなら多分実現可能だと思います。が私は詳しくないので「Excel メール送信」でググッてみて下さい。
この長い文字列はPHPというプログラミング言語の「セッションID」というものです。 セッションIDはランダムな文字列なので解読することは出来ません。
1秒ウエイトするのであれば System.Threading.Thread.Sleep(1000)
>どなたか案をください。 自分の身の回りに関するデータベースで考えてみるとイメージが湧くのでは？ 複雑なものより、誰が見ても単純で実用的な管理システムのほうが作りやすいかと思いますね。 例えば、レンタルCDやDVDなどを利用されているのであればビデオ貸出システムの流れがだいたい分かりますね。 後は、在庫管理システム、図書貸出システム、顧客管理システム・・・などなど。 ビデオ貸出システムであれば、フィールドとして題名、ジャンル、監督名、主演名、貸出日、返却予定日、フラグ（返却確認用）、管理IDなどが挙げられますので、それらをテーマごとに分けたテーブルを作成して、クエリで連結させます。 後は、画面となるフォームで表示させれば良いです。 >Access VBAを用いて成果物を作成 フォームにボタンを配置して、各フォームを表示させたり、題名（タイトル）から検索できるボタンなどを作成すれば・・・。 Accessはデータベースソフトなので、主にたくさんのデータを蓄積して、それらデータから必要なデータだけを抽出したり、編集・削除したりするシステムを作るものです。 失敗しないポイントは、複雑なテーブル構成にしないことです。単純なテーブルでクエリやフォームがうまく動くことを確認しながら作ってください。
>実行するとFoprm1が起動しますこれをForm2を起動するようにしたいのと ①メニューバーより「プロジェクト」→「xxxxxのプロパティ」（一番下） ②「スタートアップフォーム」で、起動時のフォームを選択。（↓画像参照） >ちなみにフォームは移動すると前のフォームは消えるのでしょうか？ >Form1 から Form2 に移動して再度、Form1 に戻る時Form2 を消したいのです Form1.Hide() 等で自分で消さない限りは消えません。 Form2 を消して Form1 に戻るには、From2を[×]で閉じるか、Me.Hide() か Me.Close() で閉じます。 Form2を開くときに、 Dim Frm As New Form2 Frm.ShowDialog() にすると、モーダルで開くので、Form2が閉じられるまでForm1の操作は出来ません。 >できれば引数AとBとCを持って行って戻る時に返したいのですが、 私は、フォームにプロパティを作成して、開く前に値をセットします。 プロパティについては、検索すればサンプルが多く出てきます。 または、標準モジュールでグローバル変数（Public）を作れば簡単です。
今度は「ListBox」なのですね。 作ってみました。 前回の「TextBox」とほとんど同じです。 ------------------------------------- Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click OpenFileDialog1.Multiselect = True OpenFileDialog1.Filter = "すべてのファイル(*.*)|*.*" OpenFileDialog1.InitialDirectory = "c:\" If OpenFileDialog1.ShowDialog() = Windows.Forms.DialogResult.OK Then ListBox1.Items.Clear() For Each strFilePath As String In OpenFileDialog1.FileNames ListBox1.Items.Add(strFilePath) Next End If End Sub -------------------------------------
まだ投球再開のメドも立ってないみたいです。 今シーズンの復帰は難しいですね。
画像が表示出来るコントロールは他にもあったり、画像ファイルの種類によっては背景が透明にならなかったり。 試すことは色々…頑張ってみたら？
各項目にダブルクオーテーションを付けたCSVファイルを出力するためには、独自に項目を編集してファイルに出力するしかありません。 また、「全項目半角」にするためにはStrConv関数を使用しますが、全角ひらがなや漢字の場合は半角にはできません。 【サンプル】（出力対象セルがA2～N73として） Sub CSV作成() Dim myFileName Dim fn As Integer Dim buff As String Dim rng As Range Dim x As Long Dim y As Long myFileName = Application.GetSaveAsFilename(FileFilter:="CSVファイル (*.csv,*.csv") If TypeName(myFileName) = "Boolean" Then Exit Sub Application.ScreenUpdating = False fn = FreeFile() 'CSVファイルを出力で開く Open myFileName For Output As #fn '行2～73を繰り返し For x = 2 To 73 buff = "" '列1～14（A～N）を繰り返し For y = 1 To 14 '項目をダブルクオーテーションで括りカンマを付ける buff = buff & """" & Cells(x, y).Value & """," Next y '最後のカンマを除き、半角に変換 buff = StrConv(Left(buff, Len(buff) - 1), vbNarrow) '出力 Print #fn, buff Next x Close #fn Application.ScreenUpdating = True End Sub
下記で解説されています。 ■クリップボードに格納されているデータを確認する■ クリップボードとデータのやりとりをする http://www.moug.net/tech/exvba/0150091.html
キーボードで操作したいんですかね？ コンボボックスはF4で開いたはずです。
Copy した直後は新しくコピーで作成されたファイル（ブック）がアクティブにあるため、r=2になった時の WorkShees は、その新しいファイルの２つ目のシートをコピーしようとするためエラーになります。 以下のようにしてはどうでしょうか。 Sub d() For r = 1 To 5 ThisWorkbook.Worksheets(r).Copy Next r EndSub
こんちには。 If .Cells(tRow, tCol) Then vgyo = Worksheets("移動シート").Cells(Rows.Count, tCol).End(xlUp).row .Range("D" & tRow & ":K" & tRow).Copy _ Worksheets("移動シート").Range("D" & vgyo+1 & ":K" & vgyo + 1) とか、コピー元と同じサイズにしたら、問題は少ないです。
以下のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim w As Integer Dim h As Integer w = 4 h = 5 Dim i As Long, j As Long Dim r As Long, c As Long For i = 1 To w c = w - i + 1 For j = 1 To h r = h - j + 1 Sheet2.Cells(r, c).Value = Sheet1.Cells(j, i).Value Next j Next i End Sub
第一のキラ、第二のキラ、Ｘキラ
high.s1.xrea.com/q12160481197.xls リストボックスを使った対象の文字列を判別するサンプルです。 If strsc(ac(SplitCnt)) Then '条件いずれかに一致･･･ Sheets("翻訳作業").Cells(z, 2) = ac(SplitCnt) z = z + 1 Else '条件に一致しない場合 End If とすると条件に一致するかどうかを判別して結果をTrue/Falseで返す関数を作ってみました。 Function strsc(trg As String) As Boolean Dim q As String Dim t As Boolean t = False For w = 6 To 12 'リストの上限row q = Sheets("翻訳作業").Cells(w, 10).Value Select Case Sheets("翻訳作業").Cells(w, 11).Value Case "から始まる" t = (Mid(trg, 1, Len(q)) = q) Case "完全一致" t = (q = trg) Case "で終わる" t = (Right(trg, Len(q)) = q) Case "を含む" t = (InStr(1, trg, q) <> 0) Case Else t = True End Select Sheets("翻訳作業").Cells(w, 12).Value = t 'テスト出力 If t Then strsc = t End If Next w End Function
If文の並び順がダメなんじゃないんですかね。コードは上から処理されるので、btとbttが文字列であったとしても、c1に何らかの演算子が入力されていれば計算してしまいます。 エラー判定のコードをc1の記号判定のコードより前に持ってくれば解決すると思います。 どうでもいい事ですが、c1の判定処理はIfとElseIfを使うよりもSelect Case を使った方がすっきりするかもしれませんね。 それでは。
こんにちは。 このコードだと、リストコントロールに流し込んだデータをチェックしてますよね、 主様のしたいことは、オートフィルターで出来る操作なのでは？ それだったら、探したいシートを選択し、探したいフィールドで、フィルター情景を設定する操作を自動記録を作成して、 それに対して「検索キー」を渡してあげるコードを作成したらいいです。 シートを切り替えて、「セルジャンプ」している、というコードなのですから。 最初からそのシートを開いて、フィルターをかけるのが、「あいまい用」ということでいいかと。
該当のサイトのURLはいただけませんでしょうか？
入力不備のメッセージを表示した後Exit Subで終了させていますが、 Application.EnableEvents = Falseしたままですので、イベントが発生しない状態です。 Application.EnableEvents = True としてからExit Subするか、 Application.EnableEvents = False を入れる場所を、エラー判定したあとにします。
こんにちは。 主様のデバイスに、googleアプリをインストールし、正しくログインした状態で 使っている状態があります。 続いて、本題の操作です。 1) デバイスの「googleアプリ」のアイコンをタップ 2) 表示した画面には、Googleのイメージ文字と、「検索ボックス」と お勧めの記事などが、表示されています。 検索ボックスは、タップすると、「文字を入力する、urlを入力する、などできますが、何回か使っている、履歴の表示があり、一番下の行に、「検索履歴の表示」の部分があります。 そこをクリックして、履歴のクリアの操作をする、ということを、主様のヘルプ画面では説明しています。 Googleは、Googleマップやメールなど、たくさんアプリがあります。 Google Chromeは、ブラウザーのアプリです。 それぞれ、イメージアイコンが違っているので、よく確認してください。 主様、説明画面と違う操作をしているようです。
こんにちは。 O列の関数は、間違っています。 1) 正しくO列を入力します。 2) マクロの自動記録を開始して、o3セルの編集とエンターとして、 関数のマクロコードを取得します。 3) 記録は停止。 これで、出来たコードと差し替えてください。 コードは、m3:n3のselectをm3:o3としたり、コピペーストのcells(13,14 の部分がm n oの付近です。 ここを正しくあわせてください。
ThisWorkbookはその名前の通り、ワークブックに対するイベントを管理するモジュールです。 各シートにSheet1からできているのと同じ。 確かにThisWorkbookにPublicの関数を書けばいろんなところからアクセスできますが、それはSheet1も同じこと。 「書ける」状況が「適正」な状況ではない。 グローバルな関数を書くのであれば標準モジュールに書くのが適正です。 オブジェクトに対応したモジュールの中にはそのオブジェクトだけを扱い、共通部品などの処理は標準モジュールに準備する。 それがお約束です。 ThisWorkbookに共通関数などを作るメリット？と言えばモジュールの数が少なくなる。 デメリットは処理が複雑になればなるほどどこに作ったか判らなくなる関数が現れる。
Session.SendAndReceive True を設定してはどうでしょう。 Const olFolderInbox = 6 With CreateObject("Outlook.Application") .GetNameSpace("MAPI").GetDefaultFolder(olFolderInbox).Display .Session.SendAndReceive True End With
サーバーにはデータベースを配置。 ローカルのBookではサーバ上のデータベースと値をやり取りしながら加工表示するとか。
Forms!は『開いているフォームの集まり』を意味しているので、 このエラーが出ているということはFスタートが開かれていないのに 代入しようとしたことを意味します。 事前にFスタートを開いておいて、そのうえでOK_Clickを実行すると うまくセットされます。
Excelの余計なお世話機能が炸裂すると、32E01は00320と同一で72E02は07200と同一です。指数表記とゼロサプレス表記の違いだけで数値としてはおなじですからね。 これらがきちんと文字列として格納されているのか、条件付き書式の数式がきちんと文字列として比較しているか、の2点がポイントになります。
こんにちは。 カレントプロジェクトのCN=の部分は、 set CN= で試してください。 rsのopenで、yahoo知恵袋 というのは、どんな定義でしょうか さて、ieオブジェクトから、アクセスに読込みさせる、 ということなんですが、 実例としてだと 「あるwebページ」には、tableタグがあります。 そのテーブルに表示したものをアクセスに読込みしたい というような場合だったら、ieに検索結果を表示し、tableタグをgetelementsして、 cellsとrowのfornextでセルを読込みするループを組んだらよいことになりますが、 いきなりre openしたということなんですから、どんな定義なのか、説明してもらったほうがいいんでしょうかね。(単純に保存したいテーブルなのか、ということです)
状況がよく分かりませんが、CSVファイル以外でデータの管理をしたいのいうのでしょうか？ 大量のデータを、読み込み、追加、変更、削除を行うには、通常はデータベースソフトを使用します。 Access、SQL Server、Oracle などを使えば良いかと思います。 データーベースでデータを扱うには、SQL文を使用します。 ↓「SQL Server Express」（無料） http://www.microsoft.com/ja-jp/server-cloud/products/sql-server-edi... ↓SQL文 http://sql.main.jp/cont/sql/map.html 私は、Visual Basic 2012 とAccess を使って大量データを管理しています。 CSVファイルのデータを Access に取り込めば、大量データを簡単に取り扱うことができます。
TAB回数ということは、Sendkeysを利用しているということでしょうか。IE制御ならば、 ie.document.getElementsByName("PHPSESSID")(0).Submit ※前後のHTMLが不明なので、仮に配列0番にしてあります。 ということになります。
(xl, vbs) ファンクションを別にしたサンプルです。 ◆前提 エクセル名 = Book1.xlsm vbs名 = x.vbs 上記2つのファイルは同じフォルダに在中 ◆[vbs.vbs]コード Dim xlBK Dim strResult Dim strPath 'vbsで[strResult]セット strResult = Now() Wscript.Echo strResult & Chr(13) & "これはvbsのstrResult" 'vbsからエクセルをゲットオブジェ strPath = CreateObject("Wscript.Shell").CurrentDirectory & "\Book1.xlsm" Set xlBK = GetObject(strPath) 'vbsからエクセルファンクション実行 xlBK.Application.Run "step2_getResult", strResult set xlBK = Nothing ◆エクセルvba Function step1_retResult() Dim strPath As String 'vbs実行⇒[strResult]を取得 strPath = ThisWorkbook.Path & "\x.vbs" strPath = Chr(34) & strPath & Chr(34) CreateObject("Wscript.Shell").Run strPath End Function Function step2_getResult(ByVal strResult As String) As String MsgBox strResult & vbNewLine & "エクセルvbaに戻ってきた", vbInformation '残りの処理はここから下へ記載 End Function ◆エクセルvbaから [step1_retResult] 実行
こんにちは。 結論から、 cmdの印刷オプション 印刷オプション path ： ファイルパス printername ： プリンタ名 と、あります。 shellで開くときに、ファイル名を指定し、さらに、プリンター名を追加で指定してください https://helpx.adobe.com/jp/acrobat/kb/510705.html 解説、 エクセルで、プリンターを切り替えても、あまり意味が無いです。 エクセルが起動して、「エクセルのアクティブ」プリンターが指定できますが、 OSのアクティブプリンターには、影響しません。 つまり、shellで起動しても、osの内容によるので、今のコードでは、対応ができません。
C:\Test\SaveBmpというフォルダを作成し、そのフォルダ内に全てのタブページをpng形式で画像保存する例です。 Dim bmp As Bitmap System.IO.Directory.CreateDirectory("C:\Test\SaveBmp") For Each tpg As TabPage In TabControl1.TabPages bmp = New Bitmap(tpg.Width, tpg.Height) tpg.DrawToBitmap(bmp, New Rectangle(0, 0, tpg.Width, tpg.Height)) bmp.Save("C:\Test\SaveBmp\" & tpg.Name & ".png") Next
私は40歳過ぎてから仕事の必要性から勉強しました。本業ではなくいわゆる片手間プログラマです。 勉強はスクールに通いました。初心者レベルなら数万円です。楽しいですよ。ゼロを一にするのは難しいですが、1を10にするのはそれほどでもありません。自力で調べられるようになるからです。最初だけはある程度投資することを勧めます。 資格があって、エクセルVBAエキスパート・ベーシックとスタンダードです。エキスパートなのかビギナーなのか分かりにくい名前ですが、ベーシック取得を目指して勉強すると、必要な基礎事項を網羅出来るようになってます。スクールやセミナーは大抵これを目指してます。セミナーは薦めません。1～2日の集中講義では修得出来ないからです。スクールも人件費を抑えたビデオ形式の方が、何度も見直し出来て時間の都合も付けやすいです。 仕事でやるなら、内容を簡単に調べておいて、テーマ解決を念頭において勉強すると捗ります。ああ、今ここの部分をやってるんだなと判るからです。 ゼロを1に出来たら、後はここで質問するとかググるとか、いくらでも方法はあります。
①について Do Until Cells(line, 1) = "" Cells(line, 2) = Application.WorksheetFunction.VLookup(Cells(line, 1), line2, 2, 0) If Err.Number = 0 Then line = line + 1 としていますが、もしApplication.WorksheetFunction.VLookupがエラーになった場合、Err.Numberは0以外なのでline = line + 1が実行されません。 つまり永久にDoループが終わらなくなります。 フリーズする原因はそのためです。 エラーが発生しようがしまいが、line = line + 1は必ず実行させる必要があります。 ②について 「1-2-3」はExcelでは日付形式とみなされます。 ですから値を設定する前にセルの書式設定を「文字列」にしておく必要があります。 Cells(line, 2).NumberFormatLocal = "@" を Cells(line, 2) = Application.WorksheetFunction.VLookup(Cells(line, 1), line2, 2, 0) の前に挿入します。 上記を踏まえて整理したコードを示します。私のPCで2万件のデータで試したところ約30秒で全件の処理が終わりました。 Option Explicit Sub 番号() Dim line As Long Dim nValue As Variant Dim rng2 As Range Application.ScreenUpdating = False Set rng2 = Worksheets("Sheet2").Range("C:D") With Worksheets("Sheet1") For line = 2 To .Range("A" & .Rows.Count).End(xlUp).Row nValue = "" On Error Resume Next nValue = Application.WorksheetFunction.VLookup(.Range("A" & line).Value, rng2, 2, True) On Error GoTo 0 If nValue <> "" Then .Range("B" & line).NumberFormatLocal = "@" .Range("B" & line).Value = nValue End If DoEvents Next End With Application.ScreenUpdating = True End Sub
「ファイルごとに列方向にまとめる」「A列はどれも同じで」「A列一つとファイルの個数分のB列を含むファイルを作りたい」といわれても具体的なイメージが湧きません。 具体的な例を示してください。
Option Explicit Sub 成績() Dim CellGyo As Long For CellGyo = 4 To 23 If Range("G" & CellGyo).Value < 60 Then Range("H" & CellGyo).Value = "不合格" End If Next CellGyo End Sub
VBAで使用するウィンドウなどはメニューの「表示」から選択でいます。 ひょっとして「表示」というメニューがなくなったのかな？ だとしたら、VBE画面の右上（メニューバーや標準バーのボタンのないグレー色）の上で右クリックして「ユーザー設定」を選択します。 「ツールバー」タブの「メニューバー」を選択して、右下の「リセット」ボタンを押してください。
いいです。 ただ、後で読んだ際に見やすいようお勧めはあるようです。 例えば、 一部を大文字で宣言しておき、入力の際は小文字入力する習慣を付けておくと、largeletter=と書いてもLargeLetter=と自動修正されので、誤入力した時には修正されず判別しやすいです。 文字数はA=とするよりも、長くていいから内容がわかるものを付ける傾向にあります。逆にFor i= 等のいわゆるカウンターはどうでもいい変数なのでi=と小文字にして目立たないようにします。 プロのプログラマなら、コーディングルールとして変数名はビシッと決まってます。複数の人数で見るものですし、お客様からの仕様で決まってることもあります。 ハンガリアン表記といって、strNameのように最初の２，３文字で変数の型や種類を書く方法があります。マイクロソフト内でハンガリー人が始めた方法だそうです。ただ、今は推奨されてないようです。名前の付け方は流行りがあるようです。
Sub test() Dim 変数1 As Long Dim 変数2 As Long Dim dic, xItem 変数1 = 123 変数2 = 456 Set dic = CreateObject("Scripting.Dictionary") With dic .Add Key:="Key1", Item:=変数1 .Add Key:="Key2", Item:=変数2 End With xItem = dic.Items 'ここでは、123 と 456 となっている。 For i = LBound(xItem) To UBound(xItem) Debug.Print xItem(i) Next 変数1 = 987 変数2 = 654 'ここでも、123 と 456 となる。ここで 987 と 654 にする方法は？ With dic .Item("Key1") = 変数1 .Item("Key2") = 変数2 End With xItem = dic.Items For i = LBound(xItem) To UBound(xItem) Debug.Print xItem(i) Next End Sub Items メソッドとItemプロパティは別物というわけです。
クラス内の定数としてもつのが良いと思います。 メモリの消費については50文字程度であれば全く考慮する必要はありませんし、速さについてはReleaseモードでコンパイルすると最適化されるのでこちらも気にする必要はありません。 ですのでコーディングの際は可読性とメンテナンス性を優先して構いません。 ちなみにそれぞれのボタンのClickイベントでの処理がほぼ同じ場合、Clickイベントプロシージャーはひとつに統合することが出来ます。 下記はDialogResultプロパティをYes、No、Cancelに設定したボタンのClickイベントの記述例です。 Private Sub Button_Click(sender As System.Object, e As System.EventArgs) Handles Button1.Click, Button3.Click, Button2.Click Dim btn As Button btn = sender Select Case btn.DialogResult Case Windows.Forms.DialogResult.Yes 'Yesボタンの時の処理 Case Windows.Forms.DialogResult.No 'Noボタンの時の処理 Case Windows.Forms.DialogResult.Cancel 'Cancelボタンの時の処理 End Select End Sub
セルの書式を日付表示にして、360を加算すればいいです。 日付表示は、「書式設定」で選択すればいいですが、エクセルの標準表示は、「2016/4/1」になります。 これを、「2016.4.1」と表示させたいなら、「ユーザー定義」を選択して、「yyyy"."m”.”d”.”」と設定すれば可能です。 データの入力は、2016/4/1 とタイプすれば、日付データとして認識されます。 ただし、上記のように表示されるだけで、実際には 1900年1月1日 を 1 とした時の 経過した「日」を全て加算した数字が記憶されています。 「2016.4.1」であれば、42461 という数字になります。 添付事例は、表示を合わせるため、「yyyy"."mm”.”dd」としました。
Sub 一例です() Dim idx As Long, sh As Worksheet Const col As String = "A" Apprication.ScreenUpdating = True For Each sh In Worksheets With sh For idx = 2 To .Range(col & Rows.Count).End(xlUp).Row If .Cells(idx, col).Value = "1" Then .Rows(idx).Hidden = True End If If .Cells(idx, col).Value = "＊" Then .Rows(idx).Hidden = False End If Next idx End With Next sh Application.ScreenUpdating = False End Sub 未実行につき不具合ご容赦。
選択して貼りつけるところだけ。エラーは考慮してません。 Range("A1").Select With Application.FileDialog(msoFileDialogFilePicker) .Show ActiveSheet.OLEObjects.Add(Filename:= _ .SelectedItems(1), Link:=False, DisplayAsIcon:= _ False).Select End With
私はレジストリを使っています。 iniフィルを使う、テキストファイルを使う、データベースを使うなど、方法はいろいろ有るかと思います。
惜しい。 【修正前】WebBrowserDocumentCompletedEventArgs e 【修正後】WebBrowserDocumentCompletedEventArgs^ e ^ 記号が足りなかっただけですね。 《備考》 WebBrowserDocumentCompletedEventArgs 型オブジェクトを指すハンドルという意味。^ 記号が無いと実物という意味になってしまいます。 ^ 記号の有無でハンドルなのか実物なのかの意味が変わってくるというわけ。
> 図の様に 図がないので、やりたいことと一致しているかわかりませんが、 以下を標準モジュールに記述して、 アクティブシートを対象に Samp1 を実行してみます Public Sub Samp1()    Dim rArea As Areas    Dim rng As Range    Dim i As Long    Application.ScreenUpdating = False    With ActiveSheet.UsedRange       With .Columns(1)          .UnMerge          On Error Resume Next          Set rArea = .SpecialCells(xlCellTypeBlanks).Areas          On Error GoTo 0       End With    End With    If (rArea Is Nothing) Then Exit Sub    For Each rng In rArea       i = rng.Count       If (i > 1) Then          i = (i - 1) \ 2 + 1          rng.Resize(i).Delete xlShiftUp       End If    Next    Application.ScreenUpdating = True End Sub
このプログラムはVBAでしょうか？それともVB.Netでしょうか？ 変数・メソッド・プロパティがすべて大文字なのはなぜでしょう？
Sub 一例です() Dim sh1 As Worksheet, sh3 As Worksheet, rng As Range, i As Long i = 7 Set sh1 = Worksheets("Sheet1") Set sh3 = Worksheets("Sheet3") With Worksheets("Sheet2") For Each rng In .Range("F2", .Cells(Rows.Count, "F").End(xlUp)) If Application.CountIf(sh3.Range("E:E"), rng.Value) > 0 Then i = i + 1 rng.EntireRow.Copy sh1.Rows(i) End If Next rng End With End Sub
以下のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim rng As Range For Each rng In Range("F2:L2") If IsNumeric(rng.Value) Then rng.Value = Round(rng.Value, 3) End If Next rng End Sub
「下記のような表」はちょっと理解できないですね。 とりあえず、1行目で最終列を割り出すとすれば、↓のような感じ。 Sub 一例です() Range("B2:B6").Copy Range("C2", Cells(1, Columns.Count).End(xlToLeft).Offset(1)).PasteSpecial Paste:=xlPasteFormulas End Sub
縦横を同時に変更するのならSize、 縦を変更するのならHeight、 横を変更するのならWidth です。
スクロールバーの「リンクするセル」を設定して、WorkSheet_Changeイベントでそのセルが変更されたらグラフに反映されるようにしてはどうでしょうか？ ただしこの方法だとマウスでスクロールバーを変化させると1変化ごとにグラフ描画が行われるので「うっとおしく」なると思うのですが・・・
担当者の表示です。活用して下さい。 Sub 担当者() Dim temp As Variant Dim i, s As Long temp = Array("野田100", "川田101", "原田102", "山田103", "岡田104", "池田105") For s = 100 To 105 i = i & temp(s - 100) & vbCrLf Next MsgBox i End Sub
マクロの登録、と書いてあるという事はマクロの基礎はおわかりなのですね。 >一つのシートに 8列10行の物を60個作り(ラベルシールになります) >それぞれ印刷したいのですが 印刷枚数も全部違います。 8列10行の物とは1ページ内に8列10行なのか、その組み合わせで60個なのか。 また何を印刷したいのか、固定文字のラベルなのか、説明が不足しています。 それぞれの枚数が違うという、それぞれとは何かの元データがあるのでしょうか。 マクロと書いてあるのに設定というもの矛盾していると思いますが、設定という事でなら、最初の回答者の方が言われる通り、そのような設定はありません。
一例です。 =IF(COUNTIF(セル範囲,"NG"),"NG","OK")
・平成生まれしか考えない ・10月時点って10月のいつだよ末日にしとくか という条件なら、基準の年から誕生年を引き算したのが「誕生日を過ぎたときの年齢」なので、誕生月が11月以降の場合だけまだ誕生日を過ぎてないとして1引きます。 =(基準年-誕生年)-(基準月<誕生月) これだけ。
こんにちは。 サムネイルの集まりの画面ですけどね。 実際クリックすると、記事になってしまうので、「画像サムネイル」の保存ということです googleの検索結果を表示しているときのurlを、メモ帳で直接開くと、メモ帳でソースは見ることが出来ます。 画像の検索結果で、imgタグのソースは、アドレスが長いですし、最後は引数で終わるので拡張すら、ありませんけど、そのアドレスだったら、MSペイントでも直接開きます。 つまり、VB6にあるような、「urlの直接ファイル保存」が、できるということです。 どこまで、なにが出来ているかで、話が変化します。確認してみてください
素晴らしい説明が有りました。ご参考になれば。 http://qiita.com/mima_ita/items/dd95ba1f25ba176fccb3 個人的にはActiveReportは使い慣れてるので、そちらを利用したいと思います。 追加変更ファイルの配布方法で考えた方がいいかもしれませんね。
プロジェクト名のプロパティを開いて 「リンカー」→「全般」→「追加のライブラリディレクトリ」に $(DXSDK_DIR)\lib\x86; というを追加してください。 「C/C++」→「全般」→「追加のインクルードディレクトリ」に $(DXSDK_DIR)include というのを追加してください。
未確認ですが、できるようです。 http://vaindespair.blogspot.jp/2012/04/blog-post_7272.html
こんにちは。 変数の初期化の確認のコードは、主様のそのコードなんでしょうか。 今まで、エラーにならなかっただけのような気がする。 redimのあと、doeventsを実行したほうが、よほど効果ありそうです。
質問が大雑把ですね。 >vbの課題研究でなにか作成しなければいけません。 VB（Visual Basic）と言っても、「Visual Basic 6.0」「Visual Basic .NET」「visual Basic for Applications」等では、それぞれ出来る事が違います。 課題研究で作成するプログラムの規模や、あなたのスキルも分かりません。 ・メモ帳 ・スケジュール帳 ・万年カレンダー ・ゲーム ・WEBブラウザ ・メーラー などなど、無限にあるかと思いますが・・・ あなたはどんな物が作りたいのでしょうか？
#include <stdio.h> int main(void) { int a,b,i; FILE *file; while(1){ printf("数値1の入力:"); scanf("%d",&a); printf("数値2の入力:"); scanf("%d",&b); if(a==b)printf("もう一度入力してください。\n\n"); if(a!=b)break; } file=fopen("range.txt","w"); if(a<b)for(i=a;i<=b;i++)fprintf(file,"%d ",i); else for(i=b;i<=a;i++)fprintf(file,"%d ",i); fprintf(file,"\n"); fclose(file); printf("出力しました。\n"); return 0; } for文の外でopenしてください。現状では１回だけの出力ではなく、上書きになっているだけです。
http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1416049108... と全く同じ質問のようですが？
このままでは、必ずlocations に指定された A1～I1に転記されてしまいます。 希望とすれば転記済の最終行の次の行に転記したいですよね。 ですから、最終行を求め、locations からその行数分下に転記するようにします。 修正例（修正部位分のみ） '項目入力ボタンがクリックされた時の処理 Private Sub CommandButton2_Click() Dim i As Integer Dim n As Long '<=最終行を入れます 'ブックが開かれていなければ何もしない If bk Is Nothing Then Exit Sub 'アクティブなシートが日シートでなければ転記しない Set st = bk.ActiveSheet If st.Name = "メイン" Then Exit Sub '最終行を求めます －－ここからーー n = st.UsedRange.Rows(st.UsedRange.Rows.Count).Row '１行目にも値がない場合は０にする If n = 1 And Application.WorksheetFunction.CountA(st.Rows(1)) = 0 Then n = 0 End If ’－－ここまで追加ーー '項目１から項目９を転記する For i = 1 To 9 'SetValue の2つめの引数を追加 SetValue locations(i - 1), n, Me.Controls("TextBox" & i) Next i 'メッセージを表示する DoEvents MsgBox "転記しました。" CommandButton3.SetFocus End Sub 'テキストボックスの内容をシートに転記する（2つめの引数を追加） Private Sub SetValue(cell As String, n As Long, data As String) On Error Resume Next '指定のセルのn行下にセットする st.Range(cell).Offset(n).Value = data On Error GoTo 0 End Sub >またシート開くときにブックが平成28年1月1.xlsになるのはなぜですか？ 'ブックを開く Set bk = Workbooks.Add(bkPath & bkName) としていますが、Workbooks.Addではブックの追加になりますので、すでにある「平成28年1月.xls」をテンプレートとして新しいブックを追加、名前は元のブック名に「1」を付けて「平成28年1月1」になってしまいます。 既存のブックを開くのであれば 'ブックを開く Set bk = Workbooks.Open(bkPath & bkName) とします。
できないことはないです。 http://www.vba-ie.net/form/subroutine-input.html ただし、パスワードの管理など適切にやらないと危ないので、 やめたほうがいいと思います。。。
下記のコードでいかがでしょうか？ 一個のセルだけでなく、複数のセル範囲が選択された場合にも対応しています。 数字以外のセルに対しては何もしません。 Option Explicit Sub Sample() Dim rng As Range If TypeName(Selection) <> "Range" Then Exit Sub For Each rng In Selection.Cells If IsNumeric(rng.Value) Then rng.Value = Round(rng.Value / 2, 3) End If Next rng End Sub
質問の意味は、わかります。 もしも私が解釈した仕様であれば、その仕様は、ごちゃごちゃして説明しづらいと思います。 よって、まずその仕様を下記に書きます。 [もともと行ないたかった仕様] ピクチャボックスの中に（上に）ボタンを配置する。 その際に、そのボタンは、透明化する（ボタンの文字列や枠だけ見えて、ボタンの背景は透けて、ピクチャボックスの画像が見えるようにする）。 [今回の質問の仕様] 上記の「もともと行ないたかった仕様」では、何をやってもボタンが透明化しない。 そこで、以下の仕様にすることにした。 ピクチャボックスの中に（上に）、別のピクチャボックスを配置する。 その際に、中側の（上側の）ピクチャボックスは、透明化する（中側のピクチャボックスに描画する枠だけ見えて、中側のピクチャボックスの背景は透けるようにする）。 この場合、中側の（上側の）ピクチャボックスの透明化は、うまく行く。 しかし、中側の（上側の）ピクチャボックスをボタン代わりにする際に、そのクリックイベントの扱い方が、わからないので本質問を出した。 [回答本編: 方法１] 上記仕様で合っている場合は、下記の通りです。 画像を貼り付けるピクチャボックスをpictureBox1とし、ボタン代わりにするピクチャボックスをpictureBox2とすると、 // pictureBox2の親コントロールをpictureBox1と指定する pictureBox1.Controls.Add(pictureBox2); とします。 全体のコードは、下記に記します。 なお、下記の全体のコードは、pictureBox2のクリックイベントの扱い方までは書いていません。 しかし、普通に、 pictureBox1.何々; と言う指定が行なえるので、イベントハンドラをいじらなくても操作が行なえます。 「＜C#＞ ピクチャーボックスの上に、透明化した別のピクチャーボックスを配置するサンプル No.１ --- 透明化ピクチャーボックスに円を描画する」 http://note.chiebukuro.yahoo.co.jp/detail/n375793 [方法２] やったことはないのですが、質問のようにParentプロパティを使う手法でしたら、以下のようにすればよいと思います。 ParentプロパティをPictureBoxクラスへのキャスト（型変換）をすれば、ピクチャボックスとして機能するはずです。 PictureBox Pic_Box_Work = (PictureBox)button.Parent; そのあとは、普通に、 Pic_Box_Work.何々; と言う指定が行なえるので、画像表示用ピクチャボックスの操作が行なえます。
いろいろ問題が有り過ぎですね？ ＆演算子も勉強しなおしです。 Sub 消費税計算() Dim Teika As Long, Zei As Double, ZeiGaku As Double Teika = Range("B3").Value Zei = Range("B4").Value ZeiGaku = Teika * Zei MsgBox "定価" & Teika & "の消費税は" & ZeiGaku & "です。" Range("B5").Value = Teika + ZeiGaku End Sub
sf As Double, lf As duble, lf As Double) を sf As Double, lf As Double) としてみてください。
こんにちは。 ファイルを開いて、環境を用意したら、「マクロの自動記録」を使って、 コードを生成し、必要に修正を追加する、というのが、ピボットのコードです。 エクセルのバージョンでも違います。 最終行の取得は gyo = sheets("シート名").range("A" & rows.count).end(xlup).row で変数でピボットに与えます。 日々変化するのでしたら、変数にすることを考えてください。 ブックが変化しない場合は、シートのもともとのピボットテーブルを初期化する考え方も必要です。
別シートのデータはどのようになっているのでしょう。 ・下図の三例のうちどれなのでしょうか。 ・また、同じ品名が複数区分に存在することは無いのでしょうか。
>Set w = ActiveSheet >w.PageSetup.Zoom = 30 '30%に縮小 となってるので、ActiveSheetだけ縮小されてるからだと思います。 不要だと思える部分があるようですが、以下でどうでしょう。 Private Sub CommandButton1_Click() For Each myWS In Worksheets If myWS.Name Like "*★*" Then myWS.PageSetup.Zoom = 30 '30%に縮小 myWS.PrintOut End If Next End Sub
バージョンがわかりませんが、たぶんどれも同じだと思います。 メニューバーの [ツール]→[オプション] を選択。 [テキスト エディター] →[すべての言語] →[全般] を選択 表示の [行番号]をオンにします
Sub MakePDF() を書きかえるのなら Sub MakePDF() Dim fName As String, i As Long, xToF As Boolean For i = 1 To 3 xToF = True If i <> 1 Then If Trim(sh.Cells(i, 1).Value) = "" Then xToF = False End If End If If xToF Then With Worksheets("Sheet" & i) 'fNameに作成するファイル名 fName = orgName & "_" & .Cells(i, 2).Value & "_" & .Cells(i, 3).Value & ".pdf" .ExportAsFixedFormat Type:=xlTypePDF, Filename:= _ nDir & "\" & fName, Quality:=xlQualityStandard, _ IncludeDocProperties:=True, IgnorePrintAreas:=False, OpenAfterPublish:=False End With End If Next i End Sub 未実行につき不具合ご容赦。
こんにちは。 csvファイルを書き込みに行く前に、ディレクトリまでのパスをチェックする形でどうでしょう？ Dim csvPath As String csvPath = "C:\データ" ’ここには必要なパスを入れてください。 If Len(Dir(csvPath, vbDirectory)) = 0 Then MkDir (csvPath) End If ただ、データの下の階層まで一度にはMkDirでいないので注意が必要です。
JavaScript どころではないです。 Flash や ある意味 Flash 以上の動きや機能を付けられます。 例 「シューティングゲーム 猫とエクセル」 http://www.geocities.co.jp/SiliconValley-Cupertino/8748/shooting.ht... ↑過去に困りごとがあったとき    この作者の方に直接質問をしとことなどもあります。    (お返事も高度過ぎて半分以上付いていけませんでしたが。。。) その他の例 「エクセルアニメーション第１回(マクロ準備編） - エクセルアニメーション」 http://blog.goo.ne.jp/cisco33/e/45c5f614633cc0b67e299afbf360c10e 「がらくた箱 猫とエクセル」 http://www.geocities.co.jp/SiliconValley-Cupertino/8748/himitu.htm JavaScript って結局操作するのが HTML なんですよ。 ですから制約だらけで動きはかなり作りにくいです。 Flash はそもそも動きをつくったり見たりするためのソフトであったりコンテンツですが Web 上のクライアントサイドでしか動作しないものなので 「セーブ」みたいなことは他言語を使わなければできませんし Web (ブラウザ) で見る店においては JavaScript 同様セキュリティも厳しいので 結構制約だらけなんです。 Excel などの VBA は そういう Web 的な制約が無い分 色々な意味での「動き」は JavaScript 以上に自由に作ることができます。 ただし！ Web 上では動作しない とか Excel を持ってないと動かない とか (Flash と同様，基本的に スマホ では動かないでしょう。) その他 セキュリティ面で弱い分ウィルスなどに注意する必要がある という「大きな障壁」はあります。
ユーザーフォーム２をShowする前に、Loadし、トグルボタンのValueやフォームのBackColorを操作します サンプルです 'フォーム①のコマンドボタンAをクリックした時の処理 Private Sub コマンドボタンA_Click() Load ユーザーフォーム2 ユーザーフォーム2.トグルボタンa.Value = True ユーザーフォーム2.BackColor = RGB(0, 255, 255) ユーザーフォーム2.Show End Sub 'フォーム①のコマンドボタンBをクリックした時の処理 Private Sub コマンドボタンB_Click() Load ユーザーフォーム2 ユーザーフォーム2.トグルボタンb.Value = True ユーザーフォーム2.BackColor = RGB(0, 255, 255) ユーザーフォーム2.Show End Sub
＞VBAでA1〜A15に入力された整数の中から最大値をC2に表示させる方法 ⇒普通、ワークシート関数でC2に=MAX(A1:A15)で十分 ＞if〜then もし〜ならばGoTo 繰り返し処理 ⇒どうしてもＶＢＡなら一例ですがGoToは使用しません。 Sub sample() Dim mx As Long, r As Range For Each r In Range("A1:A15") If IsNumeric(r) And r > mx Then mx = r Next Cells(2, "C") = mx End Sub また、ワークシート関数を利用すればこんな感じです。 Sub sample1() Cells(2, "C") = Application.Max(Range("A1:A15")) End Sub
http://www.grapecity.com/tools/support/technical/knowledge_detail.a...
vb.netの話なら、基本的にはこんなでしょうか。 PictureBox1がある場合です。 Sub sample() With New OpenFileDialog() If .ShowDialog() = DialogResult.OK Then PictureBox1.ImageLocation = .FileName End If End With End Sub 詳しくは 「ファイルを開く」ダイアログボックスを表示する http://dobon.net/vb/dotnet/form/openfiledialog.html PictureBoxコントロールに簡単に画像を表示する http://dobon.net/vb/dotnet/graphics/pictureboximage.html を参照
こんなでしょうか。 Sub sample() Dim r As Long ActiveSheet.ResetAllPageBreaks '改ページ削除(必要なら) r = 5 '見出し行 Do r = r + 25 'データ行 ActiveSheet.HPageBreaks.Add Before:=Rows(r + 1) '改行挿入(指定セルの前(Before)で指定するので+1している) Loop Until r >= ActiveSheet.UsedRange.Rows.Count '最終セルを超えたら終わり End Sub
If Range("B1").Value <> "" Then .AutoFilter Field:=2, Criteria1:="*" & Range("B1").Value & "*" End If If Range("B2").Value <> "" Then .AutoFilter Field:=3, Criteria1:="*" & Range("B2").Value & "*" End If If Range("B3").Value <> "" Then .AutoFilter Field:=6, Criteria1:="*" & Range("B3").Value & "*" End If ↓↓↓ IIf Range("B1").Value <> "" Then .AutoFilter Field:=2, Criteria1:=Range("B1").Value & "*" End If If Range("B2").Value <> "" Then .AutoFilter Field:=3, Criteria1:=Range("B2").Value & "*" End If If Range("B3").Value <> "" Then .AutoFilter Field:=6, Criteria1:=Range("B3").Value & "*" End If
一例です。 Sub sample() Dim i As Long, j As Long, db, wk, wk1 On Error Resume Next Set db = CreateObject("Scripting.Dictionary") With Sheets("sheet1") For i = 1 To .Cells(Rows.Count, "A").End(xlUp).Row wk = .Cells(i, "A") & "," & .Cells(i, "B") db(wk) = db(wk) & .Cells(i, "C") & " " Next End With wk = db.keys With Sheets("sheet2") .Cells.ClearContents For i = 0 To UBound(wk) .Cells(j + 1, "A") = Split(wk(i), ",")(0) .Cells(j + 1, "B") = Split(wk(i), ",")(1) wk1 = Split(Trim(db(wk(i))), " ") .Cells(j + 1, "C").Resize(UBound(wk1) + 1) = _ Application.Transpose(wk1) j = j + UBound(wk1) + 1 Next End With Set db = Nothing End Sub
こんにちは。 基本的に、fsoは、処理が時間かかります。 ファイルの数が多いことで、ファイルの処理が追いついていない、というのでしたら、 ファイルをひとつコピーしたら、一定時間待ってみるか、 コピーし終わった後で、fileの確認するコードを追加して、ゆっくり処理させたら、 様子が変化するかもしれません。 それで変化したら、osの処理が、期待通りではない、ということです。
.SaveAs Filename:=mypath & sheetname & ".xlsx" ↓ .SaveAs Filename:=mypath & Worksheets(r).Name & ".xlsx" 名前が空白で、拡張子だけのファイル名はご法度
match関数の第三引数を確認しましょう。
デフォルトだと、Visual Studioの右の方に「ソリューションエクスプローラ」と言うタブがあるので、クリックして表示します。 修正したいフォームが含まれるプロジェクトを選択して、フォームをデザイナで表示します。 フォームがデザイナで表示されたら、修正するボタンを右クリック→プロパティ→「テキスト」と言う項目があるので、それを修正します。
こんな感じですかね Public Class Form1 Private Sub Form1_Load(sender As Object, e As EventArgs) Handles MyBase.Load Dim dt As New DateTime(Now.Ticks) NumericUpDown1.Value = dt.Month NumericUpDown2.Value = dt.Day \ 10 NumericUpDown3.Value = dt.Day - (dt.Day \ 10) End Sub Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click Try Dim setyear As Integer = Now.Year Dim setmonth As Integer = NumericUpDown1.Value Dim setday As Integer = (NumericUpDown2.Value * 10) + NumericUpDown3.Value Dim dt As New DateTime(setyear, setmonth, setday) MsgBox(dt.ToString) Catch ex As Exception MsgBox(ex.Message, 16) End Try End Sub End Class アプリ起動時にNumericUpDownへ日付をセットします。 Button1をクリックするとDateTime型へ変換します。 参考 ・DateTime 構造体 https://msdn.microsoft.com/ja-jp/library/system.datetime(v=vs.110)....
モーダルで開いたら別のフォームの操作は出来なくなりませんか？ モーダルで3つのフォーム開けてますか？
A1とA2にはそれぞれ別の画像の名前が指定されているのですか？ それなら1セルずつ処理させなければ一気に2枚処理は出来ません。 Range("A1:A2")とした場合、デフォルトで範囲(オブジェクト型)が取られます。 Range("A1")とした場合デフォルトで.value(値)が取られます。 これが型が違いますと言われている部分ですよ。 Sub 画像() With ActiveSheet.Pictures.Insert("C:\image\" & Range("A1") & ".png") .Left = Range("E1").Left .Top = Range("E1").Top ' With .ShapeRange .LockAspectRatio = msoTrue If .Width * Range("E1").Height / .Height < Range("E1").Width Then .Height = Range("E1").Height Else .Width = Range("E1").Width End If End With End With With ActiveSheet.Pictures.Insert("C:\image\" & Range("A2") & ".png") .Left = Range("E2").Left .Top = Range("E2").Top ' With .ShapeRange .LockAspectRatio = msoTrue If .Width * Range("E2").Height / .Height < Range("E2").Width Then .Height = Range("E2").Height Else .Width = Range("E2").Width End If End With End With End Sub コードそのまま分割しただけなので未検証ですがどうでしょう。
書類はワープロ等で出力されているものですか？それとも手書きですか？ OCRなどといった技術を使って、数字として読み取ることも可能ですし、入力させることも可能ですが、ご認識を考えるとリスクのほうが大きいと思います。 手書き文字ですと、0と６の区別、ワープロ文字でも0と9の区別、その他、2と5、1と7など、特に金額のように間違うと大変なことになるものを自動化するのはリスクが大きいです。 そもそも論で言えば、書類でいただくのをやめるか、書類でもらったものを（計算が必要でなければ）そのままスキャンして保存しておけば良いです。 Excelに入力して計算するひつようのない文書や、内部まで詳細に検索する必要のない文書であれば、社内でわかりやすいファイル名にするルールを作って、スキャンして終わりにすれば良いです。 「本当にそれは、PCに入力して緻密なデータに変換する必要があるか？」を考えなおしたほうが良いでしょう。 つぶさに見なおせば、おそらく金額計算用の数字と、注文書番号だけ入力すれば良いような仕組みになると思いますよ。
>③でD1＆N1を一番右端に挿入しA1は【東京都 杉並区鈴木 太郎】にする >④でA1【東京都杉並区鈴木太郎】にする と言うようなのは不要です。 COUNTIFSという便利な関数があるのですから、それを使わない手はないでしょう。 以下の例は、D列＆N列で重複をカウントし、結果をB列へ。 結果が１以上の場合、B列のセルを赤色背景にしています。 Sub 一例です() Dim i As Long For i = 1 To Cells(Rows.Count, "D").End(xlUp).Row With Cells(i, "B") .Value = Application.CountIfs(Columns("D"), Cells(i, "D"), Columns("N"), Cells(i, "N")) If .Value > 1 Then .Interior.Color = vbRed End If End With Next i End Sub ①・②の工程は、ご自身で考えてみてください。
一番左の名称の列の区切りのいいところ。 今回は15行の所との事なので 名称列15行のセルを選択して 表示タブ＞ウィンドウ＞ウィンドウの固定 でスクロールできるようになりませんか？？ マクロを組んで実施したことがないため間違えていたりできなかったら申し訳ありません
それは大変ですね。まぁ、中身が見えないんで何とも言えませんが。
改行を検索したいの？改行を無視して検索したいの？ で、何のGrep?もしかして自分でGrep作りたいの？
誰からも回答が無いようなので、直接の回答では有りませんが参考になれば。 私はＲを使った事が無いのでＲに付いてはサッパリ判りませんが、 ＣＳＶファイルは , で文字列を区切ったテキストファイルです。 メモ帳等のテキストエディタで開く事が出来ます。 処理出来ているファイルと出来ないファイルをテキストエディタで内容を比較すれば原因が判るのでは？
getElementsByClassNameの返り値は配列ですから、「(0)」を付けなければ、自動的に指定したクラス全てが配列として取得されます。 Set obj=objIE.document.getElementsByClassName("class") 後は、配列としてアクセスすれば良いだけです。 For n=0 To obj.Length-1 msg=obj(n).outerHTML Next getElements○○は、複数形になっていることから分かるように、配列で複数取得される命令です。
こんにちは。 主様、どう考えても、最初は、台帳 その台帳から、条件を与えて、請求書の作成をする、というようにしないと、 「どこに請求書を作成したのか、が、わかりません」 もし、「今だけは」というのがあるのでしたら、 与えるほうのデータは「生データー」ということになるので、せっかく転記のコードを作成しても、あらゆる整合チェックが必要ということです。 転記しないといけない伝票の数の最大値の確認。 ルール違反のデータのある/なしの確認 転記が正しく出来たか、出来なかったかの「リスト」を作成。 リストを中心に、転記の回路作成 リストを順番に実行 というような手順となります。 あと、ブックのリンクとか、確認です。 その程度の伝票で外部にリンクが あったら、問題です。
一例です。 Sub Sample() Dim rng As Range, buf As String For Each rng In Range("A1:A" & Cells(Rows.Count, 1).End(xlUp).Row) If Val(rng.Offset(, 1)) >= 1 Then buf = buf & rng.Value & " " & rng.Offset(, 1) & "回" & vbCrLf End If Next rng MsgBox buf End Sub
下の図のようなことでよろしいでしょうか？ ・データ数は省略して作っています。 ・なお、B列の型番の数字は、”文字列数字”（セルの左寄りになる）である必要があります（「004」のように前に「0」が付く型番の場合に正しいデータが表示されなくなる可能性があります）。 ・それと、B列の型番の範囲内に空白のセルがない、という前提です。 C2セルには、 ① =IFERROR(LOOKUP(10^4,MATCH("*"&B$2:B$10&"*",A2,),B$2:B$10),"") の式を入れて、下にオートフィル（コピー）しています。
知恵袋は変数でしょうか、それとも「知恵袋」という文字列を意図しているのでしょうか？ もし知恵袋が変数であれば、知恵袋にはどのような値を設定していますか？ もし知恵袋が文字列なら「If フィルター = "知恵袋" Then」としてみてください。
>いきなりk=32となってしまいます そりゃそうですよ。 For j = 1 To 150 'ｊは列番号 ですから、j が32になった時にはkも32になりますから。 For j = 1 To 15 'ｊは列番号 の間違いですよね・・
ご存知だと思いますが、手動で行う場合は B21:C21 をコピーして、B16:B20 を選択してコピーすれば問題なく参照の法則が変わりませんよね。 VBAにすれば Cells(21, 2).Resize(1, 2).Copy Selection.Offset(-4, 0).Resize(5, 1) となります。 数式だけコピーしたいんだ、ってことであれば Cells(21, 2).Resize(1, 2).Copy Selection.Offset(-4, 0).Resize(5, 1).PasteSpecial (xlPasteFormulas) Application.CutCopyMode = False となります。 では Selection.Offset(-4, 0).Resize(5, 2).FormulaR1C1 = Cells(21, 2).FormulaR1C1 ではうまくいって、 Selection.Offset(-4, 0).Resize(5, 2).FormulaR1C1 = Cells(21, 2).Resize(1, 2).FormulaR1C1 ではうまくいかないのでしょうか。 私も詳しくはないのでわかりません。 ですが、FormulaR1C1 は数式の文字列がはいるので Selection.Offset(-4, 0).Resize(5, 2).FormulaR1C1 = "=R1C-RANK.AVG(RC1,R[-4]C1:RC1)" でも思った通りになります。 これは Cells(21, 2).FormulaR1C1 の中身が "=R1C-RANK.AVG(RC1,R[-4]C1:RC1)" なので当たり前です。 でも、Cells(21, 2).Resize(1, 2).FormulaR1C1にすると単純に文字列ではなく、たぶん配列になるんだと思います。 ただ、それを Selection.Offset(-4, 0).Resize(5, 2).FormulaR1C1 に代入するとあんな式に変換されるのかは説明できません。
行列の積って一般的な積でいいのですよね。 Excel VBA なら、Excel ワークシート関数のMMULTを使うのが便利だと思います。 セル範囲等が分かりませんが、例えば [Sheet2!A1:C3]=Application.WorksheetFunction.MMult([Sheet1!A1:C3],[Sheet1!E1:G3]) のようにすればいいわけです。 もちろん、ループを組んで公式どおりに計算したって構いません。 たとえば下記のように記述すれば同じように計算できます。 しかしたった１行で済むところを、このように長々と書くのは無駄だし、計算も遅いです。 Dim A As Variant, B As Variant, C(1 To 3, 1 To 3) As Variant Dim I, J, K As Long A = [Sheet1!A1:C3] B = [Sheet1!E1:G3] For I = 1 To 3 For J = 1 To 3 C(I, J) = 0 For K = 1 To 3 C(I, J) = C(I, J) + A(I, K) * B(K, J) Next Next Next [Sheet2!A1:C3] = C
一般的な用語的で「ケタ」と言うのは使わないと思います。 Y = Range("C" & Rows.Count).End(xlUp).Row で、YにC列の最終行の値を取得できます。 ある行の最終列を求める場合は、 X = Cells(5, Columns.Count).End(xlToLeft).Column とすると、Xに5行目の最終列の値を取得できます。
>配列（tmp)にcsvファイルの全行カンマ区切り文字列を格納したい なにをしたいのか伝わらないですね。 とりあえず、適当に解釈すると １つ１つの項目をバラバラにして、配列に格納するのなら Sub Sample() Dim xTxt As String, xAry, 配列数 As Long With CreateObject("Scripting.FileSystemObject") With .GetFile("C:\AAA\HogeHoge.csv").OpenAsTextStream xTxt = .ReadAll .Close End With End With xTxt = Replace(xTxt, vbCrLf, ",") xTxt = Replace(xTxt, " ", "") xAry = Split(xTxt, ",") 配列数 = UBound(xAry) End Sub そうではなく、「,」は残し、1行ずつ配列に格納するということなら Sub Sample() Dim xTxt As String, xAry, 配列数 As Long With CreateObject("Scripting.FileSystemObject") With .GetFile("C:\AAA\HogeHoge.csv").OpenAsTextStream xTxt = .ReadAll .Close End With End With xTxt = Replace(xTxt, " ", "") xAry = Split(xTxt, vbCrLf) 配列数 = UBound(xAry) End Sub 全行一気に読み込むなら、FileSystemObjectが扱いやすいです。
こういうこと？ vp = "C:\" ''試験用'' Set Name=CreateObject("Shell.Application").BrowseForFolder(0, "scriptを選択",1,"" & vp & "") If Not Name Is Nothing Then   If Name.Items.Item.Path = "C:\Program Files" Then     WScript.Echo(Name.Items.Item.Name)     ''特定Script実行''   End If End If
Accessの帳票フォームは行ごとにプロパティを変更することは出来ません。 条件付き書式でなら見た目をいじることが出来るので挑戦してみてはどうでしょうか？ https://support.office.com/ja-jp/article/%E6%9D%A1%E4%BB%B6%E4%BB%9...
データを表示するものだからデータの保存はやっぱり既に書かれている方法になるような
環境変数を使わずとも 画像ファイルのパスは System.IO.Path.Combine(System.Environment.GetFolderPath(Environment.SpecialFolder.MyPictures), "画像フォルダ\画像.png") とすればOKです。 System.IO.Path.Combine System.Environment.GetFolderPath Environment.SpecialFolder.MyPictures の意味はヘルプを参照してください。
下記のコードでいかがでしょうか Sub b() Dim v(10, 10) Dim i As Integer, j As Integer For i = 0 To 10 For j = 0 To 10 v(i, j) = Range("F3").Offset(i, j).Value Next j Next i For i = 0 To 10 For j = 0 To 10 Range("F3").Offset(j, i).Value = v(i, j) Next j Next i End Sub
gnsgnsdrognoさん 1024=2^10 DFT 2^10*2^10=2^20=100万 FFT 10*2^10= 1万 ???
Sheets("sheet1").Range("A4:K4").Copy _ Sheets("sheet12").Cells(Rows.Count, 1).End(xlUp).Offset(1) ↓↓↓ Sheets("sheet1").Range("A4:K4").Copy _ Sheets("sheet12").Cells(Rows.Count, 2).End(xlUp).Offset(1)
質問のプログラムは、標準モジュールからユーザーフォームのListBox1を設定してるようですが、以下はユーザーフォーム内のVBAです。 あらかじめListBox1を用意してください。 'ユーザーフォーム初期化時 Private Sub UserForm_Initialize() Dim ws As Worksheet Dim rng As Range Dim adr As String For Each ws In Sheets '全てのシートを調べる If ws.Name <> "Sheet1" Then '注目シート名が"Sheet1"でなかったら Set rng = ws.Cells.Find(What:="田中") '注目シートで"田中"を探す If Not rng Is Nothing Then '1個でもあったら adr = rng.Address '見つけた場所を記憶(終了チェック用) Do ListBox1.AddItem ws.Name 'ListBoxに見つけたシート名を追加 ListBox1.List(ListBox1.ListCount - 1, 1) = rng.Address '上で追加した行の2列目に見つけたセルを記憶 Set rng = ws.Cells.FindNext(rng) '次を探す Loop Until rng.Address = adr '見つけたアドレスが最初のアドレスなら終わり End If End If Next End Sub 'ListBoxがクリックされた時 Private Sub ListBox1_Click() Sheets(ListBox1.List(ListBox1.ListIndex)).Select 'Sheet選択 Range(ListBox1.List(ListBox1.ListIndex, 1)).Select 'Range選択 'Unload Me'ユーザーフォームを閉じる(必要なら) End Sub
こんなでしょうか。 Sub 連続印刷() Dim c As Integer Dim lastColumn As Integer Worksheets("印刷").Select With Worksheets("台帳") lastColumn = .Cells(1, Columns.Count).End(xlToLeft).Column '"台帳"シートの1行目最終列 For c = 3 To LastRow '注目列を3列目(C列)から最終列まで Range("E1").Value = .Cells(1, c).Value '"印刷"シートのE1に"台帳"シートの1行目注目列の値をセット ActiveSheet.PrintOut '"印刷"シート印刷 Next End With End Sub
以下のコードでいかがでしょうか？ Private Sub CommandButton7_Click() Dim tmp3 As Variant If TextBox17.Text = "" Then tmp3 = Date Else tmp3 = TextBox17.Text End If TextBox17.Value = DateAdd("d", 1, tmp3) & vbCrLf End Sub
提示されたコードの範囲内ではExcel2016で動かない原因はありませんしフォントの相違も関係ありません。 他のコードの部分、またはActiveSheetが違うシートになっている、ということはありませんか？
Private Sub UserForm_Initialize() Me.TextBox1.Text = Sheet1.Range("A1").Text End Sub ではうまくいかないのですか？
>COUNTIFの答えが2になっているのが、原因かなと思うのですが、その原因がわかりません。 原因を確認したいなら以下の式を入力して下方向にオートフィルしてください。 =COUNTIF($A$2:$A$35000,C2) 添付の写真のように、どちらにもあるのに、消えた！新しい！と言われて困惑してます。 この場合は、それらのセルが同じデータでないことを示しています。 以下の数式を入力して「FALSE」が返ることを確認して、その違いを調べてください。 ＝A列のセル＝C列のセル ＞あと処理時間が凄くかかります。他にいい方法があればご教授いただきたく。 COUNTIF系の関数を何万行に及ぶ多数のセルに入力すると、計算に時間がかかるのはやむを得ないのですが、それよりも重要なことは、このような数式を多数入力すると大量のメモリーを消費するので、場合によってはエクセルがフリーズする可能性があります。 目的にもよりますが、この数式で出てきた結果を利用して特定の集計をしたいためにこのような数式を使用しているなら、配列数式を使用する（計算速度は基本的に変わりませんが、エクセルがフリーズすることはなくなる）、あるいは計算済みのセルは一番上のセルを残して、それ以外のセルは値に変換しておくなどの運用がお勧めです（数式が必要になった時は数式セルの右下をダブルクリックする）。
こんにちは。 テストでは、最初に、「直接文字列を設定する」続いて、文字列をエクセルの文字列にしてみるという順番にテストとます そうでないと、なにが原因か、わかりません。 コードをみて、Range(&quot;D33&quot;) は Range(&quot;D33&quot;).value になってほしい、というのはありますが、何が起こっているのか、まずは確認してください
>mies197803さん2016/6/110:43:29 >どのようにすれば良いのか分からないので、お教えいただければと存じます。 FTPで接続し落とせばいいと思います。
漢字からひらがなへの変換がどんな事例を見つけられたのかわかりませんが ようは《決まった単語》への変換なのか《不特定の単語》の変換なのかで変わらないかな？ 決まった単語なら変換させる一覧表を事前に作成すれば出来そうだけど、不特定ならそもそも《どの漢字をあてるのか？》がわからないじゃないですか？ 実際変換させて文章を作成する際に候補が複数ありますしね
パターン "\b(\d(月|日))" 追加 re.Global = True 置換の２番目 "0$1" かな？
WsName = Left(ts.Range("D2").Value, 31) を if i = 1 Then ws.Name = Left(ts.Range("D2").Value, 31) Else ws.Name = Left(ts.Range("D2").Value, 31) & "（" & i & "）” End If としてみてください。 2枚目のシート以降もエラーは出なくなると思います。
【式1】 K8=N(J8="西田C") ★下にコピー 【式2】 L8=COUNTIF(J8,"*西田C*") または、 L8=COUNT(FIND("西田C",J8)) ★下にコピー
エラーを表示させないだけなら、Sub の後に On Error Resume Next を書けば、エラーが出てもそのまま次のステップに進んでくれます。 普通なら、Dir関数とかで対象のファイルをチェックしてから開いたほうがよろしいかと思いますが・・ サンプル（ディレクトリの指定はしていません） Dim Filename As String Filename = Dir("Workbook*.xlsx") Do Until Filename = "" Workbook.Open Filename Filename = Dir() Loop
>myTemp = "C:\" & ThisWorkbook.Worksheets("御見積").Range("G7") & "_" & ".xlt" セキュリティが厳しくなって、Cドライブ配下に出力するとエラーの原因となりやすいです。 出力先を、My Documents などのドキュメント保存用フォルダに変更してみて下さい。
一例です。 Sub sample() Dim Target, rng As Range, i As Long, ii As Long With Worksheets("機種別").Range("K1:K5") ii = Application.CountA(.Cells) If ii > 0 Then ReDim Target(1 To ii) For Each rng In .Cells If rng.Value <> "" Then i = i + 1 Target(i) = rng.Value End If Next rng Worksheets("一覧表").Range("A3").CurrentRegion.AutoFilter Field:=3, _ Criteria1:=Target, _ Operator:=xlFilterValues End If End With End Sub
①そのシステムはyonnkaku.pngという画像ファイルを使っているので、その画像ファイルを入手します。 ②あなたのＰＣのデスクトップに「rogozukei」というフォルダを作成します。 ③入手した画像ファイルを②で作成した「rogozukei」フォルダに入れます。 ④再度システムを動かしても同じエラーが出る場合は、そのシステムのソースコードに「C:\Users\(その方のPCのアカウント名)」と書かれた部分があるはずですので、その部分を「C:\Users\(あなたのPCのアカウント名)」に修正して再コンパイルしてみて下さい。
train_benoistさんへの回答リクエストは拝見しました。 そもそもcolumns(1),0の意味もわからず変えても結果に繋がるわけもなく。 columns(1)はA列を検索 0は完全一致のための引数 MATCH関数の引数でしかないです。（って回答リクエストにも説明してあったことを噛み砕いただけですけどね） その結果を.Cells(i, 2).Valueと表現しています。ヒットした行の2列目＝B列、には= Range("B4").Value、B4の値を入れる。 そういうコードですよ。行を変えるならこの２を３にしたらC列になります。
For～Nextの使い方に誤りがあります。(ロジックミスです・・・。) これでは、rが1の時にiが1～8まで回って rが2の時にiが1～8まで回って・・・・ となっていますよね。 このような処理を行う時は、 Selection.Cut ではなく Selection.Copy を使用して 最後にデータをクリアするようにすれば カットした行を考えなくても済むのでは ないかと思います。 であれば、 >次に >「２」行目を移動先の「９行目」と移していきたいと考えています。 も簡単に考えられますよね・・・。
以下のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim bkNames As Variant, bkName As Variant Dim bk As Workbook, sh As Worksheet 'ブックを選択する（複数可） bkNames = Application.GetOpenFilename(FileFilter:="Microsoft Excelブック,*.xls?", MultiSelect:=True) 'キャンセルされたら終了 If VarType(bkNames) = vbBoolean Then Exit Sub '画面更新停止 Application.ScreenUpdating = False '選択されたブックすべてについて処理を行う For Each bkName In bkNames 'ブックを開く Set bk = Workbooks.Open(bkName) '開いたブックのすべてのシートについて処理を行う For Each sh In bk.Worksheets 'シート名にAが含まれているとき If sh.Name Like "*A*" Then 'AY1に1を設定する sh.Range("AY1").Value = 1 'シート名にBが含まれているとき ElseIf sh.Name Like "*B*" Then 'AY1に2を設定する sh.Range("AY1").Value = 2 'シート名にCが含まれているとき ElseIf sh.Name Like "*C*" Then 'AY1に3を設定する sh.Range("AY1").Value = 3 'シート名にDが含まれているとき ElseIf sh.Name Like "*D*" Then 'AY1に4を設定する sh.Range("AY1").Value = 4 End If Next 'ブックを閉じる（更新されていたら上書き保存する） bk.Close True Next '画面更新再開 Application.ScreenUpdating = True End Sub
wb2.Worhsheets(1) は wb2.Worksheets(1) のパンチミスですか？
Loopの前の fname = Dir は fname = Dir() では？ このVBAを実行するブックは、開こうとするするブックと 同一フォルダ内にあるということで良いですね。 このコードだと開こうとするブックは、すべてXlsmではないと駄目です。 OKですか？ fname = ThisWorkbook.Path & "\*.xlsm?" は拡張子xlsmの後ろに何か文字が入っている場合には 有効ですが、それは無いですよね？ fname = ThisWorkbook.Path & "\*.xls?" で良いのでは。 これだと、xlsもxlsxもxlsmも対象にしてくれます。
.SaveAs (xPath & xName & ".csv") を .SaveAs (xPath & xName & ".csv", xlCSV) として下さい。 なおCSV形式で保存されたファイルはテキストファイルです。 試しにメモ帳で開いてみて下さい。
これでは、1行しか処理されないでしょう。 For I = 1 To MaxRowは、空回りするだけ。 何も処理されないです。 コピーするかしないかの判定(1だったらコピー)まで、 Sheet3にコピーしているのも分からないですが？ Sub Sample() Dim I As Long, J As Long Sheets("Sheet1").Activate J = 8 With Sheets("Sheet3") .Cells.ClearContents For I = 2 To Cells(Rows.Count, 2).End(xlUp).Row If Cells(I, 1) = 1 Then J = J + 1 .Range(.Cells(J, 1), .Cells(J, 3)).Value = _ Range(Cells(I, 1), Cells(I, 3)).Value .Cells(J, 8) = Cells(I, 4) End If Next I End With End Sub こんなんで良いんですかね？ Option Explicit の宣言をしてないようすが？ VBAを勉強したいのなら、まずここからですね。 http://officetanaka.net/excel/vba/beginner/11.htm
下記のコードをSheet1のシートモジュールにコピペして下さい。 それでA1またはA2を変更するだけで画像が表示されるようになります。 Option Explicit Private Sub Worksheet_Change(ByVal Target As Range) Dim rng As Range For Each rng In Target.Cells If rng.Column = 1 Then Select Case rng.Row Case 1: SetPicture rng, Worksheets("Sheet2") Case 2: SetPicture rng, Worksheets("Sheet3") End Select End If Next rng End Sub Private Sub SetPicture(srcRng As Range, dstSheet As Worksheet) Const FOLDER As String = "C:\" Dim pic, fName As String Dim shp As Shape '既存の画像を消去する For Each pic In dstSheet.Pictures pic.Delete Next '画像ファイルを検索する fName = Dir(FOLDER & srcRng.Value & ".png") '画像ファイルが見つからなければ画像ファイルを"C:\0.png"とする If fName = "" Then fName = FOLDER & "0.png" Else fName = FOLDER & fName End If 'B1に画像ファイルを挿入する Set shp = Nothing On Error Resume Next Set shp = dstSheet.Shapes.AddPicture( _ Filename:=fName, LinkToFile:=msoFalse, _ SaveWithDocument:=msoTrue, _ Left:=dstSheet.Range("B1").Left, _ Top:=dstSheet.Range("B1").Top, _ Width:=0, Height:=0) If Not shp Is Nothing Then shp.ScaleHeight 1, msoTrue shp.ScaleWidth 1, msoTrue End If End Sub
また投稿されていますね。調べてみていたんですが。なさそうですね。 自分で作る方が早いかなぁ。
別ファイルの顧客情報とありますが 基準となるものが不明なので シートの種類と内容、主となるワークブックがどれなのかなど シートの構成をもう少し詳しく教えてください。 顧客情報(ファイルA）には顧客名それぞれのシートがあるのでしょうか？ また顧客情報(ファイルA）とは別のファイルになるのでしょうか。
>If文で「空欄なら」 は If R.Value = "" Then >「移動して空欄なら」 ではなく、「ひとつ下のセルが空白なら」です If R.Offset(1).Value = "" Then Set R = R.End(xlDown).Offset(1) の行はこんなふうにしたらどうでしょうか。 If R.Value = "" Then 'Rが空欄なら移動しない ElseIf R.Offset(1).Value = "" Then 'Rの１つ下のセルが空白なら、１つ下のセルに移動 Set R = R.Offset(1) Else 'それ以外なら最終行の次の行に移動 Set R = R.End(xlDown).Offset(1) End If
提示されたコードはDoループの終わりがありませんし、あまりにも中途半端です。 ダイアログで選択したファイルをbufという配列に読み込んで、それをddという配列に、16進数表記の文字列に変換してセットしているところまでは理解できますが、それをもとに「何がしたいのか」がまったく判りません。 上司の方は何を目的としてマクロを組んでいるのでしょうか？
Labelは配列にすべきですが、 とりあえず、x1～x5を配列にしてみました。 Randomize() Dim xs(5) As Integer Dim duplicate As Boolean = False For i As Integer = 0 To 4 Do duplicate = False x = Int(Rnd() * n0) For j As Integer = 0 To i - 1 If x = xs(i) Then duplicate = True Exit For End If Next j Loop While duplicate = True Or sd(x).s4 = "済" Or sd(x).s1 = "" xs(i) = x Next i Label1.Text = sd(xs(0)).s1 Label2.Text = sd(xs(1)).s1 Label3.Text = sd(xs(2)).s1 Label4.Text = sd(xs(3)).s1 Label5.Text = sd(xs(4)).s1
試していませんが、 If lst物件.Text = "" Then を If lst物件.SelectedIndex = -1 Then としてみてください。
一例です。 Private Sub CommandButton1_Click() Dim i As Integer With UserForm1 If Len(.TextBox1.Value) > 4 Then MsgBox "5ケタになっています。" Exit Sub End If For i = 1 To 4 .Controls("TextBox" & (i + 1)) = Mid(.TextBox1, i, 1) Next i End With End Sub
ActiveWorkbook.Sheets("山").Copy after:= Workbooks.Add.Sheets(1) っておかしいですよね。 Dim wb as workbook set wb=workbooks.add を追加しておいて、 ActiveWorkbook.Sheets("山").Copy after:= wb.Sheets(1) でどうでしょう。
外部データの取り込みを使ってみてはいかがでしょうか？ 頭のゼロが消えて困るフィールドや長い数字は文字列として取り込みます。
> opencv2で使用して 「使用して」ってどういうこと? >主にソースファイルが開けません 正確にその通りなのですか? > opencvとopencv2での表記の仕方が変わったから 質問の内容からでは判断しかねます。多分その情報からでは誰にもわからないでしょう。 やったことは、理想としては回答者がまるまる同じことを再現できるくらいに詳しく。 起こったことは、理想としては全く省略なくそのまま。 質問に書いて下さい。
※１はインスタンスなしでメソッドを呼びだそうとしているので当然エラーですね。 それからRenameクラスについて、 はっきり言ってこのクラスの存在意義が分かりません。 単にクラスの中から他のクラスを利用する例として述べられただけなのか、それとも本当にRenameの機能を実装されようとしているのか。 もし後者であればRenameクラスを別に作る必要性は全くありません。 Projectクラス内にRenameメソッドを作ればいいだけの話です。 クラス内のフィールド操作は外部から直接するのではなく、そのクラス自身にさせるようにするのがオブジェクト指向の基本指針です。 Textプロパティについて言えば、これは既にプロパティとして外部に公開されているのでRenameメソッドを作らなくても外部から直接Textプロパティを操作することはできます。 しかしいずれの場合でもProjectのインスタンスの参照が必要です。 そもそもこのProjectクラスを利用するクラスは何かという問題がありますね。 Projectクラスのインスタンスは当然それを利用する側（作成したクラス）が管理するべきものです。 このプログラムではProjectクラスの中にMainメソッドがあるので、自分自身で自分を作成していますよね。Projectインスタンスは１つしかないということですか？ だとすればProjectインスタンスをstaticメンバに保存して、 class Project :Form { public static Project me; static void Main() { Application.Run(me = new Project()); } } class Rename { public Rename() { Project.me.Text = "（リネーム後のタイトル）"; } } とすれば他のクラスから自由にアクセスできますよ。
コネクションストリングでは、データベースファイルを指定するのではなく、SQLSERVERを指定します。 アプリケーションははSQL文をサーバーにおくります。SQLの実際の実行はサーバーにやってもらいます。ですから、SQLサーバーの指定は必要です。 SQLサーバーがデータベースファイルの場所を把握しているので、データベースファイルの場所をアプリケーションで設定する必要はありません。
Sub Print_Out_1() 'セルに値を設定しながら印刷する '定数 Const conStart As Long = 1 '開始番号 Const conEnd As Long = 40 '終了番号 Const conStep As Long = 1 '間隔 Const conCell As String = "B2" 'セル番地 '変数 Dim lngI As Long ↓↓↓ Sub Print_Out_1() 'セルに値を設定しながら印刷する '定数 Const conStep As Long = 1 '間隔 Const conCell As String = "B2" 'セル番地 '変数 Dim lngI As Long Dim conStart As Long '開始番号 Dim conEnd As Long '終了番号 With Worksheets("印刷シート") conStart = .Range("R14").Value conEnd = .Range("S14").Value End With
このコードで減算、乗算、除算の連続演算出来ているとは思えません。 VBでの「+」は数値の加算のほかに文字列の連結を行う機能も持っています。 ですから TextBox1.Text = X + TextBox1.Text とすると文字列の連結の意味になってしまい、「6+5+8」は「658」になってしまいます。 それを防ぐためには加算する各項目を数値に直してから+する必要があります。 TextBox1.Text = Val(X) + Val(TextBox1.Text) とすれば連続加算になると思います。
異なるイベントを１つのイベントプロシージャで処理する事はできません。 素直に「処理A」をサブプロシージャや関数にして下さい。
こんにちは。 リストなんですよね、 adoRs.Open strSQL, adoCn 'SQLを実行して対象をRecordSetへ while not adoRs.eof With ComboBox1 .additem adoRs.fields(0).value End With adoRs.movenext wend adoRs.close というようになります。
並べ替えは並べ替え（ソート）で行うしかありません。 並べ替えてからフィルターしてください。
数式でやる範囲を超えているように思いますので、下記を読んで検討して下さい。 これはシートＢのC3の式です。 =IF(LEFT(INDEX(シートＡ!$C$5:$G$24,(MOD(ROW()+2,5))*4+COLUMN()-2,INT((ROW()+2)/5)),1)="A",INDEX(シートＡ!$A$5:$A$24,(MOD(ROW()+2,5))*4+COLUMN()-2,)&RIGHT(INDEX(シートＡ!$C$5:$G$24,(MOD(ROW()+2,5))*4+COLUMN()-2,INT((ROW()+2)/5)),2),"") ここで実現できているのは、パートAの人でOの人までです。 勤務はAかBで数字は2桁限定です。 式をコピーすると、Pの人まで入ってしまいます。 PからTだけ特別に右端の列にする事は出来ていません。 上記実現できていない事を更に追加すると、とてつもなく長い式になります。 回答の欄で2行以上になるような長い式は理解が大変だしメンテナンスも出来ないと思います。 入力方法を変更できないのであれば、VBAにした方がいいと思います。
>そのあと、動いてくれません。 どこで、どういう風に「動かない」のか症状を書かないと、アドバイスしようがないのは、お解りになりますよね？ とりあえず、以下の修正は、必要と思います。 t = WorksheetFunction.Sum(Range(Range("A5").End(xlToRight).Column, Range("A5").End(xlDown)) ↓ t = WorksheetFunction.Sum(Range(Range("A5").End(xlToRight), Range("A5").End(xlDown)))
>Q1.Label1.textなどに値を格納するとき、Label1.text = null、nothing、"空欄"のそれぞれの違いはなんでしょうか？ null, nothing は使いませんね。 Label1.text=null だとエラーになります。（主にDBで使用） nothingはオブジェクト変数に使う物です。 Label1.text=nothingでもエラーにはなりません。 通常は、Label1.text="" か Label1.text=String.Empty を使います。 >Q2.｢And｣｢&｣｢AndAlso｣の具体的な違いはなんでしょうか？また、これらの使い分けはどういったものでしょうか？ If A=1 And B=2 And C=3 Then と、If文などで複数のAnd条件が有る場合・・ Andだと、最初の「A=1」で結果がFalseになっても、２つめ、３つめを評価しにいきます。 If A=1 AndAlso B=2 AndAlso C=3 Then にすると、最初の「A=1」で結果がFalseになった場合、残りの評価は無駄なので行いません。（３つともTrueになることは無いので・・） 条件が多く有る場合、このように書くと処理が少し早くなります。 同じように、Or の場合は、OrElse が有ります。
Thread.Sleepではなく、Timerを使うのがよいかと。 https://msdn.microsoft.com/ja-jp/library/3tszykws(v=vs.110).aspx
下記のコードは「Sample」というマクロをSheet2にコピーするコードです。 ただし下記のコードを実行する前に [Microsoft Visual Basic for Applications Extensibility] を参照設定しておく必要があります。 Sub CodeCopy() Dim procName As String, procStart As Long, procCount As Long Dim lines As String, i As Long procName = "Sample" With Application.VBE.ActiveVBProject With .VBComponents("Sheet1").CodeModule On Error Resume Next procStart = .ProcStartLine(procName, vbext_pk_Proc) On Error GoTo 0 If procStart = 0 Then MsgBox "指定された名前のマクロが見つかりません。" Exit Sub End If procCount = .ProcCountLines(procName, vbext_pk_Proc) lines = .lines(procStart, procCount) End With With .VBComponents("Sheet2").CodeModule .AddFromString (lines) End With End With End Sub
A1:D2の入力規則を「すべての値」にすれば削除できると思うのですが？
下記のコードでいかがでしょうか。 Private Sub CommandButton4_Click() Frame7.Visible = getSt() End Sub Private Sub CommandButton5_Click() Frame8.Visible = getSt() End Sub Private Function getSt() As Boolean Static st As Boolean st = Not st getSt = st End Function ただしFrameのVisibleを切り替えるだけなら下記で出来ます。 Private Sub CommandButton4_Click() Frame7.Visible = Not Frame7.Visible End Sub Private Sub CommandButton5_Click() Frame8.Visible = Not Frame8.Visible End Sub
下記のコードでいかがでしょうか？ Option Explicit Sub Sample() Dim i As Long, buf As String Dim NM As String, r As Long Const Path As String = "C:\Users\AA\Desktop\Aフォルダ\" r = 3 i = 3 Do While Range("B" & r).Value <> "" NM = Range("C" & r).Value buf = Dir(Path & "*" & NM & "*.*") Do While buf <> "" Range("F" & i).Value = buf i = i + 1 buf = Dir() Loop r = r + 1 Loop End Sub
接続文字列が Windows 認証を指定しますね。 Integrated Security=False と username, password を指定しないと SQL 認証になりません。 SQL 認証を有効にするかどうかはサーバーレベルの設定です。 混合モードに設定しているのなら、そのサーバーで作られたデータベースはSQL認証「も」使うことができます。SQL ユーザーは作りましたか？そのSQLユーザーに適切な権限を与えましたか？確認してください。 SSMSは接続するときのダイアログで Windows 認証か SQL 認証かを選ぶドロップダウンリストがあるはずです。SQL 認証を選んで、SQL ユーザーのユーザー名とパスワードを入力すれば SQL ユーザーでログオンできます。
。。。。。。。。。。。。。。
それを開発するのがプログラミングだろ？ PDFのどこに情報があるのか、データを解析するのもプログラミングに必要だよ。 ツールとかじゃなくて、データの仕組みを調べてよ。
アプリケーション部でのやり取りに関しては分かりませんけど、通信処理を作りたいのであれば基本的な事を書きます。 ・二台のPCによる通信をテストしたいのであれば、まずIPアドレス指定で普通にパケットが通ることを確認 → pingでも何でも良いです。双方のPCを同一ネットワークアドレスに手動で設定。ゲートウェイはお互い対抗するPCのアドレスでも設定しておけばOKなはず。直結ならクロスケーブルで、ハブ経由ならストレートケーブルで接続。 ・受信側でパケットキャプチャ起動（例 ワイヤーシャーク等にて）。そして送信アプリケーションを動作させ、きちんとキャプチャできるか確認。 → キャプチャされているが受信処理が動かない場合、キャプチャログが意図通りの信号内容になっているか確認。 → キャプチャされない場合、受信PCにパケットは届いていない。 ・受信側にキャプチャされていなければ、送信側PCにパケットキャプチャを掛けて送信側アプリを起動。 → キャプチャされている場合、生成されたパケットに何らかの問題があると思われるので、ログをチェック。届かない要因はUDP/IP以下の階層に原因があるはずだが、ソケット制御をカーネルに任せている場合はこの問題はまず発生しないと思われる（PING等が通っていれば、の話）。ROWソケット等で下層プロトコルから手動生成しているのであれば、間違っている可能性あり。 → キャプチャされていない場合、送信側アプリがそもそも正常なソケット通信に失敗していると思われる。もしループバック（送信側）アドレス指定でキャプチャできるのであれば、そのログから問題を探す。キャプチャでかないのであれば、送信アプリのソケット通信手順が本当に合っているか、机上で確認。 こんな感じですかね。 パケット開通の有無はアプリレベルで確認するのではなく、キャプチャログで下位のプロトコルごと確認するのが、面倒なようでも結果的に確実で早いです。
他の方の回答が何故か付いてしまいましたが・・・。 とりあえず、OS、IEのバージョンを、動く方と動かない方とで教えてください。HTMLのソースが変わるということは、ブラウザが影響している可能性が高いと思います。 後、リクエストしていただいたからお答えしましたが、もしも最初の回答者様に頼るのでしたら、その旨、返信してください。時間の無駄を省く為、回答を取り消します。
>A列1行から約1000行にまで単語が入っています。 A列の最終行までにしています。 Sub sample() Dim xAry xAry = Application.Transpose(Range("A1", Cells(Rows.Count, 1).End(xlUp))) Range("C1").Value = Join(xAry, " ") End Sub
A7=INDEX(A4:C6,SUMPRODUCT((A1:C3<>"")*{1;2;3}),SUMPRODUCT((A1:C3<>"")*{1,2,3}))
私のExcel2010では貴殿の構文のままで、縦長の画像も横長の画像も特に問題なく結合セルの範囲内に収まりますが、ただエクセルのバージョンによっては以前同じような現象が起きたことがありましたので、一度、下記の構文で試してみて下さい。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Excel.Range, Cancel As Boolean) Dim myF As Variant Dim mySp As Object Dim myAD1 As String Dim myAD2 As String If Application.Intersect(Range("B5,B21,B37,N5,N21,N37,Z5,Z21,Z37,AL5,AL21,AL37,AX5,AX21,AX37"), Target) Is Nothing Then Exit Sub Cancel = True With Application.FileDialog(msoFileDialogFilePicker) .Title = "画像の選択" .AllowMultiSelect = False .InitialFileName = Range("B3").Value If .Show = -1 Then myF = .SelectedItems(1) End If End With If myF = "" Then MsgBox "画像を選択してください。" Exit Sub End If For Each mySp In ActiveSheet.Shapes myAD1 = mySp.TopLeftCell.MergeArea.Address myAD2 = Target.Address If myAD1 = myAD2 Then mySp.Delete Next Set mySp = ActiveSheet.Shapes.AddPicture(Filename:=myF, LinkToFile:=False, _ SaveWithDocument:=True, _ Left:=Target.Left, _ Top:=Target.Top, _ Width:=0, Height:=0) mySp.ScaleHeight 1, msoTrue mySp.ScaleWidth 1, msoTrue mySp.LockAspectRatio = msoTrue If mySp.Width / Target.Width > mySp.Height / Target.Height Then mySp.Width = Target.Width - 10 Else mySp.Height = Target.Height - 10 End If mySp.Left = Target.Left + (Target.Width - mySp.Width) / 2 mySp.Top = Target.Top + (Target.Height - mySp.Height) / 2 Set mySp = Nothing End Sub
伝票のフォーマットがあるのであれば、あらかじめ全てに○を付けておき、 条件に合わせてDeleteしていったほうが楽かもしれませんね。
参考にどうぞ。 ただの長方形面積の積算です。 Dim result As String = "" For d As Double = 0.1 To 1 Step 0.1 Dim x, y As Double Dim sum As Double = 0.0 For x = 3.0 To 10.0 Step d y = 3 * x * x - 4 * x + 5.0 Dim xw As Double = 10.0 - x If xw < d Then '最後の短冊の幅の調整 sum += y * xw Else sum += y * d End If Next result += "delta=" + d.ToString("F3") + ", sum=" + sum.ToString("F3") + System.Environment.NewLine Next Label1.Text = result
なんのマクロなんでしょうか
まる という名前の単体図形と、まる という名前の図形をグループ内に含んだ図を選択する例です。 Sub Test() Dim myShp As Shape, i As Long For Each myShp In ActiveSheet.Shapes If myShp.Name = "まる" Then myShp.Select False If myShp.Type = msoGroup Then For i = 1 To myShp.GroupItems.Count If myShp.GroupItems(i).Name = "まる" Then myShp.Select False Exit For End If Next End If Next End Sub
>たとえばA=10とB=20 この「A」「B」は変数ですか？ どんなコードでエラーになっていますか？ 単純に TextBox1.Text = A & "～" & B ではだめでしょうか。
System.Diagnostics.Process.Startでxdoc2txtを呼び出して、 結果はファイルにリダイレクトしておけば、後はファイルからデータを読み込む時と同様になります。 xdoc2txt.exe等は面倒であれば自分の作ったプログラムと同じ所に突っ込んでおけば動きます。
ActiveWorkbook.Sheets(1).Delete Application.DisplayAlerts = True ActiveWorkbook.SaveAs 保存ファイル名, xlNormal ActiveWorkbook.Close False ↓ ActiveWorkbook.Sheets(1).Delete ActiveWorkbook.SaveAs 保存ファイル名, xlNormal ActiveWorkbook.Close False Application.DisplayAlerts = True を試してください。
この本が有名ですね。 http://www.geocities.jp/excelgame/books/ 結構古い本ですが、VBAでアクションゲームを作る上でのノウハウが詰まっています(例えば質問にあった待ち時間の処理とか、ゲーム全体ではどのようなループ処理が必要なのかとか、キャラクターの移動の際に発生する自キャラの描画と背景の再描画を簡略化するにはどうすればいいかとか....)。ただVBAそのものの解説は薄めなので、この本だけでVBAを勉強するには無理があります。 CDが付属しており、その中にコード閲覧が可能なサンプルゲームが複数入っています。 本を買うのが嫌なら、上記サイトにあるサンプルゲームをダウンロードしてコードを見たり、各作者のホームページを見に行ったりするだけでも勉強になりますよ。本に付属のCDにはもっといろいろなサンプルゲームがありますけどね。 それでは。
RIGHTやFINDはOutlookのVBAでも使い方は同じです。
Phoneticを使用するのは危険だと思います。 違う読みで入力されていれば、違うカナになってしまいますね・・・。 なお、このまま使うなら その下にReplace関数を複数行挿入する事で対応出来ます。 tmp = Replace(tmp,"ｬ","ﾔ") tmp = Replace(tmp,"ｭ","ﾕ") tmp = Replace(tmp,"ｮ","ﾖ") tmp = Replace(tmp,"ｯ","ﾂ")
一例です。 作業シートのC列にシート名、D列に図形名を表示してます。 Sub sample() Dim rng As Range, sh As Worksheet, shp, xTxt As String Set rng = Worksheets("作業").Range("B5") For Each sh In Worksheets If sh.Name Like "P##" Then For Each shp In sh.Shapes xTxt = shp.TextFrame2.TextRange.Characters.Text If xTxt <> "" Then rng.Resize(, 3).Value = Array(xTxt, sh.Name, shp.Name) Set rng = rng.Offset(1) End If Next shp End If Next sh End Sub
エラーの内容とエラーとなっているコードを提示して下さい。
下回答者さんの補足です。 rc = mciSendString("close " & SoundFile, "", 0, 0) rc = mciSendString("open " & SoundFile, "", 0, 0) rc = mciSendString("Play " & SoundFile, "", 0, 0) を入れる前に必ず rc = mciSendString("stop " & SoundFile, "", 0, 0) を入れてください。 （つまり、CLOSEする前に再生中の音声を停止するという意味） CLOSEはあくまで再生中の音声の読み取りを終了するという意味で、再生している音声を停止するものではありません。CLOSEを送った時、既にバッファにすべての音声が読み込まれていたら、当然最後まで音声が流れます。 音声停止は明示的に指示する必要があります。 通常、MCIを使う場合はNOTIFYで終了時にコールバックハンドルを送りますが、それが出来るのはVCなどの機械語レベル。 あと、根本的にMCIの使い方が間違っています。 mciSendStringを省きますが、MCIコマンドで書くとこうなります。 OPEN C:\Users\Home\OneDrive\H28\あいさつ.mp3 alias aisatsu PLAY aisatsu 再生停止の場合は STOP aisatsu CLOSE aisatsu MCIを使う場合は、必ずOPENでファイル名に対するALIAS名を割り当て、それ以降のファイルハンドルはALIASで割り当てた名前を使います。
以下でどうなりますか そのシートに以下を記述して確認してみます Private Sub Worksheet_Change(ByVal Target As Range)    Dim rng As Range    Dim i As Long, j As Long    Dim bV As Boolean    Const CRNG As String = "E8,G8,I8,K8"    Set rng = Range(CRNG)    Set Target = Intersect(Target, rng)    If (Target Is Nothing) Then Exit Sub    For i = 1 To rng.Areas.Count       If (Not Intersect(Target, rng.Areas(i)) Is Nothing) Then          bV = rng.Areas(i).Value = ""          j = (i + 1) * 10          Rows(j).Resize(10).Hidden = bV          j = i + 3          Worksheets("Sheet2").Rows(j).Hidden = bV       End If    Next End Sub ' 確認用簡易データ作成 標準モジュールで Public Sub testData()    Dim r As Range    Const CRNG As String = "C8,E8,G8,I8,K8"    Const CRH As Long = 60    With Worksheets("Sheet1")       .Cells.Delete       For Each r In .Range("A9:Z9").Resize(CRH)          r.Value = r.Address(False, False)       Next       For Each r In .Range(CRNG)          r.Resize(, 2).Merge       Next       .Rows("20:59").Hidden = True       .Columns.AutoFit    End With    With Worksheets("Sheet2")       .Cells.Delete       For Each r In .Range("A1:Z1").Resize(10)          r.Value = r.Address(False, False)       Next       .Rows("4:7").Hidden = True       .Columns.AutoFit    End With End Sub
こんなでどうでしょうか。 FindNextを使うと不具合があったため、Findだけで処理しています。 対象セルは選択範囲になってますが、 Set target = Selection '選択セルを対象 を Set target = Cells '全セルを対象 にすると全セルが対象になります。 Set target = Range("A1:BH5") '指定セルを対象 などにすると、指定したセル範囲(ここでは"A1:BH5")が対象になります。 Sub sample() Dim target As Range Dim rng As Range Dim adr As String Dim n As Integer ' Set target = Selection '選択セルを対象 'Set target = Cells '全セルを対象 'Set target = Range("A1:BH5") '指定セルを対象 Application.FindFormat.Locked = False '非ロックセル検索 Application.FindFormat.FormulaHidden = False '表示セル検索 Set rng = target.Find(What:="", After:=Cells(target.Row + target.Rows.Count - 1, target.Column + target.Columns.Count - 1), LookAt:=xlPart, SearchFormat:=True) '最終セルの次から探す(A1が対象の場合に対応) If rng Is Nothing Then Exit Sub '無かったら終わり adr = rng.Address '最初に見つけたセルのアドレス n = 1 '表示する番号の初期値 Do rng.Value = n '見つけたセルの番号を表示 n = n + 1 '表示する番号+1 Set rng = target.Find(What:="", After:=rng, LookAt:=xlPart, SearchFormat:=True) '次のセルを検索(FindNext打と不具合があったので) Loop Until rng.Address = adr '最初のアドレスになったら抜ける End Sub
コード例です。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) If Not Intersect(Target, Range("g2:g152")) Is Nothing Then UserForm1.Show Cancel = True ElseIf Not Intersect(Target, Range("e2:e152")) Is Nothing Then UserForm2.Show Cancel = True End If End Sub
With ComboBox2 .AddItem "A" .AddItem "B" .AddItem "C" .AddItem "D" ComboBox3.List = .List End With ですか？
以下のコードです。 Private Sub UserForm_Initialize() Me.ListBox1.RowSource = "Sheet1!A1:A10" Me.ComboBox1.RowSource = "Sheet1!B1:B10" End Sub 参考となるサイトのURLを提示しておきます。 http://officetanaka.net/excel/vba/tips/tips139.htm
Sub 一例です() Dim sh As Worksheet, xName, xVal, i As Long xName = Split("*A*,*B*,*C*,*D*", ",") xVal = Array(1, 2, 3, 4) For Each sh In Worksheets For i = LBound(xName) To UBound(xName) If sh.Name Like xName(i) Then sh.Range("AY1").Value = xVal(i) Exit For End If Next i Next sh End Sub
下記のコードを入力シートが存在するブックの標準モジュールにコピペしてください。 反映シートはBook2.xlsxと仮定しています。 Option Explicit Sub Sample() Dim bk1 As Workbook, bk2 As Workbook Dim st As Worksheet, st1 As Worksheet, st2 As Worksheet Dim r1 As Long Dim dt As Variant Application.ScreenUpdating = False Set bk1 = ThisWorkbook Set st1 = bk1.Worksheets(1) '反映ブックを開く Set bk2 = Workbooks.Open("Book2.xlsx") 'A5から最下行まで繰り返す For r1 = 5 To st1.Range("A" & st1.Rows.Count).End(xlUp).Row '日付を取得する dt = st1.Range("B" & r1).Value Set st2 = Nothing '日付シートを探す For Each st In bk2.Worksheets If st.Range("A2").Value = dt Then Set st2 = st Exit For End If Next '日付シートが見つからなかったときはシートを追加する If st2 Is Nothing Then bk2.Worksheets("原紙").Copy After:=bk2.Worksheets(bk2.Worksheets.Count) Set st2 = bk2.Worksheets(bk2.Worksheets.Count) st2.Name = Day(dt) & "日" st2.Range("A2").Value = dt End If '号炉ごとに合計値を算出する With st2.Range("G7").Offset(st1.Range("A" & r1).Value) .Value = .Value + st1.Range("C" & r1).Value End With Next r1 '反映ブックを上書き保存して閉じる Application.DisplayAlerts = False bk2.Close True Application.DisplayAlerts = True Application.ScreenUpdating = True End Sub
既にhdumpさんが回答されていますが、全くその通りです。 一つのテキストボックスで年月日を入力させるのではなく、あいだの「/」はラベルを用いて、年月日それぞれを別々のテキストボックスで入力させてみてはどうでしょうか？
Dim hogehoge As Range For Each hogehoge In Range(Range("I2"), Cells(Rows.Count, 9).End(xlUp)) hogehoge.Value = Application.RoundDown(hogehoge.Value, 1) Next
可能性としては最初に提示いただいた終了条件の、 Range("A1").End(xlDown).Row の部分が 列AのA1～下方向にかけて空白でないセルまでくりかえしといった、 終了条件となっているので たとえばA100までデータがあったとしても 途中のA53のセル値が空白などであった場合は A52のセルで終了となりますが、データは空白を含みますか？（´∀｀）
試してみてください。 Sheet1表示状態で実行します。 Sub Test() Dim r As Long, T As String, spT As Variant Dim L As Long, rng As Range r = 2 Do While Cells(r, 1).Value <> "" If Cells(r, 1).Value <> 0 Then _ T = T & Cells(r, 2).Value & "," Set rng = Rows(r) r = r + 1 Loop spT = Split(T, ",") For L = 0 To UBound(spT) - 1 r = 2 Do While Cells(r, 2).Value <> "" If Cells(r, 2).Value = spT(L) Then _ Set rng = Union(rng, Rows(r)) r = r + 1 Loop Next rng.Copy Sheets("Sheet2").Activate Rows(2).Select ActiveSheet.Paste rng.Delete Shift:=xlUp End Sub
>このようなことはGriedViewを使ってできますか？ ⇒はい、できますよ。 GridViewの列の中身をカスタマイズするには、templateFieldというものを使います。 これを使うと、列の中身のコントロールを自由に配置することが可能です。 http://www.atmarkit.co.jp/fdotnet/vs2005db/vs2005db_04/vs2005db_04_... （ちょっと古いですが） ＞そしてユーザーにテキストボックスに日 付を入力してもらい、ドロップダウンリストの内容を変えたいと思っています。 ⇒これはjavascriptとajaxを使うのがスマートかと。 ちょっと敷居高いかもですが。
何かを作れって言われていない？ なければ、自分の仕事の中で使用できそうなものをつくる。 仕様書作って、設計して、プログラミングして、実行結果をまとめる。 までが成果物だと思うけど？
まず、ホームページはhtmlと言うルールに沿った言語で書かれています。 これは各ブラウザで違う所もあるのですが、基本的には各ブラウザ共通の言語です。 基本のhtmlだけでは色々の事が出来ませんが、Dom(Document Object Model)と言う仕組みで、htmlを色々操作する事ができます。 これはサーバ側でPHPやJavaやPerlやjavaScript(javaScriptは一部クライアント側)で操作する仕組みなので、基本的にはクライアント側(ブラウザ側)から操作できない仕組みです。 ただ、Microsoftが自分の会社アプリケーション同士を操作できるOLE(Object Linking and Embedding)と言う仕組みを組み込んだので、VBAを使ってMicrosoft Internet Explorer上のDomを使うことができるようしました。 ちなみにphpはサーバ側で動いているので、VBAからは操作できません。 なので、phpやDomは、データを使うホームページ制作をするなら覚えた方がいいですが、VBAにとっては本道から離れていると思います。 特に最近のホームページではOleでは対処できないものも多くなってきています。 VBAからDomを使って操作できるブラウザはMicrosoft Internet Explorerだけです。 phpやDomはサーバ側の技術です。 DomはJavaScriptなどの本の方が詳しいと思います。 ちなみに、Microsoftの新しいブラウザのMicrosoft EdgeもVBAから操作できるようですが、詳しくは不明です。
自分は簡単なVBAなら組めるってレベルですが、「何がしたいか」が明白であれば行動に移しやすいです。「エクセルで○○を○○したい！」という欲求が有り、VBAで実現するにはどうすればいいのかをネットで検索して…をひたすら繰り返す、というかしたのが自分のやり方でした。たとえば英語を覚えるのにアルファベットから覚えてThis is a pen.から始めるとゴールは遠いですが、来週アメリカに旅行に行くんだけど〜てな時には「必要な英語だけをとりあえず覚えとく」方が効率がいいですよね。
こんにちは。 主様が実行しようとしている環境そのものが、特殊です。 たとえば、「もともとクラウド」にあったエクセルブックを、自動的にダウンロードし、マクロのブックが開いているような場合です。 クラウドの場合は、「見せ掛けのシームレス」のために、舞台裏は、とんでもなく複雑になっています。 主様のフォルダのcacheの言葉は、それを物語っています。 このブックを「ローカルパソコン」のドキュメントフォルダで実行したら、主様の期待した動作になるはずです。 (主様の問題が、複雑な舞台裏の仕様が原因、ということですよ つまり、そこだけでしか、再現できません) もし、社内で使っていて、というのでしたら、同じような環境での実行ということでしょうから、問題は起こります。 問題の洗い出しと、回避策を考えましょう
左側のグレーのスペースは メニュー項目のアイコン表示のためのスペースです 必要がなければ ContextMenuStripの『ShowImageMargin』を Falseにして見ましょう 項目のない部分での右クリックに対しては ListBoxのMouseDownイベントにて if e.Button = MouseButton.Right then dim pt as Point = e.Location dim bflag as boolean ' 余白か 項目かをチャック for n as integer = 0 to ListBox1.Items.Count -1 if bflag orelse ListBox1.GetItemRectangle(n).Contains(pt) then ' 項目上 bflag = true exit for end if next if bflag = false then ' 余白なら 右メニューをやめる listBox1.ContextMenustrip = Nothing else ' 項目なら 右メニューを設定 ListBox1.ContextMenuStrip = ContextMenuStrip1 end if End if といった具合です
最後（一番右）のシートのシート名が数字だけでないとエラーになります。 シート名を確認して下さい。
>原因を教えて下さい!! BlnA3 = ISBLANK(A3) ISBLANKというステートメント・関数は、VBAに存在しません。 A3は、変数ですか？ あと、示されたコードは、冗長な部分が多いです。 ダイエットしましょう。 ↓は、ダイエット結果の一例。 Private Sub CommandButton1_Click() Dim NextRow As Long, xDate As String xDate = Format(Date, "mm月dd日") '初めて日付ボタンをクリックした時の処理 If Cells(3, 1).Value <> "" Then Cells(3, 1).Value = xDate Else '日付ボタンを2回以上クリックした時の処理 'F列に値が入力されている最終行を取得して､最終行の次の行及び日付列に次の日の日付を入力する｡ NextRow = Range("F" & Rows.Count).End(xlUp).Row + 1 Cells(NextRow, 1).Value = xDate End If End Sub
vbaなら Split("aaaa_rehrte_kore_sert", "_")(2) で、２つめの_と３つめの_の間の文字列が取り出せます。
質問の内容はなんでしょう？
テンプレートに書き込みしたファイルをサーバ上で保存して、Webページからはその保存したファイルにリンクを設定する要領で表示できます。
質問の以下の内容が分かりませんが.. よく似た方法で例を回答します。 >列幅をすべて1に設定しセルの結合でサイズを合わせ、 > 固定長形式のファイルを作成することができました。 >(拡張子を.prn→.txt) 固定長の仕様が） 社員番号：数字4桁、頭0 漢字氏名：全角10字（20バイト） カナ指名：半角20字 生年月日：数時8桁（yyyymmdd形式） 性別：半角１字 シート名は次のような想定 出力：固定長のデータの出力元 固定長のファイル名にしたほうが後が楽かな？ データ：元データ（エクセル表） 見出し：ヘッダー１行目、フッタ２行目に設定 出力シートの １行目A1 =見出し!A1 ここに直接書いてもいいけれども... ２行目A2 =IF(データ!A2<>"",TEXT(データ!A2,"0000")&LEFTB(データ!B2&REPT(" ",10),20)&LEFTB(データ!C2&REPT(" ",20),20)&TEXT(データ!D2,"yyyymmdd")&LEFTB(データ!E2&" ",1),IF(データ!A1<>"",見出し!$A$2,"")) これを下にコピー これで、prn形式で保存してください。 この場合、列幅は関係ありません。 ただし、フッター以降に改行だけのデータが大量にできると思います。 全角漢字氏名はREPT関数で全角空白を繰り返していますが、文字数はLENBなど半角換算（全角１文字＝半角２文字）でしています。 また、固定長にする方法として＝A2&REPT(" ",20-LENB(A2))のような回答が見受けられますが、元のA2が20字以上入力されると取り込むシステム側でエラーになるか、データがずれます。（私はシステム管理者側で経験あり） なので、LEFT関数で切り捨てています。 よく使いそうな、文字形式は網羅したつもりです。
visualstudio.comで合っています。マイクロソフトのVisualStudioの特設ページです。 2010は5年以上前のものだから、もうないと思います。 今の無料版の最新版は、VisualStudioCommunity2015です。 ビジュアルスタジオの中にVB、VC++、VC#などのコンパイラが入っています。 昔はバラバラにダウンロードする形式でしたが、今はセットでダウンロードします。
試していませんが、 myRng.Copy .Cells(1, 1) を myRng.Copy .Cells(1, 1).PasteSpecial Paste:=xlPasteValues としてみてはどうでしょうか？
こんにちは VB.NETで回答させていただきます。 ＞AAとかBBを表示するには そのまま表示すると全部表示されてしまいますので、3文字目から表示するようにします。 Substring(2)を利用します。 Substringは3文字めから最後まで表示するには引数に2を入れます。 1番目の文字のインデックスは0です。 サンプルではButtonとLabel、ListBoxを貼り付けています。 Public Class Form1 Private Sub f() Handles MyBase.Shown ListBox1.Items.Add("1 AA") ListBox1.Items.Add("2 BB") ListBox1.Items.Add("3 CC") Label1.Text = "" Button1.Text = "表示" End Sub Private Sub Button1_Click(sender As System.Object, e As System.EventArgs) Handles Button1.Click For Each st As String In ListBox1.Items Label1.Text &= st.Substring(2) & vbNewLine Next End Sub End Class
masaya13125さん プログラムの種類等、あいまい。 絶対パスで書けばよい。
グラフを表示させる手法 （１）Chartコントロールを用いる （２）Staticコントロール全体を描画領域として軸、目盛りを表示する （３）グラフ表示領域とメモリ表示領域を分けてStaticコントロールに描画 など、いくつかの方法があります。 HTMLなどではビットマップを拡大縮小する方法が取られることが多いですが、C#等では利便性と自由に描画できるため直接描画するほうが良いと思います。 目盛り値を表示するためにラベルを用いるなどはやらないほうが良いと思います。 私はスクロールを含め直接描画するほうがやり易いですね。
.Find(What:=i).Select ではありませんか？ Range(1)といった使い方もできません。 検索対象が 1行目ならRows(1)、1列目ならColumns(1)を使うとよいと思います。 あとコードだけでは判別がしにくいので 検索対象の行列番号、シート名 シートの構成など内容をもう少し詳しく教えていただけると 回答しやすくなります。
質問の意味がイマイチわからんけど、こういう事？ Public Class Form1 Private Sub Button1_Click_1(sender As Object, e As EventArgs) Handles Button1.Click Dim ItemList As New strList From {"33いうえ", "00えあか", "11あいう", "22いおか"} ItemList.Sort() ListBox1.Items.Clear() For Each str As String In ItemList ListBox1.Items.Add(str.Substring(2)) Next End Sub End Class Public Class strList Inherits List(Of String) Public Overloads Sub Sort() Dim ary() As String = ToArray() Me.Clear() AddRange(ary.OrderBy(Function(o) o.Substring(2))) '降順なら OrderBy の代わりに OrderByDescending End Sub End Class
提示されたコードを見ると「For Cnt = 1 To 25」となっていますので、データ貼付シートのC列のデータ量にかかわらず下記を25回繰り返していますね。 ①「リストとカードを印刷しますか？」のメッセージを表示する ②管理ﾘｽﾄシートを印刷する ③P1-2シートを印刷する ④P3-4シートを印刷する ・本当に「シート"P1-2"とシート"P3-4"だけ」が沢山印刷されているのでしょうか？ ・ループごとにメッセージを表示していますが、ループの前に一度だけ表示してNoなら何も印刷しない、という方法ではだめなのでしょうか？
Pictures.Insertで画像を貼り付けた場合、 Excel2007：画像情報がExcelに保存されるの・・・msoPicture(13) Excel2010：リンクオブジェクトとして取り込まれる・・・msoLinkedPicture(11) と変更になりました。 (参考)[Microsoftサポート情報] Excel 2010 で Pictures.Insert メソッドを使用して図をワークシートに挿入すると図がリンク オブジェクトとして挿入される https://support.microsoft.com/ja-jp/kb/2396509 基本的にはShapes.AddPictureを使うように書かれています。 Set objShape = ActiveSheet.Shapes.AddPicture( _ Filename:=objFileName, _ LinkToFile:=False, _ SaveWithDocument:=True, _ Left:=Selection.Left, _ Top:=Selection.Top, _ Width:=50#, _ Height:=50#) With objShape .ScaleHeight 1!, msoTrue .ScaleWidth 1!, msoTrue End With この中で LinkToFile:=False でリンクオブジェクトにしないことを指定 SaveWithDocument:=True で画像情報をファイルに保存することを指定 こうすることで、追加した画像はmsoPicture(13)になります。 なお、以下のサイトでPictures.Insertした画像をクリップボードにコピーし、削除した後貼り付けることでリンクでない画像にする方法が書かれていますので参考にしてみてください。 [mougモーグ] 画像ファイルを挿入する http://www.moug.net/tech/exvba/0120020.html
Msgbox TypeName(Cells(1,1).Value) 変数型を調べる命令ですが、これを実行するとどうなりますか？ また、A1の数式は何が入っているのでしょうか。
例えばこんな感じの XAML で。 <Window ・・・ xmlns:vw="clr-namespace:WpfApplication1.Views" xmlns:vm="clr-namespace:WpfApplication1.ViewModels"> <Window.Resources> <DataTemplate DataType="{x:Type vm:AViewModel}"> <vw:AView /> </DataTemplate> <DataTemplate DataType="{x:Type vm:BViewModel}"> <vw:BView /> </DataTemplate> <DataTemplate DataType="{x:Type vm:CViewModel}"> <vw:CView /> </DataTemplate> </Window.Resources> <DockPanel> <StackPanel DockPanel.Dock="Top" Orientation="Horizontal"> <Button Content="A" Command="{Binding ChangeScreenCommand}" CommandParameter="A" /> <Button Content="B" Command="{Binding ChangeScreenCommand}" CommandParameter="B" /> <Button Content="C" Command="{Binding ChangeScreenCommand}" CommandParameter="C" /> </StackPanel> <Grid> <ContentControl Content="{Binding CurrentViewModel}" /> </Grid> </DockPanel> </Window> ChangeScreenCommand で CurrentViewModel を切り替えて 画面切り替えをします。 AViewModel に対する画面は AView、 BViewModel に対する画面は BView、 CViewModel に対する画面は CView というユーザーコントロールになります。
複雑に見えているだけで実際はそうでもないです。結合セルとひらがなが目くらましになっていて表は添付図のようになっています。 D列とE列にはB列が空白セルになっていてB列の情報はないわけです。というより、空白セルは０扱いですから４０００未満と同じです。 なので上からループするときBの４０００以上４０００未満の判定結果を保持する変数を使えばいいですね。B2,B3,B4は４０００以上、B5でまた変数にB５,B６,B７は４０００以上、B8でB8,B9B10は４０００未満・・・・という感じです。 集計列には文字が入っているので＋演算子が使えません。SUM関数を使います。 Sub test() Dim Judge As Boolean Dim Csum As Long, Dsum As Long, Esum As Long, i As Long, d As Long With WorksheetFunction For i = 2 To Cells(Rows.Count, 2).End(xlUp).Row + 2 If i Mod 3 = 2 Then Judge = Cells(i, 2) >= 4000 '3行置きに判定 If Judge Then Csum = .Sum(Csum, Cells(i, 3)) Dsum = .Sum(Dsum, Cells(i, 4)) Esum = .Sum(Esum, Cells(i, 5)) End If Next i Cells(4, 7) = Csum Cells(4, 8) = Dsum Cells(4, 9) = Esum '-------------------------------------------------- '上と同じことをする Csum = 0: Dsum = 0: Esum = 0 For i = 2 To Cells(Rows.Count, 2).End(xlUp).Row + 2 If i Mod 3 = 2 Then Judge = Cells(i, 2) < 4000 '3行置きに判定 If Judge Then Csum = .Sum(Csum, Cells(i, 3)) Dsum = .Sum(Dsum, Cells(i, 4)) Esum = .Sum(Esum, Cells(i, 5)) End If Next i Cells(8, 7) = Csum Cells(8, 8) = Dsum Cells(8, 9) = Esum End With End Sub
前半だけですが、これでどうでしょう。 Dim myKey As String Dim rng As Range sidx = 34 myKey = "小計" rng = Range("E:E").Find(whgat:=myKey) If rng Is Nothing Then Exit Sub r = rng.Row Range(Cells(r, "H"), Cells(r, "L")).Formula = _ "=sum(" & Range(Cells(sidx, "H"), Cells(r - 1, "H")).Address(ColumnAbsolute:=False) & ")" 小計を探すのにfindを使いました。 関数の一気入力を使ってます。 セル範囲.Formula="先頭セルに入力するべき関数" これでセル範囲全部に入力されます。
こんにちは。 >Workbook_Deactivate と Workbook_WindowDeactivate 最初のは、ブックレベル、次のは、ウィンドレベルです。 テストは、ブック1を開き、ウィンドから「新しいウィンド」を開く として、同じブックを二つのウィンドでみるようにします。 つづいて、「新規ブック」をクリックし、ブック2を表示。 このとき、ブック1は2つブック2で、合計、3つのウィンドがあります。 この状態で、ウィンドを順番にクリックしてください。 発生するイベントがどんな順番で発生するか、みてみてください。 で、説明、なんですが、ブック1とブック2の切り替えの時に、発生するのが、 Workbook_Deactivateです。 そして、ウィンドが切り替わったときには Workbook_WindowDeactivateです。 つまり、ブックが1とブック2しか、ない、という環境では、両方のイベントが発生します。 違いが分かるのは、同じブックを、複数のウィンドで、みている場合です。 同じブックを見続けている間は、「Workbook_Deactivate」は、発生しません。 さらに、見ているブックしかない、という場合は、「Workbook_Deactivate」が発生するのは、ブックを閉じるだけになります。 OSレベルで、ウィンドを切り替えたとき、イベントは発生しません。 イベントの処理では、状況環境に合わせてコードを記述するので、最初のうちは、テストコードを使って、確認してみないと、分からないことが多いです
最終的にどのような処理をしたいのか不明ですが、チェックボックスがオンになっている数を数えるのであれば以下のようなコードで可能です。 Sub CheckBoxOn() Dim chk As Object, cnt As Integer For Each chk In ActiveSheet.CheckBoxes If chk = xlOn Then cnt = cnt + 1 End If Next chk MsgBox "オンは" & cnt End Sub
こんにちは。 このアプリは、そもそも、エクセルVBAから、window制御する、というような実行ファイルではありません。 このアプリは、パスの保存の設定、そして、展開先のフォルダを保持する仕組みがあり、設定を調整することで、制御しなくても保存先は保持できるようです。 高度な設定には「パスワードファイル」なるものが使えるようなので、そのファイルを正しく設定する部分をエクセルで作ることが出来たら、 そのファイルを使って、展開動作をさせることが、やってみないといけません。 パスワードファイルそのものも、暗号になっていたら、結局、アプリで作成させる、ということなんですから、どこかであらかじめ作業が必要ということです
表が何行目から始まっているとか何列にあるとかの情報があるとズバリの数式を提示できるのですが不明なので添付図の場合です。 せめて何行名から始まってもいいように空いている列の２行目に数式を入れます。 H2 =IF(C2="○",SUBSTITUTE(TRIM(H1&" "&B2)," ",","),H1) 下にコピーします。（元の表の最終行に合わせて） C列が「購入」列、B列が商品名の列という想定です。
①に書かれている For i = 1 To Worksheets(1).Range("A" & Rows.Count).End(xlUp).Row Worksheets(r).Range("C1").Value = Worksheets(1).Range("A" & i) '★ Next i をみると、 「r」は、変わらず「i」は、１～最終行の行番号まで変化します。 ★のところの左辺は、なにも変わらない、ということは、iが変わっても、同じシートのC1セルに上書きされるだけ。最終行の値が最後にC1セルに残ることになります。 ということは、この3行は、 i = Worksheets(1).Range("A" & Rows.Count).End(xlUp).Row Worksheets(r).Range("C1").Value = Worksheets(1).Range("A" & i) と書くのと同じだということですね。 全体を書きかえると Sub d() For r = 2 To 5 i = Worksheets(1).Range("A" & Rows.Count).End(xlUp).Row '■ Worksheets(r).Range("C1").Value = Worksheets(1).Range("A" & i) Next r '■のステップはFor文に影響されないので、ループの外に持っていくと Sub d() i = Worksheets(1).Range("A" & Rows.Count).End(xlUp).Row For r = 2 To 5 Worksheets(r).Range("C1").Value = Worksheets(1).Range("A" & i) Next r ということになりますね。 Worksheets(1)のA列最終行の値を、他のシートのC1に代入しているということですね。
イメージ的にはこんな感じかな。 Sub Sample() Dim buf As String, i As Long, Check As String For i = 1 To Cells(Rows.Count, 1).End(xlUp).Row If Cells(i, "B") = "○" Then buf = buf & vbCrLf & Cells(i, "A") & "," Check = Cells(i, "A") ElseIf Cells(i, "A") = Check And Cells(i, "B") = "" Then buf = buf & Cells(i, "A") & "," ElseIf Cells(i, "A") <> Check And Cells(i, "B") = "○" Then Else Check = "" End If Next i MsgBox buf End Sub
一点目 If Range("A1").Value = "" Then Range("A1").Value = left Range("B1").Value = right Else With Range("A1").End(xlDown) .Offset(1, 0).Value = left .Offset(1, 1).Value = right Wnd With End 二点目 無限ループになります。 何か終了条件が無いと終わりません。 Dim r As Long r = 1 Do If Range("A" & r).Value = "" Then Range("A" & r).Value = "何か値" r = 1 Else r = r + 1 End If Loop
カテゴリがファイル共有・P2Pになっています。違反報告で投稿が削除されライフが減る前にカテゴリ修正する事をお勧めします。 読み込んだ文字列の右側1文字を削るのは如何でしょうか。但し、ファイルの最終行は改行コードが無いはずですので、最終行かどうかをIf文で判断させる必要があるかと思います。あるいは、文字列の最後の文字が改行かどうか、で判断させてもいいですね。 https://msdn.microsoft.com/ja-jp/library/cc392241.aspx 文字列がbufという変数に入っているとして、 buf = Left( buf , Len( buf ) - 1 ) で、右側1文字を削れます。 それでは。
おかしな点ですが、 For r = 1 To Worksheets(1).Range("a" & Rows.Count).End(xlUp).Row 1からＡ列の最終行まで処理をしますが、変数 r は Worksheets(1).Range("c" & r).Value とＣ列の行として処理しています。Ｃ列の最後まで処理するのではないですか？ Worksheets(1).Range("b1:b5").Find Ｂ列は５行目までで固定ですか？Ｂ列の最終行まで処理しませんか？ そういったことを考えて変更したサンプルが以下になります。 Sub 文字の検索() '先頭のシートをアクティブにしておきます Worksheets(1).Activate 'Ｃ列の最終行まで処理します For r = 1 To Range("C" & Rows.Count).End(xlUp).Row 'Ｂ列の先頭から最終行までを検索対象にします With Range("B1", Range("B" & Rows.Count).End(xlUp)) 'Ｃ列の文字で検索します Set Rng = .Find(Range("C" & r).Value, lookat:=xlPart) '１件以上あった場合 If Not Rng Is Nothing Then '検索結果の先頭アドレスを控えておきます firstaddress = Rng.Address Do '左のセル（Ａ列）に○を入れます Rng.Offset(0, -1).Value = "○" '次を検索します Set Rng = .FindNext(Rng) '検索結果が先頭に戻るまで繰り返します Loop Until Rng.Address = firstaddress End If End With Next r End Sub
おはようございます。 セルの代入 Cell(○○)＝なにがし までは出来ているという事ですよね。 セルにセットする内容が上記内容で決め打ち出来るのなら単純に文字列をつないでおけば良いのでは無いでしょうか？ dim setCellData As String setText = "○○は" & txtboxA & "秒、▲▲は" & txtboxB & "秒、■■は" & textboxC" & "秒" といった感じで作っておいて、 Cell(○○) = setCellData と入れていく。 もしセルの内容がだいぶ複雑で対応出来ないのでしたら正規表現を使う事となりますが、そこまでしなくても良いのかなと感じました。 http://excel-mania.com/vba/regexp2.html ただ、Cellが数百に及ぶなどですと、若干重いかも知れませんね。 この場合レンジで書き込むことで高速化出来ますが連続している必要があるのでword表（たぶんExcel表の埋め込みですよね）の仕様を変更する事も視野に入れるべきですね。
変更箇所以外を判断するためには、変更する前の内容を覚えておく必要がありますが、そのためには「変更した」と見なすルールを明確にする必要があります。 例えば該当のブックが最後に保存されてから、なのか、 ある日付以降、なのか、 などです。
数字が１００になるまでです。 シートモジュールに Sub test() Cells.Clear With Range("A1") .Value = "=(ROW(A1)-1)*4/18+COLUMN(A1)/2+0.5" .Font.Size = "32" End With Range("A1:A16").Merge With Range("A1:B18") .Borders.LineStyle = True .AutoFill Destination:=Range("A1:H18") End With Range("A1:H18").AutoFill Destination:=Range("A1:H450") End Sub 数字が１０００まで欲しいときは 最後の２行目を Range("A1:H18").AutoFill Destination:=Range("A1:H4500") といった具合です。 フォントサイズ、位置、罫線、結合セルの個数などは写真からは読み取れないので適宜設定をしてください。
性別が「男性」「女性」に限られているのであれば 都道府県を切り出す =LEFT(A1,LEN(A1)-2) 性別を切り出す =RIGHT(A1,2) でいかがでしょうか？
Option Explicitを書かないと問題がない、ということはあり得ません。 宣言されていない変数は暗黙的にVariant型とみなされてしまうため、変数のスペルミスに気付かないことがあります。 その結果「うまくいかない」と半日悩んでしまうこともあり得ます。 Excel VBAでの例になりますが、下記のサイトを参考にしてください。 Office TANAKA - 今さら聞けないVBA「変数って宣言しなくちゃいけないの？」 http://officetanaka.net/excel/vba/beginner/06.htm
>201601・201602と月毎に名前が変わるので、セルA1に2016、B1に01or1 >と入力した場合に201601のフォルダを指定しフォルダを開く と書いてありますが、質問文に書かているコードが①のものなら「201601」というのはフォルダなくブック名だと思います。 ブック名でいいとしたら 他の方のご指摘のように、変数の文字が違う点もありますが、それ以外に FName = Range("A1").Value & Range("B1").Value & ".xlsx" 最後の拡張子部分がありません。 ②は①とは別の質問ですね。 フォルダがどこなのか、わかりません。 最新とはファイル名で「収集データ（最新版2）」の最新版の後の数字で判断していいのですね？
他の質問で回答しましたが、これは質問がおかしいですよ。 10進の0.00390625 を表現するには最低何バイト必要ですか？なら通じます。 10進256は、あなたの書いたとおり100000000ですから1バイトでは1ビット足りないですよね。しかもすべて整数としてです。 小数を表したければ、マイナス何乗で表す必要があります。 1.00000000かける2のマイナス8乗ですから 指数のプラスかマイナスを表すために1ビット 指数の8を表すために4ビット(3ビットだと7までしか表せないので) 1.00000000を表すために8ビット あれば良いので、0.00390625 を表したいだけなら、13ビットあれば良いので最低1.625バイトあれば表現できます。(面倒くさいので2バイトと言いたい) 浮動小数点数というやり方ですね。 実際のプログラムの世界では float型(4バイト)やdouble型(8バイト)を使って小数を表現します。
正規表現の一例です。 Sub sample() With CreateObject("VBScript.RegExp") .Pattern = "文字列" .Global = True MsgBox .Execute([a1]).Count End With End Sub
2行目がおかしいのでは。 Dim s As String = TextBox1.Text TextBox2.Text = s ←変更 If s.Length = 4 Then TextBox2.Height = 60 TextBox2.Width = 240 End If あと、TextBoxの高さを指定するには、TextBoxのMultiLineプロパティをtrueにする必要があります。
C#でPictureBoxに折れ線を引くのであればPictureBoxのPaintイベントでDrawLinesメソッドを使うことをお勧めします。 参考サイト： http://dobon.net/vb/dotnet/graphics/drawline.html#fold なお、グラフを描画するのであれば保持する座標データはPointの配列ではなく、List<Point>型にした方が座標点の追加が楽です。 また、キャンバスに使うコントロールはPictureBoxではなく、Panelの方が子コントロールを配置することが出来るのでレイアウト調整が容易になります。
下記のコードでうまくできますが.... Private Sub コマンド12_Click() Dim DB As DAO.Database Dim RS As DAO.Recordset Set DB = CurrentDb() Set RS = DB.OpenRecordset("リンクパステキスト", dbOpenDynaset) Do Until RS.EOF Kill RS![画像パス] RS.MoveNext Loop RS.Close: Set RS = Nothing DB.Close: Set DB = Nothing End Sub
最終行=RANGE("C" & ROWS.COUNT).END(XLUP).ROW FOR I=1 TO 最終行 IF RANGE("C" & I)=Sheet2.RANGE("C7) THEN RANGE("B" & I)=RANGE("B7") RANGE("D" & I)=RANGE("D7") NEXT で 試してください。
非表示のフォームを起動しておいて、 そのフォームの Form_Unload が動けば･･･ 普通に終了する場合は、 そのフォームの Form_Unload を無効にしてから閉じるとか･･･ 以下参考になると思います ACCESSの閉じるボタンを無効にする？ http://hatenachips.blog34.fc2.com/blog-entry-163.html
見出し行が２行目、項目がＡ列で合計行が必ず最終行の前提 Ａ列の最終行を求め、２列目から最終列（見出し行の最右列）までを０かどうかチェックして、０なら非表示にします。 【サンプル】 Sub Sapmle() Dim r As Long Dim c As Long Dim m As Long '最終行（合計行）を求めます r = Range("A" & Rows.Count).End(xlUp).Row '最終列を求めます m = Cells(2, Columns.Count).End(xlToLeft).Column ’２列目から最終列までを繰り返します For c = 2 To m ’合計欄が０かどうかを判断 If Cells(r, c).Value = 0 Then '０なら列を非表示 Columns(c).Hidden = True Else '０でなければ、列を表示 Columns(c).Hidden = False End If Next End Sub
>「画像ﾌﾙﾊﾟｽ」テキストボックスのコントロールソースには「=[画像検索2]![画像フルパス]」 循環参照になります。コントロール名を「画像ﾌﾙﾊﾟｽ１」に変更すとokです。
ＶＢのバージョンは何ですか？ 普通は、 TextChanged イベントを拾って if 文で、text と "" を比較して違っていたら ボタンのプロパティーを Enabled = True にするのです。 逆に、"" だったら False にします。
コードが変わってしまいますが良いですか？ 以下でどうなりますか Sheet1 の A 列に連番？で、B 列が名前で、C 列が時間であるとします 標準モジュールに記述し Samp1 を実行してみます 時分を扱う時、値そのままなら誤差が入り込みやすいので、 文字列にして比較します Public Sub Samp1()    Dim dic As Object, dicT As Object    Dim vA As Variant, vK As Variant, v As Variant    Dim dt As Date    Dim sS As String    Dim i As Long, j As Long, k As Long, n As Long    Set dic = CreateObject("Scripting.Dictionary")    Set dicT = CreateObject("Scripting.Dictionary")    For dt = #6:00:00 AM# To #2:00:00 PM# Step #12:30:00 AM#       sS = Format(dt, "h:nn")       dicT(sS) = dicT.Count + 1    Next    With Worksheets("Sheet1")       With .Range("A1").CurrentRegion          vA = .Resize(, 3).Value          k = 0          For i = 2 To UBound(vA)             sS = Format(vA(i, 3), "h:nn")             j = dicT(sS)             If (j > 0) Then                If (Not dic.Exists(j)) Then                   dic.Add j, CreateObject("Scripting.Dictionary")                End If                n = dic(j).Count + 2                dic(j)(n) = vA(i, 2)                If (k < n) Then k = n             End If          Next       End With    End With    If (dic.Count > 0) Then       ReDim vA(1 To k, 1 To dicT.Count)       For Each v In dicT.Keys          vA(1, dicT(v)) = v       Next       For Each vK In dic.Keys          For Each v In dic(vK).Keys             vA(v, vK) = dic(vK)(v)          Next       Next       Application.ScreenUpdating = False       With Worksheets("Sheet2")          .Cells.Delete          With .Range("A1").Resize(k, UBound(vA, 2))             .Value = vA             .Rows(1).NumberFormatLocal = "h:mm" '            .Columns.AutoFit          End With          .Activate       End With       Application.ScreenUpdating = True    End If    Set dic = Nothing    Set dicT = Nothing End Sub ※ > accessをエクセルに変換した表だと であれば、クロス集計で Sheet2 様式のものを作って、 単に張り付ければ簡単そうですが･･･ 例えば、Sheet1 のデータが Access のテーブル ★★ にあり フィールド名：an、名前、時間 の３つ an は数値型で 1 ～ の重複しない番号 時間は、日付/時刻型 と仮定した時 クエリのSQLビューに以下を記述してみると、 Sheet2 の様式と雰囲気同じ様になると思います TRANSFORM First(名前) AS 値 SELECT 順 FROM ( SELECT Q1.名前, Q1.時間, Count(Q2.時間)+1 AS 順 FROM ★★ AS Q1 LEFT JOIN ★★ AS Q2 ON (Q1.時間=Q2.時間) AND (Q1.an>Q2.an) GROUP BY Q1.an, Q1.名前, Q1.時間) AS Q3 GROUP BY 順 PIVOT Format(時間,'hh:nn');
コンボボックスに表示されるテキストは1列分しか設定できません。
対象の個人名はＡ列のみを対象にすれば良いのでしょうか。 また、２行目以降を対象にすればよいのでしょうか。 ファイル名は、氏名の前に何か付いて、後ろには付かない、かつ拡張子は.xlsx固定でよいのでしょうか。 上記の条件であれば、以下は一例です。 【サンプル】 Sub Sample() Dim r As Range Dim TargetCell As Range Dim WSH As Object Dim TargetPath As String Dim WBfile As String Dim WB As Workbook '対象フォルダの取得（Desktop上の(仮)新規フォルダ） Set WSH = CreateObject("Wscript.Shell") TargetPath = WSH.SpecialFolders("Desktop") & "\(仮)新規フォルダ\" Set WSH = Nothing 'A列で値が入っているセルを抽出（２行目以降で値か式の入ったセル） With Range("A2", Range("A" & Rows.Count).End(xlUp)) On Error Resume Next Set TargetCell = .SpecialCells(xlCellTypeConstants) If TargetCell Is Nothing Then Set TargetCell = .SpecialCells(xlCellTypeFormulas) Else Set TargetCell = Union(TargetCell, .SpecialCells(xlCellTypeFormulas)) End If On Error GoTo 0 End With '対象がない場合は終了 If TargetCell Is Nothing Then Exit Sub If TargetCell.Address(False, False) = "A1" Then Exit Sub 'セルの値を繰り返し処理 For Each r In TargetCell WBfile = Dir(TargetPath & "*" & r.Value & ".xlsx") '対象のファイルは一つだとしてループさせません If WBfile <> "" Then 'ファイルを開く Set WB = Workbooks.Open(Filename:=TargetPath & WBfile) ＊＊ここに作業部分を入れます＊＊ 'ファイルを閉じる（保存するならSaveChanges:=True） WB.Close SaveChanges:=False End If Next End Sub
>"(JANコード = '" & Jan & "' ) " & _ のカラム「JANコード」に「T.」か「M.」が必要ということなのでは？
GetOpenFilenameを使ってテンプレートファイルの選択を行ってはどうでしょうか。 変数の定義で Dim oftFile As String を追加。 For の前に ChDrive "C:\" ChDir "C:\Users\AA\Desktop\Aフォルダ" oftFile = Application.GetOpenFilename("テンプレート,*.oft", 1, "テンプレートの選択") If oftFile = "False" Then Exit Sub を追加 テンプレートファイルを読み込むところを Set m = ol.CreateItemFromTemplate(oftFile) とします。
いろいろ方法はあると思いますが、一例です。 テーブルで、コピー元列（FAIL1のsheet1の列）とコピー先の列（FAIL2のsheet2の列）を並べて定義しておきます。 For～Next でそれを取り出して、コピー元の２行目から最終行までをコピーします。 【サンプル】 Sub Sample() Dim tbl As Variant Dim i As Long Dim SrcWs As Worksheet Dim DstWs As Worksheet 'コピーする列を対で定義します tbl = Array( _ "A", "B", _ "B", "D", _ "C", "A", _ "D", "E", _ "E", "C") 'コピー元のワークシート Set SrcWs = Workbooks("FAIL1.xlsx").Worksheets("sheet1") 'コピー先のワークシート Set DstWs = Workbooks("FAIL2.xlsx").Worksheets("sheet2") ’テーブルから２つおきに処理します For i = LBound(tbl) To UBound(tbl) Step 2 'コピー元の列の２行目から最終行までをコピー SrcWs.Range(tbl(i) & "2", SrcWs.Range(tbl(i) & Rows.Count).End(xlUp)).Copy 'コピー先の列の２行目以下に貼り付けます DstWs.Range(tbl(i + 1) & "2").PasteSpecial Paste:=xlPasteAll Application.CutCopyMode = False Next End Sub
コード例です。 ユーザーフォーム上にコマンドボタンを設置し、記述してください。 Private Sub CommandButton1_Click() With Workbooks.Open("C:\Users\...") '←ブックBのフルパスを指定 .Worksheets(1).Range("B5").Value = ComboBox1.Text .Close SaveChanges:=True '←記入後ブックBを閉じなければこの行を削除 End With End Sub
Settingファイル、独自XML、iniファイル、レジストリ、データベース、テキストファイル。 何でも良いんで保存すれば良いんじゃないですか。 http://dobon.net/vb/dotnet/index.html#file
秀和システムはいかがでしょうか はじめてのExcel VBA［決定版］（Windows7/Excel2010完全対応） http://www.shuwasystem.co.jp/products/7980html/2710.html はじめてのAccessVBA http://www.shuwasystem.co.jp/products/7980html/1928.html ※2007以降のVBAはどのバージョンでも殆ど同じです。
このあたりですかねぇ http://www.asahi-net.or.jp/~ef2o-inue/vbnet/sub13_05_020.html
試していませんが、 SAVE_PATH & FILENAME & "Microsoft Print to PDF Microsoft Print to PDF PORTROMPT" の部分を SAVE_PATH & Filename & """ Microsoft Print to PDF Microsoft Print to PDF PORTROMPT""" としてみてください。
シートをコピーするだけで、画像が崩れることは考えられない。 写真を張り付けたPCと異なったPCで開くと、写真が崩れてしまうのであれば、原本の貼付け作業のしなおし。 原本の貼付けをマクロ・プログラムで実施しているのなら、そのマクロも手を入れる必要あり。
21日固定なら月の変わり目を考慮する必要もないし、シート1のどこかに開始日を入力したらシート2の最初の日付は =シート1!どこか で、翌日は=最初の日付+1で、シート3の最初の日付は =シート2!最終日+1 ですよね。何の問題もありません。
NETWORKDAYS.INTL関数をご確認ください。 （両端入れになっているので、経過時間の場合にはマイナス1します。） 日時の入力をEXCEL標準の日時として入力してください。 「5/30 8:00」とスペース区切りで入力するだけです。 そうすれば、時間表示の方は引き算し、そこから休日を引き算するだけで済みます。 休日=INT(F2)-INT(E2)-(NETWORKDAYS.INTL(E2,F2,11,祭日)-1) 稼働時間=F2-E2-(INT(F2)-INT(E2)-(NETWORKDAYS.INTL(E2,F2,11,祭日)-1)) =NETWORKDAYS.INTL(E2,F2,11,祭日)-1+MOD(F2,1)-MOD(E2,1) 表示形式をユーザー定義で、 [h]:mm:ss;; としましょう。 日にちの方ですが、補足欄で補足してください。 7:59とか、23:59などのアブノーマルな考え方は捨ててください。 1日が23:59であるわけがないでしょう。 「5/30 0:00～5/31 0:00」で24:00の稼働で、30日=24:00、31日=0:00（稼働無し）と考えてください。 ご質問の趣旨がよく分かりません。 日にちは「足掛け何日」ということですか。 「5/30 8:00～5/30 8:30」の場合は「0日・1日」のどれになるのですか。 「5/30 0:00～5/31 0:00」の場合は「1日・2日」のどれになるのですか。 「5/30 23:45～5/31 0:15」の場合は「1日・2日」のどれになるのですか。 経過日数で良いなら表示時刻の端数を切り捨てるだけです。 =INT(B2) （表示形式を標準にします。）
「VB」だけではバージョンが分かりません。 「VB6.0」系と「VB.NET」系でコーディングが違います。 ※何で開発しているのかくらいは書きましょう。
こんにちは。 主様、２回入りますよ。 たとえば、2行目と5行目だったとします。 i=2かつj=5の場合と、i=5かつj=2の場合です。 同じi=1to10とj=1to10で、主様、本当に、やりたいことができるのでしょうか。 もしかして、 for i=1 to 10 for j=i to 10とかではありませんか？ ソートの考え方です。
こんにちは。 エクセルで、その程度でエラーという場合、イベントのネストが発生していないか、確認してください。 パソコンのメモリやHDDのサイズの問題ではありません。 リソースをあっという間に食い尽くしてしまう、コードの問題です。
Application.OnKeyを使って、イベント作るしかないですね。 特定のセルだけOnKeyでEnterとTabにイベント紐づけて、そのイベントでフォーカスを飛ばしOnKeyを外す。 ヘルプ https://msdn.microsoft.com/ja-jp/library/office/ff197461.aspx サンプル http://okwave.jp/qa/q8243935.html
VBAでは文字をUnicodeで扱いますから、ANK文字であっても１文字は２バイトです。 VBAではExcelのワークシート関数と違い（同名なのでややこしいですが）LEFTB,MIDB,RIGHTB関数を使っても「全角５文字分の幅の文字列」を切り出すというような事は出来ません。 「ANSI形式にして」とおっしゃっていますから、この事は理解されているように思います。 Excelですので、ワークシート関数のMIDB関数などが使えるといいのですが、残念ながら、Application.WorksheetFunciton オブジェクトのメンバにMIDBはありません。 Evaluate メソッドを使うというのはどうでしょうか。例えば文字列が変数 S に入っているとして、 Application.Evaluate("MIDB(""" & S & """,11,256)") のようにするわけです。 ただし、半角と全角が混じっているということなので、11バイト目ではなく10バイト目から取る必要があるかもしれません。ですので MID(S,LEN(Application.Evaluate("LEFTB(""" & S & """,10)"))+1) のようにするのが無難ではないかと思います。
If Worksheets(1).Range("a1").Value = "5" Or "55” Then ではなく If Worksheets(1).Range("a1").Value = "5" Or Worksheets(1).Range("a1").Value = "55” Then
A1に入力された文字列が名前の一部になっているファイルをE2以下に書き出します。 Sub Test() Dim i As Long, buf As String Dim NM As String Const Path As String = "C:\Users\AA\Desktop\Aフォルダ\" NM = Cells(1, 1).Value buf = Dir(Path & "*.*") Do While buf <> "" If buf Like "*" & NM & "*" Then i = i + 1 Cells(i + 1, 5) = buf End If buf = Dir() Loop End Sub
雰囲気以下でどうなりますか 標準モジュールに記述して、 処理対象のシートをアクティブにした状態で Samp1 を実行してみます Public Sub Samp1()    Dim dic As Object, dicE As Object    Dim vA As Variant, vK As Variant, v As Variant    Dim i As Long, j As Long, k As Long    Set dic = CreateObject("Scripting.Dictionary")    Set dicE = CreateObject("Scripting.Dictionary")    Application.ScreenUpdating = False    With Range("A1").CurrentRegion       For j = 4 To .Columns.Count Step 4          vA = .Columns(j).Resize(, 2).Value          For i = 2 To UBound(vA)             If (vA(i, 1) <> "") Then                k = dicE(vA(i, 1))                If (k = 0) Then                   k = dicE.Count                   dicE(vA(i, 1)) = k                End If                If (Not dic.Exists(i)) Then                   dic.Add i, CreateObject("Scripting.Dictionary")                End If                dic(i)(k) = vA(i, 2)             End If          Next       Next       ReDim vA(1 To .Rows.Count, 1 To dicE.Count)       For Each v In dicE.Keys          vA(1, dicE(v)) = v       Next       For Each vK In dic.Keys          For Each v In dic(vK).Keys             vA(vK, v) = dic(vK)(v)          Next       Next       Range(.Columns(4), .Columns(.Columns.Count)).Delete       With .Columns(4).Resize(, UBound(vA, 2))          .Value = vA          .Sort .Cells(1), xlAscending _             , Header:=xlNo, Orientation:=xlSortRows       End With    End With    Columns.AutoFit    Application.ScreenUpdating = True    Set dic = Nothing    Set dicE = Nothing End Sub ' 確認用簡易データ作成 Public Sub testData()    Dim r As Range    Dim vC As Variant    vC = Array("たこ焼き", "お好み焼き", "コーラ")    Randomize    Application.ScreenUpdating = False    Cells.Delete    For Each r In Range("A1:O30")       Select Case r.Row          Case 1             Select Case r.Column                Case 1: r.Value = "氏名"                Case 2: r.Value = "生年月日"                Case 3: r.Value = "性別"                Case Else                   Select Case r.Column Mod 4                      Case 0: r.Value = "食べ物"                      Case 1: r.Value = "好き嫌い"                      Case Else                         r.Value = r.Address(False, False)                   End Select             End Select          Case Else             Select Case r.Column                Case 1                   r.Value = Chr(Asc("A") + Int(26 * Rnd()))                Case 2                   r.Value = Format(Date + Int(1000 * Rnd()), "yyyymmdd")                Case 3                   r.Value = IIf(Rnd() > 0.5, "男", "女")                Case Else                   Select Case r.Column Mod 4                      Case 0                         If (Rnd() > 0.5) Then                            r.Value = vC(Int((UBound(vC) + 1) * Rnd()))                         End If                      Case 1                         If (r.Offset(, -1).Value <> "") Then                            r.Value = IIf(Rnd() >= 0.5, "好き", "嫌い")                         End If                      Case Else                         r.Value = r.Address(False, False)                   End Select             End Select       End Select    Next    Columns.AutoFit    Application.ScreenUpdating = True End Sub
月、日が各二けたと決まっていれば下記でOK Sub test() Dim i, r, s, t As String i = Range("A1").Value r = Mid(i, 1, 4) & "/" s = Mid(i, 6, 2) & "/" t = Right(i, 2) Range("A1").Value = r & s & t End Sub
時間の入力方法は（将来的には・・の記述があります）後回しにするとして。 入力させるシートと項目、出力したいシートと項目がわかりにくいです。 Sheet1とSheet2が入力でSheet3を作成したいのかと思いましたが そうだと、代替の人の名前はどこに入力されるのかがわかりません。 ご自身も混乱されているようですが、まずこの入出力の項目をはっきりさせないと先へ進めないと思います。
＞違うワークブックの中の、違うシート は、Book2.xlsx、Sheet2の時の例です Sub sample() Dim i With Workbooks("Book2.xlsx").Worksheets("Sheet2") i = Application.Match(Range("A3").Value, .Columns(1), 0) If Not IsError(i) Then .Cells(i, 2).Value = Range("B4").Value End If End With End Sub
まだ手直しが必要ですが、一応できました。 「Sheet1」 H2:=COUNTIF(A$2:A2,A2) I2:=IF(H2=1,1,0)+I1 J2:=IFERROR(INDEX(A:A,MATCH(ROW(A1),I:I,0),1),"") これらをデータのある行まで下方へドラグコピーします。 K2:=MATCH($J2,INDIRECT(ADDRESS(1,1)):INDIRECT(ADDRESS(100000,1)),0) これをJ列のデータ（名前）があるところまでドラグコピーします。 L2:=IFERROR(MATCH($J2,INDIRECT(ADDRESS(1+K2,1)):INDIRECT(ADDRESS(100000,1)),0) +K2,"") これを下方へはK列と同じ要領でドラグコピーします。 そして右方へはデータが表示されなくなるまでドラグコピーします。 「Sheet2」 A3:=IF(MOD(COLUMN()-1,5)<>0,"",INDIRECT("Sheet1!"&ADDRESS(INT((COLUMN()-1)/5+2),10))) 右方へ全員の名前が出終わるまでドラグコピーします。 この次が未完成です。 A4:=IFERROR(INDEX(Sheet1!B:B, INDIRECT("Sheet1!"&ADDRESS( INT((COLUMN()-1)/5+2), ROW(Sheet1!A11) )), 1),"") 下方へはデータが表示されなくなるまでドラグコピーします。 右方へは、とりあえずE列までドラグコピーします。 そしてC,D,E列は表示形式を 00:00 にします。 このA列からE列の「Sheet1!B:B, 」のところを「Sheet1!$B:$B, 」 に変更してから、５列まとめて右へコピペします。 ↓Sheet1の画像
500行に満たないのであれば、最終行までをcsvにしたらいいのでは？
対象とするデータは２行以上有りますか？ 有るのにエラーになるのでしたらＰＣを再起動してみて下さい。 Ｗｉｎ８以後なら「完全シャットダウン」して下さい。
御望みのことがよく解ってませんが、↓のような例は参考にならないでしょうか？ Sub sample() Dim xTime As Date xTime = DateAdd("n", 10, Range("A1").Value) If Time < xTime Then MsgBox "期限時刻10分後より前です" End If End Sub
コードの一部からだけではなんとも言えない そもそもobjIEってのは変数なんだからその宣言型とか見てみないとなんとも言えんね （たぶんDim objIE As InternetExplorerこんな感じなんだろうけど、推測だけでは回答できないし）
以下でどうなりますか （チョコチョコ書き直してます） Public Sub Samp3()    Dim vA As Variant, vR As Variant, v As Variant    Dim sS As String    Dim i As Long, j As Long, k As Long, n As Long    Const CREP As String = "さん 年齢"    Const CSP As String = " "    Const CRH As Long = 5    Application.ScreenUpdating = False    For j = Range("B1").Column To Range("DD1").Column       vA = Cells(65, j).Resize(CRH).Value       ReDim vR(1 To CRH * 2, 1 To 1)       k = 0       For i = 1 To UBound(vA)          sS = StrConv(vA(i, 1), vbNarrow)          While (sS Like "*" & String(2, CSP) & "*")             sS = Replace(sS, String(2, CSP), CSP)          Wend          sS = Replace(sS, CREP, CSP)          v = Split(sS, CSP)          If (UBound(v) > 0) Then             k = k + 1             vR(k, 1) = Array(v(0), Val(v(1)))          End If       Next       If (k > 0) Then          n = 0          v = "Go"          While (Not IsEmpty(v))             n = n + 1             v = Empty             For i = 1 To k - n                If (vR(i, 1)(1) > vR(i + 1, 1)(1)) Then                   v = vR(i, 1)                   vR(i, 1) = vR(i + 1, 1)                   vR(i + 1, 1) = v                End If             Next          Wend          For i = k To 1 Step -1             vR(i * 2, 1) = vR(i, 1)(1)             vR(i * 2 - 1, 1) = vR(i, 1)(0)          Next       End If       Cells(4, j).Resize(CRH * 2).Value = vR    Next    Application.ScreenUpdating = True End Sub
EntireRowを覚えましょう。 Sub Macro1() Dim n As Long n = Cells(Rows.Count, "A").End(xlUp).Row + 1 Range(Range("A" & n), Range("A300")).EntireRow.Select End Sub Sub 一行でやるなら() Range(Cells(Rows.Count, "A").End(xlUp).Offset(1), "A300").EntireRow.Select End Sub
通常、プログラムの実行開始で Application.ScreenUpdating = False 終了時 Application.ScreenUpdating = True とします。 これで、Excelはディスプレイの描画更新を行なわなくなり、画面のチラツキがなくなり、実行速度もアップします。
IEの自動操作には、HTMLソースコードが不可欠なのですが、ログインが必要なページでは、部外者は基本的に手が出せません。従って、こういった考え方になる、という回答になります。 まず、FirefoxやChromeにある、HTMLの「要素を調査」という機能を使えるようにしてください。ブラウザをインストールすれば、右クリックで出てくるはずです。これで、各WEBパーツがどのソースに該当するのかを調べることができます。 次に、上記機能を使い、「CSV取込」タブがどのタグなのかを調べ、そのタグを取得後にクリック、というコードを作ってください。 その後のページ移動時間ですが、これは、こちらではどのように動くのかが分からないので、適当な時間を作ってください。 ページ移動後、参照ボタンを押します。これは恐らく、FILE属性のINPUTタグです。上記と同様にタグのソースを探し、そのタグを取得してクリックするコードを作ってください。ただし、これは後に記述するSendkeysの動作の関係上、JavaScriptに翻訳して実行させる必要があります。後で返信したいと思いますので、とりあえずはVBAで作成してください。 そして次に、クリップボードに文字列を送り、出てきたダイアログに「Ctrl+V」で貼り付け、Enterキーを押します。これにSendkeysを使います。 まずは、クリップボードに文字列を送り込みます。 Dim clip As DataObject clip.SetText "C:\EDIDATA\RCV\シーワ\SW_0525.csv" clip.PutInClipboard そして、Sendkeysを使い、予定したキー操作を行ないます。 'ダイアログが出るまで待つ Application.Wait [Now()+"00:00:02"] 'Ctrl+V Sendkeys "^V" '少し待つ Application.Wait [Now()+"00:00:01"] 'Enter Sendkeys "{ENTER}" '少し待つ Application.Wait [Now()+"00:00:01"] そして、「取込」ボタンを押します。これは、これまでと同様に該当タグを調べて、取得・クリックするコードを作成してください。 その後のログアウトについては、どういった画面になるかが分からないので、ボタンが出ているならば動揺に作成する等、対応してください。
ＣＳＶファイルは , で区切ったテキストファイルで拡張子が CSV と言う定義が有るだけです。 データを ” で囲うかどうかでエクセルが規定の状態で開いた時の結果は異なります。 ＶＢＡの勉強の為に行うなら止めはしませんが、 テキストエディタでＣＳＶファイルを開けば違いは一目瞭然です。
>というコードを付け加えることで解消することが出来ました。 お示しの対策で解消することは考えられません。 シートモジュールのプログラムがなんかの影響を与えているのでしょうね。 >他に良い方法があれば教えていただけないでしょうか。 他のプログラムの存在があり、そのプログラムの処理内容が解らない以上、対応策を提案しにくいです。 そもそも、「Selectすればシートの保護が解ける」という事自体、シートの保護を掛ける意味があるのか疑わしくありませんか？ 保護制御自体見直す方が良いかも。
VBAからなら、普通に Workbooks.Open "https://------------/data/aaa.xls" で開けませんか？ ただ、使用頻度次第ですが、月50個で3年間分なら、ローカルにダウンロードした方がいいかもしれません。 ダウンロードもAPIのURLDownloadToFileを使えば自動的にできると思います。
書かれているコードは改行がおかしくなっています。 エラーにならないように改行を入れてテストしてみました。 最後のほうのSaveAs の「FileFormat:=xlWorkbookNomal」は「FileFormat:=xlWorkbookNormal」のつづり間違いだと思いますのでそこは修正しました。 結果、ファイルは作成されました。 ただし開くことはできませんでした。 これは、マクロ有効のブックなのでSaveAsのFileFormatは「xlWorkbookNormal」ではなく「xlOpenXMLWorkbookMacroEnabled」としなければならないことが原因だと思います。（もしくはFileFormatを省略） いずれにしても、ファイルが作成されましたので、プログラムの問題ではないのかもしれません。 たとえば、該当のフォルダに対して書込みの権限がないとか、ディスクがいっぱいで書き込めないとか。 On Error Resume Next でエラーを無視していますので、それをコメントに（あるいは削除）してエラーが出ないか確認してはどうでしょうか。
Sheet2のC3セルに =SUMIF(Sheet1!C$1:I$1,1,Sheet1!C6:I6) と数式を入れて下にコピーします。 Iから右にもデータがある場合はSheet1には他の表がないという前提で全列計算に入れます。SUMPRODUCT関数のように処理が重くなることはないです。 =SUMIF(Sheet1!$1:$1,1,Sheet1!6:6) 下にコピーします。
>シート１の特定セルに検索値を入力すると シート1のどのセルに検索値を入力するのでしょうか？ 次のようなイメージですか・・。 シート1のA1に「1001」と入力すると、VLOOKUP関数を用いて、シート3のA列の中から「1001」を検索し、見つかればシート3の1001の行のB、C列のデータをシート1、および印刷用のシート2にも反映されるようにしている。 マクロのボタンを押すと、結果となる値が表示されたシート2を印刷し、同時にシート3のA列で「1001」の値のある行のD列に本日の日付を入力する・・。 違っていれば、補足してください。
Dim i As Integer = ListBox1.IndexFromPoint(e.Location) If i = -1 Then Exit Sub Else ListBox1.SetSelected(i , True) End Sub ↓の６－５が求めるものに近いのかも http://homepage1.nifty.com/rucio/main/dotnet/ClassLibrary/L007_Syst...
DoCmd.PrintOut acPrintAll, , , , 梱包数量 でブレークで止めた時、梱包数量 は幾つになっていますか？
残念ながらマクロでは「赤になる」というタイミングは検知することが出来ません。 単純にB３、B６、B17、B２０の数字が赤だったらA３、A6、A17、A２０の数字も赤にする、というマクロでしたら以下のコードになります。 Private Sub Sample() Dim rng As Range For Each rng In Range("B3,B16,B17,B20").Cells If rng.Font.Color = 255 Then rng.Offset(, -1).Font.Color = 255 End If Next End Sub
こんばんは 条件分岐でテキストボックスが空の場合は TextBox1.Enabled = False で使用不可にできます。 Public Class Form1 Private Sub f() Handles MyBase.Shown Button1.Text = "入力したらボタンを押してね。" End Sub Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click If TextBox1.Text = "" Then TextBox1.Enabled = False End If End Sub End Class
例えばA列からL列までの間でそのようなことがあるとして色を付けるのでしたらA列からL列を選択してから「条件付き書式」で「新しいルール」を選択します。 「数式を使用して…」にチェックをしてから、下の窓には次の式を入力します。 =AND(COUNTIF($A1:A1,"○"),COUNTIF(A1:$L1,"★")) 「書式」をクリックし「塗りつぶし」のタブで好みの色を設定してOKすればよいでしょう。 どの行であっても同じ行に○と★があればその間のセルに色が付きます。
>自身のPC表示設定では、拡張子は非表示なので出ないものと これは表示上の設定だけでファイルの名前自体は拡張子付きでファイル名になっています。 ThisWorkbook.Name には拡張子もついていますから、そこからファイル名だけ取り出さなくてはなりません。 質問文は全部が書いていないので、その部分だけです。 ThisWorkbook はマクロ付きブックなので拡張子は「.xlsm」だとして、その部分だけ書きます。 ファイル名は PA & "\" & Left(ThisWorkbook.Name, Len(ThisWorkbook.Name) - 5) & Worksheets(i).Name & ".xls"
VBA初心者です。よろしくお願いします。 図の左 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1216023953... 上記での、Samp1 / Samp2 やってみてダメだったのでしょうか 別シートへの集計でしたよね
コード例です。 Sub Sample() Dim Rng As Range Dim buf As String Dim Num As Long Dim i As Long Dim Score As Long '←点数に小数点以下があれば「As Double」 Label1: buf = Application.InputBox("人数を入力してください。") If buf = "False" Then Exit Sub If Not IsNumeric(buf) Then MsgBox "入力値が不正です。" & vbLf & "数値を入力してください。" GoTo Label1 End If Num = buf Set Rng = ActiveCell For i = 1 To Num Label2: buf = Application.InputBox(i & "人目の点数を入力してください。") If buf = "False" Then GoTo Label3 If Not IsNumeric(buf) Then MsgBox "入力値が不正です。" & vbLf & "数値を入力してください。" GoTo Label2 End If Score = buf If Score * (Score - 150) > 0 Then Score = -5 Rng.Value = Score Label3: Set Rng = Rng.Offset(1) Next End Sub
以下でどうなりますか Public Sub Samp1()    Dim dic As Object    Dim r As Range    Dim vA As Variant    Dim i As Long    Const CF As String = _          "=IF(COUNTIF(RC4:RC5,""*小口*""),1,"""")"    Set dic = CreateObject("Scripting.Dictionary")    Application.ScreenUpdating = False    With ActiveSheet.UsedRange       With .Resize(, .Columns.Count + 1)          vA = .Columns(1).Value          With .Columns(.Columns.Count)             .FormulaR1C1 = CF             .Value = .Value             For Each r In .SpecialCells(xlCellTypeConstants)                dic(vA(r.Row, 1)) = Empty             Next          End With          vA(1, 1) = ""          For i = 2 To UBound(vA)             If (dic.Exists(vA(i, 1))) Then                vA(i, 1) = i             Else                vA(i, 1) = ""             End If          Next          i = .Columns.Count          .Columns(i).Value = vA          .RemoveDuplicates i, xlNo          .Columns(i).ClearContents       End With    End With    Application.ScreenUpdating = True    Set dic = Nothing End Sub
Sub test() Dim x As Long, i As Long Cells(2, 6) = Cells(2, 1) Cells(2, 7) = Cells(2, 2) Cells(2, 8) = Cells(2, 3) x = 2 For i = 3 To Cells(Rows.Count, 3).End(xlUp).Row If Cells(i, 1) = "" Then Cells(x, 8) = Cells(x, 8) + Cells(i, 3) Else x = x + 1 Cells(x, 6) = Cells(i, 1) Cells(x, 7) = Cells(i, 2) Cells(x, 8) = Cells(i, 3) End If Next i End Sub
Thisworkbook上のシートを コンボボックスに追加したうえで、 選択可能にしたフォームを呼び出し、OKボタンをクリックした際に シート分割を呼び出す際に選択したシート名を渡すものを作ってみました（´∀｀） 補足ですが、 なにか特定のシートを名前で指定したい場合 Sheets("対象のシート名") でアクセス可能です。 high.s1.xrea.com/sample10.xls
ActiveWorkbook.SaveAs Filename:=varFile, FileFormat:=xlCSV, _ CreateBackup:=False, Local:=True Rows(Range("J" & Rows.Count).End(xlUp).Row + 1 & ":" & 206).ClearContents ↓ With Cells(Rows.Count, "J") Range(.End(xlUp).Offset(1), .Cells).EntireRow.Clear End With ActiveWorkbook.SaveAs Filename:=varFile, FileFormat:=xlCSV, _ CreateBackup:=False, Local:=True ということですか？
下記で I10～I32 の処理ができると思います。 念の為ファイルのバックアップを作成してから試して下さい。 Sub 印刷() Dim i As Integer For i = 10 To 32 Range("I" & i).Select Selection.Copy Range("B7").Select Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _ :=False, Transpose:=False ActiveWindow.SelectedSheets.PrintOut Copies:=1, Collate:=True, _ IgnorePrintAreas:=False Next i End Sub
いくつも設計すると分かりますが、仕様変更や機能追加が多いのは、入力画面、売り上げ計算などの集計機能、ファイル出力や印刷などの帳票出力です。 これらに対しては最初から、種類が増えても対応しやすいように設計することが多いです。集計する種類や帳票の種類が最初から2種類以上ある場合は特にです。 >どのような基準でFunctionやClassにするのか、手本や基準などはあるのでしょうか？ 難しいかもしれませんが、「デザインパターン」を学ばれると良いと思います。 「オブジェクト指向における再利用のためのデザインパターン (単行本) 」 http://www.amazon.co.jp/gp/offer-listing/4797311126
>B.xlsmのSheet1のA列とB列を、A.xlsmのSheet2のC列とD列にコピーする Sub 一例です() Workbooks("B.xlsm").Worksheets("Sheet1").Range("A:B").Copy _ Workbooks("A.xlsm").Worksheets("Sheet2").Range("C:D") End Sub
検索部分だけの回答です。 削除や書き込みなどもそうですが検索もコマンドボタンを使ったほうがスムーズです。 ユーザーフォームにコマンドボタンを挿入しCaptionを「Search」とか「検索」とかにしておくといいです。 検索ワード用がTextBox1であとは順番にTextBox2~TextBox11という配置です。 コマンドボタンを右クリックしてコードを書きます。 Private Sub CommandButton1_Click() Dim n, i As Long n = Application.Match(TextBox1.Value * 1, Sheets("Sheet1").Columns(1), 0) If IsError(n) Then MsgBox "該当番号は見つかりません": Exit Sub For i = 2 To 11 UserForm1.Controls("textbox" & i).Text = Sheets("Sheet1").Cells(n, i - 1).Value Next End Sub 他に標準モジュールに Sub フォーム起動() UserForm1.Show vbModeless End Sub とユーザーフォームを起動するコードを書いておくとセルの編集もできるようになります。このコードは図形などにマクロの登録してシートに置いておくといいです。 感想としてはそれほど難しいコードではないと思います。削除なども上のコードの変数ｎを使えばRows(n).Deleteで簡単に削除できます。ただ 新規の場合はsheet2に同様の項目で入力 とかの意味はよくわかりません。普通新規は最終行の下に書き足していくのだと思いますが・・・
>以下の条件のものをフィルターによって非表示にしたい ご承知の通り、列の間の条件は、AND結合。 ORは使えないですよね？ なので、フィルターを使うなら、作業列を設け条件式を組み込み、そこをフィルタリングしなきゃだめ、ということになりますね。 ↓はA～H列の表に対し、I列を作業列にした例です。 1行目は項目名の行。 表の最終行はA列で判定。 Sub 一例です() Dim i As Long Const xFormula As String = _ "=OR(AND(B2<>SUBSTITUTE(B2, ""ＡＡＡ"",""""),D2=""1-100""),AND(OR(E2=""○"",F2=""○""),G2<>H2))" i = Cells(Rows.Count, 1).End(xlUp).Row Range(Cells(2, "I"), Cells(i, "I")).Formula = xFormula Columns("I").AutoFilter Field:=1, Criteria1:=False End Sub
ご質問の方法は、ZIPファイルをフォルダとして扱えるという、Windows標準の機能を利用したものです。単純に、フォルダオブジェクトを取得し、その中のファイルをコピーする、という体なので、パスワード引数などありません。 従って、パスワード付きZIPファイルを解凍するのであれば、Sendkeys等を使って、力技でパスワードを送り込まなければなりません。 VBSだと、その辺りの動作は怪しいですし、UWSCあたりを使った方が楽かもしれません。UWSCでも、同様にCOMオブジェクトを使って処理ができますし、はっきりとターゲットを絞ったウインドウ操作も可能です。
どの程度まで勉強したいかと、あなた自身のパソコン全般の知識とプログラミングの知識にもよりますので、大きめの書店へ行って実際に手に取ってみてみることをお勧めします。
前もって言いますが、ストレートな回答じゃありません。 VBAでできない処理じゃあないんですが、あくまでVBAでやるのか？ということなんです。 こういう処理はACCESSでRDB使った方が楽なんですよ。 各PCにクライアント画面を配布して、サーバーとなるPC上のRDBに更新かけさせるのが一般的。 これまでEXCELでやって来たからその延長線上でやりたいのは分かりますが、大きな声を出せば全体に伝わっていた企業規模から脱して大きくなっている企業なんでしょう？ そろそろ作業のシステム化を考えるレベルなのです。 VBAでルールを守らない人のリカバリをするのではなく、そもそもルールを破れないシステム化をするべきなのではないかな？ 質問の件はDIR関数、FOR EACH文、INSTR関数で対応できます。
Sub test() Dim i As Long, j As Long, ij As Long For i = 1 To 10 For j = 1 To 10 If Cells(i, j).Interior.Color = 0 Then ij = ij + 1 End If Next j If ij = 10 Then MsgBox i & "行目はつながっています" ij = 0 Next i ij = 0 For i = 1 To 10 For j = 1 To 10 If Cells(i, j).Interior.Color = 0 And i = j Then ij = ij + 1 End If Next j Next i If ij = 10 Then MsgBox "斜め右下方向でもつながっています。" End If ij = 0 For i = 10 To 1 Step -1 For j = 1 To 10 If Cells(i, j).Interior.Color = 0 And i + j = 11 Then ij = ij + 1 End If Next j Next i If ij = 10 Then MsgBox "斜め右上方向でもつながっています。" End If End Sub
こんにちは。 管理ファイルのシート1に「更新ボタン」を設置して、クリックイベントにコードを記述です。 ターゲットファイルは v指定データファイル名 = "ドライブ名\ファイル名.xlsx" ネットワークドライブは、正しく設定して、ターゲットのファイルに正しくパスが通るようにしてください。 VBAは、 v1 = dir(v指定データファイル名) if len(v1)=0 then なかった処理 else あった処理 set w1 = application.workbooks.open(v指定データファイル名) v特定セル = w1.sheets(特定シート).range(特定セル).value if v特定セル="まるまる" then セル= 色の変化。 else セル= 色の変化。 end if w1.close false とまあ、書いている流れだと、こんか様子になります 文章がふわーーーっとしているから、コードもふわっとしてます。 主様、仕様として明確にするのは、ターゲットブックに対するパスをコンピュータから、正しくネットワークドライブの指定が必要ということ、 正しいファイル名、シート名セルの座標が必要です。 セルの色の変化は、「マクロの自動記録」でできたものを使ってください。 あと、ブックの更新日時を取得して、その変化で、ブックを開く、というようにするのが、よくある考え方です。 仕様、煮詰めてください。
使用目的や使い方さえ間違えなければ、VBだって十分使えると思うのですが。。。 何故そんなに毛嫌いされるのでしょうか？ 理由をお聞かせください。
仕事で使われるのですから、自前で作成できない場合は費用を負担して外注されることをお勧めします。
以下のコードでいかがでしょうか？ Option Explicit Sub チェック() Dim tbl As Range, rng As Range Dim var As Variant, match As Boolean '判定用のテーブルのセル範囲を設定する Set tbl = Worksheets("Sheet1").Columns("E:F") '一旦選択されているセル範囲の文字色を自動に戻す Selection.Font.ColorIndex = xlAutomatic '選択されているセル範囲をチェックする For Each rng In Selection '2列に渡って値が入っているセルをチェック対象とする If rng.value <> "" And rng.Offset(0, 1).value <> "" Then match = False '判定テーブル内に存在するかチェックする On Error Resume Next var = Nothing var = Application.WorksheetFunction.VLookup(rng.value, tbl, 2, 0) On Error GoTo 0 If VarType(var) <> vbError Then '組み合わせが一致しているかチェックする If rng.Offset(0, 1).value = var Then match = True End If End If '組み合わせが一致していなければ文字色を赤にする If Not match Then rng.Resize(, 2).Font.Color = RGB(255, 0, 0) End If End If Next rng End Sub
DISK PLUSにはDISK PLUS用のアカウントを取得してください バンビジュのアカウントとは別です
テストしていませんが、 wd.Sections(1).Headers(wdHeaderFooterPrimary).Shapes.Range("世帯主").TextFrame.TextRange.Text = "指定した言葉" とすればできませんか。
getElementsByNameは、 <div name="sample"> のように、NAME属性値を元にタグを集める命令です。取得しようとしているタグにはNAME属性がありませんので、意味がありません。 どのようなページ構成なのかが分からないので、少し無駄がある方法を提示します。 Set tmp=objIE.document.getElementsByTagName("meta") For Each t In tmp If (t.getAttribute("property")="example") Then msg=t.getAttribute("content") Exit For End If Next 何番目のmetaタグかが分かっていれば、もっと単純にできます。
以下でどうなりますか 標準モジュールに記述して実行してみます ※ ４階層限定にはなってません Public Sub Samp1()    Dim dic As Object    Dim vA As Variant    Dim i As Long, j As Long, k As Long, n As Long    Set dic = CreateObject("Scripting.Dictionary")    With Range("A1").CurrentRegion       With .Offset(1)          vA = .Value          For i = 1 To UBound(vA)             For j = 2 To UBound(vA, 2)                If (vA(i, j) <> "") Then                   n = dic(j)                   If (n > 0) Then                      For k = j + 1 To UBound(vA, 2)                         If (dic.Exists(k)) Then                            dic.Remove k                         End If                      Next                   End If                   dic(j) = n + 1                   vA(i, 1) = Join(dic.Items, "-")                   Exit For                End If             Next          Next          With .Columns(1)             .NumberFormatLocal = "@"             .Value = vA          End With       End With    End With    Set dic = Nothing End Sub
VC++ランタイムの配布ページではvc_redist.x64.exeとvc_redist.x86.exeの2つが配布されていますが、両方ともインストールしましたか？ 通常のPC向けWindowsの64bit版では、64bit(x64アーキテクチャ)プログラムと32bit(x86アーキテクチャ)プログラムの両方を動かすことが出来ます。 そして、動かす対象のプログラムが64/32bitのどちらであるかによって必要なランタイム(再頒布可能パッケージ)も変わってきます。 (単にOSの64/32bitと合わせれば良いわけではありません。) もし片方のランタイムしかインストールしていないのであれば、もう一方もインストールしてみてはどうでしょうか。
昔は基本的にクエリで処理するのを進められて覚えましたが、実際の業務で作ると、単価変更があるため、その時点での単価を記憶していなければならず、最近は(かなり前の話)、ハードディスクの容量やPCに搭載されたメモリも増えてるので、処理速度も上がってるのでクエリでもいいかもしれないけれど、単価や金額はフィールドに埋め込んでいました。 個人的な見解です。 だいたい、バックアップにUSBメモリと言う時代だから
Sub Macro() Dim AllData As Variant Dim i As Long i = 1 Do While Cells(i, 1).Value <> "" AllData = Split(Cells(i, 1).Value, " ") Cells(i, 1).Resize(, UBound(AllData) + 1).Value = AllData i = i + 1 Loop End Sub
BackspaceやDeleteによる削除は入力扱いではないようで「可能ではない」となります。VBA使えば簡単に対応できるのだけれど。 VBAを使用したくないとのことですが、規則で使ってはいけないのでなければ使った方が格段に使い勝手が増しますし手作業とは比べ物にならない処理力も得られるようになりますよ。最初がとっつきにくいのは確かですけどね。
以下のコードでどうでしょうか。 Option Explicit Sub Sample() Dim FSO As Object, bkName As String, sCode As Variant Dim fName As Variant, fPath As String Dim bk1 As Workbook, bk2 As Workbook Dim st1 As Worksheet, st2 As Worksheet Dim r1 As Long, r2 As Long Application.ScreenUpdating = False Set FSO = CreateObject("Scripting.FileSystemObject") Set bk1 = Workbooks.Add Set st1 = bk1.Worksheets(1) r1 = 1 fName = Application.GetOpenFilename(FileFilter:="Excelファイル(*.xls),*.xls") If VarType(fName) = vbBoolean Then Exit Sub If fName Like "*集計*" Then Exit Sub Set bk2 = Workbooks.Open(fName) fPath = bk2.Path bkName = FSO.GetBaseName(bk2.Name) sCode = "" On Error Resume Next sCode = WorksheetFunction.VLookup(bkName, ThisWorkbook.Worksheets("マスタ").Range("A:B"), 2, False) On Error GoTo 0 For Each st2 In bk2.Worksheets For r2 = 2 To st2.Range("A" & st2.Rows.Count).End(xlUp).Row If st2.Range("D" & r2).Value = "A" Then st1.Range("A" & r1).Value = st2.Range("A" & r2).Value st1.Range("B" & r1).Value = st2.Range("B" & r2).Value st1.Range("C" & r1).Value = st2.Range("C" & r2).Value st1.Range("D" & r1).Value = st2.Range("D" & r2).Value st1.Range("E" & r1).Value = sCode st1.Range("F" & r1).Value = " " r1 = r1 + 1 End If Next r2 Next st2 bk2.Close False Application.DisplayAlerts = False bk1.SaveAs fPath & "\" & bkName & ".csv", xlCSV bk1.Close False Application.DisplayAlerts = True Application.ScreenUpdating = True End Sub
for ～ do ( の閉じ括弧側を ) | CLIP にすれば流し込めるやも。
作業列を使って対応します。 シート1はお示しの通りの表でA1セルからF1セルまでには項目名があるとします。 J2セルには次の式を入力して下方にドラッグコピーします。 =IF(A2="","",IF(COUNTIF(A$2:A2,A2)=1,ROUNDDOWN(MAX(J$1:J1),-3)+1000,ROUNDDOWN(INDEX(J$1:J1,MATCH(A2,A$1:A1,0)),-3)+COUNTIF(A$1:A1,A2))) その後にシート2に移って2行目に名前を表示するとしてA2セルには次の式を入力して右横方向にドラッグコピーします。 =IFERROR(IF(MOD(COLUMN(A1),5)=1,INDEX(Sheet1!$A:$A,MATCH(ROUNDUP(COLUMN(A1)/5,0)*1000,Sheet1!$J:$J,0)),""),"") A3セルには次の式を入力して右横方向にドラッグコピーしたのちに下方にもドラッグコピーします。 =IFERROR(INDEX(Sheet1!$B:$F,MATCH(ROUNDUP(COLUMN(A1)/5,0)*1000+ROW(A1)-1,Sheet1!$J:$J,0),MOD(COLUMN(A1)-1,5)+1),"") なお、時間が表示される列には時刻のシリアル値が表示されますのでそれらの列を選択してからセルの表示形式で「時刻」から好みの表示に変えます。 なお、シート1の作業列が目障りでしたらその列を選んで右クリックし「非表示」を選択すればよいでしょう。
Range("A1:K" & 最終行).Sort Columns("A"), xlAscending, Header:=xlYes Range("A1:K" & 最終行).Sort Columns("C"), xlAscending, Header:=xlYes ↓ Range("A1:K" & 最終行).Sort Key1:=Range("A1"), Order1:=xlAscending, Key2:=Range("C1"), Order2:=xlAscending, Header:=xlYes
１つめのFor~Next文が無茶苦茶。２つめも疑問だらけ。 Range("E23:AH36").Valueの戻り値は、配列になります。 素直に、ワークシート関数のSUM関数を起動しましょう。 Sub Test1() Dim TmpSheet As Worksheet, i As Integer Dim ws As Worksheet Dim xCur As Range Set xCur = Selection Set TmpSheet = Worksheets.Add(After:=Sheets(Sheets.Count)) With TmpSheet For i = 1 To Sheets.Count - 1 '●↓ここの箇所↓ もともとセル1つ指定だったのを範囲指定に変更しました● .Cells(i, 3).Value = Application.Sum(Worksheets(i).Range("E23:AH36")) Next For Each ws In Worksheets Cells(ws.Index, 1) = ws.Name Next
ユーザーフォームのコマンドボタンは、シートに配置するボタンでたとえると、フォームコントロールのボタンではなく、ActiveXのボタンのようなものです。 ボタンにマクロを登録するのではなく、フォームのモジュールにイベントのマクロを記述します。 たとえば、コマンドボタンAをクリックした時のマクロは、ユーザーフォームのモジュールに Private Sub コマンドボタンA_Click() End Sub で記述します。 質問の例では、以下のように記述します。 Private Sub コマンドボタンA_Click() ThisWorkbook.Worksheets("Sheet1").Range("A1").Value = "ボタンA＝1" Call Macro100 End Sub Private Sub コマンドボタンB_Click() ThisWorkbook.Worksheets("Sheet1").Range("A1").Value = "ボタンB＝2" Call Macro100 End Sub
以下でどうなりますか 標準モジュールに以下を記述し、Samp1 を実行してみます ※ Interior.ColorIndex で色指定してますが、 Interior.Color にするとか適宜変更してみてください Public Sub Samp1()    Dim rng As Range, r As Range    Dim sAdr As String    Set rng = Worksheets("マスター").Range("A1")    With Worksheets("データ").UsedRange       .Interior.ColorIndex = xlNone       While (rng.Value <> "")          Set r = .Find(rng.Value, LookAt:=xlPart)          If (Not r Is Nothing) Then             sAdr = r.Address             Do                r.Interior.ColorIndex = _                   rng.Interior.ColorIndex                Set r = .FindNext(r)             Loop While r.Address <> sAdr          End If          Set rng = rng.Offset(1)       Wend    End With End Sub
質問者さんのやり方を継承するなら、 If TypeOf tgo Is DBNull Then ですね。 しかしメソッドの引数は、Null許容型変数の方が望ましいと思います。 Private Function CalcWorkdate(tin As DateTime?, tout As DateTime?, tgo As DateTime?, tback As DateTime?) As TimeSpan この場合だと判別は、 If tgo.HasValue Then '値が渡された場合の処理 Else 'Nullの場合の処理 End If ですね。
こんにちは。 >エクセル2007からデフォルトとなった列幅の自動調整をキャンセルさせる すみません、これ、はつみみです。 主様、どんな状態で、自動調整になったのでしょうか、そこをまず、明確に。 VBAの話は、その次です
Private Sub Worksheet_Change(ByVal Target As Range) Dim xRngs As Range, xRng As Range Const xAdr As String = "C:C,E:E,G:G,I:I,K:K" On Error Resume Next Set xRngs = Intersect(Range(xAdr), Target) If xRngs Is Nothing Then Exit Sub On Error GoTo 0 For Each xRng In xRngs Application.EnableEvents = False xRng.Offset(, -1).Value = Date Application.EnableEvents = True Next xRng End Sub
こんな感じでいかがですか。・・・・・・・・・・・・・ Sub 重複() Dim temp, i As Long temp = 2 Range("A1").CurrentRegion.RemoveDuplicates _ Columns:=1, Header:=xlYes Do While Range("A" & temp) <> "" temp = temp + 1 Loop For i = 2 To temp Range("A" & i) = Range("A" & i) & Range("B" & i) _ & Range("C" & i) & Range("D" & i) & Range("E" & i) Next Range("B2:E" & temp) = "" End Sub
PCでは画像が細かすぎてレイアウトの詳細が判りません。 タイトルは何行目から何行目、表題項目は何列目から何列目が結合されていて○○、などレイアウトの具体的な内容とを示してください。
Currencyは通貨型ですよね。小数点の場合はDoubleで定義です。 Sub Sample() Dim a As Double, b As Double a = Round(Cells(2, 2), 2) b = Round(Val(ActiveSheet.TextBox1.Text), 2) If a >= b Then MsgBox "正常" Else MsgBox "異常" End If End Sub
次のようなコードを実行すると、正しい結果が返ります。 「cells(2,2)」「textbox1」の値を調べるのが先決でしょう。 Dim a As Currency Dim b As Currency a = "10.6" b = "10.2" If a >= b Then MsgBox "正常" Else MsgBox "異常" End If
どのようなエラーリカバリをしたいのでしょう？ 今の記述では、 ・エラーがあったら Err1 に･･･ ・Err1 では、何も処理せずに、エラーが発生したところから再実行･･･ Resume だけではなく、 ･･･処理した後に、Resume Next だったり･･･ やりたいことをまとめた上、処理を進められたらと思います なお、Err1 では、 想定されるエラーに対処する処理を記述されたらと････ ファイルのありなしだけではないと思いますけど･･･ ※ 処理例等、回答する際には、 ほとんど、エラー処理を省いたものになっているかと思います
>何か出力先を決めれるような機能はあるでしょうか？ 普通のOpenメソッドと同じような機能なので、そのような機能は、無いでしょう。 一旦開き、セルをお好きなところへコピー＆ペーストすれば、よいのでは？ どうしても、直接既存シートに取り込みたい のなら、 QueryTables を使うのでしょうね。 EX2010で言えば、 データ＞外部データの取り込み＞テキストファイル のマクロ記録が元ネタになりますね。
＞式内の「=+IFERROR((VLOOKUP(A3,Sheet1!$N$」 ＞ここまでは理解しましたが ちょっと待って、それはおかしいです。 =+IFERROR((VLOOKUP(A3,Sheet1!$N$2:$R$3000,5,0)),"") ↑こう数式があったら、まず一番内側の関数を読みましょう。 VLOOKUP(A3,Sheet1!$N$2:$R$3000,5,0) これで最後の5,0の意味が解らないのならVLOOUP関数が理解できていないのです。 ただし最後の0は慣れている人の書き方で本来関数のヘルプなどを見ればFALSEと書くべきところです。が、Excelの場合FALSEは0、TRUEは1となりますのでFALSEを0と書いても同様に機能するのです。 次に IFERROR(VLOOKUP関数,"") これはVLOOKUP関数の結果がエラーだったら空文字を表示させていますね。 VLOOKUPで検索値が見つからないと#N/Aとエラー値が表示されて見た目がよろしくないので空文字にしたいのですね。 さて、先頭の+の意味は良くわかりません。数値として計算したいわけでもなさそうですし、無くても同じじゃないでしょうか？ カッコも無駄に1組多いと思います。 =+IFERROR((VLOOKUP(A3,Sheet1!$N$2:$R$3000,5,0)),"") ↓ =IFERROR(VLOOKUP(A3,Sheet1!$N$2:$R$3000,5,0),"")
確認します。 下記の様な 表は存在するのでしょうか 時間＿＿＿＿＿＿料金 7：00～8：00＿＿_100 8：01～9：00＿＿＿200 ～ 13：01～14：01 ＿_300 14：01～15：00＿_400 始まる時間＿＿終わる時間＿＿総計 7:32＿＿＿＿＿＿13:50＿＿＿1000 6:00＿＿＿＿＿＿_8:00_____ 14:01_________19:00_____ もし このような表に基づき 関数があるなら シートを増やさずに 時間帯区分の 行数をふやせば シートを増やす必要はないのですが シートを増やさずにでは なく 行を増やさず と いうことですか？ 今組んでいる関数とは 具体的に どんな 関数に されているのでしょうか その 関数をが どう組まれているかによって 例えばＡ列に区分のための記号（７：００始まりのときは空欄、６：００始まりのときは○など）を入れて、関数を切り替える 事が 可能かどうか 変わってきますが？ また 関数によっては 7:00～ を 6:00に ～15:00を 19:00に 変えれば すむのでは？
タイムテーブルはA2から下方向に日付、B1から右方向に「○コマ目」と入力されているとします。 ActiveXコントロールのコンボボックスをシート内に設置し、以下コードをシートモジュールに記述してください。 Private Sub ComboBox1_Change() Dim TableRng As Range Dim Rng As Range Dim Results() As String Dim ResultRng As Range If ComboBox1.Text = "" Then Exit Sub ReDim Results(1, 0) Set TableRng = Range("A1").CurrentRegion With TableRng Set TableRng = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1) End With For Each Rng In TableRng If Rng.Value = ComboBox1.Text Then If Results(0, 0) <> "" Then ReDim Preserve Results(1, UBound(Results, 2) + 1) Results(0, UBound(Results, 2)) = Format(Cells(Rng.Row, "A").Value, "m/d") Results(1, UBound(Results, 2)) = Cells(1, Rng.Column).Value End If Next Set ResultRng = TableRng.Offset(TableRng.Rows.Count + 1, -1).Cells(1) ResultRng.Resize(Rows.Count - ResultRng.Row + 1, 2).Clear ResultRng.Resize(UBound(Results, 2) + 1, 2).Value = WorksheetFunction.Transpose(Results) End Sub Private Sub ComboBox1_DropButtonClick() Dim TableRng As Range Dim Rng As Range Dim Members() As String Dim i As Long On Error Resume Next Do While Err.Number = 0 ComboBox1.RemoveItem 0 Loop On Error GoTo 0 ReDim Members(0) Set TableRng = Range("A1").CurrentRegion With TableRng Set TableRng = .Offset(1, 1).Resize(.Rows.Count - 1, .Columns.Count - 1) End With For Each Rng In TableRng If Rng.Value <> "" Then For i = 0 To UBound(Members) If Members(i) = Rng.Value Then GoTo Label Next ReDim Preserve Members(UBound(Members) + 1) Members(UBound(Members)) = Rng.Value ComboBox1.AddItem Rng.Value End If Label: Next End Sub
こんにちは。 outerTextをinnerTextは、試してください。 通貨記号は、vbaからみても、特別な文字なので、できるだけ触らないように 転記して、それから、考えてください。
こんな感じでどうでしょうか Range("B1").Resize(Range("A" & Rows.Count).End(xlUp).Row).FormulaR1C1 = "=IF(RC[-1]="""","""",LEFT(RC[-1],FIND(""_"",RC[-1])-1))" Range("C1").Resize(Range("A" & Rows.Count).End(xlUp).Row).FormulaR1C1 = "=IF(RC[-2]="""","""",MID(RC[-2],FIND(""_"",RC[-2])+1,LEN(RC[-2])))"
Sub リスト化() Dim ws As Worksheet Dim RowCnt As Integer Dim ColCnt As Integer Dim y As Integer Dim x As Integer Dim z As Integer Dim i As Long z = 4 Sheets("作業").Cells.ClearContents For i = 1 To Worksheets.Count - 3 Set ws = Worksheets(i) RowCnt = ws.Cells.SpecialCells(xlLastCell).Row ColCnt = ws.Cells.SpecialCells(xlLastCell).Column y = 1 x = 1 For y = 1 To RowCnt For x = 1 To ColCnt If ws.Cells(y, x) <> "" Then z = z + 1 Sheets("作業").Cells(z, 2) = ws.Cells(y, x) End If Next x Next y Next i End Sub こんな感じでは？
提示されたActiveSheet.UnprotectSheetのコードですが、保護を解除したいシートがActiveになっているとは限りません。 おそらくSheet(”△△△”)のシートの保護を解除したいということだと思われますので、ActiveSheetの部分を以下のように明示的にシート名を指定してみてください。 Sheet(”△△△”).Unprotect
具体的な事がわかりませんので、例ですが。 Ａ1セルに値（例えば10）を入れるなら Range("A1").Value = 10 Ａ1セルの内容をＢ1セルにi入れるなら Range("B1").Value = Range("A1").Value Ａ1セルの内容とＢ1セルの内容を入れ替えるなら 変数を定義して（例 tmp という変数） tmp = Range("A1").Value Range("A1").Value = Range("B1").Value Range("B1").Value = tmp >プルダウンの選択を自動で 自動選択ということでなく、セルに値を入れるだけですので、その値が決まっていれば Range("A1").Value = xxx の構文で出来ます。
Range("A1").Value =ThisWorkbook.Name とします。 ActiveWorkBookは「現時点でアクティブになっているブック」を指すので複数のExcelを開いている場合に自分自身ではない可能性があります。 ThisWorkbookはその名の通り「このブック」なのでどんな場合でも自分自身を指します。 ActiveSheetは「現時点でアクティブになっているワークシート」を指します。 ActiveSheet.Pasteは「現時点でアクティブになっているワークシートにセル範囲をペーストする」というメソッドですのでこの使い方は誤りです。
コードの一例です。 Private BeforeText As String Private Sub TextBox1_BeforeUpdate(ByVal Cancel As MSForms.ReturnBoolean) If TextBox1.Text = BeforeText Then MsgBox "同じ番号です" Cancel = True Exit Sub End If BeforeText = TextBox1.Text End Sub オペレーションミスの例として、２つ手前の商品のコードを読み込んでしまう可能性はありませんか？そういうミスがあり得るのならCOUNTIFを使う方がより確実だと思います。
Private Sub Worksheet_SelectionChange(ByVal Target As Range) With Target If .Count > 1 Then Exit Sub If .Column = 4 And .Value <> "" Then If .Row > 7 And .Row < 109 Then Select Case MsgBox("入力されてます、編集しますか?", vbExclamation Or vbYesNo) Case vbYes Application.SendKeys "{F2}", True End Select End If End If End With End Sub >どうしてでしょうか？ 複数セルを選択するとそのエラーが表示されます。 ↑のプログラムはとりあえず、１つのセルだけ選択されたとき起動するようにしました。
こんにちは。 このaタグには、idやnameはないので、 for eachで、リンクsをループして、aタグのテキスト文字が15/07/28 になっていたら、clickをさせるように、コードを組んでください。 if left(obj.innertext,8)= "15/07/28" then obj.click というようになります
更新後処理（AfterUpdate）ではなく、フォーカス喪失時（Exit）でチェックし、エラーならばフォーカス喪失をキャンセルします。 （サンプル） Private Sub imp_端末_Exit(Cancel As Integer) Dim IMsg As String Dim IRet As Integer '長さチェック If Len(Me.imp_端末) > 10 Then IMsg = "10文字以内で入力してください。" IRet = MsgBox(IMsg, vbCritical, "Error") Me.imp_端末 = Null Cancel = True Exit Sub End If End Sub
こんにちは。 原因は、もっと別のコードです。 dir関数は、ひとつの文字列を取得するコードです。 フォルダ名を設定して、dirしたら、そのフォルダ名が表示するだけです。 点になっているのは、正しい文字コードの処理が出来ていない、ということです。 セルに設定するときに、'記号と組み合わせてもてください。 か、セルの書式を文字列に変更してから、設定ということです。 エクセルの仕様の範囲では、ファイルの取り扱いは、dirよりは、 filesystemobjectで処理するようにしてみてください。 windows の wshやvbscriptの説明ページに、あります。
相対パスではありませんが、どこでも動作するということは、基準を決めるということだと思います。ならば、マクロブックのパスを基準にするのはどうでしょうか。 strDir = ThisWorkbook.Path & "\"
余計なところにカギかっこ [ が入ってますよ。 RC[-11] の前 ActiveCell.FormulaR1C1 = _ "=IF(RC[-12]="""",IF([RC[-11]="""","""",MID(RC[-11],5,3)),RC[-12])" ↓ ActiveCell.FormulaR1C1 = _ "=IF(RC[-12]="""",IF(RC[-11]="""","""",MID(RC[-11],5,3)),RC[-12])"
こんにちは。 そういえば、このコード、なにがしたいんでしょうか。 記号を検索して、ユニオンして、usedrageともしているし、 結局、targetの記号をみて、判定してますよね。 「選択したセル」の状態をみての動作だったら、最初の検索って、なんのためにしているのでしょうか アクティブシートのイベントでの処理なので、できるだけ最小の処置にすること、 このイベントで、targetになにもなかったら、すぐに終了させたらいいです
おはようございます。 私が思っていたのは、ひとつのファイルを開く前に、それぞれのファイルのパスワードを入力するのはどうかということです。 pw = InputBox(myFn&"123") pw = InputBox(myFn&"321") pw = InputBox(myFn&"213") といくつもInputBoxを並べるのではなく、 pw = InputBox(myFn&"のパスワードを入力してください") とひとつだけ入れておけば、これから開くファイルのパスワードを入力を聞くことができます。 Sub TEST01() Dim myFn As String Dim pw As String Dim wb As Workbook '以上変数宣言 Application.ScreenUpdating = False '画面更新一時停止 myFn = Dir(ThisWorkbook.Path & "\*.xls?") 'エクセルBOOK検索 Do While myFn <> "" '対象が存在する限り続行 If myFn <> ThisWorkbook.Name Then 'ファイル名が自分の名と違っていれば pw = InputBox(myFn&"のパスワードを入力してください") Set wb = Workbooks.Open(ThisWorkbook.Path & "\" & myFn, Password:=pw) '開く With wb Application.DisplayAlerts = False '警告一時停止 .SaveAs Filename:=wb.FullName, Password:="" 'パスワードなしで上書保存 .Close False '閉じる Application.DisplayAlerts = True '警告停止解除 End With End If myFn = Dir() '次検索 Loop '繰り返し Application.ScreenUpdating = True '画面更新停止解除 MsgBox "終了しました。" End Sub
貴方が書いたコードを示してみてください。 morgのページに書いてあるコードを参考にした、とのことですが、該当ページのコードを理解した上で参考にしているのであれば、外部プログラムの開始を待機してしまう、ということはないはずです。
こんにちは。 表示しているページのソースを確認して、「どこからコピーするのか」のnameやidなど、識別できるものを探します。 見つけたら、それをコピーするコードを追加です。 示しているコードで、inputタグを見つけて、送信を2かいしているので、 どこで、どの部分を読みたいか、分かりにくいですですね。 2度目の送信の次でしたら、end subの手前に、「待つ」というコードと、転記のコードを 追加してください
2015の方でOpenCVは使えるようにしてあるのですね? それと、ヘッダ関係は2.0だったかで随分編成が変わったはずです。使うバージョンで、使う関数がどのヘッダに入っているか確認して適宜修正の必要があると思います。
異常が発生した時にＰＣの再起動は試されましたか？ （Ｗｉｎ８や１０なら”完全シャットダウン”からの起動です。）
オプションとか違うので、結果が違うのは当然だと思います。 (全く同じにしているなら話は別ですが...)
コード例です。 シート名やキー文字列が入った列は適宜書き換えてください。 （シート1もシート2もA列として書いています。） Sub Sample() Dim Row1 As Long Dim Row2 As Long Dim Sht1 As Worksheet Dim Sht2 As Worksheet Dim Sht3 As Worksheet Dim KeyStr As String Dim CopyRng As Range Set Sht1 = Worksheets("シート1") Set Sht2 = Worksheets("シート2") Set Sht3 = Worksheets("シート3") For Row1 = 1 To Sht1.Cells(Rows.Count, "A").End(xlUp).Row KeyStr = Sht1.Cells(Row1, "A").Value For Row2 = 1 To Sht2.Cells(Rows.Count, "A").End(xlUp).Row If Sht2.Cells(Row2, "A").Value = KeyStr Then If CopyRng Is Nothing Then Set CopyRng = Sht2.Rows(Row2) Else Set CopyRng = Union(CopyRng, Sht2.Rows(Row2)) End If End If Next Next If Not CopyRng Is Nothing Then CopyRng.Copy Destination:=Sht3.Cells(Rows.Count, "A").End(xlUp).Offset(1).EntireRow End If Application.CutCopyMode = False End Sub
移動ですよね？ With Range("C1").End(xlDown) .Offset(, -1).Value = .Value .ClearContents End With
下記のコードでいかがでしょうか。 Option Explicit Sub Sample() Dim r As Long, c As Long, v As Variant For r = 1 To Range("A" & Rows.Count).End(xlUp).Row For c = 1 To 4 v = "" On Error Resume Next v = WorksheetFunction.Match(Cells(r, c).Value, Range("F" & r & ":H" & r), 0) On Error GoTo 0 If v <> "" Then Cells(r, c).Font.Color = 255 End If Next c Next End Sub
VBAではWSH.Popupは不安定で使わない方がいいそうです。 ネットで下記のコードを見つけました。 ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ MessageBoxTimeoutっていうHiddenAPI（非公開ＡＰＩ) を使って見るとか。 （Sample） Private Declare Function MessageBoxTimeoutA Lib "User32" _ (ByVal Hwnd As Long, _ ByVal lpText As String, _ ByVal lpCaption As String, _ ByVal uType As VbMsgBoxStyle, _ ByVal wLanguageID As Long, _ ByVal dwMilliseconds As Long) As Long Private Const MB_TIMEOUT = &H7D00 Sub TimerMsgbox() Dim Sec As Long Dim Result As Long Dim sMsg As String Sec = 4 * 1000 '4秒 sMsg = "4秒後に消えます。" Result = MessageBoxTimeoutA(Application.Hwnd, sMsg, _ Application.Name, vbOKCancel + vbMsgBoxSetForeground, 0&, Sec) Select Case Result Case vbOK sMsg = "OKボタンが押された。" Case vbCancel sMsg = "キャンセルボタンが押された。" Case MB_TIMEOUT sMsg = "4秒経ちました。" End Select MsgBox sMsg End Sub ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
ジェネリックメソッドです。 型自体をパラメータとして与えて汎用的な使い方が出来ます。
個体識別番号はどんな値ですか。 例を複数3～5個位教えてください。 またテーブルを受信するようですが、B列からずらっと受信するのですか？ シートを変えて受信するのですか？
ご質問のコードでは、ただ単にページ上に存在するリンクを全てさらっているだけになります。Google検索結果には、結果以外にもリンクはありますので、そこをクリックしたのでしょう。 WEBページにはそれぞれ、製作者が定めたルールがあります。それを知ることができなければ、目的の情報を自動収集することはできません。そのためには、HTMLソースコードの解析が必要です。 Google検索結果のページは、ID属性値「rso」を持つDIVタグにぶら下がる形でまとまっています。ただし、中身が少し複雑で、CLASS値に「srg」を持つDIVタグに結果リストがまとまっていて、「data-hveid」という属性値を持つDIVタグにニューストピックがまとまっているようです。それぞれのまとまっている中身の構造の細かい部分は置くとして、H3タグに、結果のリンクが含まれています。 以上をまとめると、 ・ID「rso」のタグを取り出す ・上記の中からCLASS「srg」のDIVタグを取り出す ・上記からH3タグ群を取り出す ・取り出したタグにClickメソッドを実行 ・CLASS「data-hveid」にも、必要ならば同様の処理を行なう という手順になります。質問日時等は、結果情報としてまとまっているタグ群の中から、必要なものをテキストで取り出し、更に文字列操作で抽出するということになります。 いきなりコードを示しても混乱するだけで応用することはできないでしょうし、何より私自身、どのように応用するのかが見えていません。 まずは、検索結果が上記のような構造になっていることを、ブラウザでソースコード解析することで確認してみてください。FirefoxやChromeの右クリックメニュー内「要素を調査」が便利です。 構造が分かれば、どう命令を起こすかはさておき、どのような流れを組むべきかは見えてくると思います。
①テンプレートファイル（.xlsx）をコピー、とありますが、どこにコピーするのでしょうか？ ②テンプレートファイルからコピーするのは特定のシートだけでしょうか？それともすべてのシートをコピーするのでしょうか？ ③コピーしたテンプレートファイルのシート("ファイル1")に、とありますが、画像ではシート名は「1」ですが、どちらが正しいのでしょうか？ ④ファイル1～3のあるパスに③でできたファイルを名前を付けて保存、とありますが、ファイル1はテンプレートファイルのシート("ファイル1")だけを保存する、ということでしょうか？ファイル2、ファイル3も同様でしょうか？ ⑤ファイル1～3のコピー範囲は完全に固定でしょうか？例えば下の表は常に見出し行1行+データ行5行の6行で固定なのでしょうか？それとも17行目以降にもデータが続く可能性があるのでしょうか？
private ではクラス外からはアクセスできません。 public class Foo { private void bar() { ... } } この場合、クラス外から bar関数にはアクセスできません。
ラムダ式と呼ばれる表記法で、そこに関数を作り出します。 分解して直せば .... private void func() { Tread.Sleep(5000); } .... await Task.Run(func); というような感じです。（delegeteつけないといけなかったかな？） 以前はDelegeteと呼ばれていた表記方法をさらに簡単に記述できるようにした書き方だと思えばよいです。 今回の例のように外界と特別な接点を持たない処理だとあまりありがたみはありませんが、LINQと組み合わせた時に、大きな力を発揮しますよ。
それは無理です。 ご質問のようなコードは、セルの値の変化といった「イベント」と呼ばれる変化をキーとしているのですが、入力中の変化を検出する方法はありません。 キー入力イベントがあれば良いのですが、ユーザーフォームにはあっても、セル入力そのものにはありません。
どの様な症状にお悩みなのか、よく解ってません。 違和感を感じるのが、 項目を編集する前に、フォームを起動している点。 UserForm2.show のタイミングが早過ぎ、なのでは？ 「・・・・・以下同じように続きます・・・・」 と画面項目を編集したあと、.Showするのが普通のやりかた、のように思います。
回答し直してます 2016/06/04 15:06:46 シート１・２の発送日（C2列・A2列にある発送日）のある物だけを集計するにはどの様にコードを書くのでしょうか。手間を掛ける事になり、重ね重ねご迷惑をおかけしまして大変申し訳ありません。何卒、よろしくご教授の程、お願いいたします。 Sheet3 からは、D28 ～ の商品コードを入手し、K 列に【発送日のある物】の集計結果書き出し Sheet1 からは、【C2～発送日(ある物のみ）】、F2 ～ の商品コード、AJ の個数を入手を Sheet2 からは、【A2～発送日（全部記載ある）】、B2 ～ の商品コード、R の個数を入手 ～～～～～～～～～～ 条件に抜けがあったということですね Sheet1 / Sheet2 で、データ行範囲を求める際、 発送日の列を使った方が良いのか･･･商品コードの列･･･ 確実に行範囲を決定できる 商品コード の列を使ってみます ただ、商品コード ２行以上ない状態で実行すると、 エラー処理入れていないので････ポン･･･（これは前からですが） 変数 vC の Array 定義部分と、★ 部分を変更しています これも未実行なので、おかしかったらごめんなさい Public Sub Samp3()    Dim dic As Object    Dim vSh3Data As Variant    Dim vA As Variant, vB As Variant, vD As Variant ' ★    Dim vC As Variant, v As Variant    Dim i As Long, j As Long    vC = Array( _          Array("Sheet1", "F", "AJ", "C"), _          Array("Sheet2", "B", "R", "A") _       )    Set dic = CreateObject("Scripting.Dictionary")    With Worksheets("Sheet3")       With .Range("D28", .Cells(Rows.Count, "D").End(xlUp))          vSh3Data = .Value          For i = 1 To UBound(vSh3Data)             dic(vSh3Data(i, 1)) = i             vSh3Data(i, 1) = Empty          Next          For Each v In vC             With Worksheets(v(0))                With Range(.Cells(2, v(1)), .Cells(Rows.Count, v(1)).End(xlUp))                   vA = .Value                   i = Cells(1, v(2)).Column - .Column                   vB = .Offset(, i).Value                   i = Cells(1, v(3)).Column - .Column ' ★                   vD = .Offset(, i).Value ' ★                End With             End With             For i = 1 To UBound(vA)                If (IsDate(vD(i, 1))) Then ' ★                   j = dic(vA(i, 1))                   If (j <> 0) Then                      vSh3Data(j, 1) = vSh3Data(j, 1) + vB(i, 1)                   End If                End If ' ★             Next          Next          i = Cells(1, "K").Column - .Column          .Offset(, i).Value = vSh3Data       End With    End With    Set dic = Nothing End Sub 以下、初期回答 2016/6/3 11:57:40 私が回答したものがベースに、 グチャグチャになっているように見受けられます まず、過去に回答した、 ・誰の ・どんな質問に ・どう回答した これらを Access にて自己管理しています vSh3Data をキーワードに検索してみると２件ヒットします シート１シート２のデータをシート３で集計したいネットで調べてたコードで作成し… http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1014739448... 前回シート１シート２のデータをシート３で集計したい質問したsyokora15329です。 http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1414743763... 現在見えなくなった ちょい足し へ記述した内容をみても、 同じ記述は見当たりません >> グチャグチャに と表現したのは、 > For Each v In vA 記述の下りの処理で v(1) は使われていない > With Worksheets(v(0)) > With .Range(.Cells(2, v(3)), .Cells(Rows.Count, v(2)).End(xlUp)) > vShDay = .Value > i = Cells(1, v(3)).Column - Cells(1, v(2)).Column > vShData = .Offset(, i).Resize(, CELM).Value これを初めのループに限ってみると With Worksheets("Sheet1") With .Range(.Cells(2, "AJ"), .Cells(Rows.Count, "F").End(xlUp)) vShDay = .Value i = Cells(1, "AJ").Column - Cells(1, "F").Column vShData = .Offset(, i).Resize(, CELM).Value どこにも C 列の内容を読み込んでいるところはない･･･ また、vShDay には、F2 ～ Ajxxx の広範囲の内容を読み込んでいます これで動いているといわれる内容 > このマクロは現在使用中 > シート１．２のC列・A列は発送日（C列の発送日はまばらになってて、シート２のA列は全て記入されています。） この処理は見つからない > シート１のAJ列に個数、シート２はR列が個数、集計はシート１のF列・シート２のB列が商品コードで、集計シート３のD列の商品コードを基準にして、発送済のシート１・２の合計個数をシート３で集計 これは、曲がりなりにもできていて、 > .Resize(, CELM + 1).Value = vSh3Data これにより、D,E 列に上書きしている > 右に移動しK列に集計したい 先に提示した URL での処理は、 １４列分を一気に集計して････ Const CELM As Long = 14 で･･･ というものにしてました > 社員の誰か不明 については id で心当たりの人を探すとか･･･ とはいっても、 今回は、１列分の集計で良いというお話？ Sheet3 からは、D28 ～ の商品コードを入手し、K 列に集計結果書き出し Sheet1 からは、F2 ～ の商品コード、AJ の個数を入手 Sheet2 からは、B2 ～ の商品コード、R の個数を入手 という条件で良いですか？ 以下は未実行なので、おかしかったらごめんなさい Public Sub Samp2()    Dim dic As Object    Dim vSh3Data As Variant    Dim vA As Variant, vB As Variant    Dim vC As Variant, v As Variant    Dim i As Long, j As Long    vC = Array( _          Array("Sheet1", "F", "AJ"), _          Array("Sheet2", "B", "R") _       )    Set dic = CreateObject("Scripting.Dictionary")    With Worksheets("Sheet3")       With .Range("D28", .Cells(Rows.Count, "D").End(xlUp))          vSh3Data = .Value          For i = 1 To UBound(vSh3Data)             dic(vSh3Data(i, 1)) = i             vSh3Data(i, 1) = Empty          Next          For Each v In vC             With Worksheets(v(0))                With Range(.Cells(2, v(1)), .Cells(Rows.Count, v(1)).End(xlUp))                   vA = .Value                   i = Cells(1, v(2)).Column - .Column                   vB = .Offset(, i).Value                End With             End With             For i = 1 To UBound(vA)                j = dic(vA(i, 1))                If (j <> 0) Then                   vSh3Data(j, 1) = vSh3Data(j, 1) + vB(i, 1)                End If             Next          Next          i = Cells(1, "K").Column - .Column          .Offset(, i).Value = vSh3Data       End With    End With    Set dic = Nothing End Sub
なんか、統一されていない書き方ですね > "FROM [" & conSourceName & "] " & _ ここで、テーブル/クエリ名を動的に設定しようとしている･･･？ けど、 > SELECT [10出力前完成_Q].[Pin]･･･ ここで、固定している やるなら、 "FROM [" & conSourceName & "] AS Q1 " & _ とか AS して、SELECT Q1.[Pin]･･･ するとか strSQL = "SELECT [{%1}].[Pin]･･･ FROM [{%1}] ･･･ とかしておいて、 strSQL = Replace(strSQL, "{%1}", conSourceName) で一気に書き換えるとか 本題で、 上記で出来上がった strSQL を一時的なクエリとして扱います Set db = CurrentDb Set qd = db.CreateQueryDef("", strSQL) qd.Parameters("★★") = ★★への値 Set rsHeader = qd.OpenRecordset qd.Parameters("★★") で、 "10出力前完成_Q" へのパラメータを指定します ※ ヘルプで CreateQueryDef を見ておいた方が･･･
マクロ実行中にユーザーフォームを表示する場合です。 このコードをマクロの中に記述 UserForm1.Show ユーザーフォームにはリストボックスを配置 下記のコードを用います。 Private Sub UserForm_Initialize() ListBox1.ColumnCount = 1 ListBox1.RowSource = "A40:A42" ListBox1.ControlSource = "A4" ListBox1.BoundColumn = 1 End Sub この場合、アクティブなシートを変えると別なシート上でも実行できます。 たくさんのシートがある場合、 各シート上にコントロールを配置するより便利かもしれません。 お試しください。
Sub sample() Dim i As Long, xAry, xDiv xAry = Split("2,3,5,7,11,13", ",") For i = 0 To 2 With Range("A2").Offset(, i) If .Value > 1 Then 'A2は１より大きいか？ For Each xDiv In xAry If .Value Mod xDiv = 0 Then .Offset(, 1).Value = .Value / xDiv .Offset(1, 1).Value = xDiv End If Next xDiv End If End With Next i End Sub 未実行につき不具合ご容赦。
フィルターの詳細設定は 出来ますか? それが できれば 条件を コンボボックスやテキストボックスの値、チェックボックがTUREの場合は 検索条件は "○"を 入れるようにして 条件範囲の中にいれて フィルターをかけてやればよい。 わざわざ オプションボタンは 不要で コンボボックスに 入力しない場合は 条件項目は 空白にしておけば コマンドボタン一つで 出来ます。 3つ入れれば ３つそろったものが 抽出されます。 まず マクロの前に フィルターの詳細設定で 検出できるようにしてください。 次に マクロの記録で 一度行って マクロを作成 マクロの名前を付けてください。 次に コンボボックス テキストボックスの 値を シートの条件範囲のセルに入力するようコードを組んでください。 それができたら 先ほどのマクロ名を 書き込んだら 出来上がりです。 全データー表示は フィルターの解除で出来ます。または 検索条件を全クリアーで検索
>CSVのExcelファイルをフォルダの中に作成できるようになりました。 >ただ、テキストファイルが作れるコードができていないのが問題です。 csvはテキストファイルですよ。 .txtのファイル形式で作りたいのであれば、filePathの最後を.txtにすれば問題ないです。
マクロでシート保護するときに ActiveSheet.Protect UserInterfaceOnly:=True とすれば、保護した後でもマクロからはセルが操作できるはずです。
Sub 複数のブックのシートをコピーする() Dim ファイル名一覧 As Variant Dim ブック As Workbook Dim i As Integer Dim s As Integer Dim dtkazu As Integer 'データ数 ファイル名一覧 = Application.GetOpenFilename("Excelのファイル,*.xls" _ , MultiSelect:=True) If VarType(ファイル名一覧) = vbBoolean Then Exit Sub Application.EnableEvents = False For i = 1 To UBound(ファイル名一覧) Set ブック = Workbooks.Open(ファイル名一覧(i)) dtkazu = Cells(9, 1).End(xlDown).Row - 8 s = InputBox("シートの番号1:経費清算書、2:交通費清算書") ThisWorkbook.Worksheets(s).Cells(7, 2) = ブック.Worksheets(1).Cells(4, 2) ThisWorkbook.Worksheets(s).Cells(8, 2) = ブック.Worksheets(1).Cells(5, 2) ブック.Worksheets(1).Range(Cells(9, 1), Cells(dtkazu, 11)).Copy ThisWorkbook.Worksheets(s).Cells(9, 1) ブック.Close Next Application.EnableEvents = True End Sub 集計用ブックにこのマクロをいれます。このマクロを起動するとファイル選択のウインドウが出ますので経費清算書または交通費清算書のファイルを指定して、「開く」を押します。インプットボックスが現れますので、経費清算書の場合は1を交通費清算書の場合は2を入力してください。そうすると経費清算書の場合はB4,B5のデータを集計用ブックのシート1のB7,B8に、経費清算書のA9から下のKカラムまでのデータは集計用ブックのシート1のA9から下にすべてコピーされます。 交通費清算書の場合はB4,B5のデータを集計用ブックのシート2のB7,B8に、交通費清算書のA9から下のKカラム(経費清算書似合わせてあえてKカラムまでとしました)までのデータは集計用ブックのシート2のA9から下にすべてコピーされます。 回答します。一応これで試してください。複数回実行するときはどうするのでしょうか。
アメリカでプログラマをしています。 アメリカと日本ではプログラマと呼ばれる集団の構成員がずいぶん違うので、直接の比較はあまり意味がないと思いますよ。 アメリカではプログラマは大学で専門教育を受けた人たちがする専門職です。高卒や文系大卒の未経験者がプログラマとして採用されるというのはまず考えられません。専門教育を受けていないプログラマが出来る仕事というのは、付加価値の低い仕事が中心になるでしょう。 また、アメリカでは転職が当たり前の社会ですから、大手企業でも中小企業でもプログラマであれば日本ほど給料に差が出ません。中小の会社が社員としてプログラマを雇う場合は大手と遜色ない待遇を示さなければ必要な人材を集めることができません。基本的に正社員のプログラマは好待遇で付加価値の高い仕事をさせ、付加価値の低い仕事は契約社員に担当させたり外注したりします。 さらに、アメリカではプログラマが経験を積むと経験を積んだプログラマとして処遇されます。プログラマとしてより多くの責任を引き受けるようになり、責任の重さに応じて給料も上がります。日本ではSEの仕事とされるようなものでもプログラマの仕事である場合が多いです。日本でのSEの下位互換としてのプログラマは、アメリカでは経験の浅いプログラマとほぼ同等だと思います。 もちろん例外はありますが全体的な傾向として １．日本でプログラマと呼ばれる人の教育レベルが低いこと、 ２．日本でプログラマと呼ばれる人の仕事の多くが付加価値の低い仕事であること、 ３．日本でプログラマと呼ばれる人のほとんどは経験が浅いこと、 を考えると、日本のプログラマの平均収入をアメリカのプログラマとは単純に比べられません。日本でも平均収入の母集団を、理系大学院卒、大手元請企業勤務のプログラマおよびSEとすれば、平均収入はかなり上がるはずです。 私は日本で中小企業と大手外資系の両方で働いた経験がありますが、中小企業退職時の年収は３００万円。１年間派遣プログラマをした後、大手外資系に採用された時のオファーはボーナス込みで８００万ほどでした。２年で私の能力が３倍になったわけではなく、付加価値の低い仕事しかない現場から付加価値の高い仕事がある現場に移っただけです。大手外資系で働いていた時に付き合いのあった他社のプログラマも大体同じぐらいの待遇でした。 何が言いたいかというと、日本のプログラマの平均収入が低いのは、日本のプログラマが付加価値の低い仕事をしているからだということです。日本の文化や言語の特性もあって、付加価値の低い仕事がまだ国内にとどまっているせいでプログラマの平均収入が上がらないのだと思います。付加価値の低い仕事をやめて、付加価値の高い仕事に注力すればプログラマの平均収入も上がるはずです。
これでOKです。・・・・・・・・・・・・・・・・・・・・・・ Public Class Form1 Private Sub Button1_Click(ByVal sender As System.Object, _ ByVal e As System.EventArgs) Handles Button1.Click Dim proc As New Process() proc.StartInfo.FileName = "C:\Users\Documents\defg.exe" proc.Start() End Sub End Class
今さななぜVB?って気もするが、個人的にはRubyは飽きると思う。 ので、この二択なら、VB.Net。 グラフィカルにソフトを開発できるしね。 なんで頑なにRuby、VBに必死なの！？
素人の私が言うのもなんですが、作成の際に利用するのが知恵袋というのはどうかと。。。 (正直、そのようなソフトは信じられないと思うのは私だけでしょうか？)
以下でどうなりますか 以下を標準モジュールに転記して、Samp1 を実行してみます （記述量はチョット多いですが、それなりに処理してます） 確認用簡易データ作成 testData でデータが出来上がります このデータで、１秒ソコソコ･･･ かも Public Sub Samp1()    Dim vA As Variant, v As Variant    Dim vP As Variant, vN As Variant    Dim i As Long, j As Long, k As Long    Const CH As String = "-"    vA = Worksheets("SheetA").Range("A1").CurrentRegion.Value    For j = 1 To UBound(vA, 2)       vN = Empty       i = 1       While (i <= UBound(vA))          If (vA(i, j) = CH) Then             k = 1             Do While ((i + k) <= UBound(vA))                If (vA(i + k, j) <> CH) Then Exit Do                k = k + 1             Loop             v = ""             If ((i + k) <= UBound(vA)) Then                vP = vN                vN = vA(i + k, j)                If (Not IsEmpty(vP)) Then v = (vP + vN) / 2             Else                k = k - 1             End If             While (k >= 0)                vA(i, j) = v                i = i + 1                k = k - 1             Wend          Else             vP = vN             vN = vA(i, j)             If (Not IsEmpty(vP)) Then                vA(i, j) = (vP + vN) / 2             Else                vA(i, j) = ""             End If             i = i + 1          End If       Wend    Next    With Worksheets("SheetB")       .Range("A1").Resize(UBound(vA), UBound(vA, 2)).Value = vA       .Columns.AutoFit    End With End Sub ' 確認用簡易データ作成 Public Sub testData()    Dim vA(1 To 100, 1 To 1000) As Variant    Dim i As Long, j As Long    Randomize    For i = 1 To UBound(vA)       For j = 1 To UBound(vA, 2)          If (Rnd() > 0.8) Then             vA(i, j) = "-"          Else             vA(i, j) = Int(30 * Rnd()) + 1          End If       Next    Next    With Worksheets("SheetA")       .Cells.Delete       .Range("A1").Resize(UBound(vA), UBound(vA, 2)).Value = vA       .Columns.AutoFit    End With End Sub
上記の後に do loop が無いのなら、１行しかないファイルなのでは？ （もしくは先頭行だけ読み込めば良い。） 対象としているファイルをメモ帳で開けば何を読み込んでいるのかの確認は簡単です。
Cells(r, c).Value = FName Cells(r, c+1).Value = FileDateTime(FPath & "\" & Fname)
こんな感じです。・・・・・・・・・・・・・・・ Dim x As Integer Sub 乱数() Dim a, c, d, j, h As Integer Dim b(50) As Integer Randomize a = 50 h = 0 owari: j = 0 d = Int(Rnd() * a + 1) For c = 0 To a - 1 If b(c) = d Then j = 1 End If Next If j = 1 Then GoTo owari ElseIf h < a - 1 Then b(h) = d h = h + 1 GoTo owari End If If h = a - 1 Then b(h) = d End If For c = 0 To a - 1 Range("E" & c + 1) = b(c) Next End Sub Sub ステップ() x = x + 1 Range("A1").Value = "" Range("A1").Value = Range("E" & x).Value End Sub Sub リセット() x = 0 Range("A1").Value = "" End Sub
>設問IDごとに自動で並べ変えるマクロ VBAはこういうときに全く使い物にならないのでperlとかrubyとかやった方がいいです 学んでも何も書けないので別のスクリプト言語やった方がいいです
貴殿の3つの条件を満たし、なおかつ、 ④B2の住所が間違っていた場合（B5:B8の範囲内にない場合）、 ⑤C5:C8の範囲内が全て埋まっていて、なおかつC2の住所がその範囲内にない場合、 も想定すると数式が結構長くなりました。 ・なお、C5:C8の範囲内にあえてワイルドカードの「*」は必要ありません。 D2セルには、 =IFERROR(IFERROR(LOOKUP(1,0/((B5:B9=B2)*(C5:C9<>"")*COUNTIF(C2,C5:C9&"*")),D5:D9),INDEX(D5:D9,MAX(INDEX((B5:B9=B2)*(MATCH("ーー",C5:C9,1)+1),)),)),"")&"" の式を入れています。 なお、⑤のケースを想定して、数式では「B5:B9」「C5:C9」などと空白の行を含めた作りにしています。
前回の質問で回答していますが、ボタンに置き換わったのですね。 コマンドボタンに以下のコードをコピペします。 Sub ボタン1_Click() Dim Kanri As Worksheet, Kouji As Worksheet Dim EndRow As Long, i As Long Set Kanri = Worksheets("見積もり管理表") Set Kouji = Worksheets("工事予定表") With Kanri For i = 1 To 4 EndRow = Kouji.Cells(Rows.Count, i).End(xlUp).Offset(1).Row Kouji.Cells(EndRow, i) = .Cells(3, i) .Cells(3, i).ClearContents Next i End With Kouji.Select End Sub ※ただし、工事予定表のA～D列の２行目には見出しが入力されているとしています。
VBAでのやり方はhelpnanodaさんが説明されておりますので 関数だけで処理してみます。 ただ、チェックボックスについてですが、開発タブの挿入から、 「フォームコントロール」の「チェックボックス」を選択設定 されたということで、よろしいですか？ Activexでは、ないですよね。 Activexだと、VBAを使うという前提になってしまいます。 1.チェックボックスを右クリックし、「コントロールの書式設定」を選択。 2.リンクするセルを選択し、離れた列同一行のセルを選択。 (私の例では、F列としています) 3.上記1.2.と同様の作業を最下位行まで、行います。 4.チェックボックスにチェックを入れたり、外したりしてみてください。 F列の該当するセルが、チェックがONの時は、TRUEでOFFの 時は、FALSEと表示されるはずです。 5.OKであればG列3行目に、=IF(F3=TRUE,ROW(),"")と入力し、 最下位行のセルまで、コピー。 6.H列3行目に=IFERROR(INDIRECT("A"&SMALL($G$3:$G$7,ROW()-2)),"") と入力し、最下位行のセルまで、コピー。 ＊5.6.についてですが、将来的にA・B列のデータが増加しそうならば、 100行目あたりまでコピーしてもOKです。 Sheet2のA3に=Sheet1!H3と入力し、下位行にコピーします。 5.6.でコピーした行数と同じ行数となるようにしてください。 Sheet1のF～H列は作業領域なので、目障りならば、F～H列を選択後 非表示にしてください。 以上になりますが、不明点等発生した場合は、お気軽にお問合せください。
If Cells(i, "B") <> "" Then Cells(i, "A") = i - 4 を If Cells(i, "B") <> "" Then Cells(i, "A") = "'" & Right("000" & Int(i / 2) - 2, 3) として下さい。
↓のような考え方のほうが、解りやすいし、速度的に有利でしょう、きっと。 Sub 選択() Dim ws As Worksheet Dim x As String For Each ws In Worksheets With ws If .Name Like "P##" Then x = x & "," & .Name End If End With Next If x <> "" Then Worksheets(Split(Mid(x, 2), ",")).Select End If End Sub
このサンプルは yomikaki 0, 1, n, a ' ←ここで１枚目のシートから配列aに値を読み込む s = Time sortB n, a s = s & "->" & Time MsgBox "経過時間(バブル) " & s yomikaki 1, 2, n, a ' ←ここで２枚目のシートへ配列aの値を書き出す となっていますので、シートが２つ存在することが前提になっているようです。 シートを１枚追加してみてください。
以下で回避可能です。 continueのラベルがエラー処理と固定シートとで共用されているのが 問題あるかと思いましたのでルーチンの最後に固定シートの並び替えを 置いてエラー処理と分けました。 あと変数名に日本語は控えたほうがよいと思いましたが 動作しているのでそのままで掲載しますね＾＾； Sub 連番() On Error GoTo continue Dim n As Integer Dim 文字連番 As String Dim i As Long Dim a As Long Dim shname As String For i = 1 To Sheets.Count - 1 shname = Sheets(i).Name If Sheets(i).Name <> "作業" And Sheets(i).Name <> "素材" And Sheets(i).Name <> "原紙" Then 文字連番 = Mid(i + 100, 2) Sheets(i).Name = Sheets.Count - i If Left(Sheets(i).Name, 1) <> "P" Then hoge: Sheets(i).Name = "P" + 文字連番 End If End If Next i GoTo End_ continue: If Err.Number <> 0 Then If Err.Number = 1004 Then '同一名のシート存在時 エラーになりシート名変更がされない状態簡易回避 Sheets("P" + 文字連番).Name = "dummy" + CStr(i) Err.Clear Resume hoge End If End If End_: ThisWorkbook.Sheets("作業").Move after:=Sheets(Sheets.Count) Sheets("素材").Move before:=Sheets("作業") Sheets("原紙").Move before:=Sheets("素材") End Sub
MonthCalendarのカスタマイズについては、下記サイトが参考になると思います。 http://d.hatena.ne.jp/panda728z/20090812
回答します。 >VBSでテキストファイルを1文字ずつ読み込んで10文字目の文字をメッセージボックスに表示することはできますか？ →必ずテキストファイルに10文字以上の文字列が記述されている保証がないため、その考慮も踏まえて、プログラムを作成してみました。 サンプルプログラムは以下の通りです。 ■使用方法 ①空のVBScriptファイル（vbs）を開き、下記のプログラムを保存してください。 ②起動するときに、読み込みたいファイルを①で作成したファイルにドラッグ＆ドロップしてください（ドロップしたらプログラムが起動します）。 ■プログラム Option Explicit Dim oFSO: Set oFSO = Nothing Dim oFile: Set oFile = Nothing Dim bFileOpenFlg: bFileOpenFlg = False Dim sFile: sFile = "" Dim sValue: sValue = "" Sub Main() 'ファイル操作を行うためのオブジェクトを生成 Set oFSO = WScript.CreateObject("Scripting.FileSystemObject") If Err.Number <> 0 Then Err.Raise Err.Number '引数が無い場合、強制終了 If WScript.Arguments.Count = 0 Then WScript.Echo("引数（読み込みたいファイル）を指定してください。") WScript.Quit(-1) End If '引数が1件でない場合、強制終了 If WScript.Arguments.Count <> 1 Then WScript.Echo("引数（読み込みたいファイル）は１ファイルのみ指定してください。") WScript.Quit(-1) End If '引数を取得 sFile = WScript.Arguments(0) 'ファイルの存在確認 If oFSO.FileExists(sFile) = False Then WScript.Echo("引数（読み込みたいファイル）は１ファイルのみ指定してください。") WScript.Quit(-1) End If '拡張子の確認 Select Case LCase(oFSO.GetextensionName(sFile)) Case "txt", "csv", "dat" Case Else '上記で定義された拡張子以外のものは、エラーとする WScript.Echo("読み込み可能なファイルではありません。") WScript.Quit(-1) End Select 'ファイルの読み込み（読み取りモード） Set oFile = oFSO.OpenTextFile(sFile, 1) If Err.Number <> 0 Then Err.Raise Err.Number bFileOpenFlg = True '全ての文字列を取得 sValue = oFile.ReadAll '文字列が10以上存在するか確認 If Len(sValue) >= 10 Then '10文字目の文字を表示 WScript.Echo "10文字目の文字は『" & Mid(sValue, 10, 1) & "』です。" Else WScript.Echo "読み込んだファイルには、10以上の文字が記述されておりません。" End If 'ファイルを閉じる oFile.Close Set oFile = Nothing End Sub Sub Try() Call Main() End Sub Sub Catch() On Error Resume Next Call Try() End Sub Call Catch() '変数の初期化 sFile = "" If Not oFile Is Nothing Then If bFileOpenFlg = True Then oFile.Close Set oFile = Nothing End If Set oFile = Nothing End If Set oFSO = Nothing '処理中にエラーが発生した場合、その旨のメッセージを表示し、それ以外は正常終了する If Err.Number <> 0 Then WScript.Echo CStr(Err.Number) & ":" & Err.Description WScript.Quit(Err.Number) Else WScript.Quit(0) End If
プログラムのステップ実行はご存じでしょうか？ １ステップづつ実行しながら変数の変化等を調べればコードのミスは見つかると思います。 変化が判るように Application.ScreenUpdating = True の状態で行いましょう。
日付は見える日付が文字列型なのか、日付型(内部的には単精度整数型)なのかによって、比較の仕方が異なるので、シートの日付の型が何で、どうやって比較しているのかで変わってくると思います。
C列の会社名をブック名にするなら、 >For r = 2 To w.Range("A65536").End(xlUp).Row を For r = 2 To w.Range("C" & Rows.Count).End(xlUp).Row に変更。 >s = w.Cells(r, "A") & "_" & w.Cells(r, "B") を s = w.Cells(r, "C").Value に変更。 でどうでしょうか。
http://officetanaka.net/excel/vba/file/file07.htm http://officetanaka.net/excel/vba/tips/tips69.htm よくお世話になってる有名なVBAレクチャーサイトです。 上がエクセルシートへの書き出し、下はそのDir関数の注意点。 参考までに。
End ステートメントを使ってください。ただちに処理を終了できます。 似たようなステートメントとして STOP ステートメントもあります。 こちらは処理を中断します。 sub A() ・・・・ if 条件 then End End if ・・・・ End sub
エクセルのオプション☞詳細設定の表示☞次のシートで作業するときの表示設定 で「改ページを表示する」:OK…でExcel終了 次にExcelを開くと…改ページ表示になります. このファイルで…ファイル☞開く…希望するファイルを開きます。
>13ファイルあるが、途中でコピーが止まり、3ファイルで終了してしまいます。 「終了」とは正常に終わったのですか、エラーになって終わったのですか。 エラーであれば、どこで、どんなメッセージが出ていますか。 >又、コピーが終わると、そのファイルを閉じると言うWB.close部分がデバックが出てしまう… そこでエラーになって終わるということでしょうか。 その時のメッセージは。 先日のコードに、回避策だけ入れ替えた場合、単純なデータでは問題なく動きましたよ。 C列からAA列まで2000行にびっしりデータを入れたファイルを13個用意して動かしました。 2000行×13ファイルで26000行のデータがきちんとできました。 やはり nagato_blue_noahさんの書かれているように、コードを示していただかないとわかりませんね。 気になったのは、該当のフォルダには、その13ファイル以外のファイルは入ってませんよね。 フォルダにあるファイルをすべて開くようになっていますので。
Private Sub ComboBox1_Validating(sender As System.Object, e As System.ComponentModel.CancelEventArgs) Handles ComboBox1.Validating If Not ComboBox1.Items.Contains(ComboBox1.Text) Then ComboBox1.Text = String.Empty e.Cancel = True End If End Sub でいかがでしょうか。
>テキストボックスBで入力中の文字が確定せずそのまま移動してしまいます。 >テキストボックスBでの入力を取り消してフォーカスを移動させる方法はありま すでしょうか。 こちらの環境では、テキストボックスBが未確定で下線状態の時にテキストボックスAやCにマウスクリックでフォーカスを移動すると、テキストボックスBは未入力のままになります。またA、C共に空白のままです。 質問者さんの場合はBの入力が移動したように見える、テキストボックスAまたはCが未確定下線状態になってしまうのでしょうか? そうだとすると以前にリリースしたアプリケーションで、XP環境にて同様な現象が発生するエンドユーザさんの端末を見たことがあるので、質問者さんの場合も環境依存の不具合ではないかと思います。他のマシンがある場合は、同様な現象が発生するかを確認してみて下さい。
質問者さんの場合だと、「異常有りなし」を選択するオプションボタンは非連結にした設計の方が良いのではと思います。 そのオプションボタンのクリックイベントまたは値が変更された場合に発生するイベントで「異常なし」の場合はレコード次へ移動するように動作させます。 「異常有り」の場合はレコードはそのままにしておいて、コントロールに値を入力するように動作させます。そうすれば「異常有り」で別フォームを開く必要ないでしょう。 この動作だと異常なしの場合はコントロールをDisableにしておいて、異常有りの場合にEnableにすると見た目にも分かりやすいし、異常なしデータに誤って値を入力してしまうミスも防げると思います。 どのような動作を実現したいのかが読み取れない部分があるので、こんな回答ですが。
質問者さんの場合だと、「異常有りなし」を選択するオプションボタンは非連結にした設計の方が良いのではと思います。 そのオプションボタンのクリックイベントまたは値が変更された場合に発生するイベントで「異常なし」の場合はレコード次へ移動するように動作させます。 「異常有り」の場合はレコードはそのままにしておいて、コントロールに値を入力するように動作させます。そうすれば「異常有り」で別フォームを開く必要ないでしょう。 この動作だと異常なしの場合はコントロールをDisableにしておいて、異常有りの場合にEnableにすると見た目にも分かりやすいし、異常なしデータに誤って値を入力してしまうミスも防げると思います。 どのような動作を実現したいのかが読み取れない部分があるので、こんな回答ですが。
http://tsware.jp/study/vol5/event_09.htm コンボは同様にAfterUpdateでも使えばいい。
回答１ 以下のコードでいかがでしょうか。 Private Sub ComboBox1_KeyDown(sender As System.Object, e As System.Windows.Forms.KeyEventArgs) Handles ComboBox1.KeyDown Dim p As Control p = CType(sender, ComboBox).Parent '下矢印の時 Select Case e.KeyCode Case Keys.Down '最終項目が選択されているとき If ComboBox1.SelectedIndex = ComboBox1.Items.Count - 1 Then '直前のコントロールをアクティブにする p.SelectNextControl(ActiveControl, True, True, True, True) e.SuppressKeyPress = False Exit Sub End If 'コンボボックスの選択項目をひとつ下の項目にする If ComboBox1.SelectedIndex < ComboBox1.Items.Count - 1 Then ComboBox1.SelectedIndex += 1 End If Case Keys.Up '先頭項目が選択されているとき If ComboBox1.SelectedIndex = 0 Then '直前のコントロールをアクティブにする p.SelectNextControl(ActiveControl, False, True, True, True) e.SuppressKeyPress = False Exit Sub End If 'コンボボックスの選択項目をひとつ上の項目にする If ComboBox1.SelectedIndex > 0 Then ComboBox1.SelectedIndex -= 1 End If End Select End Sub 回答２ VB.Netのコンボボックスでは何も指定しなくてもダブルクリックで項目の全選択が可能です。
UserForm_QueryCloseはフォームが閉じられる場合に発生して、Cancel引数でイベントを中止することができます。また、CloseMode引数でイベントが発生した原因、例えば×ボタンが押されたのかOSがシャットダウンしようとしているのかなどを知ることができます。 UserForm_TerminateイベントはClass_Terminateイベントと同じくクラスのインスタンスが破棄される直前に発生します。このイベントでは主に終了処理を実行します。
http://excel-ubara.com/excelvba4/EXCEL244.html
触ったCOMオブジェクトを全て解放しないとプロセスが残ることが有ります。 http://www.asahi-net.or.jp/~ef2o-inue/vbnet/sub13_03_030.html オブジェクトを管理するラッパークラスを作って操作するのが一般的です。
一例です。 因みにFind検索はB4の次のセルからになりますので開始をB3にしました。 Sub sample() Dim result As Range, r_end As String Set result = Range("B3:B300").Find _ (What:=Range("C1").Value, LookAt:=xlPart) If result Is Nothing Then MsgBox "該当データがありません！" Exit Sub Else r_end = result.Address Do result.Select msg = MsgBox("検索を続けますか？", vbQuestion + vbOKCancel) If msg = vbCancel Then Exit Sub Set result = Range("B3:B300").FindNext(result) Loop Until r_end = result.Address MsgBox "以降に該当データは見つかりませんでした！", vbInformation End If End Sub
文法的にいうと正確には If Date > CDate("2016/6/2") Then や If Date > #6/2/2016# Then なんでしょうね。 Excelなら（他のアプリケーションは知りません） If Date > "2016/6/2" Then でOK
質問のコードだけを実行するとコピーされたシートのほうのA2からE3のセルのデータがクリアされますが、コピー元のシートはデータは残っています。 たぶん、コードの途中途中のコードが抜けた状態を質問とされているようですので、書かれていないコードのほうに問題がありそうですね。 次のように書き換えてみては？ ShNameにコピー元のシート名を取得してから、そのシート名をコピーします。 コピーすると、コピーされたシートがActiveSheetに自動になることを利用してください。 Sub CopySh() Dim ShName As String ShName = ActiveSheet.Name With Sheets(ShName) .Copy after:=ActiveSheet ActiveSheet.Name = .Range("Y1") & "月分" End With Range("A2:E3").ClearContents End Sub
面倒がらずに画像ではなく、文章で書いて下さい。 それが質問するうえでのマナーです。
minaaa_xさん 1. パズルはC++のほうが、組みやすい。 下の順で解く? 2. 仮置きなしで、解けるもの。 3. 仮置きして、解くもの。
R[-33]C[-10]は相対参照ですから、それを絶対参照にしたいのでしょうか。 現在は、関数が指定されているセルから33行前の10列前が指定されています。 たとえば、関数が指定されているセルがK40（R40C11→40行目11列目）とすれば、33行前の10列前はセルA7なので７行目1列目なので「R7C1」とします。
Visual Basicのカテゴリーで質問したほうが、的確な答えが来るでしょう。 http://chiebukuro.yahoo.co.jp/dir/list/d2078297666/list
何が聞きたいのでしょうか？
何が聞きたいのでしょうか？
共に数字がない場合にはAndを使っているなら、どちらかならOrとか？ かけ算をFor Nextで累乗の回数分繰り返せば良いのでは？
面倒がらずに画像ではなく、文章で書いて下さい。 それが質問するうえでのマナーです。
回答し直してます 前回提示した Samp1 は、 除外する人がいなければソコソコ動きます ある程度、除外者を連続設定すると、無限ループに陥る･･･ チョット処理をいじった Samp2 を･･･ 以下記述内容としては、 文字数の関係で、 前回の回答の Samp1 を Samp2 に置き換えただけです 前回回答 2016/5/20 18:20:27 面白そうだったので、やってみました ソコソコ動くと思いますが、サラッとしか検証していないので････ おかしいところがあったら、ごめんなさい 以下のコードは標準モジュールに記述します シートには、添付図の様に作成する情報を作っておいて、 そのシートをアクティブにした状態で Samp1 を実行すると、 結果を新規シートに表示します 用意するシートの情報） ・A 列 A2 ～ 氏名 ・B 列 B2 ～ 場所名情報 ・C 列 C2 ～ 作成した表から除外する日付 ・D 列 D2 ～ 割当て不可の人がある日付 ・E ～ 列 E2 ～ 割当て不可の人の名前 表を作成する月の特定順） C2, D2 を順に見て日付があったらその月 C2, D2 に日付がない場合、実行した翌月 ★～ ～★をコメントにすると、 A2 ～ 記述した人順で割り当てていきます （除外する人がなければ、毎月同じ順パターンに） また、A2 ～ の順を自力で変更すると、 それなりに違うパターンに ★～ ～★では、処理は入る前に、人の順を変えているだけ･･･ これは、初期の表を作るだけなので、 途中で都合の悪くなった人を割り当てしなおす･･･ 別途コードを作成することになります ※ やってみた感想でもいただければと思います Public Sub Samp2()    Dim dic As Object, dicM As Object, dicE As Object    Dim dicS As Object, dicU As Object, dicW As Object    Dim vA As Variant, vD As Variant, vK As Variant, v As Variant    Dim dt As Date    Dim i As Long, j As Long    Set dic = CreateObject("Scripting.Dictionary")    Set dicM = CreateObject("Scripting.Dictionary")    Set dicE = CreateObject("Scripting.Dictionary")    Set dicS = CreateObject("Scripting.Dictionary")    Set dicU = CreateObject("Scripting.Dictionary")    Set dicW = CreateObject("Scripting.Dictionary")    vA = Range("A1").CurrentRegion.Value    If (vA(2, 3) <> "") Then       dt = vA(2, 3)    ElseIf (vA(2, 4) <> "") Then       dt = vA(2, 4)    Else       dt = DateAdd("m", 1, Date)    End If    dt = CDate(Format(dt, "yyyy/mm"))    For i = 1 To DateAdd("m", 1, dt) - dt       dic.Add dt, CreateObject("Scripting.Dictionary")       dt = dt + 1    Next    For i = 2 To UBound(vA)       If (vA(i, 1) <> "") Then          dicM(vA(i, 1)) = Empty       End If       If (vA(i, 2) <> "") Then          dicE(vA(i, 2)) = dicE.Count + 3          dicU.Add vA(i, 2), CreateObject("Scripting.Dictionary")       End If       dt = vA(i, 3)       If (dic.Exists(dt)) Then dic.Remove dt       dt = vA(i, 4)       If (dic.Exists(dt)) Then          For j = 5 To UBound(vA, 2)             If (vA(i, j) <> "") Then dic(dt)(vA(i, j)) = Empty          Next       End If    Next ' ★～    Randomize    For i = 1 To 10       v = dicM.Keys()(Int(dicM.Count * Rnd()))       dicM.Remove v       dicM(v) = Empty    Next ' ～★    For Each vD In dic.Keys       For Each vK In dicE.Keys          Do While (1)             For Each v In dicS.Keys                If ((Not dic(vD).Exists(v)) _                   And (Not dicU(vK).Exists(v))) Then                   dic(vD)(v) = vK                   dicS(v) = dicS(v) - 1                   If (dicS(v) <= 0) Then dicS.Remove v                   dicU(vK)(v) = Empty                   If (dicM.Count = dicU(vK).Count) Then                      dicU(vK).RemoveAll                   End If                   Exit For                End If             Next             If (Not IsEmpty(v)) Then Exit Do             For Each v In dicS.Keys                If (Not dic(vD).Exists(v)) Then                   dicU(vK).Remove v                   dicW(v) = Empty                   Exit For                End If             Next             If (IsEmpty(v)) Then                For Each v In dicM.Keys                   If (Not dicW.Exists(v)) Then                      dicS(v) = dicS(v) + 1                   End If                Next                dicW.RemoveAll             End If          Loop       Next    Next    ReDim vA(1 To dic.Count + 1, 1 To dicE.Count + 2)    vA(1, 1) = Format(dic.Keys()(0), "m月")    For Each vK In dicE.Keys       vA(1, dicE(vK)) = vK    Next    i = 1    For Each vD In dic.Keys       i = i + 1       vA(i, 1) = Format(vD, "d")       vA(i, 2) = Format(vD, "(aaa)")       For Each vK In dic(vD).Keys          v = dic(vD)(vK)          If (Not IsEmpty(v)) Then             vA(i, dicE(v)) = vK          End If       Next    Next    Application.ScreenUpdating = False    With Worksheets.Add(After:=ActiveSheet)       With .Range("B2").Resize(i, UBound(vA, 2))          .Value = vA          .Range("A1:B1").Merge          .Rows(1).Interior.ColorIndex = 35          .HorizontalAlignment = xlCenter          .Borders.LineStyle = xlContinuous       End With       .Columns.AutoFit    End With    Application.ScreenUpdating = True    Set dic = Nothing    Set dicM = Nothing    Set dicE = Nothing    Set dicS = Nothing    Set dicU = Nothing    Set dicW = Nothing End Sub
まず、再質問と書かれていますが、ID非公開では再質問されてもこちらは以前の質問を見つけることが出来ません。以前の質問と関連付けるのなら、以前の質問のページへのリンクを明記してください。 ブックの結合は物凄くたくさんの事例があります。 「Excel VBA 最終行取得」でGoogleなりYahoo!なりで検索して見ましたか？
VBAの勉強の前にエクセルの勉強をしたほうがよさそうですね。 '5/9は文字列になるので、VBAで何か作業をしたい場合は気をつけてください。 日付のままで表示だけ変えたいのであれば、 書式設定でm/dにしたほうがいいと思います。 dim r as range for each r in range(cells(1,1),cells(7000,44)) if '５桁の数字で前２桁が42の場合 r.numberformatlocal="m/d" end if next r お勉強中であればif分岐の部分くらい調べてくださいね。
コード例です。 全く検証していないので、不具合があればご返信ください。 Sub Sample() Dim Row As Long Dim Code As String Dim BkFullName As Variant Dim Bk As Workbook Dim BkB As Workbook Dim ShtA As Worksheet Dim ShtB As Worksheet Dim i As Long Dim Shell As Object Dim FolderPath As String Dim BkName As String Dim NewBk As Boolean If MsgBox("このファイル以外のエクセルファイルは全て閉じてから実行してください。" & vbLf & "実行しますか？", vbYesNo) = vbNo Then Exit Sub Set ShtA = ThisWorkbook.Worksheets(3) Set Shell = CreateObject("WScript.Shell") FolderPath = Shell.SpecialFolders("Desktop") & "\" & Format(Date, "yymmdd") If Dir(FolderPath, vbDirectory) = "" Then MkDir FolderPath End If Shell.CurrentDirectory = ThisWorkbook.Path BkFullName = Application.GetOpenFilename("Excelファイル,*.xls*", , , , True) If Not IsArray(BkFullName) Then Exit Sub For i = 1 To UBound(BkFullName) For Each BkB In Workbooks If InStr(BkFullName(i), BkB.Name) > 0 Then GoTo Label0 Next Set BkB = Workbooks.Open(BkFullName(i)) Label0: For Each ShtB In BkB.Worksheets NewBk = False Code = ShtB.Name For Row = 3 To ShtA.Cells(Rows.Count, "A").End(xlUp).Row If ShtA.Cells(Row, "A").Value = Code Then BkName = ShtA.Cells(Row, "B").Value & "様分.xlsx" '←拡張子は必要に応じて書き換えてください。 Exit For End If Next For Each Bk In Workbooks If Bk.Name = BkName Then GoTo Label1 Next If Dir(FolderPath & "\" & BkName) = "" Then NewBk = True Set Bk = Workbooks.Add Bk.SaveAs FolderPath & "\" & BkName Else Set Bk = Workbooks.Open(FolderPath & "\" & BkName) End If Label1: ShtB.Copy after:=Bk.Worksheets(Bk.Worksheets.Count) If NewBk Then Application.DisplayAlerts = False Bk.Worksheets(1).Delete Application.DisplayAlerts = True End If Next Next For Each Bk In Workbooks If Bk.Name <> ThisWorkbook.Name Then Bk.Close SaveChanges:=True Next End Sub （注1）このコードはブックAに記述し、実行前にブックA以外を閉じてから実行してください。 （注2）保存するファイルの拡張子は「.xlsx」にしていますが、「.xls」などに変更したい場合は、コメントを入れた行を書き換えてください。
以下の様な方法はどうでしょう やっていることは Range("A1").CurrentRegion でデータの範囲を求めておいて 右隣の１列を作業用に使って B 列の値が２週間以内なら、行番号を、でなければ空白を これを作業列に書き出し、重複の削除 作業列の空白だった行部分は削除され、行番号が残るのできれいにして 少なくなったデータに対して並び替え･･･ Public Sub Samp1()    Dim vA As Variant    Dim iDs As Long, iDe As Long    Dim i As Long    iDs = Format(Date, "yyyymmdd")    iDe = Format(DateAdd("d", 14, Date), "yyyymmdd")    With ActiveWorkbook.Worksheets("Sheet1")       With .Range("A1").CurrentRegion          With .Resize(, .Columns.Count + 1)             vA = .Columns(2).Value             vA(1, 1) = ""             For i = 2 To UBound(vA)                Select Case vA(i, 1)                   Case iDs To iDe                      vA(i, 1) = i                   Case Else                      vA(i, 1) = ""                End Select             Next             Application.ScreenUpdating = False             i = .Columns.Count             .Columns(i).Value = vA             .RemoveDuplicates i, xlNo             .Columns(i).ClearContents             .Sort .Cells(2), xlAscending, Header:=xlYes             Application.ScreenUpdating = True          End With       End With    End With End Sub
Excel2010 VBA のソースであれば、「開発」タブ→「Visual Basic」で編集できるはずですが、パスワードでもかかっているのでしょうか？ 「開発」タブが無い場合は、「リボンのユーザー設定」で「開発」のチェックをONにすれば表示されます。 VB（VB6.0やVB.NET）などで作成して、.exeファイルになった物は編集できないので、ソースファイルが必要です。
実際の色は、どんな色コードが使われているのですかね？ 色が変わらなかったセルを選択して、↓のようなプログラムで調べてみたのでしょうかね？ Sub sample() With ActiveCell.Interior If .Color = RGB(231, 255, 5) Then MsgBox "予想している色と同色" Else MsgBox "予想の色コード：" & RGB(231, 255, 5) & vbCr & _ "実際の色コード :" & .Color End If End With End Sub
Msgbox TypeName(Range("A1:B2").Value) 上記を実行してみれば分かりますが、Variant型配列をSetTextで扱おうとしています(2次元配列)。従って、ご質問のような表記はできませんし、まとめてSetTextでセットすることもできません。 Copyメソッドでは目的にそぐわないということであれば、1つ1つセルを参照して、文字列変数に構成し直すしかないでしょう。
最初のコードは、コード内に条件となる「男、女」を書いています。 2つ目のコードは、Sheet2のA1からA2に条件となる文字を入れ、Sheet1のA列と比較して判定しています。条件となる文字が増えた場合は、3行目のSheet2のセル範囲を修正します。 Sub SexCheck1() Dim i As Long For i = 1 To Range("A" & Rows.Count).End(xlUp).Row If InStr(Range("A" & i), "男") Or InStr(Range("A" & i), "女") Then Range("B" & i) = "○" End If Next i End Sub Sub SexCheck2() Dim i As Long, Word As Range, rng As Range Set Word = Worksheets("Sheet2").Range("A1:A2") For Each rng In Word For i = 1 To Range("A" & Rows.Count).End(xlUp).Row If Range("A" & i).Value Like "*" & rng.Value & "*" Then Range("B" & i) = "○" End If Next i Next rng End Sub
まず、準備として、マクロを実行するための 図を「挿入タブ」の「図形」から邪魔にならない場所に設定してください。 Altを押しながら、F11を押してください。 VBA(マクロ)を書くウインドウが表示されると思います。 Altを押しながら、Iを押しMを押すと何やら真っ白の画面が 出てくるはずです。 そこに、下記のコードをコピーペースト後、当該画面を閉じて かまいません。 Option Explicit Sub TxtDtGet() Dim Tgt As String, Tmpc As String Dim I As Long, J As Long, K As Long Application.ScreenUpdating = False Tgt = Application.GetOpenFilename("Txtファイル,*.txt") If Tgt = "False" Then Exit Sub End If Range(Rows("2:2"), Rows("2:2").End(xlDown)).Delete Shift:=xlUp I = 1 Open Tgt For Input As #1 Do Until EOF(1) Line Input #1, Tmpc Tmpc = Replace(Replace(Tmpc, "、", ","), vbTab, ",") I = I + 1 K = 0 For J = 0 To UBound(Split(Tmpc, ",")) K = K + 1 Cells(I, K) = Split(Tmpc, ",")(J) Next J Loop Close #1 Application.ScreenUpdating = True End Sub 上記で作成した図を左クリックし、マクロの登録を選択後、 TxtDtGetを選択し、OKをクリック。 これで図をクリックすると動くはずです。 注意：1行目は見出しとし、A列2行目から処理するようになっています。 実行する度に、データ部をクリアする必要はありません。 見出し部を残し、データー部をクリアして処理するようにしています。 マクロを含んだワークブックを保存する際は、Excel2003以前なら問題 ないのですが。 Excel2007以降であれば、必ず拡張子をxlsmとしてください。
「VisualBasic2015」は「.NET Framework」上で動作するので「.NET」系です。 「VisualBasic6.0」とは別物です。（仕組みが全然違います） ↓Microsoft Visual Basic .NET https://ja.wikipedia.org/wiki/Microsoft_Visual_Basic_.NET 「バージョンの履歴」なども書いて有るので、「VisualBasic2015」がどっちなのか分かるでしょう。
A社＿東京＿大阪 のリンクするPDFファイルの 保存場所 ファイル名を フルバスで教えて下さい・・・ HYPERLINK関数 と INDIRECT関数 の組みあわせで・・
>二つ目のＣＳＶファイル選択時にキャンセルした場合、一つ目に開いたブックは閉じたいです。 というより、先にファイル選択を２回して、それから２回ＣＶＳファイルを取り込んではどうでしょうか？ （strFileName も配列にします） >2つのCSVデータを、ひとつのエクセルに抽出したいです。 どのようにひとつにしたいのでしょうか。 >ふたつのＣＳＶをwb(1)とwb(2)にセットできれば解決します。 上記のコードでもwb(1)とwb(2)にセットされているのでＯＫなんでしょうか？ 思うに、一つのブックで１つ目のシートと、２つ目のシートに入れたいのではないかと想像しますが、違いますか。 （サンブル） Sub sample() Dim i As Long Dim strFileName(1 To 2) As String Dim wb As Workbook Dim ws(1 To 2) As Worksheet 'ファイルの選択を繰り返し、途中でキャンセルされれば開かずに終わる For i = 1 To 2 strFileName(i) = Application.GetOpenFilename(FileFilter:="CSV ファイル (*.csv),*.csv,テキストファイル (*.txt),*.txt", Title:=cnsTITLE) If (strFileName(i) = "False") Then Exit Sub Next i '新しいブックを一つ追加 Set wb = Workbooks.Add For i = 1 To 2 'シートが足りない場合は追加する If wb.Worksheets.Count < i Then wb.Worksheets.Add After:=wb.Worksheets.Count 'wsにシートをセットし、CSVをセットする Set ws(i) = wb.Worksheets(i) With ws(i).QueryTables.Add(Connection:="TEXT;" & _ strFileName(i), _ Destination:=ws(i).Range("A1")) .AdjustColumnWidth = False .TextFilePlatform = 932 .TextFileCommaDelimiter = True .TextFileColumnDataTypes = Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, _ 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, _ 1, 1, 2, 2, 2, 1, 1, 1, 1, 2, _ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) .Refresh .Delete End With Next i End Sub
On Errorのタイミングが悪いでしょう。 あと、On Errorは出所構わず、すべてのエラーを対象とするので、ピンポイントで使用するのが肝心。 Sub シート並べ替え() Dim i As Long With Worksheets("顧客一覧") .Hyperlinks.Delete .Move before:=Worksheets(1) For i = 2 To .Cells(Rows.Count, 2).End(xlUp).Row On Error Resume Next Worksheets(.Cells(i, 2).Value).Move after:=Worksheets(i - 1) On Error GoTo 0 Next i .Activate End With End Sub
コントロールソースは、「テーブル上の各フィールド」を設定します。 これだけでフォーム上で入れたものがテーブルに格納されます。 その後、コンボボックスの更新後処理イベントにおいて、 各テキストボックスに「代入」します。 Private Sub コンボボックス名_AfterUpdate() Me![テキストボックス1] = Me![コンボボックス名].Column(1) Me![テキストボックス2] = Me![コンボボックス名].Column(2) End Sub
[Ctrl]+[H]で置換画面を開きます。 検索する文字列には「*」を入れ、その右の「書式ボタン」を押して、該当の色の塗りつぶしを選択します。 置換え後の文字列にセットしたい数字（文字）を入れます。 「すべて置換」ボタンを押します。
上記のコードなら上書きで出力されます。 ただし、Application.GetSaveAsFilenameで保存先ファイル名を指定すると、出力先のフォルダは変更できますし、ファイル名も変更されてしまいます。 もう、確認せずに上書きするなら csvFile = "￥￥１１１．１１１．１１１．１１１￥データ" & dname & Format(buf, "mmdd") & ".csv" として、ファイル名を固定化してしまえば良いのではないでしょうか。
若干、誤解が生じそうな質問内容です。 Sub 一例です() Dim i As Long, rng As Range, rngs As Range Dim x1Adr As String, xrow As Long With Range("A1").CurrentRegion With .Offset(1).Resize(.Rows.Count - 1) For i = 1 To .Rows.Count If .Cells(i, 1).Value <> 0 Then Set rng = .Find(.Cells(i, 2).Value, LookIn:=xlValues, LookAt:=xlPart) If Not rng Is Nothing Then x1Adr = rng.Address Do rng.Font.Color = vbRed If rng.Column = 2 Then If rngs Is Nothing Then Set rngs = rng Else Set rngs = Union(rngs, rng) End If End If Set rng = .FindNext(rng) Loop While rng.Address <> x1Adr End If End If Next i If Not rngs Is Nothing Then Rows(2).Resize(rngs.Cells.Count).Insert rngs.EntireRow.Copy Rows(2).PasteSpecial rngs.EntireRow.Delete End If End With End With End Sub
コンボボックスの内容が変更されたときに、その値でVLOOKUP関数を使ってＢ列の内容を検索し、Ｃ１にセットする。 サンプル Private Sub ComboBox1_Change() If ComboBox1.ListIndex >= 0 Then Range("C1").Value = Application.WorksheetFunction.VLookup(ComboBox1.Value, Range("A:B"), 2, False) End If End Sub
シートが保護されているのですから、セルに色を付けることはできません。 方法としては (1) 保護を解除して色を付けて、再度保護する ActiveSheet.UnProtect Range("K5").Interior.ColorIndex = 3 ActiveSheet.Protect (2) 対象のセル（K5）のロックをはずしておき、シート保護する時に「セルの書式設定」は許可するようにする （VBAなら ActiveSheet.Protect AllowFormattingCells:=True） (3) シートの保護をする時にUserInterfaceOnlyを付ける これはVBAで保護する場合のみ指定できるオプションで、画面上からの変更は保護されますが、マクロからの変更は保護されません。 ActiveSheet.Protect UserInterfaceOnly:=True WorkSheetが保護されたときにセルを赤くする方法はわかりません。
http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1416000673... この質問に対して何の対応もせずに、同じ質問ですか？ 納得できる理由がなければ、マルチポストとして違反報告しますが？
dplyrというライブラリを使うと簡単にできます。 http://qiita.com/matsuou1/items/e995da273e3108e2338e 基礎編とJOIN編が参考になると思います。 Rの基礎はこのあたり http://cse.naro.affrc.go.jp/takezawa/r-tips/r.html グラフはggplot2があります。多少クセがありますので最初は一般的なplot命令がよいように思います。
APIを使って、wavファイルを再生します。 Windowsの効果音("C:\Windows\Media\tada.wav")を再生する例です。 Private Declare Function mciSendString Lib "winmm.dll" Alias "mciSendStringA" (ByVal lpstrCommand As String, ByVal lpstrReturnString As String, ByVal uReturnLength As Long, ByVal hwndCallback As Long) As Long Sub sample() Dim file As String file = "C:\Windows\Media\tada.wav" '再生したいサウンドファイル mciSendString "Play " & file, "", 0, 0 End Sub ただ、再生ファイルのフォルダ名やファイル名にスペースが含まれると再生できないので、スペースを含まないフォルダとファイルを用意してください。
こんにちは。 >Web ページからのメッセージ」ボックスに表示されているメッセージの取得方法を教えてください。 セキュリティの挙動の取得は、できませんよ。 ieのセキュリティがらみのウィンド画面の制御が必要なのでしょうか。 もしかして、ブラウザーのバージョンが違っていて、仕様の限界のようなきがしますど。
アプリも問題あるかもしれませんが、OSがなにかも判っていないし、 ミドルウェア有るなら、その辺りも変わってくるでしょう。 しかし、Windows7だったとしても推奨メモリは32ビットだとしても「快適に動作させる場合は2 GB 以上を推奨」と謳ってるんですから、想定外だと思いますけどね１Gメモリの環境は。
一例です。 Sheet1のシートモジュールに登録してお試しください。 Private Sub Worksheet_Change(ByVal Target As Range) If Target.Address(0, 0) = "A1" Then Select Case Target Case "a001", "a002": wk = "Sheet2" Case "b001", "b002": wk = "Sheet3" Case Else: wk = "Sheet1" End Select If wk <> "" Then Application.Goto Sheets(wk).Cells(1, 1) End If End Sub
せっかくなので確認してみました。 ClassLibrary1.dll側にForm1を追加して当該の処理を入れました。 backの戻り値を確認するためにCase文の前に Console.WriteLine(back.ToString) を追加してる以外は同じです。 Public Class Form1 ____Private Sub btnEnd_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEnd.Click ________Dim back As Long ________back = MsgBox(("当処理を終了し画面を閉じてよろしいですか"), vbOKCancel, "終了処理") ________Console.WriteLine(back.ToString) ________Select Case back ____________Case vbOK ________________'閉じる ________________Me.Close() ____________Case vbCancel ________________Return ________End Select ____End Sub End Class 一方新規で作成したプロジェクトでClassLibrary1.dllを参照設定して Form1を呼び出します。 雑ですいませんが名前が被るのでこちらのデフォルトFormはForm2にしてます。 ボタンを押すとdllのForm1をモーダルします。 Imports ClassLibrary1 Public Class Form2 ____Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click ________Dim f As New ClassLibrary1.Form1 ________f.ShowDialog(Me) ____End Sub End Class これを実行してみると正常に動作しました。 また、backにはキャンセル時に2、OK時に1が入ってるので正しく分岐出来てます。 ということで質問者さんのソースのbackの中身が気になるところです、 キャンセルしても閉じるということは、 Case文で分岐してるのにvbOKの方しか走ってないということですよね？ Console.Writelineで結果をチェックしてみてください。 と、根本的なところですが 右上の×印を押した時も確認処理を入れるのであれば そもそもボタンクリックイベントにこの記述するべきではないです。 画面を閉じるパターンは他にもAlt+F4のショートカットキーとかありますから 終了確認はFormClosingイベントに集約するといいと思います。 Public Class Form1 ____Private Sub btnEnd_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEnd.Click ________Me.Close() '閉じるだけ ____End Sub ____Private Sub Form1_FormClosing(sender As Object, e As Windows.Forms.FormClosingEventArgs) Handles Me.FormClosing ________If MsgBox(("当処理を終了し画面を閉じてよろしいですか"), vbOKCancel, "終了処理") _ ________= MsgBoxResult.Cancel Then ____________e.Cancel = True ________End If ____End Sub End Class
StreamはIDisposableインターフェースを実装しているので、コンストラクタで渡す設計は個人的にはしないですね。 ただ、IDisposableインターフェースを実装しているクラスでもテスト用のコンストラクタとして、StreamのMockなどを渡すように設計することはあり得ます。 その場合は（C)でしょうね。 また、Streamを引数とするメソッドを作る可能性は普通にあります。
シートにリスト形式でデータを作成ているならCountif関数で予め氏名に一致するデータのカウント数を出してIfステートメントで条件分岐し、カウント数が0だったらエラーメッセージを表示するようにする等がいいのでは？ あとは http://officetanaka.net/excel/vba/tips/tips142.htm 等が参考になるかもしれません。
シャットダウンを止める事は不可能。 シャットダウンプロセスは最高位の権限で実行されることなので一般のアプリからどうこうできる物じゃない。 それ以前にPCの電源ボタン長押しされれば、強制シャットダウンになるのでどんな手を使っても阻止できないから。 それがPC-AT互換機(一般的なパソコンの事)の仕様なので。
コードの記載がないので何ともですが、 2次元にしておいて、出現回数をカウントしては？ またはCountifで範囲内の数を数えるか。
ご質問の意図が分かりにくいのですが、 作成しコンパイル済みのプログラムを起動するのに、PowerShellを介したい、という意味ではないですよね？ それこそ、exeを呼び出しすれば良いだけですし、そんなわけはないんだと推察します。 何をどうしたくてどこがわからないのか、具体的にお願いします。
マクロでは有りませんが 4.0マクロ関数・GET.WORKBOOK シート一覧 名前定義で 名前 例 book 範囲 ブック 選択 参照範囲 =GET.WORKBOOK(1) =IFERROR(SUBSTITUTE(INDEX(book,ROW(A2)),"["&doc&"]",""),"") 下方向にコピー 4.0マクロ関数・GET.WORKBOOK ファイルは名前を付けて保存で xlsm形式で保存 http://www.tipsfound.com/excel2013/01306
'修正例 Public Sub str(ByVal a() As String) Dim x As Integer = a.Length - 1 Console.WriteLine(x * 4) End Sub それとVB.NETでは、配列の長さと添え字(Index)は異なります。 質問者さんの場合は Dim x As Integer = a.Length ではないでしょうか?
Set R = R.End(xlDown).Offset(1) は、セル R （最初はA1）から下方向に有効なセルを探して（[Ctrl]+[↓]を押した時とおなじ）、さらにその一つ下のセルを R にセットします。 ようするに、次にコピーするセル位置を移動させています。 なぜエラーになるかと言うと、コピーが１行しかされなかった場合、セル R のすぐ下は空白です。 そんな状態で[Ctrl]+[↓]を押すと最下行に行ってしまいますよね。 そのさらに次の行は無いためエラーになります。 回避するなら If R.Offset(1).Value = "" Then Set R = R.Offset(1) Else Set R = R.End(xlDown).Offset(1) End If とすると良いでしょう。 気のせいか、昼間にも同じようなコードを見たような気がしますが・・
>今日の日付を検索しようと思うのですが上手くいきません。 原因は、B列の日付は = B5 + 1 として日付を表現しているからです。単なる加算の場合は、その日付は見かけであって、本来の日付を表すシリアル値が存在しないからです。 そこで、現状のままで検索したいのであれば、B10からB161までの表示形式を「*2012/3/14」に変更して以下のコードで検索できます。 Sub Test() Dim FoundCell As Range, Hani As Range, myToday As Date Set Hani = Range("B10:B161") myToday = Range("B1") Set FoundCell = Hani.Find(What:=DateValue(myToday), LookIn:=xlValues) If Not FoundCell Is Nothing Then FoundCell.Select End If End Sub 表示形式を「m/d」などと表現したい場合は、日付のセルを「=B5+1」というものではなく、ちゃんと「2016/5/1」とシリアル値と認識できる日付で入力してください。連続日なら、日付を下にドラッグすると簡単に１日毎の日付になります。 シリアル値の日付にしたら表示形式を変更して、以下のコードにします。 Sub Test() Dim FoundCell As Range, Hani As Range, myToday As Date Set Hani = Range("B10:B161") myToday = Range("B1") Set FoundCell = Hani.Find(What:=DateValue(myToday), LookIn:=xlFormulas) If Not FoundCell Is Nothing Then FoundCell.Select End If End Sub ※変更したところはFindメソッドのLookIn引数の定数です。
こんにちは。 hiddenで、innertextは、見えないでしょ。 もし、取り出せたら、hiddenでない属性のときです。 どっちか。 .valueで取り出せるか、やってみてください
InputBoxは２つあるので注意してください。 Sub inputbox関数の例() Dim rtn rtn = InputBox("知恵袋の質問？") If rtn = "" Then Exit Sub MsgBox rtn & "が入力されました" End Sub Sub inputboxメソッドの例() Dim rtn rtn = Application.InputBox("知恵袋の質問？") If TypeName(rtn) = "Boolean" Then Exit Sub MsgBox rtn & "が入力されました" End Sub http://officetanaka.net/excel/vba/tips/tips37.htm
>条件 Z列が Cの場合、E列の値をA列に貼り付けたい（値のみ） であれば、Z列を順にチェックし"C"ならE列の値をA列に貼り付けます。 （サンプル） Sub Sample() Dim r As Long ’Ｚ列の先頭から最終行まで繰り返し For r = 1 To Range("Z" & Rows.Count).End(xlUp).Row 'Z列が"C"ならE列の値をA列にコピー If Range("Z" & r).Value = "C" Then Range("A" & r).Value = Range("E" & r).Value Next End Sub
シート２の全てのセルの値を貼り付け（コピーして値の貼り付け）すれば、シートをコピーしても問題ないと思います。 VBAで簡単に行う方法としては Worksheets("シート２").UsedRange.Value = Worksheets("シート２").UsedRange.Value Worksheets("シート２").Copy で一括して行うことができます。 ただし、このままではシート２の式が消えてしまいますので、保存せずに終われば元に戻りますが、それができない場合もあるでしょう。 その場合は、まずシート２をコピー。 そのあと、シート２の値を新しいシート（コピーしたシート）に値の貼り付けをします。 Worksheets("シート２").Copy ThisWorkbook.Worksheets("シート２").UsedRange.Copy ActiveSheet.Range("A1").PasteSpecial (xlPasteValues) Application.CutCopyMode = False
こんにちは。 >以前visual basicで作成された販売管理システム 示しているコードは、VBのコードではありません。 確認してください
>If Dir(Workbook_path & "\" & Filename & Right("00" & CStr(fCount), 3) & ".csv") = "" Then で、これから保存しようとしているファイル名の存在確認をしていますよね。 この時に、「And」を使ってサブフォルダ内についても存在確認をする方法はどうでしょうか？ If Dir(Workbook_path & "\" & Filename & Right("00" & CStr(fCount), 3) & ".csv") = "" And Dir(Workbook_path & "\サブフォルダ名\" & Filename & Right("00" & CStr(fCount), 3) & ".csv") = "" Then
UTF-8はUnicodeのエンコード方式の一つです。 Unicodeには複数のエンコード方式(UTF-16、UTF-8)などがありますが、規格内に収録している文字の文字集合(レパートリー)は同一です。 ただし、Unicode規格は今も改定されており、収録文字数は増え続けています。 UTF-16の場合、2文字の組(2バイト*2文字分)で1文字を表すサロゲートペアというものがあります。 Unicodeに対応しているシステムでもサロゲートペア文字を正しく1文字として扱わないで、2文字として扱うものもあります。 また、Unicodeは合成文字や異体字セレクター(IVS)など非常に複雑な仕組みを持つ仕様になっています。 シフトJIS(Shift_JIS)は元々規格があってできて文字コードではなく実装(三菱のマルチ16というPC用)が先にあって、その後日本のPC用の事実上の文字コードの標準として広まりました。 規格としては後追いでJIS規格のJIS X0208の付属書にシフト符号化表現として規定されました。 ただし、実装は各社のPCで異なっていて、各社のPCごとにエンコード方式は同じですが、レパートリーが異なる「シフトJIS」がありました。 今は、Windows上のシフトJISとMac OS9以前で使用されていたシフトJISに収斂しています。 Windows上のシフトJISは、「本当のシフトJIS」にNEC特殊文字とIBM拡張文字およびNEC選定IBM拡張文字を付加した文字集合を持ちます。 「本当のシフトJIS」と区別する場合は、コードページ932(CP932)やWindows-31J、MS 漢字コードなどと呼びます。 Mac OS9以前の「シフトJIS」はMacJapaneseと言います。 JIS X0208の後継規格であるJIS X0213には、Shift_JIS-2004が規定され、使用できる文字集合が拡張されましたが、増えた文字のコードポイントは従来のシフトJISと互換性がないので普及していません。 文字集合の大きさは Unuicode>CP932>Shift_JISです。 従って、Unicode→CP932/Shift_JISでは変換できない文字が出てきます。たとえば森鷗外の「鷗」は森鴎外にしないと文字化けします。 CP932→Shift_JISの場合は、前述のNEC特殊文字とIBM拡張文字およびNEC選定IBM拡張文字は使用できません。 どのような文字コードを使うかは使用するデータベースによってことなります。 たとえばSQL-Serverはchar、varcharで格納できる文字コードは日本語環境ではCP932です。nchar、nvarcharはUnicodeが格納できます。 Shift_JISは半角英数カナは1バイト、全角文字(漢字など)は2バイトでエンコードされます。 UTF-16は、Unicodeの基本多言語面にある文字は1文字2バイト、その他の拡張面にある文字は1文字4バイト(サロゲートペア)でエンコードされます。 UTF-8は1文字1バイト-4バイトでエンコードされます。ただしOracleの「UTF-8」は1-6バイトでエンコードされます。本来のUTF-8の場合は、Oracleでは「AL32UTF8」という名称になっています。 1バイトの文字はASCIIにある文字で、漢字やカナは3バイトでエンコードされます。 なお、合成文字やIVSが使用される場合は、1文字のバイト数は、バイナリーエディター等で確認するまでわかりません。
マクロの一例。 データはSheet1のA列からD列で20行目までとしています。データはSheet2に転記。 Sub Test() Dim i As Long, j As Long, k As Integer k = 1 For i = 1 To 20 Step 2 For j = 1 To 4 Step 2 If Cells(i, j) <> "" Then Cells(i, j).Offset(1).Resize(, 2).Copy Sheets(2).Cells(k, 1) k = k + 1 End If Next j Next i End Sub
WIN2015ってものが何物か判りませんが、EXCEL2007であれば。 「こちらの3行で1データにつき、1グラフを300こ近く作りたいのですが、 マクロなどで可能でしょうか？」 と言う質問の回答は 「可能」です
「"0:00"になったら、処理を終了する」となっているので、モジュール自身をコールしたら？
「デスクトップ」や「マイ ドキュメント」などの特定のフォルダ名は物理的なパス名と異なっています。 もしかして、TextBox1にはそういう名前を指定していませんか？
ブックBをアクティブにして、実行してください。 Sub 一例です。() Dim rng As Range, xPath As String, sh As Worksheet, sh0 As Worksheet, i Application.ScreenUpdating = False Set rng = Workbooks("ブックA.xlsx").Worksheets("シート2").Columns(1) With ActiveWorkbook xPath = .Path & "\" For Each sh In .Worksheets With sh i = Application.Match(.Name, rng, 0) If Not IsError(i) Then If sh0 Is Nothing Then .Copy Else .Copy after:=sh0 Application.DisplayAlerts = False sh0.Delete Application.DisplayAlerts = True End If Set sh0 = ActiveSheet sh0.Parent.SaveAs Filename:=xPath & rng.Cells(i).Offset(, 1).Value & "様分" End If End With Next sh End With If Not sh0 Is Nothing Then sh0.Parent.Close savechanges:=False End If Application.ScreenUpdating = True End Sub
With Worksheets("Sheet1")の部分以降を関数化して、目的のWorksheet名を引数で渡すのが一番簡単だと思いますね。 Sheet1から5まですべてが対象ならば、for each文で回す手も有りますが、複数シートの内特定のシートだけとなると、別関数にした方がすっきりすると思います。
提示されている添付図を参考にしています。 職員番号を入力するシートにボタンを配置して、そのボタンに下のマクロを登録してください。 また、次のことを前提にしています。 ・職員番号はB4に入力 ・C3に「氏名」、その下のC4は自動的にマクロで氏名が表示される ・D6とE6に、「品名」、「数量」という見出しが書かれている。 ・一覧シートの一行目に見出し「職員番号」「氏名」「品名」「数量」がある Sub KensakuDelete() Dim Bangou As Integer, FC As Range, Hani As Range Dim Ichiran As Worksheet, EndRow As Long, i As Long Set Ichiran = Worksheets("一覧") Bangou = Range("B4").Value Set Hani = Ichiran.Range("A1").CurrentRegion Set FC = Hani.Columns(1).Find(What:=Bangou, LookAt:=xlWhole) If Not FC Is Nothing Then Range("C4") = FC.Offset(, 1).Value Else MsgBox "該当する番号はありません" Exit Sub End If With Hani .AdvancedFilter xlFilterCopy, Range("C3:C4"), Range("D6:E6") End With EndRow = Range("D" & Rows.Count).End(xlUp).Offset(1).Row Range("D" & EndRow).Value = "合計" Range("D" & EndRow).Offset(, 1).Formula = "=SUM(E7:E" & EndRow - 1 & ")" '削除 With Ichiran EndRow = .Range("A" & Rows.Count).End(xlUp).Row For i = EndRow To 2 Step -1 If .Range("A" & i) = Bangou Then .Rows(i).EntireRow.Delete End If Next i End With End Sub
データの種別[単なる実数ベクトルなのか何らかの 構造化データなのか]でも変わってくるでしょうけど… 外れ値 R でネット検索するだけで それなりに引っかかるかと。 http://www.okadajp.org/RWiki/?cmd=read&page=R%E3%81%A7%E3%83%87%E3%... bl<-hazureti(iris$Sepal.Width) iris$Sepal.Width[ bl$caselist] #外れ値を抽出# iris$Sepal.Width[!bl$caselist] #外れ値以外# #※分散も var(～) で計算可能 http://www.geocities.jp/ancientfishtree/R_JI.html ページ内を外れ値で検索[sg.RはUTF-8] 自分でも検索して見れば良いのでは。
Dim RAI As Integer = CInt(TextBox2.Text) ここじゃないかしら？ TextBox2の内容が数値か同か保障されていませんよね。おそらく。 http://adonetvb.com/Learning/TryParse.html この辺り確認してみてください。
試していませんが以下でどうですか 'TimeSpanで1時間0分0秒を計算しておいて Dim d As New TimeSpan(1, 0, 0) '上記dの分だけ引き算 Dim c As TimeSpan = b - a - d ' #01:00:00# ■参考 http://dobon.net/vb/dotnet/system/datetimecal.html
ぱっと見ですが、問題があるようには思えません。 > LST = Wsb.Columns("Z").Find(objFind).Row > LST = objFind.Row ... なんで2つの行のコードをわざわざ変えているの? という疑問はありますが...。 > 実際表にはまだまだ250行や590行にも山田はあります。 検索でヒットした山田と上記2行の山田は別なんじゃないですか?現状の検索では完全一致したセルしか検索していません。例えば『山田 』とか『 山田』とか空白があったりすると除外されます。『山 田』とかだとFindメソッドでは検索できないですね。確認してみて下さい。 https://msdn.microsoft.com/ja-jp/library/office/ff839746.aspx F8キーでステップ実行しつつ、ローカルウィンドウやウォッチウィンドウで変数や式の変化状況を確認してみるといいでしょう。 それでは。
Y1には5や12といった数字が入っていることを想定しているようですが、 実際に入っているのは日付のシリアル値で書式設定で月だけを表示しているようにしていませんか？ ステップ実行は試してみましたか？
たぶん、「Workbooks("5月線量結果.csv").Worksheets("5月線量結果")」の部分が毎月変わるので困っておられるのですよね。 ワークブック（CSVファイルも）を開いた時、そのブックを変数にセットできます。 さらにCSVファイルならシートは１つしかありません。 開いたブックが変数にセットされ、さらに１つ目のシートを処理すればいいわけですから、名前などわからなくても処理ができます。 Dim WB As Workbook Set WB = Workbooks.Open(FileName:=strFileName) WB.Worksheets(1).Range("A:A,C:C,D:D,E:E,F:F,H:H,I:I,K:K,L:L,M:M,N:N,P:P,Q:Q,R:R,S:S").Select Range("S1").Activate Selection.Delete Shift:=xlToLeft 以降 「Workbooks("5月線量結果.csv").Worksheets("5月線量結果")」を「WB.Worksheets(1)」に置き換えます。 また、最後あたりの ActiveWorkbook.Saved = True ActiveWorkbook.Close は WB.Saved = True WB.Close と書けます。 （または WB.Close SaveChanges:=False でも良いかと思います）
ActiveCellは、B列内にありますか？ After:= は、そのセルの次から範囲内を検索します。After:=に指定したセルが検索範囲内になければいけません。
C列に品番があり、それを検索し連番分上の行にあるヘッダの行をヘッダで検索する例です。 Functionプロシージャ化してありますので、品番、ヘッダの文字列を引数にして呼び出すと、品番の行とヘッダの列の交わるところの値を返します。 なお、ヘッダが２行あることを考慮し、ヘッダの引数は２つ指定できるようにしてあり、２つ目のヘッダーは省略可能。省略した場合は１つ目のヘッダのみで検索し、最初に現れたものを返します。また２つ指定があってもヘッダがひとつしかない場合は無視します。 また、検索するシートはアクティブシートとしています。 検索した結果、該当の品番、ヘッダがない場合はNullを返します。 Function 検索サンプル(Hinmei As String, _ Header1 As String, Optional Header2 As String = "") As Variant Dim Rng As Range Dim x As Long Dim y As Long Dim z As Long Dim i As Long 検索サンプル = Null With ActiveSheet '品名、ヘッダ１のどちらかが空値なら終了 If (Hinmei = "") Or (Header1 = "") Then Exit Function '品名の検索（完全一致） Set Rng = .Range("C:C").Find(What:=Hinmei, LookIn:=xlValues, LookAt:=xlWhole) '品名がなければ終了 If Rng Is Nothing Then Exit Function '品名が一致した行（x）を控える x = Rng.Row '連番数上の行（i）が１より小さい、あるいはヘッダでなければ終了 i = x - Rng.Offset(0, 2) If i < 1 Then Exit Function If .Range("E" & i).Value <> "ヘッダ" Then Exit Function 'ヘッダ１の検索 Set Rng = .Range(i & ":" & i).Find(What:=Header1, LookIn:=xlValues, LookAt:=xlWhole) 'ヘッダ１がなければ終了 If Rng Is Nothing Then Exit Function 'ヘッダ１が一致した列（y）を控える y = Rng.Column 'ヘッダ２の指定があり、ヘッダが２行ある場合は一致するまでヘッダ１を繰り返し検索 If (Header2 <> "") And (.Range("E" & i + 1).Value = "ヘッダ" Then '最初に検索した列を控えておく z = y Do 'ヘッダ２が一致すればループを抜ける If .Cells(i + 1, y).Value = Header2 Then Exit Do '次にヘッダ１が一致するセルを検索 Set Rng = .Range(i & ":" & i).FindNext(Rng) y = Rng.Column '最初に検索したセルに戻ったらヘッダ２に一致するものがないので終了 If y = z Then Exit Function Loop End If '一致した行（x）、列（y）の値を返す 検索サンプル = .Cells(x, y).Value End With End Function
ファイルをwモードで開いているため、毎回1文字が上書きされています。 モードを変更するか、文字列にしてから書き込むようにしましょう。
初回の検索セルをループ終了としていましたが、「,」が置換されるとエンドレスループとなるので少し修正してみました。 Sub sample2() Dim r As Range, r_end As String Set r = Range("A4:A1000").Find(What:="*") If r Is Nothing Then Exit Sub r_end = r.Address With CreateObject("VBScript.RegExp") .Pattern = "(\d)(,)(\d+?)" .Global = True Do r = .Replace(r, "$1$3") Set r = Range("A4:A1000").FindNext(r) Loop Until r_end = r.Address End With End Sub
値集合ソースは元になるデータはテーブルですか？ 以下、テーブルの場合の回答になります。 それ以外はできません。 値集合ソースの元になるテーブルにテキストボックスの値を追加する 追加クエリを作成し、コマンドボタンをクリックしたら追加（クエリの実行) するようにします。 その後、マクロのアクションで「再クエリ」処理すると、 ②の値集合ソースの表示に反映されます。
表示したいのは特定のセルに対してでしょうか？ それならば、セルの書式設定をすれば良いのではないでしょうか。 Range("A1").NumberFormatLocal = "m/d" その上でセルに日付を入れます。
(ポリシーとして、直接的なコードの回答は避けております。ご容赦ください。) 初心者ならば、[ツール]-[オプション...] → 「変数の宣言を強制する」にチェックを入れて、各変数ごとに、きちんとDim構文で宣言した方がいいです。コード記述のミスを早期発見できます。 2つのファイルを使うのでしたら、それぞれのブックにて使用するシートをオブジェクト変数に割り当てる事で、簡単に記述できます。Dim文とSet文を使います。たとえば変数CにWorkbook("データ出力先.xlsx").Worksheets("sheet1")が割り当てられている場合、 C.Cells(1,1).Value = "test" でセルA1にtestという文字が入力できます。 >FormulaR1C1 これはセルにR1C1形式の数式を代入、あるいは取得するためのプロパティです。セルの値の操作には、これ以外にも、Formura・Value・Value2・Text があります。それぞれ用途が異なりますので調べてみて下さい。まぁ、だいたいFormuraとValueしかつかいませんけどね。日時とお金の時だけ、あえてValue2を使う事があるかもしれません。 >書き方がわかりません VBEの画面でヘルプを見れば分かります....というのも投げやりすぎですか。概要は書きますが、あとでヘルプも見てみて下さい。ただし、今回の内容はIfよりもSelect Case の方がいいでしょう。あと、「Excel VBA Select Case MSDN」でググると、マイクロソフトのネット上のヘルプに辿りつけます。 Select (調査対象の値) case (条件1) (処理するコード) case (条件2) (処理するコード) case else (処理するコード) end Select 今回、調査対象の値は、データ元のB列の値ですね。条件1は「データ」とか「項目型」とか、文字列になります。調査対象の値と条件1が一致すると、処理するコードが実行されます。 質問の中にはありませんでしたが、上記の処理を「複数の行で」処理する必要があるのではありませんか? その場合、処理する行の行数を変数にして、この変数を2行目から最終行まで変化させながらループ処理をさせる必要があります。For ～ Next 文ですね。「Excel VBA For Next MSDN」でググッて見て下さい。 ググった上で、分からない内容があれば、返信頂ければ回答します。 それでは。
コード例です。 動作検証していないので、不具合があればご返信ください。 Sub Sample() Dim buf As Variant Dim Bk As Workbook Dim DestRng As Range Dim CopyRng As Range Dim i As Long Set Bk = Workbooks.Open(FileName:="C:\共有\マクロ.xlsx") For Each buf In Array("様式A", "様式B") Set CopyRng = ThisWorkbook.Worksheets(buf).Range("B16:AA2000") Set DestRng = Bk.Worksheets("様式" & i + 1).Cells(Rows.Count, "B").End(xlUp).Offset(1) Set DestRng = DestRng.Resize(CopyRng.Rows.Count, CopyRng.Columns.Count) DestRng.Parent.Protect userinterfaceonly:=True DestRng.Value = CopyRng.Value DestRng.Parent.UsedRange.EntireRow.RemoveDuplicates 2 i = i + 1 Next Bk.Close SaveChanges:=True MsgBox "『マクロブック』へ" & vbCrLf & "データ転送しました。" End Sub
こんにちは。 シートのイベントのマウス右クリックイベントで cancel=trueとすると、選択のときの、メニューが表示しません。 よく使うのは、むしろ、こっちですけどね。
仕様が一部不明ですが、登録で重複チェックするのは品名だけでいいのでしょうか。 TextBox1とTextBox2とCommandButton1が登録用です。 TextBox3とTextBox4とCommandButton2が削除用です。 TextBox5とTextBox6とListBox1とCommandButton3とCommandButton4が修正用です。 修正は、TextBox5とTextBox6に品目とロケーションを入力してCommandButton3を押すと、ListBox1に対象を表示します。 ロケーションを入力しないときは品目が一致したものをすべて表示します。 ListBox1をクリックすると、修正モードのなるのでロケーションを修正してCommandButton4で修正実行です。 修正はわかりにくい操作になってしまいました。 もっと操作を工夫した方がいいかもしれません。 '登録 Private Sub CommandButton1_Click() '入力チェック If TextBox1.Value = "" Then '品目入力チェック MsgBox "品目は必須です" TextBox1.SetFocus '品目選択 Exit Sub End If '重複チェック Dim lastRow As Long Dim n As Integer lastRow = Range("A" & Rows.Count).End(xlUp).Row 'A列最終行 n = WorksheetFunction.CountIf(Range("A2:A" & lastRow), TextBox1.Value) '品目の重複カウント If n > 0 Then '重複があれば If MsgBox("品目が既に" & n & "個あります" & vbCrLf & "登録しますか？", vbYesNo) <> vbYes Then Exit Sub 'Yesじゃなければ中止 End If '登録(A列最終行の下に) Range("A" & lastRow + 1).Value = TextBox1.Value Range("B" & lastRow + 1).Value = TextBox2.Value '次に備える(必要なら) TextBox1.Value = "" TextBox2.Value = "" TextBox1.SetFocus End Sub '削除 Private Sub CommandButton2_Click() '入力チェック If TextBox3.Value = "" Then '品目入力チェック MsgBox "品目は必須です" TextBox3.SetFocus '品目選択 Exit Sub End If 'データチェック Dim lastRow As Long Dim n As Integer lastRow = Range("A" & Rows.Count).End(xlUp).Row 'A列最終行 n = WorksheetFunction.CountIfs(Range("A2:A" & lastRow), TextBox3.Value, Range("B2:B" & lastRow), TextBox4.Value) '品目とロケーションの組み合わせの重複カウント If n = 0 Then '重複が無ければ MsgBox "見つかりません" Exit Sub End If If MsgBox(n & "個の重複がありました" & vbCrLf & "削除しますか？", vbYesNo) <> vbYes Then Exit Sub '削除を確認 '削除 Dim target As Range Dim r As Long For r = 2 To lastRow '2行目から最終行まで If (Range("A" & r).Value = TextBox3.Value) And (Range("B" & r).Value = TextBox4.Value) Then '品目とロケーションが同じなら If target Is Nothing Then '初めての対象なら Set target = Rows(r) '削除対象を設定 Else '初めてじゃなければ Set target = Union(target, Rows(r)) '削除対象に追加 End If End If Next target.Delete xlShiftUp '削除対象を削除して上に詰める '次に備える(必要なら) ListBox1.Clear TextBox3.Value = "" TextBox4.Value = "" TextBox3.SetFocus End Sub '初期設定 Private Sub UserForm_Initialize() ListBox1.ColumnCount = 2 'ListBox1の初期設定(プロパティで設定すれば不要) End Sub '検索 Private Sub CommandButton3_Click() '入力チェック If TextBox5.Value = "" Then '品目入力チェック MsgBox "品目は必須です" TextBox5.SetFocus '品目選択 Exit Sub End If ' Dim lastRow As Long Dim n As Integer lastRow = Range("A" & Rows.Count).End(xlUp).Row 'A列最終行 If TextBox6.Value = "" Then 'ロケーションなければ n = WorksheetFunction.CountIf(Range("A2:A" & lastRow), TextBox5.Value) '品目の重複カウント Else '違ったら n = WorksheetFunction.CountIfs(Range("A2:A" & lastRow), TextBox5.Value, Range("B2:B" & lastRow), TextBox6.Value) '品目とロケーションの組み合わせの重複カウント End If If n = 0 Then '無ければ MsgBox "見つかりません" Exit Sub '中止 End If 'リストボックスに登録 Dim r As Long ListBox1.Clear For r = 2 To lastRow If Range("A" & r).Value = TextBox5.Value Then '品目が一致して If (TextBox6.Value = "") Or ((TextBox6.Value <> "") And (TextBox6.Value = Range("B" & r).Value)) Then 'ロケーション無しか、ロケーションありで一致したら ListBox1.AddItem Range("A" & r).Value 'Listbox1に品目追加 ListBox1.List(ListBox1.ListCount - 1, 1) = Range("B" & r).Value '2列目に品目追加 ListBox1.List(ListBox1.ListCount - 1, 2) = r '3列目に何行めかを追加(見えない) End If End If Next End Sub 'リストボックスクリック Private Sub ListBox1_Click() If MsgBox("品目：" & ListBox1.List(ListBox1.ListIndex) & vbCrLf & "ロケーション：" & ListBox1.List(ListBox1.ListIndex, 1) & vbCrLf & vbCrLf & "を修正しますか？", vbYesNo) <> vbYes Then Exit Sub '修正しないなら終わり '修正表示 TextBox5.Value = ListBox1.List(ListBox1.ListIndex) '品目表示 TextBox6.Value = ListBox1.List(ListBox1.ListIndex, 1) 'ロケーション表示 TextBox5.Tag = ListBox1.List(ListBox1.ListIndex, 2) '今表示しているデータの行をTextBox5のTagに格納(Gloval変数用意してもいい) End Sub '修正実行 Private Sub CommandButton4_Click() '入力チェック If TextBox5.Tag = "" Then 'まだデータが選ばれてなければ MsgBox "データが選ばれてません" Exit Sub End If If TextBox5.Value = "" Then '品目入力チェック MsgBox "品目は必須です" TextBox5.SetFocus '品目選択 Exit Sub End If If MsgBox("修正してもいいですか？" & vbCrLf & "品目は修正されません", vbYesNo) <> vbYes Then Exit Sub '修正実行 Dim r As Long r = TextBox5.Tag '修正対象行 'Range("A" & r).Value = TextBox5.Value '品目(修正するなら) Range("B" & r).Value = TextBox6.Value 'ロケーション '後始末(必要なら) TextBox5.Value = "" '品目 TextBox6.Value = "" 'ロケーション TextBox5.Tag = "" '行 TextBox5.SetFocus 'TextBox5選択 End Sub
Application.CommandBars("Cell")の部分を Application.CommandBars("Shapes") とするのが基本ですが(上URL)… バージョンにより違いがあるようです（下URL) http://excelwork.info/excel/shortcutmenu/ http://www.ka-net.org/blog/?p=5093
このコードを入力シートのシートモジュールに貼り付けてください。 Private Sub Worksheet_Change(ByVal Target As Range) If Target.Value = "" Then Exit Sub If Target.Count <> 1 Then Exit Sub If Target.Column = 2 Then If Len(Target.Value) <> 13 Then MsgBox "13桁の数字を入力してください。" Target.Select Exit Sub ElseIf Not IsNumeric(Target.Value) Then MsgBox "13桁の数字を入力してください。" Target.Select Exit Sub Else Application.EnableEvents = False Target.Resize(, 3).NumberFormatLocal = "@" Target.Offset(, 3).Value = Mid(Target.Value, 13, 1) Target.Offset(, 2).Value = Mid(Target.Value, 9, 4) Target.Offset(, 1).Value = Mid(Target.Value, 5, 4) Target.Offset(, 0).Value = Mid(Target.Value, 1, 4) Application.EnableEvents = True Target.Offset(, 4).Select End If ElseIf Target.Column = 6 Then Target.Offset(1, -4).Select End If End Sub まず、B列に13桁の数字を入力してします。 13桁を4つのセルに自動で分割します。 次にF列に入力を終えると次の列のBセルに飛びます。
こんにちは。 csvを扱うときに、「どこに着目するか」ですが、 テキストファイルの1行目と2行目について、できるだけ細かく、状況を把握。 csvのファイルは、1行目が見だしなのか、そうでないか、は、違いを明確にする必要があります。 データ部分の説明ですが、「コンマ記号」が区切りなので、 一つ目が数値なのか、文字列なのか、文字列の場合、区切り記号でダブルクォーツがある、とか、ない、とかです。 次、仕様の説明、 パーターンAの場合は、かくかく、しかじか、というデータになります。 という説明が必要。 これらを、正しく表現できないと、コードには、なりません。 処理の内容で見ると、エクセルでなくてもできるような課題なので、 「どんな入力」「処理内容」「どんな出力」をきちんと整理できている必要があります。 あと、説明の内容では、「出力」について、説明が不十分です。 出力は、 出力のシートは、この名前、1行目の構成は、かくかくになっていて、 読み込みしたデータは、列AとBと、というように、 読み込みしたデータ1つが、出力には、どうなっている、ということが、わからないといけません。 計算する、といえば、数値の合計ができること、項目は、どうする、となり、読み込みがたとえは100行あって、出力は何行になるか、も、イメージしていないといけません。 それらの整理をしていったら、コードも、できますよ。
セルの選択がひとつの場合は、Buffer = rngTarget.Value としても Buffer が配列にはなりませんので、IsArray で配列かどうか判定して処理を分岐させます。 配列ではない（セルの選択がひとつの場合）は単に Buffer に対象セルの値が入るだけなので、その先頭の空白を除くだけです。 （修正したサンプル） Sub 空白を削除() Dim rngTarget As Range Dim Buffer As Variant Dim lngRowCnt As Long Dim lngColCnt As Long Dim k As Long, j As Long Set rngTarget = Selection Buffer = rngTarget.Value If IsArray(Buffer) Then '選択範囲が単一ではない場合は配列の処理 lngRowCnt = UBound(Buffer) lngColCnt = UBound(Buffer, 2) For k = 1 To lngRowCnt For j = 1 To lngColCnt Buffer(k, j) = LTrim$(Buffer(k, j)) Next j Next k Else '選択範囲が単一のばあいは、１セルの処理 Buffer = LTrim$(Buffer) End If rngTarget.Value = Buffer Set rngTarget = Nothing End Sub
前の質問に対する回答で誤解が生じたのかもしれませんね。 UserForms.Add(FormNameBox2.Text) で取得したユーザーフォームは、既に開いているUserForm1とは別物の新しいUserForm1オブジェクトなんです。 .List(i) でリストボックスの内容を取ってこれたりしますが、それは新しいUserForm1のリストボックスの内容なんです。 だから、それに対して .SetFocus したり、.ListIndex = i しても、元のUserForm1の内容は変わりません。 その場合、現在開いているユーザーフォームコレクション（UserForms）からユーザーフォームオブジェクトを取り出し、対象のユーザーフォームかどうかを判定します。 その場合 .Name ではなく TypeName(オブジェクト）で判定します。 詳しくは以下のサンプルを見てください。 （UserForm2 の CBtn2_Click サンプル） Private Sub CBtn2_Click() Dim i As Long Dim uf As UserForm If TextBox2.Text = "" Then Exit Sub 'UserFormsからUserFormを順に取り出す For Each uf In UserForms 'UserFormのタイプ名がFormNameBox2と一致した場合 If TypeName(uf) = FormNameBox2.Text Then 'ListBNameBox2のコントロール（ListBox）に対して操作 With uf.Controls(ListBNameBox2.Text) 'リストの中身を順にTextBox2と比較 For i = 0 To .ListCount - 1 If .List(i) = TextBox2.Text Then '一致すればListIndexを変更 'MsgBox i & "番目に見つかりました" '****************************** .SetFocus .ListIndex = i '****************************** Unload Me Exit Sub End If Next End With MsgBox "見つかりませんでした" Exit Sub End If Next MsgBox "フォームが見つかりませんでした" End Sub
おおおぅ、回答リクエストなんて初めてもらった....。 maschsuke12さんとpurinkichiさんのやりとりを踏まえています。他人のふんどしで相撲を取るようでmaschsuke12さんには申し訳ないのですが....。 > やってみましたがエラーになりました。 → コードにて、「Sub ●●●() 」というのは、「ここが●●●というプログラムの始まりですよ」と言う事を意味しており、「End Sub」までを●●●というプログラムの塊として扱います。よって、Sub の行からend Sub までの行の間にSubの行を含めることはできません。また、Sub・End Sub 共に単体で使う事は出来ず、必ずセットで使います。 > 最終行の下ではなく、各No.の行の下に1行だけ追加する方法はありまっせんか？ → 表を見てみると、1つの項目(図面番号?)にて複数の行を使用している部分もありますね。なおかつ、1行だけを追加する場合、セルの結合か、あるいは間の罫線の削除をしているようです。（しかも、行11～13に関しては、11～12行目には罫線があるのに12～13行目には罫線がない。） 1行だけの追加の場合には追加の処理が必要になるのではないですか？ その場合、図面番号としての追加なのか、図面番号の入力行を1行追加なのか、判断が必要になります。最終行の追加のみ図面番号としての追加、という事であれば、追加する行が最終行かどうかをVBAで判断させることは出来ます。しかし、そうでない場合（途中でも図面番号としての追加があり得る or 最終行であっても1行追加があり得る）場合には、行の挿入がどっちのパターンかVBAでは判断できないのではないでしょうか。 後者の場合、図面番号追加用のコードとは別に、1行だけ追加のコードを別に用意する必要があります。 図面番号追加用のプロシージャ(=sub～end subの塊の事)はmaschsuke12さんの提示されたコードで大丈夫です。 1行追加のプロシージャは、画面追加用のプロシージャを利用し、End Subの1行上に、セルを結合するか罫線を削除するコードを挿入すれば出来ます。もちろん、図面番号追加用のプロシージャとは別の名前にして下さいね。 あ、ActiveXコントロールのクリックイベントだから、プロシージャ名は固定でしたね。 結合や、罫線の削除はマクロの自動記録機能を使っててきとうに記録して、生成されたコードを見れば記述方法が分かるでしょう。 複数領域のセルの選択は、 Range(セルを示すオブジェクト1,セルを示すオブジェクト2) で記述できます。Rangeでヘルプを見てみて下さい。Selectionと、Offsetも必要になるでしょう。 maschsuke12さんのコードでは、Offset(1)となっていますが、これはOffset(1,0)を省略して記述したものです。 ここまでの内容を ＋ VBAのヘルプと、MSDNを見れば、思い通りのコードが記述できると思います。 マクロは作るのは大変ですが、メンテナンスはもっと大変です。自分で運用するコードは自分で把握しておかないと、トラブルがあった時 ( 大抵そんな時は緊急で対応しないといけない ) に痛い目にあいます....。 困った時はこちらのサイトをよく利用していました。 http://officetanaka.net/ それでは。
miximixi788さん プログラムは完結したものを書くと、テストできる。
ExecuteExcel4Macroにはパスワードを指定するオプションはありませんので、 Application.SendKeys "password" Application.SendKeys "{Enter}", True Cells(2, 4) = ExecuteExcel4Macro('D:\M管理DATA\[データ2015.xls]データBOX'!R25C4) とします。 「excel vba ExecuteExcel4Macro パスワード」でググったら沢山ヒットしましたよ。
ユーザーフォームの 中に シートのデーターを 表示するのは 無駄が多いと思います。 そのデーターの数だけテキストボックスを コントロールする必要が有りますので、そのマクロが必要。 ただ そのUSERFORMを 開いたまま 別シート 今回の場合 表示したいシートに 移動する事は可能です。 USERFORMの ＳｈｏｗＭｏｄａｌ を FALSEに しておけば USERFOM表示したまま 他の動作 シートの移動や セル入力が出来ます。
とりあえず、ざっくりこんな感じでどうでしょう。 ☆Module1☆ Public num As Integer '問題番号 Public exitFlg As Boolean '終了フラグ Sub Start() num = 1 '問題番号1から始めます exitFlg = False '終了フラグ=False For i = 1 To 5 '５問繰り返します If exitFlg Then '終了フラグがTRUEの場合、終了します。 Exit Sub End If UserForm1.Show 'ユーザーフォームを表示 Next End Sub ☆UserForm1☆ '初期化 Private Sub UserForm_initialize() TextBox1 = Worksheets(1).Cells(num + 2, 2) 'テキストボックスに、「num+2」行目の問題を表示します 'OptionButton1～5に、答えを設定していきます。 For i = 1 To 5 Me.Controls("OptionButton" & CStr(i)).Caption = Worksheets(1).Cells(num + 2, i + 2) Next '↑ '左辺は説明すると長くなるので調べてみてください…。 '右辺は、「num+2」行目、「i + 2」列目の答えを設定するようにしています。 End Sub 'CommandButton1クリック Private Sub CommandButton1_Click() '■変数を宣言 Dim myCtrl As Control 'チェックボックスやオプションボタンのON/OFFをまとめて管理するためのコントロール Dim flg As Boolean 'オプションボタンを押してあるかを調べるチェックフラグ '■OptionButtonに未選択がないかチェック For Each myCtrl In Controls 'UserForm1上のコントロールをひとつずつ調べます If TypeName(myCtrl) = "OptionButton" Then 'コントロールのタイプが「オプションボタン」のものだけを調べます If myCtrl.Value Then 'もしオプションボタンの値がTRUEだったら flg = True 'フラグをONにします。 End If End If Next '■結果判定 If flg = False Then 'フラグがFALSEだったら ret = MsgBox("答えを選択してください！！", 48, "注意") ElseIf Me.Controls("OptionButton" & CStr(Worksheets(1).Cells(num + 2, 8))) Then '正解のオプションボタンが選択されていたら MsgBox ("正解") Else '上記以外だったら MsgBox ("不正解") End If End Sub '次の問題へ進む Private Sub CommandButton2_Click() 'UserForm1を閉じます Unload UserForm1 '次の問題番号へ num = num + 1 End Sub 'UserForm1を閉じます Private Sub CommandButton3_Click() Unload UserForm1 exitFlg = True End Sub
コード最適化されたら、 デバッグ・ストップできない行が、 含まれ兼ねませんから、 デバッグ・モードのコンパイルでは、 一般に、最適化は、施されません。 それは、Xcode も同じはずです。 プログラムを終わらせないで、 もう一度、同じ処理をしても 同じ処理時間ですか？ Windows では、.exe の実行時に、 DLL が、Load on Call（デフォルト） になっていると DLL 内の何れかの関数の最初のコールで 初めてメモリーへのロードが起きるので、 複数の DLL が、関与する場合、 それぞれの初回で、負荷を生じるはずです。 DLL には、Preload という設定も可能で、 予備元 .exe の実行のタイミングで 関連 DLL は、メモリーにロードされます。 これに関連して、Ｘcode の環境との違いを検証してみて下さい。
明瞭な回答ではありませんが、、、 黄色行は「この次にこの行を実行するぞ」の印なので、この時点ではRange("E7").Valueの値がEmptyであっても異常ではありません。むしろ気になるのは黄色行でのKATABANの値です。こちらが異常でエラー終了しているのですから。
>objInpTxt.Value = "Range("A1")" を objInpTxt.Value = Range("A1") に 個人的には objInpTxt.Value = Range("A1").Value か objInpTxt.Value = Range("A1").Text にしてほしい。
以下のコードでいかがでしょうか？ Sub Sample() If WorksheetFunction.CountIf(Range("F1:F20"), 1) > 0 Then MsgBox "1表示あり" End If End Sub
どの表を取り出すのかが分からないのですが、基本的には、TABLEタグを取り出し、その中のTRタグを抽出、更に各TRタグ毎にTHもしくはTDタグを抽出して各要素を取り出す、という手順になります。 'TABLEタグを取り出す '末尾の括弧番号はTABLEタグの出現順序 '2番目を取り出す場合は1に変更 Set tbl=ie.document.getElementsByTagName("table")(1) 'TRタグを取り出す 'これが行方向にあたる Set tr=tbl.getElementsByTagName("tr") 'THタグ(タイトル行)を取り出す Set th=tr(0).getElementsByTagName("TH") '各タグのテキストをセルに代入 For c=1 To th.Length Cells(1, c).Value = th(c-1).InnerText Next '行方向ループ For r=2 To tr.Length 'TDタグ取り出し Set td=tr(r-1).getElementsByTagName("td") '列方向ループ For c=1 To td.Length 'タグのテキストをセルに代入 Cells(r, c).Value = td(c-1).InnerText Next Next
こんにちは。 A1からJ1のコピーを、ソートの後で実行していますよね、この「値貼り付け」は、 AEの値貼り付けの次に、実行を、検討してください ソートは、できるだけ、値だけの状態にします。 列を非表示にしていますが、最初に全部見えるようにしていないのは、どうしてなんでしょうね。 フィルターの解除は、再計算のきっかけとなります。 最初にフィルターを解除してから、フィルターを実行しないようにしてください。 ソート対象が2000行ということですが、シートは、最小のデータにすること、できるだけ削除は、実行してください。 ターゲットのブックのシートは、ひとつでしょうか、複数でしょうか。 計算式も、できるだけ少ないのがいいです
こんにちは。 Do While obIE.readyState <> 6 の行は Do While obIE.readyState <> 4 ですね。 ループには、doeventsをさせてください。 それで、wait行の手前まで、実行できます。
>シート名(データ)の3行目～12行目を１行目毎にコピーし、2行目に貼り付け、シート名(出力)を３回印刷するもの この処理でいいのですか・・。 やっていることは「データ」シートの３行目から12行目を順にコピーして、同じシートの2行目に貼り付けていますよね。 そして、印刷するのは「出力」シートです。「出力」シートのセルと「データ」シートの2行目が紐づけされているのでしょうか・・。 一例のコードです。 Sub PrintThree() Dim i As Integer With Worksheets("データ") For i = 3 To 10 .Rows(i).Copy .Rows(2) Worksheets("出力").PrintOut Copies:=3 Next i End With End Sub ※むやみにSelectは使わないほうが良いです。
他のブックにあるVBAを動かすには、 Application.Runを使います。 http://excel-ubara.com/excelvba1/EXCELVBA427.html
こんにちは。 dirnameは、作業空間のフォルダを設定してください。メールの近くでいいです。 outputの次に、stopを設定して、outputの変数のローカルスコープをみてください。 型が違う、というのでしたら、別の理由です。 引数のParaですが、サンプルもよく確認してください。スペース記号は、どうでしたか。
#include<stdio.h> #include<stdlib.h> #include<string.h> #define N 256 #define MM 22 void histogram(double*,int); int main(void) { char d[N],*t; int n,i; double *g; printf("入力\n"); scanf("%d",&n); getchar(); g=(double*)malloc(sizeof(double)*n); fgets(d,N,stdin); t=strtok(d," "); i=0; while(t!=NULL){ g[i++]=atof(t); t=strtok(NULL," "); } histogram(g,n); return 0; } void histogram(double *g,int n) { int i,j,a,b,m[MM]; for(i=0;i<MM;i++)m[i]=0; for(i=0;i<n;i++)m[(int)(g[i]+0.5)]++; a=0; for(i=0;i<MM;i++){ if(m[i]>0){ a=i; break; }} b=0; for(i=a+1;i<MM;i++)if(m[i]>0)b=i; printf("\n出力\n"); for(i=a;i<=b;i++){ printf("%2d ",i); for(j=0;j<m[i];j++)printf("*"); printf("\n"); } } ご注文の通りに作ったつもりですけど、何か問題があれば適当に修正してください。 プログラムの解説はしません。 実数1個で1行の入力ではなく、全実数の入力が1行での入力になっているので、面倒な処理になっている。 getchar();はscanfでの読み残しの改行(ENTERキー)がｆgetsで不具合を起こすので、読み飛ばしている。
>redim 動的配列名(1) 配列のインデックスは常に1で再定義されています。誤りではないでしょうか? redim 動的配列名(i) では？ >ボタンＸのサブプロシージャにおけるredimがプロシージャ内の適用範囲のためボタンＹサブプロシージャでは参照できないのではないかと思っています。 動的配列名 をコード上で右クリック→ウォッチ式の追加 で配列の内容がウォッチできるので、変化を確認されてはどうでしょうか?
プリプロセッサ条件にはOSの環境変数は利用できません。 環境変数自体はSystem.Environment.GetEnvironmentVariableで取得できます。
空白文字族の違いを無視する は、たいていのdiffツールの 設定オプションにありますよ。 Winmerge なら [編集]-[設定] の 比較 - 空白 □ 変更を無視する にチェックすればよいのでは？ http://px.otogawa.com/winmerge.html
その場合はsheetのインデックスを取得すれば良いのでは無いかと思われます。 Sub Sample() MsgBox ActiveSheet.Index MsgBox Sheets("予定表").Index End Sub これで試してみて下さい。
VBのテキストボックスやC++のエディットボックスの処理、また、コマンドプロンプトへの表示もわりと遅いと思いますよ。 テキストボックスを使っているなら、使うのを止めて、他の方法を試してみるのがいいと思います。 C++のTextOut()なら速そうなのですが、.Netではないですよね。 DrawString()はどうでしょうか？試してみてはいかがでしょうか？ コマンドプロンプトへの表示はテキストボックスよりは速いかもしれない？
formをSubmmitすればいいと思います。 それとパスワード、ＩＤを探すのにループさせる必要はないと思います。 Sub sample() Dim ie As Object Set ie = CreateObject("InternetExplorer.Application") 'ie ie.Visible = True 'ie表示 ie.Navigate "https://www.netbk.co.jp/wpl/NBGate" Do While ie.Busy Or (ie.ReadyState <> 4): DoEvents: Loop '表示完了待ち ie.Document.getElementsByName("userName")(0).Value = "ユーザー名" ie.Document.getElementsByName("loginPwdSet")(0).Value = "パスワード" ie.Document.getElementsByName("LoginForm")(0).submit Do While ie.Busy Or (ie.ReadyState <> 4): DoEvents: Loop '表示完了待ち 'ie.Quit End Sub
"\p{Han}+" は文字コードがUnicodeのときの「漢字」の正規表現です。 VBSでは文字コードはシフトJISなので"[亜-熙]"とします。
目的のTDタグを取得済みならば、getAttributeを使えば取り出せます。 msg=td.getAttribute("rowspan") 他の属性値も、同様にして取り出すことが出来ます。
テストExcel.xlsのクローズ時ですよね？ xlBook.Close ↓ xlBook.Close SaveChanges:=True を試してください。
複数のシート、ブックを扱うときには、それらを省略したり、ActiveSheetやActiveworkbookなど不安定な記述は使わないようにしましょう。 Withや変数を使って、明示的にしないと頭が混乱するだけ。 Sub Macro1() Dim GYOU As Long Dim 様式1 As Worksheet, 様式2 As Worksheet Dim 様式A As Worksheet, 様式B As Worksheet With ThisWorkbook Set 様式A = .Worksheets("様式A") Set 様式B = .Worksheets("様式B") End With With Workbook.Open(Filename:="C:\共有\マクロ.xlsx") Set 様式1 = .Worksheets("様式1") Set 様式2 = .Worksheets("様式2") 様式1.Unprotect 様式2.Unprotect 様式A.Unprotect 様式B.Unprotect 様式A.Range("A2:AA2000").Copy 様式1.Range("A" & Rows.Count).End(xlUp).Offset(1).PasteSpecial xlPasteValues 様式B.Range("A2:W2000").Copy 様式2.Range("A" & Rows.Count).End(xlUp).Offset(1).PasteSpecial xlPasteValues Application.CutCopyMode = False 様式1.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True 様式2.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True 様式A.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True 様式B.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True .Close SaveChanges:=True End With End Sub 未実行につき不具合ご容赦
VB.NETはよく知らないのですが、 dt = Nothing にすればいいのでは？ 呼び出し側は、 dt = ExecuteSql(...) If dt Is Nothing Then で判別する 例外の内容も知りたいのであれば、 ExecuteSqlメソッドに、参照型の引数を追加し、その引数に例外の内容を格納して返す方法があります。 私だったら、単純に、呼び出し側に例外処理を追加して、ExecuteSqlメソッドの例外処理は削りますが...。
まず、どこまで分かっているのでしょうか。 1.IEを起動 2.目的のページへ接続 3.表示終了まで待機 4.検索窓にキーワード入力 5.検索ボタンを押す 6.表示終了まで待機 検索ページが不明なので手順しか示せませんが、結果までの手順がこうなります。この後、 ・結果ページのHTMLソースを解析して、結果リストの規則性を見つける。 といった手順が加わり、その結果から、適当なループを組んで、Rangeオブジェクトを使ってセルに代入したり、テキストファイルを開いて書き込んだりします。 検索ページによってコードは個々別々と言ってよく、サンプルコードといった定型フォーマットはありません。とりあえず上記手順を参考に、どこが分からないのかをはっきりさせて、個別に尋ねてください。
LIst(Of T)クラスから 派生させた SubListクラスを定義して 現在の _d を置き換えてみては … Public Class SubList inherits List(of String) private _sList as new List(of String) dim _sortorder as SortOrder public overloads Sub Add(ByVal item as string) dim s1 as String = item.substring(0,2) ' 前半2文字を記憶 _sList.add(s1) ' 3文字目以降を記憶 MyBase.Add(item.substring(2)) End Sub ' 昇順: Ascending ' 降順: Descending public property SortOrder as SortOrder get return _sortorder end get set(byval value as SortOrder) _sortOrder = value end set end Property private Function CompareTo(byVal x as string, ByVal y as string) as integer ’ Nothingとの比較 if y is nothing then if _sortorder = SortOrder.Descending then return -1 end if return 1 end if if x<>y then if _sortorder = SortOrder.Descending then ’ 降順指定の場合 return y.CompareTo(x) end if ’ 昇順指定の場合 return x.CompareTo(y) end if return 0 End Function public Orverloads sub Sort() ’ 3文字目以降のソート MyBase.Sort(Addressof CompareTo) ’ 2文字目までのソート _sList.Sort(AddressOf CompareTo) End Sub End Class といった具合で どうでしょう ･･･
>簡単に言うと >選択した雛形ブックをコピーしてデスクトップに保存 と書かれてますが、前半の説明では複数指定された雛形を一つのブックにまとめてから保存するように思えます。 そのようにするようなサンプルを以下に記載します。 なお、チェックボックスの見出しにはかっこ（「」）が付いているので、前後１文字ずつを除いたものを雛形ブック名にしています。 出力するファイル名もわかりませんので、「新規ブック.xlsx」にしています。 （サンプル） Sub CommandButton1_Click() Dim desktopPath As String Dim hinagataPath As String Dim chkbox As OLEObject Dim cnt As Long Dim hinagataWB As Workbook Dim newWB As Workbook Application.ScreenUpdating = False 'デスクトップのパス、雛形集のパスを取得 desktopPath = CreateObject("WScript.Shell").SpecialFolders.Item("Desktop") & "\" hinagataPath = desktopPath & "雛形集\" 'すべてのOLEオブジェクトを順に処理 cnt = 0 For Each chkbox In ActiveSheet.OLEObjects 'OLEオブジェクトがチェックボックスの場合に処理する If TypeName(chkbox.Object) = "CheckBox" Then With chkbox.Object 'チェックボックスのチェックが入っている場合に処理する If .Value = True Then Set hinagataWB = Workbooks.Open(Filename:=hinagataPath & Mid(.Caption, 2, Len(.Caption) - 2) & ".xls") If cnt = 0 Then ’選択１つ目の場合には、コピーで新しいブックを作成 hinagataWB.Worksheets(1).Copy Set newWB = ActiveWorkbook Else '選択２つ目以降は、新規ブックの最後にコピー hinagataWB.Worksheets(1).Copy After:=newWB.Worksheets(newWB.Worksheets.Count) End If '雛形ブックは閉じる hinagataWB.Close SaveChanges:=False cnt = cnt + 1 End If End With End If Next Application.ScreenUpdating = True If cnt = 0 Then 'チェックがひとつもない場合はメッセージを表示して終了 MsgBox "雛形がひとつも指定されていません" Else '新規ブックを保存 newWB.SaveAs Filename:=desktopPath & "新規ブック.xlsx" MsgBox "新規ブックを保存しました" End If End Sub
こんにちは。 1010 DATA 93 90,81,35,54,55,32,48,34 は 1010 DATA 93,90,81,35,54,55,32,48,34 ですよ。 最初のデータ93と90のあいだのコンマが、ないです。 それだと、10*3のデータそろいません。
Sub 一例です() Dim rng As Range, rtn On Error Resume Next Set rng = Range("B4", Cells(Rows.Count, 3).End(xlUp)) _ .SpecialCells(xlCellTypeConstants, xlNumbers) If Err.Number = 0 Then rng.Select rtn = MsgBox("入力セルを削除しますか？", Buttons:=vbYesNo) If rtn = vbYes Then rng.Delete Shift:=xlUp End If End If On Error GoTo 0 End Sub >コードの意味も一緒に解説いただけると幸いです。 実質10行程度のコード。 調べてみて解らないところを返信してください。 調べる技術は、プログラミング技術の重要な要素のひとつ。
仕様がよくわからないのですが、どこかのフォルダに"A100.docx","B100.docx","C100.docx"があって、それを開く場合でしょうか。 それともA1の値のワード文章を開くという事でしょうか。 ["C:\sample\"フォルダに"A100.docx","B100.docx","C100.docx"がある場合] Private Sub Worksheet_Change(ByVal Target As Range) Dim folder As String folder = "C:\sample\" 'ファイルがあるフォルダ If Target.Address <> "$A$1" Then Exit Sub 'A1でなければ終わり If (Target = "A100") Or (Target = "B100") Or (Target = "C100") Then 'A1の値が"A100.docx","B100.docx","C100.docx"なら With CreateObject("word.application") 'Word .Visible = True '表示 .Documents.Open folder & Target & ".docx" '開く End With End If End Sub ["C:\sample\"フォルダにA1のワードファイルがあったら開く場合] Private Sub Worksheet_Change(ByVal Target As Range) Dim folder As String folder = "C:\sample\" 'ファイルがあるフォルダ If Target.Address <> "$A$1" Then Exit Sub 'A1でなければ終わり If Dir(folder & Target & ".docx") = "" Then Exit Sub '指定フォルダにファイルが無ければ終わり With CreateObject("word.application") 'Word .Visible = True '表示 .Documents.Open folder & Target & ".docx" '開く End With End Sub
どんなマクロを実行しているのか判らないので答えようがないです。
コード例です。 コード内の「シート1」や「シート2」は実際のシート名に書き換えてください。 動作確認はしていないので、不具合があればご返信ください。 Private Sub CommandButton1_Click() Dim i As Long Dim Rng1 As Range Dim Rng2 As Range Set Rng1 = Worksheets("シート1").Cells(Rows.Count, "C").End(xlUp).Offset(1).EntireRow Set Rng2 = Worksheets("シート2").Cells(Rows.Count, "C").End(xlUp).Offset(1).EntireRow For i = 1 To 15 If Controls("TextBox" & i).Value = "" Then Exit For Rng1.Cells(i).Value = Controls("TextBox" & i).Value Rng2.Cells((i - 1) Mod 3 + 1).Value = Controls("Textbox" & i).Value If i Mod 3 = 0 Then Set Rng2 = Rng2.Offset(1) Next End Sub
属性値の取得は、getAttributeを使えば可能です。タグオブジェクト「t」が取得済みだとして、 n=t.getAttribute("name") とします。他の属性値も、「class」「aria-checked」といったような属性名を指定することで取得可能です。 ただし、どのタグを対象にするかは、事前に決めておかなくてはいけないでしょう。
>ブックを開けない、とエラーが表示されます。 伝票.xlsxは、カレントフォルダに格納されているということですよね？ そうでないのなら、 Filename:="伝票.xlsx" を Filename:="C:\AAA\伝票.xlsx" といったフルパス指定にしてみてください。 >開くと他のデータソースへのリンクが含まれています >と表示されます。 手動で開いた ということでしょうか？ もし、不要なリンクというのなら、ネット検索で探し http://pc.nikkeibp.co.jp/article/column/20081022/1009006/?P=1 のようなサイトの対応策を実行してください。 必要なリンクで、リンクの更新を行わなくて良いのであれば、 Set TargetBook = Workbooks.Open(Filename:="伝票.xlsx", UpdateLinks:=0) と書けば、メッセージは表示されません。
こんな感じですね。 Sub Sample() Dim Rng As Range Dim DelStrs As Variant Dim Str As Variant Dim Sht As Worksheet DelStrs = Array("check", "/確認") For Each Sht In Worksheets For Each Rng In Sht.UsedRange For Each Str In DelStrs If InStr(Rng.Value, Str) > 0 Then Rng.Value = Replace(Rng.Value, Str, "") End If Next Next Next End Sub
判りやすい＝短い じゃないですよ。 正直、電卓って、近年のイベント駆動型のプログラムの基本中の基本で、オブジェクト指向のテストケースです。 まずはボタンを押したらどうなる。何を準備しないと計算処理が出来ないか。など、画面設計の良いサンプルでもあります。 自分のレベルにあったソースは自分で作るしかないでしょう。まぁなんだｇｇｒｋｓ。プログラムの勉強をするなら、自分で調べる事をまずは覚えましょう。 https://www.google.co.jp/?gws_rd=ssl#q=C%23%E3%80%80%E9%9B%BB%E5%8D... もっと言うと、ここはVisual Basicの板です。
>帳票フォーム？サブフォーム？等を駆使すればいいのでしょうか？ はい、そのとおりです。 っていうか、こういうユーザーインターフェース(UI)の設計は、やりたいことが実現できればすべて正解、あとは好みやセンスの問題、ユーザーにとってわかりやすく使いやすく、操作ミスには寛大で、それていて致命的なミスは許容しない、それが優れたUIと言われています。 ちなみに、リストボックスに直接入力することはできません。この場合、リストボックスの近くにテキストボックスを設け、さらにその横にコマンドボタンを貼って、テキストボックスに入力したデータをボタンを押してリストボックスに追加するようにします。[追加]ボタンの横には[削除]ボタンがあったほうがいいかも。この時、リストボックスで選択されていない状態で[削除]ボタンが押された場合に備える必要があります。 それか、帳票フォームのサブフォームを埋め込んでそこに入力していくとか。
UserForm上におけるカーソルの移動はSendkeysメソッドを使うのが安全です。 Me.Controls("a" & n ).Visible = True の次の行へ SendKeys "{TAB}" を記述するとどうでしょうか? Me.Controls("a" & n ).Visible = True SendKeys "{TAB}" 'Me.Controls("a" & n ).SetFocus ←このコードは削除 タブオーダーは a1 → a2 → a3 → a4 → b1 → b2 → ... と設定します。
>途中何も入力しない列や行に変化する場合もあります。 >また、同じシートに複数の表があります。 データ部分は空白があっても良いのですが、見出し行（例の場合は２行目）は必ず何か入っているとします。 また、表と表の間は１つ以上の空白列があり、上下には並んでいないとします。 そういった前提条件でこんな感じではどうでしょうか。 Dim r As Range Dim m As Long ’表の左上を起点とします With Range("B2") m = .Row '起点から左方向に空白になる手前まで処理します For Each r In Range(.Address, .End(xlToRight)) '各列の最終行が大きいもを求めます m = Application.WorksheetFunction.Max(m, Cells(Rows.Count, r.Column).End(xlUp).Row) Next '起点から左方向に空白になる手前までの列、かつ最大行番号までを選択します Range(.Address, Cells(m, .End(xlToRight).Column)).Select End With
そういうときはTEST1の中、「End」ではなく「Exit Sub」を使いましょう。
最初の Function SUBCONCATE NATE(rngArea As Range) As String は、なんで途中で改行されているのでしょうか？ Function SUBCONCATENATE(rngArea As Range) As String と１行になっていれば、問題なく動きます。 セルで「=SUBCONCATENATE(A1:A50)」のように使ってもエラーは出ませんでしたよ。 結果もフィルタで表示された値のみが連結されました。
配列じゃなくてDictionaryなら簡単にできます。 DictionaryのExistsと言うメソッドが既に存在している値か否かを判断してくれますんで、ぐるっとループすれば出来上がり。 配列でやると手間がもう一周増えるんですよね。って、Dictionaryから配列にコンバートするにもループが必要だから手間は同じですね。 VB.netならメソッド一発で変換出来るんでDictionaryやCollectionを噛ますのが一般的なんですが。 ↓各種ロジックの比較 http://www.eurus.dti.ne.jp/~yoneyama/Excel/vba/vba_jyufuku.html
よくわかりませんが、作成されたチェックボックスがすべて同じ名前なので、 For Each myChk In ActiveSheet.CheckBoxes のルーティンでも、最初のチェックボックスを見に行っているのではないでしょうか。 保存後、閉じないでそのまま２つ目以降のチェックボックスの名前を確認してみてください。最初の chkSelect から チェックxx のように変化しているはずです。 作成する時点で、チェックボックスの名前を chk.Name = "chkSelect" & i のようにすると、最初から正しいアドレスが取得されます。
タブコントロールのページには背景色を指定できません。 代替案ですが、よくやるのは各ページに四角を最初に配置し、出来るだけページいっぱいにして背景色を変えておくくらいでしょうか。
＞更新を1つのボタンで処理したいのですが とはどう言う意味ですか？ A.csv B.csv C.csv ・ ・ ・ の処理をボタン１回で全て行いたいと言う事ですか？ だとしたら MsgBox "更新1が完了しました。" の部分を下記に変更すれば”更新1”ボタンを押すだけで全てできるはずです。 （更新2 以後のボタンは削除しても良いですが、 プログラムコードはそのまま使います。） 更新2_Click 更新3_Click 更新4_Click ・ ・ ・ MsgBox "更新が完了しました。"
以下のコードでいかがでしょうか？ Option Explicit Sub Sample() Const srcName As String = "15本番データ" Const dstName As String = "16テストデータ" Dim fPath As String Dim fName As String fPath = ThisWorkbook.Path & "\" fName = Dir(fPath & srcName & "*.xlsx") Do While fName <> "" Name fPath & fName As Replace(fPath & fName, srcName, dstName) fName = Dir() Loop End Sub
>'印刷ボタンアイコンを使用できるようにする >Application.CommandBars("Standard").Controls(6).Enabled = True >'印刷ボタンアイコンを使用できなくする >Application.CommandBars("Standard").Controls(6).Enabled = False エラー9とのことなのでこの部分がExcelのバージョンに依存してエラーしていると思います。 印刷ボタンアイコンの使用の可不可を切り替える部分を、便宜的にコメントアウトして必要な処理を実行できるようにしてはどうでしょうか？ '印刷ボタンアイコンを使用できるようにする 'Application.CommandBars("Standard").Controls(6).Enabled = True '印刷ボタンアイコンを使用できなくする 'Application.CommandBars("Standard").Controls(6).Enabled = False ボタンのコントロールを外すとコードの実行中も印刷できるようになってしまうので、期待通りに動作するようになったら、別の質問でリボンの印刷ボタンをコントロールするコードを尋ねられてはと思います。 それと、このコードはWindowの動作にも依存しているので、Excel2013では期待通りに動かない可能性があります。
>If Me.連絡先 = "無" Or Len(Me!連絡先) > 0 And Len(Me!連絡先) <> 11 Then では、「連絡先が"無"か、11桁でなければ」なので、その時エラーになるので、「連絡先が"無"でないし、11桁でもなければ」エラーにするなら Private Sub 連絡先_BeforeUpdate(Cancel As Integer) If (Me.連絡先 <> "無") And (Len(Me!連絡先) <> 11) Then MsgBox "携帯は11桁です。" Cancel = True End If End Sub となると思います。 または、 Private Sub 連絡先_BeforeUpdate(Cancel As Integer) If Me.連絡先 = "無" Then Exit Sub If Len(Me!連絡先) = 11 Then Exit Sub MsgBox "携帯は11桁です。" Cancel = True End Sub とすれば、"無"の時と11桁の時はExitSubして、それ以外の時はエラーを表示するというのでもいいと思います。
実行時エラー9 インデックスが有効範囲にありません ブックが開かれていない シートが存在しない ということ。 お示しのコードでは、以下の2点を最初に確認してください。 １）以下のブックが開かれていること "Book2.xlsm" "Book1.xlsx" "Book1" (保存前？？) ２）１）がOKなら、以下のシートが存在すること "Book2.xlsm"のシート"wk" "Book1.xlsx" のシート"Sheet1" Thisworkbook（実行中のマクロが格納されているブック）のシート"wk" "Book1" のシート"Sheet1"
ソートのロジックやFor～Nextの書き方は問題ないです。 ただし、Excelのセル範囲を配列に入れると、２次元配列になってしまいます。 しかも、あらかじめ配列で定義した変数には代入できません。 Variant 型の変数、それも配列でない変数に代入すると、それが勝手に配列になってしまいます。 「なんで」と思いますが、そういうもののようです。 それを考慮して、上記のコードを直すとこんな風になります。 Dim i As Long Dim j As Long Dim work As Variant Dim age As Variant '<=配列でない変数 age = Range("D1:D10").Value '<=.Select ではなく.Value（もしくは省略） i = 1 j = i + 1 For i = i To 9 For j = i To 10 'これ以降、２次元配列なので、２つ目の添え字「, 1」を追加 If age(i, 1) > age(j, 1) Then work = age(j, 1) age(j, 1) = age(i, 1) age(i, 1) = work End If Next j Next i Range("D1:D10") = age '<=戻す時はそのまま
下記の質問をした方ですか？ http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1115895018... そうでないならば、上記QAがヒントになるでしょう。 もしも同じ方でしたら、何故、返信を返さないのでしょうか。分からないにせよ、動かないにせよ、応答がなければ解決しません(返信するな、と回答した覚えはないのですから)。
このくらいならUWSCホームページのサンプル // 掲示板のスレをテキストファイルとして保存する #N27 [ http://www.uwsc.info/sample.html#N27 ]を参考にすれば作れます。 今回は、タグを調べなくても betweenstrで十分です。 問題は、このページの反応が非常に遅く、手動の方が速いくらいです。 実用的に使うには、何らかの工夫が必要です。 エクセルへの貼付は、力量も・詳細も不明ですのでとりあえず、クリップボード経由でいいでしょう。 それと、丸投げ的な質問には答えようがなく、大半がスルーされるでしょう。 極力、自作スクリプトを提示して、アドバイスを求めるべきです。 最初の内は「参考」って言っても山ほど疑問が沸いてくるものです。 それを、調べて解決する事こそが、最大の勉強ですよ。
値の左4桁 =Left(値, 4) 値の右6桁 =Right(値, 6) です。
なぜにこのカテゴリへ？
>Gmailの本文を抽出したいです。Google Apps ScriptかVBAでコードを書いていただけませんか？ それはＩＤ非公開で頼めるような事では無いので、クラウドソーシングやシステム屋にでも頼んでやってもらいましょう。 ただ、Google Apps ScriptやVBAではなく普通に作った方が安くて便利な物になると思います。
「Finder項目を検索」で可能です。 また findコマンドを使うことでも可能です。 コマンドは「シェルスクリプトを実行」に書き込むことでAutomatorで使うことができます。
＞(Press Retry to debug the application) って書いてあるんだから、Retry(再試行)を押しましょう。 そうすると、デバッグモードになって、該当ソース位置で止まります。 input.cppですが、それはマイクロソフトのライブラリのファイル名です。 たぶん「ソースがないよ」って表示されるので、"上の関数に戻るボタン"を押します。 何回か上に上がると、自分の書いたコードのfscanfとかgetlineとかfgetsとかの位置(またはその次の行)に来ると思います。 それだけなんですが「stream != nullptr」に注目してください。 これは「stream(ファイルポインタの親戚です)がNULL以外でなければならない」 という意味なので、 ret = fgets(buffer, sizeof(buffer),file_ptr); とかのfile_ptrがnullptr(またはNULL)であるということだと推測できます。 つまり、ファイルを開いたときに失敗している可能性が高いということです。 該当ファイルが相対パスならちゃんと、exeと同じフォルダにありますか？ デバッグとリリースでフォルダが違ったりするので確認してください。 絶対パスなら、「C:\\Users\\username\\Documents\\」みたいにちゃんと書いてあるか確認をしてください。 またはエディタで該当ファイルを開いていてロックされていて、プログラムから開けない場合もあるもしれません。 また、ファイルがなくてもデバック画面が出るエラーにならないように、fopen系の後に、NULLチェックを書いてください。 下記のような物です。 file_ptr = fopen("text.txt", "r"); if( NULL == file_ptr ){ fprintf(stderr, "File Open Error.\n"); return 1; }
「コンボボックスを選んでも（修正）２列が表示される」と書かれていますが、どこに２列が表示されるのでしょうか？ コンボボックスが選ばれたときの処理は Private Sub ComboBox3_Change()に記述します。 それ以外は以下のコードとなります。 Option Explicit Private Sub UserForm_Initialize() Dim st2 As Worksheet Dim lRow2 As Long, r As Long Set st2 = Worksheets("マスターシート") lRow2 = st2.Range("A" & Rows.Count).End(xlUp).Row With ComboBox3 .ColumnCount = 3 .ColumnWidths = "0cm;3cm;1cm" .BoundColumn = 1 For r = 2 To lRow2 setItem r Next End With End Sub Private Sub CommandButton1_Click() Dim st1 As Worksheet, st2 As Worksheet Dim rng As Range Dim w As Variant Dim r As Long Set st1 = Worksheets("Sheet1") Set st2 = Worksheets("マスターシート") 'テキストボックスの内容が空欄なら何もしない If TextBox1.Text = "" Then Exit Sub 'Sheet1のA列からテキストボックスに入力された内容と一致するセルを探す Set rng = st1.Range("A:A").Find(TextBox1.Text) If rng Is Nothing Then Exit Sub '該当するセルが存在しなければ何もしない 'マスターシートのC列から品Ｎｏが一致するセルを探す Set rng = st2.Range("A:A").Find(st1.Range("C" & rng.Row).Value, LookIn:=xlValues) If rng Is Nothing Then Exit Sub '該当するセルが存在しなければ何もしない r = rng.Row 'コンボボックスの内容を一旦クリアする ComboBox3.Clear 'コンボボックスに品Ｎｏ、品種、年をセットする setItem r End Sub Private Sub setItem(r As Long) Dim st2 As Worksheet Set st2 = Worksheets("マスターシート") With ComboBox3 'コンボボックスに品Ｎｏ、品種、年をセットする .AddItem st2.Range("A" & r).Value .List(r - 2, 1) = st2.Range("B" & r).Value .List(r - 2, 2) = st2.Range("C" & r).Value End With End Sub Private Sub ComboBox3_Change() Dim idx As Integer idx = ComboBox3.ListIndex If idx = -1 Then Exit Sub '選択された行の品Ｎｏは .List(idx, 0) で取り出せる '選択された行の品種は .List(idx, 1) で取り出せる '選択された行の年は .List(idx, 2) で取り出せる End Sub
具体性に欠けるプログラミング依頼ですね。 とりあえず、アクティブなブックのすべてのワークシートを対象に、B1セルに、「＝A1」という式を入力するプログラムです。 Sub 一例です() Dim sh As Worksheet For Each sh In ActiveWorkbook.Worksheets sh.Range("B1").Formula = "=A1" Next sh End Sub
まず、Dir でファイル名を取得する場合、「***.csv」ではなく「*.csv" インポートするテーブル名が「"csv定義" & "csv"」→「csv定義csv」と固定になってしまうためひとつのテーブルに追加されてしまう。 また、インポートするファイル名myFilename にはパス名無しのファイル名が入っているので、myPath を前につけてやる。 （修正したサンプル） Sub cmdImport() Dim myFilename As Variant Dim myPath As Variant myPath = "C:\Users\Desktop\過去データ\" myFilename = Dir(myPath & "*.csv") Do Until myFilename = "" DoCmd.TransferText acImportDelim, , Left(myFilename, Len(myFilename) - 4), myPath & myFilename, True myFilename = Dir() Loop End Sub
Sub 一例です() Dim xRng As Range With Selection.EntireRow .Copy Workbooks("BookB.xlsx").Worksheets("Sheet1") _ .Cells(Rows.Count, 1).End(xlUp).Offset(1).EntireRow.PasteSpecial For Each xRng In .Areas xRng.Columns(1).Value = "印" Next xRng End With End Sub
何処で一回と数えるか？と言う、すさまじく難しい問題は置いておいて、 Workbookを開く度に1度であれば以下のような方法が考えらえれます。 Private Sub Worksheet_Change(ByVal Target As Range) Dim CheckRange As Range Static CheckSet As New Dictionary 'Microsoft.Scripting.Runtimeを参照してください For Each CheckRange In Target If CheckSet.Exists(CheckRange.Address) Then '何にもしない Else ’I列か確認 If CheckRange.Column = 9 Then ’未入力、削除だったら空にする If IsNull(CheckRange.Value) Then Cells(CheckRange.Row, 10).Value = "" Else ’そうじゃなかったら値をコピー Cells(CheckRange.Row, 10).Value = CheckRange.Value End If ’処理記録(値1は適当） CheckSet.Add CheckRange.Address, 1 End If End If Next End Sub
難しいというより、面倒なだけです。 仮に、「HTML としての完成形」が、次のようなものだとします（table 部分のみ抜粋）。 <table border="1"width="700" height="635"> <tbody> <tr> <td id="f1"><a href="./sample1.htm">1</a></td> <td id="f2"><a href="./sample2.htm">2</a></td> <td id="f3"><a href="./sample3.htm">3</a></td> </tr> </tbody> </table> これはつまり、td 要素の直下に、子要素として a 要素を追加する、という事です。 JavaScript で HTML DOM に要素を新規追加するには、 １．createElement メソッドで新規要素を生成する ２．生成した要素に必要な属性を追記する ３．appendChild メソッドで新規要素を親要素に追加する という手順を踏みます。 これを律儀に JavaScript で書くと、次のような感じになります。 var arrayD = [ // 対応する配列要素に、必要なデータを全て埋め込んでおく {"id":"f1", "link":"./sample1.htm"}, {"id":"f2", "link":"./sample2.htm"}, {"id":"f3", "link":"./sample3.htm"} ]; for(var i= 0;i<arrayD.length;i++){ var elem = document.getElementById(arrayD[i].id); // 親要素を取得 var newElem = document.createElement("a"); // 子要素を生成 newElem.href = arrayD[i].link; // 子要素の href 属性を設定 newElem.innerText =i+1; // 子要素の内容を設定(1から、にした) elem.appendChild(newElem); // 子要素を親要素に追加 } また、必要なリンク先アドレスが、計算で作れるのであれば、配列内に持たなくても、次のように実装できます。 var arrayD = ["f1","f2","f3"]; for(var i= 0;i<arrayD.length;i++){ var elem = document.getElementById(arrayD[i]); // 親要素を取得 var newElem = document.createElement("a"); // 子要素を生成 newElem.href = "./sample"+(i+1)+".htm"; // 子要素の href 属性を設定 newElem.innerText =i+1; // 子要素の内容を設定(1から、にした) elem.appendChild(newElem); // 子要素を親要素に追加 } このテクニックを自在に使えるようになると、JavaScript で HTML を自由に変更できるようになります。 ご参考になれば幸いです。
22行目と25行目に設定したい数式はR1C1参照形式で表すと どちらも =IF(AND(R19C>=R[-2]C3,R19C<=R[-2]C4),"1","") になります。 ですので、VBAでは下記のようになります。 Sub Sample() Dim r As Range For Each r In Range("G22:BJ22,G25:BJ25") r.FormulaR1C1 = "=IF(AND(R19C>=R[-2]C3,R19C<=R[-2]C4),""1"","""")" Next End Sub
テキスト1の更新後処理で、テキスト1の値が A 、かつテキスト2の値が日付でない場合に、今日の日付をテキスト2にセット。 （サンプル） Private Sub テキスト1_AfterUpdate() If [テキスト1].Value = "A" And Not IsDate([テキスト2].Value) Then [テキスト2].Value = Format(Now(), "yyyy/m/d") End If End Sub
start ftp -s:ftp_AAA_img.txt start ftp -s:ftp_BBB_img.txt
長くなりますが、下記で出来ます。 Dim i As Long, j As Long, k As Long, rr As Long i = Cells(Rows.Count, "C").End(xlUp).Row j = Cells(Rows.Count, "D").End(xlUp).Row k = Cells(Rows.Count, "E").End(xlUp).Row rr = Application.Max(i, j, k) Application.Intersect(ActiveSheet.UsedRange, Range("C1:E" & rr)).Select
For i = 0 To 10 Application.OnTime Now + TimeValue("00:00:0" & i), "Sample", , False 'Next ↑ 1分おきにSampleを呼び出しているのに、これでは10秒先までしかキャンセルできていません。 下記コードで試してみてください。 Sub ボタン2_Click() '停止ボタン Dim i As Long On Error Resume Next For i = 0 To 60 Application.OnTime Now + TimeValue("00:00:" & Format(i, "00")), "Sample", , False Next End Sub
＜0.1～1.0の間で、100回の試行回数についてだいたい均等に分布されるような乱数を発生させる＞ 0.01から1まで0.01刻みだと１００個あります。それを均等にということは さいころを６回振って１～６までを均等に、と言っているのと同じです。これでは丁半博奕の人は困ってしまいます。 C２セルに０．０１と入れます。 C3セルに０．０２と入れます。 C2:C3セルを下にC101までコピーします。 A2セル（A1セルは空白）に =INDEX(C$2:C$101,SMALL(INDEX(COUNTIF(A$1:A1,C$2:C$101)*1000+ROW(A$1:A$100),),RANDBETWEEN(1,101-ROW(A1)))) この数式で均等な数字を出せます。 A2セルをA101までコピー E2セルに =COUNTIF(C$2:C$101,A2) と入れてE101までコピーして検証します。全部１になればOKです。これは均等に分布し、ランダムに並んだ表を作る、ということであってランダムな数字を作るのとはちょっと意味が違います。ランダムな数字が欲しければ =RANDBETWEEN(1,100)/100 で充分だと思います。
＜0.1～1.0の間で、100回の試行回数についてだいたい均等に分布されるような乱数を発生させる＞ 0.01から1まで0.01刻みだと１００個あります。それを均等にということは さいころを６回振って１～６までを均等に、と言っているのと同じです。これでは丁半博奕の人は困ってしまいます。 C２セルに０．０１と入れます。 C3セルに０．０２と入れます。 C2:C3セルを下にC101までコピーします。 A2セル（A1セルは空白）に =INDEX(C$2:C$101,SMALL(INDEX(COUNTIF(A$1:A1,C$2:C$101)*1000+ROW(A$1:A$100),),RANDBETWEEN(1,101-ROW(A1)))) この数式で均等な数字を出せます。 A2セルをA101までコピー E2セルに =COUNTIF(C$2:C$101,A2) と入れてE101までコピーして検証します。全部１になればOKです。これは均等に分布し、ランダムに並んだ表を作る、ということであってランダムな数字を作るのとはちょっと意味が違います。ランダムな数字が欲しければ =RANDBETWEEN(1,100)/100 で充分だと思います。
こんにちは ②If TextBox1 = Range("E135") Then は ②If val(TextBox1) = val(Range("E135")) Then で、ためしてください。 オブジェクトをプロパティを使わないでifは、ちょっと厳しいです ほそくのtestbox.valueは、結果、「文字列」ですよ。 型をそろえてまみましょう
提示されているソースに間違いは見つけられません。 提示されていないソースにバグがあるものと推察します。
表の仕様が分からないので、違った視点での一例です。 塗りつぶしを解除したい場合は、C列のセルをダブルクリックするとしています。 Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean) Const Iro0 As String = xlNone Const Iro6 As Integer = 6 With Target If .Offset(, -1) = "" Then Range(.Offset(, -1), Cells(.Row, .End(xlToRight).Column)).Interior.ColorIndex = Iro6 ElseIf Target.Offset(, 1) = "" Then Range(Cells(.Row, .End(xlToLeft).Column), .Offset(, 3)).Interior.ColorIndex = Iro6 Else .EntireRow.Interior.Color = Iro0 End If End With Cancel = True End Sub
回答ではありませんが… いまいち、何をしたいのかがわかりません 検索範囲は、ワークシート全体なのでしょうか？ また、条件に合った場合右列に指定文字を入れると、検索順序によっては、本来検索対象の文字列Aが有ったにもかかわらず、文字列Aを 消すように指定文字列を入れてしまう恐れがありますよね。 質問内容の記載方法を ①検査範囲はワークシート全体の中で、 ②検索対象の列は、列A、C、Eの奇数列を検索して行き ③参照したセルの内容が ④文字列Aを含む場合で且つ文字列Bを含まない場合に限り、 ⑤隣のセル(列B、D、F)に指定文字を入れる の様にもう少し具体的にすると、回答もしやすくなって、より多くの回答が得られると思いますが、いかがでしょうか？
貴方はその文字化けするテキストファイルをどのように処理したいのですか？ １：そのまま処理したい。 ２：文字化けしないファイルに変換してから処理したい。 もし２なら 「テキストファイル 文字化け」 等でネット検索すれば対処方法は見つかると思います。 もし１なら上記と同じ検索で、現在の文字コードが何かの調べ方が判ると思います。 文字コードが判ったら、改めて処理方法をネットで調べて下さい。
リストと配列は別です。 リストは"List<型>"、配列は"型[]"のように定義するので、この場合は型です。 pts2.Remove(省略);のようにできるのはリストのみです。 従って、配列ではなくリストで定義してあげる必要があります。 List<Point> pts = new List<Point> { new Point { X = 50, Y = 50 }, new Point { X = 50, Y = 75 }, new Point { X = 75, Y = 80 }, new Point { X = 70, Y = 60 }, new Point { X = 100, Y = 70 }, new Point { X = 110, Y = 45 } }; List<Point> pts2 = new List<Point> { new Point { X = 200, Y = 50 }, new Point { X = 250, Y = 250 }, new Point { X = 290, Y = 240 }, new Point { X = 300, Y = 140 }, new Point { X = 400, Y = 150 }, new Point { X = 450, Y = 205 }, new Point { X = 500, Y = 220 } , new Point { X = 460, Y = 70 } }; List<Point> pts3 = new List<Point> { new Point { X = 16, Y = 10 }, new Point { X = 55, Y = 95 }, new Point { X = 66, Y = 92 }, };
◆条件付き書式による方法です １）C1:C10の範囲を指定して、【図-1】 ２）リボンの「ホーム」タブの「条件付き書式」ボタンをクリックして、 ３）「新しいルール」→「数式を使用して、書式設定するセルを決定する」の「次の数式を満たす場合に値を書式設定」に ４）=OR(A1=1,A1=3) と入力して、右下の「書式」をクリックして、【図-2】 ５）「表示形式」→「ユーザー定義」にして「種類」に、 '@' と入力して、 ＯＫ【図-3】
表全体(提示の表では、C3～Jいくつでしょう、まで)を選んで、リボンの条件付き書式を選びます。 新しいルールを開いて「ルールの種類を選択してください」の一番下「数式を使用して～」を選びます。 「ルールの内容を編集してください」「次の数式を満たす場合に～」に以下を設定します。その１とその２は別に設定します。その間選択セルは動かしません。 その１ =OR($F3="土",$F3="日") 書式をクリックし、塗りつぶしを黄色にします。 その２ =$G3="◯" 書式をクリックし、塗りつぶしを黄色にします。 以上を設定するとF列の土日、G列の◯に反応して黄色くなります。 なお、F列が文字列の土日ではなく日付シリアルを表示形式で土日にしていた場合は別の数式となります。
セルTargetの列はTarget.column 表記はABCでなく123です。 Select Case Target.column Case 4 Case 5 Case 6
以下のような内容でしょうか。 ユーザーフォーム表示用（標準モジュール） ------- Sub ShowUF() Dim r As Long r = 2 With UserForm1 .ComboBox1.AddItem Cells(r, 1).Value Do While Cells(r, 1).Value <> "" r = r + 1 If Cells(r, 1).Value <> Cells(r - 1, 1).Value And _ Cells(r, 1).Value <> "" Then _ .ComboBox1.AddItem Cells(r, 1).Value Loop .Show 0 End With End Sub ------- UserForm1のコード ------- Private Sub ComboBox1_Change() Dim fnd As Range, CP As String, r As Long ComboBox2.Clear Set fnd = Columns(1).Find(ComboBox1.Value) CP = fnd.Value r = fnd.Row Do While Cells(r, 1).Value = CP ComboBox2.AddItem Cells(r, 2) r = r + 1 Loop ComboBox2.ListIndex = 0 End Sub -------
以下でどうなりますか そのシートモジュールに記述してみます Private Sub Worksheet_Change(ByVal Target As Range)    Dim rng As Range    Dim sS As String    Set Target = Intersect(Target, Range("A3:B30"))    If (Target Is Nothing) Then Exit Sub    Application.EnableEvents = False    For Each rng In Target.Rows       With rng.Offset(, 1 - rng.Column)          If (WorksheetFunction.Count(.Resize(, 2)) = 2) Then             sS = "×"             If ((.Range("A1") = 1) And (.Range("B1") < 7)) _                Or ((.Range("A1") = 2) And (.Range("B1") < 10)) Then                sS = "○"             End If             .Range("C1") = sS          Else             .Range("C1").ClearContents          End If       End With    Next    Application.EnableEvents = True End Sub
出来るようですね http://lglink.blog81.fc2.com/blog-entry-375.html?sp
今日の日付を入力するのであれば Private Sub TextBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean) TextBox1.Text = Format(Date, "yyyy/mm/dd") Cancel = True End Sub です。
まず、先頭の「A001」は何でしょうか？ シートの名前でしょうか。 それであるなら Worksheets("A001").Cells(2, 32).Select とします。 FormulaR1C1 に関数を入れていますが、FormulaR1C1 はR1C1参照で記述しなければなりません。 記述されている関数は A1形式なので Formula に関数を入れます。 また、関数式ですが、文字列の中に " を入れる場合は "" と２つ重ねて書く必要があります。 したがって ActiveCell.Formula = _ "=MID(AC8,FIND(""@"",SUBSTITUTE(AC8,"","",""@"",5))+1,FIND(""@"",SUBSTITUTE(AC8,"","",""@"",6))-FIND(""@"",SUBSTITUTE(AC8,"","",""@"",5))-1)" のように記述します。 関数は・・短くならないかな～
フォームのイベントの「タイマー時」でテーブルの件数を確認し、前回と変わっていれば「再クエリ」するのはどうでしょうか？ タイマー間隔を短くすれば、近い処理になりますが、そう神経質なものでなければ、30秒~1分ごとに行っても良います。
>○は、入るけど、見出し行（1列）まで○が入ってしまい For Each c In Worksheets("sheet1").Columns(85).SpecialCells(xlCellTypeVisible) としたばあい、可視セルのみ繰り返しますが、オートフィルタは先頭行（見出し行）がも当然可視状態なので、見出しまで「○」が入ってしまいます。 回避する方法としては (1) c の行番号が１ならセットしない If c.Row > 1 Then If c = "" Then Exit Sub End If Range("a" & c.Row) = "〇" End If (2) 処理した後で、Ａ列の見出しをセットしなおす 処理の最後に Cells(1, 1).Value = "みだし" を入れる >次の、「2」で「◎」を入力が、動いてくれません。 Selection.AutoFilter Field:=85, Criteria1:="2" の前に Selection.AutoFilter を入れてください。 「1」のフィルターを解除してからやらないと、「１」しか表示されていないうえに「２」の行を処理しようとしますから。（「１」かつ「２」の行はないですから） ＞最後に、フィルタの解除。 最後に Selection.AutoFilter を入れて、フィルターを解除します。
データ範囲の自動更新ならこちらが簡単ですよ。お試しください。 Excel2010： ピボットテーブル【データ範囲】を自動更新するには http://www.office-qa.com/Excel/ex203.htm
Sub 一例です() Dim rng As Range With Worksheets("シート２") Set rng = .Cells(1, Columns.Count).End(xlToLeft) If rng.Value <> "" Then Set rng = rng.Offset(, 1) End If End With With Worksheets("シート１") rng.Value = .Range("A1").Value rng.Offset(2).Value = .Range("A2").Value rng.Offset(4).Value = .Range("A3").Value .Range("A1:A3").ClearContents End With End Sub
下記の要領でコーティングしました。 ▼ダイアログでフォルダを選択 ▼実行用のファイルと同じ場所に、集約したファイルが生成される。 ※対象シートの条件の記載が無かったので 仮でA1=1 And B1＝2 で設定しています。 実行用ファイルを作成し、標準モジュールに貼り付けて使ってください。 Declare Function SHGetPathFromIDList Lib "shell32.dll" Alias "SHGetPathFromIDListA" _ (ByVal pidl As Long, ByVal pszPath As String) As Long Declare Function SHBrowseForFolder Lib "shell32.dll" Alias "SHBrowseForFolderA" _ (lpBrowseInfo As BROWSEINFO) As Long Declare Function GetDesktopWindow Lib "user32" () As Long Public Type BROWSEINFO hOwner As Long pidlRoot As Long pszDisplayName As String lpszTitle As String ulFlags As Long lpfn As Long lParam As Long iImage As Long End Type Function GetFolder(Optional Msg) As String Dim bInfo As BROWSEINFO Dim pPath As String Dim R As Long Dim X As Long Dim pos As Integer bInfo.pidlRoot = 0& If IsMissing(Msg) Then bInfo.lpszTitle = "フォルダの選択..." Else bInfo.lpszTitle = Msg End If bInfo.ulFlags = &H1 X = SHBrowseForFolder(bInfo) pPath = Space$(512) R = SHGetPathFromIDList(ByVal X, ByVal pPath) If R Then pos = InStr(pPath, Chr$(0)) GetFolder = Left(pPath, pos - 1) Else GetFolder = "" End If End Function Sub Sample() Dim lngAns As Long Dim FolName As String Dim FileName As String Dim Path As String Dim Flag As Boolean Dim Bo As Workbook Dim NewBo As Workbook Dim Sh As Worksheet FolName = GetFolder("フォルダーを選択してください。") If FolName = "" Then Exit Sub End If If Dir(FolName & "\*.xls*") = "" Then MsgBox "指定したフォルダーにExcelファイルは存在しません。", vbOKOnly + vbInformation Exit Sub End If lngAns = MsgBox("処理しますか？", vbYesNo + vbQuestion) If lngAns = vbNo Then Exit Sub End If Application.ScreenUpdating = False FileName = Dir(FolName & "\*.xls*") Flag = False Do While FileName <> "" Set Bo = Workbooks.Open(FolName & "\" & FileName) For Each Sh In Bo.Worksheets If Sh.Range("A1") = 1 And Sh.Range("B1") = 2 Then '対象シートの条件 If Flag = False Then Sh.Copy Set NewBo = ActiveWorkbook Flag = True Else Sh.Copy After:=NewBo.Worksheets(NewBo.Worksheets.Count) End If End If Next Application.DisplayAlerts = False Bo.Close SaveChanges:=False Application.DisplayAlerts = True FileName = Dir() Loop Set Bo = Nothing Set Sh = Nothing If Flag = False Then MsgBox "条件を満たしたシートは、存在しませんでした。", vbOKOnly + vbCritical Application.ScreenUpdating = True Exit Sub End If Path = ThisWorkbook.Path If Dir(Path & "\集約.xlsx") <> "" Then Application.DisplayAlerts = False Kill Path & "\集約.xlsx" Application.DisplayAlerts = True End If Application.DisplayAlerts = False NewBo.SaveAs FileName:=Path & "\集約.xlsx" NewBo.Close Application.DisplayAlerts = True Set NewBo = Nothing Application.ScreenUpdating = True MsgBox "集約したExcelファイルを生成しました。", vbOKOnly + vbInformation End Sub
計算をしないで、というのが良く分かりませんが。 要するに、円の範囲の文字をクリアすれば良いのでしたら、こんな感じです。 元の処理から、中心位置と直径を指定して下記のようなものをCallすればいいかと。 Private Sub 円描画(ByVal 中心row As Long, ByVal 中心col As Long, ByVal 直径 As Long) Dim r As Range For Each r In Range(Range("A1"), Range("A1").SpecialCells(xlLastCell)) If ((r.Row - 中心row) ^ 2 + (r.Column - 中心col) ^ 2) * 4 <= 直径 ^ 2 Then r.Value = "" Next End Sub
残念ながら「登録(入力)順」というテーブルのレコード並びは保障されていません。 （稼働したての頃はそう見えるかもしれません） テーブルにオートナンバーのフィールドやフォーム(VBA)を利用し自力で入力順になるようにナンバリング設計したフィールドを設置しないといけません。
テストはしていませんが、書かれていることを忠実に行うと以下のようなコードになります。 Dim m As Long Dim i As Long 'SHEETNAMEのB列の最終行を求める m = Worksheets("SHEETNAME").Range("B" & Rows.Count).End(xlUp).Row '2行目から最終行まで繰り返す For i = 2 To m 'TEMPLATEを最後にコピー Worksheets("TEMPLATE").Copy After:=Worksheets(Worksheets.Count) With ActiveSheet 'シート名をSHEETNAMEのA列の値に変更 .Name = Worksheets("SHEETNAME").Range("A" & i).Value 'セルC1にSHEETNAMEのB列の値をセット .Range("C1").Value = Worksheets("SHEETNAME").Range("B" & i).Value 'シートの特定セルを値コピー .Range("D5:D15").Copy .Range("D5").PasteSpecial Paste:=xlPasteValues .Range("D18:D28").Copy .Range("D18").PasteSpecial Paste:=xlPasteValues .Range("D31:D37").Copy .Range("D31").PasteSpecial Paste:=xlPasteValues .Range("D40:D43").Copy .Range("D40").PasteSpecial Paste:=xlPasteValues .Range("D58:D106").Copy .Range("D58").PasteSpecial Paste:=xlPasteValues Application.CutCopyMode = False End With Next
こんにちは。 >マクロではなく関数でできるものでしょうか。 管理番号ごとの品番の管理をするのでしょうから、キーワードを追加する列は必要です。 データベース関数を使って、管理ごとの品番と数量の計算はできますが、 それだけの項目があるのでしたら、シートでデータベースを構築するのも、かなり重労働です。 管理番号がロットなのか、伝票番号なのか、にもよりますが、先入れ後だしなど、細かく管理するのでしたら、データ1行にユニークなキーを追加して、全体をデータベース登録するようにして、と、MSアクセスで構築してみる、などです。
teratermのデータと言うのが、teratermはなにか決まった形式でデータを出力するわけではないので意味を為しません。 とりあえず、excelに読み込ませるテキスト形式のファイルという点では"csv"について調べてみると何かの役に立つかも、とは思います。
問題は小数点でしょうね。Excelでは小数点の比較などでは誤差が生じることがあります。このような場合はRound関数などで処理をしてから比較すると良いでしょうね。また、変数宣言はしてください。 Sub Test() Dim k As Double, s As Double k = Round(Range("C12"), 2) s = Round(Range("E3"), 2) If k >= s Then MsgBox "問題なし" Else MsgBox "問題あり" End If End Sub
処理がわかりませんので、最終行取得部分だけです。 rmax = Worksheets("個人別").Cells(Rows.Count, "D").End(xlUp).Row With Worksheets("個人別").Range("D4:D" & rmax) rmaxという変数を使わなくてもいいのですが、長くなるので一旦変数に入れました。
普通に上手く実行されましたね。 以下の条件を満たしていて、うまく実行できないことはないはず。 1） 特定のブック”A”の特定のシート”AA”を、アクティブにしておく ２） "C:\temp\"に「.xls」を持ったExcelブックを格納しておく。 これらのブックがコピー先 ステップ実行 http://hp.vector.co.jp/authors/VA016119/step/step01.html あたりを使用して実行状況を観察してみるのが、最初にやることでしょうね。 ちなみに、 「複数のブックB~Zの一番左側にコピーしたいのです。」 の要件は満たしていないプログラムです。右端にコピーされます。
#include <stdio.h>というのはスタンダードヘッダーファイルのことです。 標準出力のprintfが使えるのこのヘッダーファイルのお陰です。 >can not open source file stdio.h はこのスタンダードヘッダーファイルが開けないということ >identifier printf is undefined というのはprintfというのはみつからないといっています。ヘッダーファイルがないから当たり前です。 >Cannot open include file stdio.h no such file or directory そのstdio.hというfileをインクルードできない。そんなファイルとディレクトは無いよっていうエラーが出ています。 まあ結論から言うとCコンパイラーのパスを設定していないんでコンパイルできないんです。 visual studioのメニューからProject->Properties-> Configuraton Properties->VC++ Diretories->Library Directories パスの追加 C:\Program Files (x86)\Windows Kits\10\Lib\10.0.10150.0\ucrt\ あなたの環境を選ぶ そしてまたメニューから C/C++->General->Additional include directories にパスを追加してください C:\Program Files (x86)\Windows Kits\10\Include\10.0.10150.0\ucrt
なんか凝った作りですね。 単純に、対象セルの中で改行を入れるのではなく、規定文字数ごとに対象セルの下に分割して入れるのですね。 気になるところも含めて、私流に直すとこんな感じになります Const RanVal As String = "A1" 'セルの個所を設定 Const MaxSt As Long = 44 '切り分ける文字数を設定 Private Sub Worksheet_Change(ByVal Target As Range) Dim StVal As String Dim i As Integer '対象のセルが変更された範囲に含まれているか If Not Intersect(Range(RanVal), Target) Is Nothing Then 'イベントの無効化 Application.EnableEvents = False '文字列を変数StValにセット StVal = Range(RanVal).Value i = 0 '変数StValが空白になるまで繰り返し Do Until StVal = "" '対象セルから順に対象文字数分をセット Range(RanVal).Offset(i, 0).Value = Left(StVal, MaxSt) i = i + 1 '対象文字数分を先頭から削る StVal = Mid(StVal, MaxSt + 1) Loop 'イベントの有効化 Application.EnableEvents = True End If End Sub
FalseをTrueに変えて実行するだけじゃないの？ http://hensa40.cutegirl.jp/archives/1253
まず、貴方が作成したマクロを提示してください。 そうでないと正確な回答が出来ない恐れがあります。 ちなみにブレークポイントを使ったデバッグは試してみましたか？ ブレークポイント：プログラムの動作を指定した行で一旦停止する機能 使い方：停止させたい行にカーソルがある状態で「F9」キーを押す（その行が反転します）
「どこに」という指定がないので、S列に設定すると仮定しています。 Sub avg() Dim maxRow As Long Dim start As Long Dim last As Long Dim i As Integer Dim avg As Double '最終行を取得 maxRow = Range("A" & Rows.Count).End(xlUp).Row '変数定義 start = 1 last = 1 '最終行まで処理 For i = 1 To maxRow '諸元名が一緒の場合、加算処理 If Range("B" & i).Value = Range("B" & i + 1).Value Then last = last + 1 Else '平均を計算 avg = WorksheetFunction.Average(Range("X" & start & ":X" & last)) Range("S" & i).Value = avg '開始位置を更新 start = i + 1 '最終位置を更新 last = last + 1 End If Next i End Sub
フルパス指定しないと認識しない、もしくはファイル名が間違っています。 分析ツール-VBAのパスを見るとatpvbaen.xlamと見えるのですが、対象はこれですか？
Do While Cells(i,2).Value <>"" ↓ Do While Cells(i, 2).Text <> ""
環境の再インストールかなぁ。 ちょっとググって駄目なら、自分の場合はそうします。
Sub Macro1() Dim GYOU As Long '←ここにGYOU変数を定義 Workbook.Open Filename:=”C:¥共有¥マクロ.xlsx” ～
(1) 構文の間違い Workbook.Open Filename:=”C:¥共有¥マクロ.xlsm” ↓ Workbooks.Open Filename:="C:¥共有¥マクロ.xlsm" (2) 転送先のマクロ.xlsm にはシートが１つしかないのでしょうか。 ブックを Open した直後に Activesheet.Unprotect していますが、大丈夫でしょうか。 念のため Sheets("様式").Select としてから Unprotect するか、 Sheets("様式").Unprotect としたほうが良いでしょう。 (3) 貼り付けを２回行っている。 Selection.PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _ :=False, Transpose:= True で貼り付けた後、さらに ActiveSheet.Paste しています。 後のほうの ActiveSheet.Paste により、B列からY列までに行方向（縦方向）に24行のデータが貼り付けられてしまいます。 後のほうの ActiveSheet.Paste は不要です。 (4) 転送先のブックを保存して閉じる場合に ActiveWorkbook.Save ActiveWindow.Close としていますが、保存は ActiveWorkbook に対して、閉じるのは ActiveWindow も間違いではないですが、 どうせなら保存して閉じるので ActiveWorkbook.Close SaveChanges:=True としてはどうでしょうか。 (5) 最後の Application.CutCopyMode =False は意味がないので不要です。 とりあえず動作させるには(1) と (3) を修正すれば動作すると思います。 全体を見直して、整理したサンプルコード（Macro1のみ）を載せておきますので、参考にしてください。 Sub Macro1() '転送先ブックを開く Workbooks.Open Filename:="C:\共有\マクロ.xlsm" '様式シートに対して処理 With Sheets("様式") 'シートの選択 .Select 'シートの保護を解除 .Unprotect '自ブックのActiveSheetのセルC4:C27をコピー ThisWorkbook.ActiveSheet.Range("C4:C27").Copy 'B列最終行の下セルに、行列を入れ替えて貼り付け .Range("B65536").End(xlUp).Offset(1).PasteSpecial Paste:=xlPasteValues, Operation:=xlNone, SkipBlanks _ :=False, Transpose:=True Application.CutCopyMode = False 'シートの保護 .Protect DrawingObjects:=True, Contents:=True, Scenarios:=True End With '転送先ブックを保存して閉じる ActiveWorkbook.Close SaveChanges:=True End Sub
以下でどうなりますか Macro1 と Samp1 を置き換えます Public Sub Samp1()    Dim vA As Variant, v As Variant    Dim i As Long, j As Long    Const CFILE As String = "C:¥共有¥マクロ.xlsx"    Const CSHTNM As String = "様式1,様式2"    With ActiveSheet       With .Range("C4", .Cells(Rows.Count, "C").End(xlUp))          If (.Cells(1).Row < 4) Then Exit Sub          j = .Rows.Count          If (j > 24) Then             j = 24          ElseIf (j < 20) Then             j = 20          End If          With .Resize(j)             vA = WorksheetFunction.Transpose(.Cells)             .ClearContents          End With       End With    End With    Application.ScreenUpdating = False    With Workbooks.Open(CFILE)       For Each v In Split(CSHTNM, ",")          With .Worksheets(v)             i = .Cells(Rows.Count, "B").End(xlUp).Offset(1).Row             If (i < 9) Then i = 9             .Unprotect             .Cells(i, "B").Resize(, j).Value = vA             .Protect , True, True, True          End With       Next       .Close True    End With    Application.ScreenUpdating = True End Sub
基本どおり、findを使ってみた一例です。やり方はいろいろあると思います。 dim obj as object dim Gyo as long dim Retsu as long set obj=range("B6:B10").find(what:=range("B3").value,lookat:=xlwhole) if obj is nothing then msgbox("該当するNoは見つかりません。") exit sub else Gyo=obj.row end if set obj=range("B" & Gyo & ":D" & Gyo).find(what:=range("C3").value,lookat:=xlwhole) if obj is nothing then msgbox("該当する品名は見つかりません。") exit sub else Retsu=obj.column end if cells(Gyo,Retsu).select
基本どおり、findを使ってみた一例です。やり方はいろいろあると思います。 dim obj as object dim Gyo as long dim Retsu as long set obj=range("B6:B10").find(what:=range("B3").value,lookat:=xlwhole) if obj is nothing then msgbox("該当するNoは見つかりません。") exit sub else Gyo=obj.row end if set obj=range("B" & Gyo & ":D" & Gyo).find(what:=range("C3").value,lookat:=xlwhole) if obj is nothing then msgbox("該当する品名は見つかりません。") exit sub else Retsu=obj.column end if cells(Gyo,Retsu).select
sub tes は Sub test() でしょうか。 変数 s は、そのままではユーザーフォームから値を入れることはできません。 コードが標準モジュール内であれば、Sub test() より前（他のコードがある場合は、それらの前）に Public s as String と記述します。 それで、ユーザーフォームからも変数 s が使用できますので、ユーザーフォームのコマンドボタンを押したときに s = "ボタン名" とすることで変数 s にボタンの名前が入ります。
以下の変更を試してみてください。 Set R = R.End(xlDown).Offset(1) ↓ Set R = Ws1.Cells(Rows.Count, 1).End(xlUp).Offset(1)
DAO での文字のワイルドカードは *、ADO は % 例えば 端末番号 LIKE '*" & Me.imp_端末 & "*'" ↓ 端末番号 LIKE '%" & Me.imp_端末 & "%'" に変更が必要です 余談）SQL 作成部分は元に戻したのですね
二重繰り返しにする必要はないです。 また範囲でコピーした方がステップが少なくてすみます。 Sub Sample() Dim i As Integer, t As Integer t = 2 For i = 3 To 19 Step 4 Worksheets("1月").Range("D" & i & ":I" & i).Copy Destination:=Worksheets("基本").Cells(3, t) t = t + 6 Next End Sub
こんにちは。 示しているコードは、ファイルの一覧表を作成するものです。主様がしたいのは、ファイルの中にあるのか、ファイルの名前で処理するか、で、対応がだいぶかわります。 メールの場合、メールがメーラーにある場合と、フォルダにある場合で、扱いがかわります。メール本文に、処理したい文字列があるのでしたら、環境により必要な処理となります。 結果、流用のレベルでは、ありません。
こんにちは。 Sub main() For a = 1 To 20 Shell "C:\Program Files\Internet Explorer\IEXPLORE.EXE http://www.yahoo.co.jp/" Next End Sub です。 修正箇所は、正しいurlと、最後の記号は、全角のダブルクォーツから半角のダブルクォーツに修正しました URLのスラッシュの隣です。 それから、shellは、一行です。 よく似ていますが、コンピュータは一文字でも駄目なら、エラーになるようになっています。
惜しいですね。 一見正しそうに、見えるのですが、FormNemuBox、ListBNemuBox は .Text または .Value を付けてやる必要があります。 MsgBox UserForms.Add(FormNemuBox.Text).Controls(ListBNemuBox.Text).ListCount
ヘッダのフォントを指定する場合、ヘッダの文字列の前に 「&"フォント名"」を入れます。 実際には、ダブルクォーテーション（"）を文字列の中に入れるので、 .CenterHeader = "&""ＭＳ Ｐ明朝""" & Join(Application.Transpose(Sheets("管理表").Range("H7:H9").Value), vbLf) のように "" と２つ続けて記述します。
アクティブなセルの値を直接クリップボードへ取り込むコーディング例です。 Sub 一例です() Dim xClip Set xClip = CreateObject("new:{1C3B4210-F441-11CE-B9EA-00AA006B1A69}") With xClip .SetText ActiveCell.Value .PutInClipboard End With End Sub
VLOOKUP関数ですね・・・ http://www.tipsfound.com/excel/04vlookup2 理解できれば、エラー回避やIF関数を絡めると 結構使いやすくできます。
どのように上手く繋がらないのか、もっと具体的に記述してください。 書いたコードも示していないのでは回答しようがありません。
基本的に、人の手で操作できることは可能ですから、作成できる範囲です。 ただ、一足飛びに全てを作ろうとすると、慣れていない人ほどごちゃごちゃになってしまい、収拾がつかなくなります。1つずつ、階段を上るように、試しながら作っていくと良いでしょう。 これが出来たら次はこれ、分からなくなったら調べる・質問する、という風に進めてみてはいかがでしょうか。マクロはプログラムの一種ですから、手順が重要です。手順を作るには要素分解は必要になります。要素分解ができていれば、分からない部分もはっきりするでしょうから、質問もし易いことと思います。
以下でどうなりますか Public Sub Samp1()    Dim i As Long    Const CROWH As Long = 1440    Application.ScreenUpdating = False    For i = 2 To 100       Cells((i - 1) * CROWH + 1, "A").Resize(CROWH).Cut Cells(1, i)    Next    Application.ScreenUpdating = True End Sub
比較のところで、isnullを追加してみてはいかがでしょう。 instr(isnull(textbox？.value,""),ssm) テキストボックス値がヌルの場合、instrは何を返すのかは、ヘルプ参照の事。
「IsNull(TextBox2.Value, "")」は間違いで 「IIf(IsNull(TextBox2.Value), "", IsNull(TextBox2.Value)」とすべきです。 AccessのVBAなら「Nz(TextBox2.Value, "")」とNz関数を使用することもできます。
同じような質問をいくつもされていますが、どれに回答すれば良いかわかりませんよ 改行があることが問題ならば、Replace関数で改行を削ってはどうでしょうか。 改行のコードを表す定数にvbCrLf、vbLf、vbCrの3つがあります。 このうちvbCrLfはvbLf＋vbCrですので、vbLf、vbCrを""に置き換えます。 また、３つのTextBoxで置き換えるので、それだけを別関数にします。 （サンプル） Dim ssm As String ssm = "通常" If InStr(改行を削る(TextBox2.Value), ssm) = 0 And _ InStr(改行を削る(TextBox3.Value), ssm) = 0 And _ InStr(改行を削る(TextBox4.Value), ssm) = 0 Then If TextBox1 = "" Then TextBox1 = ssm Else TextBox1 = TextBox1 & vbCrLf & ssm End If End If Private Function 改行を削る(st As String) As String 改行を削る = Replace(Replace(st, vbLf, ""), vbCr, "") End Function
私は放送大学の学生なのでアカデミックパックを購入しています。 もちろん、PCのハードやソフトは確定申告の時に必要経費として計上していますよ。
ファイルを相対パスでは開くことができません。 カレントパスからの相対参照ならば Set pst = ppt.Presentations.Open(CurDir & "\××\ファイル名.pptx") とするしかありません。 マクロのあるブックからの相対参照ならば ThisWorkbook.Path アクティブなブックからの相対参照ならば ActiveWorkbook.Path を使います
構成マネージャーの設定を変更すれば可能です。 一例を示すと、 Visual Studioのビルドメニュー → 構成マネージャー を表示します。 構成マネージャーの アクティブソリューション構成 をインストーラがビルドされる構成(例えばRelease)に変更します。 すると質問者さんの場合だと、Setupプロジェクトと実行ファイルのプロジェクトともに「ビルド」チェックがONになっていると思います。 実行ファイルの「ビルド」チェックをOFFにしてSetupだけビルドすれば以前にビルドした実行ファイルのタイムスタンプと同じになると思います。 上記のように、Setupプロジェクトをビルドする時点では、アプリケーションの実行ファイルはビルドしないように設定すればOKです。 アプリケーションをReleaseビルドした時点でのタイムスタンプと同一にするには、プロジェクトのプロパティで、ビルド出力パスをSetupプロジェクトの出力先に変更するか、ビルドイベントでビルド後に出力をコピーするようにコマンドを実行すればよいと思います。
こんにちは。 スプライト機能は、VBAの場合、絵の情報を設定している「コントロール」と、そのコントロールのleftとtopによる、表示位置のことですよ。 その当時、「表示の部品を動かす」ということは、「移動先のVRAM情報とorをした画面情報を計算、上書き。残像の部分の消去」をする必要がありましたが、 windowsのVBAの場合は、「コントロールに表示させたいキャラクタ」を設定して、コントロールの座標情報を直接操作します。 つまり、昔のスプライトのようなことを、今しています。 ドット絵というレベルでしたら、MSペイントで作成して、そのピクチャーを貼り付けた「四角」のコントロールを移動させることを考えてください
どう「うまくいかない」のですか？ どう動けば正解なんですか？
DSum(Worksheets("入力").Range("S3:W500"), Sheet1.Range("V3"), Worksheets("①全体実績").Range("R3:S4")) 次の2つの条件を満たしているなら、エラーは起きないと思います。 １） 2つ目のパラメータ、 Sheet1.Range("V3") のシート指定、Sheet1が「入力」シートのコード名（CodeName)であること。 MsgBox Worksheets("入力).CodeNameで確認できる筈。 ２） 「①全体実績」のR3：R4の値は、「入力」シートのS3：W3の中のいずれかの値であること。
こんにちは。 If TextBox1 = "" Then TextBox1 = ssm Else TextBox1 = TextBox1 & vbCrLf & ssm End If は If instr(TextBox1.value , ssm) = 0 Then if TextBox1.value = "" then TextBox1.value = ssm Else TextBox1 = TextBox1 & vbCrLf & ssm End If end if あと、コードは、2から4の3つのコントロールすべて、「ない状態」で発動です。 つまり、どれか、ひとつでも「文字」が存在したら、設定はしません。 説明では、そんなに厳密な説明でないので、確認です
Windows Updateが残ってるかも
activeworkbook.pathと書けば同じフォルダ内のブックの参照に必要なアドレスが取れるでしょう。 同じフォルダ内のエクセルファイルを参照するなら http://officetanaka.net/excel/vba/tips/tips69.htm から Sub Sample2() Dim buf As String, msg As String buf = Dir(activeworkbook.path & "\*.xls") Do While buf <> "" '見つけたxls系ブックへの処理 buf = Dir() Loop End Sub こちらのような処理とか。他こちらのサイトには有用な情報がたくさんあります。 やりたいことを整理するなら、あるブックでBシートをすべて値に変換(range("A1:X100").value=range("A1:X100").valueのような値転記)、Aシートを削除、Bシートの名前をブック名と同じに（質問文には”ブック名をシート名”としてますが、Bシートの名前をブック名に、の間違いなのかな、と。）そのシートは例えばVBAを実行しているファイルに移動。元のファイルは保存せず閉じる。次ファイルへ＞＞buf = Dir() 調べれば出てきそうなお話ばかりですね。
日報フォームが開かれていないために得意先コードが取得できないのが原因だと思います。 たいていのエラーはメッセージ内に解決のヒントがあります。 今回の場合、 「クエリ式'([得意先コード]=)And([商品コード]=S1)'の不要な')'があります。」 のうち ([得意先コード]=) がネックです。 =と)の間に値がないために、「変なところに)がありますよ」といっているわけです。 ここに値を入れてあげれば解決なのですが、入れたい値はフォームからの参照値なので、参照できるようにしましょう、という回答になります。
定型入力は「コード・スニペット」を使います。 製品版だと「マクロ」も有りますが、使ったことは無いですねぇ。 https://msdn.microsoft.com/ja-jp/library/8h31zbch%28v=vs.90%29.aspx
コンボボックスの内容を変更、あるいはクリアボタンでコンボボックスをクリアした時にComboBox1_Changeが処理され、該当する値が無いのでエラーになるのではないですか。 テクストボックスに値を入れる前に、コンボボックスが有効な行になっているか判断すれば大丈夫そうです。 Private Sub ComboBox1_Change() With Me!ComboBox1 If .ListIndex >= 0 Then Me!TextBox1 = .Column(1) End If End With End Sub と、こんな感じです。 ※ComboBox1.ListIndex は選択されたコンボボックス内の行番号で、選択されていない場合（無効な値の場合も）-1 が入ります。
ファンクションのF5→セル選択→空白セルにチェック→OK これで空白セルのみ選択されているので そのまま右クリック→削除→ 左方向にシフト選択→OK
相変わらず、何をどうしたいのかわかりません。 プログラムも数学と同じで、積み重ねが必要です。わからないところが出てきたら、入門書に戻って、ちゃんと理解したから、先に進むようにしないと、同じ事の繰り返しになります。 また、なれないうちは、仕様をきちんと紙にかいて、整理して見てください。ただ、闇雲にプログラムを書いてもうまく行きません。 理解、整理できていないので、いろいろな事が不足しています。スレッド、デリゲート、IPアドレス、ポート、サーバーの意味、クライアントの意味など整理してみてください。 それが、わかれば応用はきくと思います。 サーバー側のサンプル http://xfs.jp/Bmtwq8
大学、専門でゲームプログラミング講師経験者です。 確か、「GameLib_d.lib」自体、標準のライブラリでは 無いはずです。 多分、添付CDからHDにインストール（コピー）しないと 使用出来ないと、考えられます。
Aspかphpみたいなものでの実装はどうですか
簡単なのは、対象ファイルを開いて、ペースト先に指定する方法です。 Set wb=Workbooks.Open("パス\保管場所.xls") Set Sh2=wb.Worksheets("シート名") wbはWorkbookオブジェクトですので、最後に保存なり、閉じるなりの操作をすれば良いと思います。
http://officetanaka.net/excel/vba/file/file09.htm Saveメソッドではなく、SaveAsメソッドを使っていませんか？ どのようなコードを書いているか補足してもらえると回答する人がしやすいと思います。
>試そうとしたのですが、よく分かりません。 ↓を参考にして http://officetanaka.net/excel/vba/tips/tips37.htm InputBox関数を使用 x = InputBox("セルのアドレスを入力してください") For Each Sh In Worksheets Sh.Range(x).Value = Sh.Name Next InputBoxメソッドを使用 Set MyRange = Application.InputBox(Prompt:="セルを選択してください。", Type:=8) x=MyRange.Address(False, False) For Each Sh In Worksheets Sh.Range(x).Value = Sh.Name Next キャンセルボタン押された時や、InputBox関数の場合に無効な値(セルアドレス以外)を入力された場合はどの様にするのか？ 処理を継続する必要があるなら とりあえずA1セルを入力対象にする 有効な値が入力されるまでループする 等が考えられるが・・・・
マトリックスの考え方を用いて作成しました。 ①：元データで２００行まで対応としました。 ②：元データで１グループにつき最大Ｄ列（４列）までとしました。 ③：元データで最大４列×１００グループ対応としました。 ④：全５シートで作成しました。 回答です。 ＜Sheet1＞シート ご質問のレイアウトのデータです。 ＜作業１＞シート ◇数式（ここからコピーして貼り付けて下さい。） ★A2:=IF(Sheet1!A2="","",IF(Sheet1!A2="A",1,0)) ★B2:=IF(Sheet1!B2="","",IF(Sheet1!B2="A",1,0)+A2) ★A3:=IFERROR(MATCH(COLUMN(A1),2:2,0),"") ★A4:=IF(A3="","",IF(B3="",COUNT(2:2)-A3+1,B3-A3)) 各１００列目（CV列）までドラグコピー。 ★A6:=IFERROR(IF(作業２!$B2>A$4,"",IF(OFFSET(INDIRECT("Sheet1!"&ADDRESS(2,1+A$3-1)),作業２!$A2,作業２!$B2-1)=0,"",OFFSET(INDIRECT("Sheet1!"&ADDRESS(2,1+A$3-1)),作業２!$A2,作業２!$B2-1))),"") 下方へは８０５行目までドラグコピー。 右方へは１００列目（CV列）までドラグコピー。 ＜作業２＞シート ◇数式（ここからコピーして貼り付けて下さい。） ★A2:=MOD((ROW()-2),200)+1 ★B2:=IF(A2=1,1,0)+B1 各８０１行目までドラグコピー。 ＜作業３＞シート ◇数式（ここからコピーして貼り付けて下さい。） ★A6:=IF(作業１!A6<>"",1,0)+A5 下方へは８０５行目までドラグコピー。 右方へは１００列目（CV列）までドラグコピー。 ＜Sheet2＞シート・・・回答シートです。 ★A3:=IFERROR(INDEX(作業１!A:A,MATCH(ROW(A1),作業３!A:A,0),1),"") 下方へは８０２行目までドラグコピー。 右方へは１００列目（CV列）までドラグコピー。 ★A2:=IF(A3="","",CHAR(64+COLUMN())&"1") 右方へ１００列目（CV列）までドラグコピー。 ※作成したブックを提供します。 下記URLからダウンロードできます。 場所：ヤフーボックス ファイル名：並び替え URL： http://yahoo.jp/box/ZHd9YK 2.9Mあります。
②も動きます。しかし①は少々癖のある変数の使い方をしているため、それを知らずに①を修正して②にしてしまった可能性があります。 ①と②でFoundCellの型宣言は何にしてますか？①は型宣言省略あるいはVariantの筈です。型宣言を省略した場合もVariantになります。②あなたはRangeで宣言してませんか？本来はあなたの使い方にすべきです。Variantは何でもＯＫの型で、セルだろうが文字列だろうが何でも入ります。 Set FoundCell = Range("AO3:CJ3").Find(What:=Range("J3"),LookIn:=xlValues,LookAt:=xlWhole, SearchOrder:=xlByRows) ここでFoundCellにはセルが入ってます。しかし下の方で FoundCell = ActiveCell.Address 現在アクティブになっているセルのアドレス、つまり"A1"等の文字列が代入されてます。Variantには何でも入る特性を使っていわゆる「変数の使い回し」をしてます。②の型宣言をRangeにしている場合、ここでエラーになります。 修正後 Sub macro1() Dim MaxRow As Long Dim FoundCell As Range Dim FoundAdrs As String MaxRow = 20 '記載ないため勝手に決めました。 FoundAdrs="" Set FoundCell = Range("AO3:CJ3").Find(What:=Range("J3"), LookIn:=xlValues, _ LookAt:=xlWhole, SearchOrder:=xlByRows) If FoundCell Is Nothing Then MsgBox "検索に失敗しました" Else FoundCell.Select Debug.Print FoundCell.Row; FoundCell.Address End If Range("J5:M" & MaxRow).Copy FoundAdrs = ActiveCell.Address On Error Resume Next Range(FoundAdrs).Offset(2, 0).PasteSpecial Paste:=xlPasteValues Range("J3").Copy Range(FoundAdrs).PasteSpecial Application.CutCopyMode = False Set FoundCell = Nothing End Sub このマクロ、Findで見つからなかった場合は、どこにあるのかもわからないアクティブセルが代入されますが、それでいいの？前後の記載が無いから分りませんが。
【式1】 B1=A1&REPT("※",COUNTIF(A1,"*市場*")) 【式2】 C1=SUBSTITUTE(A1,"市場","市場※") 【式3】 B1=IF(COUNTIF(A$1:A1,A1)=1,"●"&A1&"●","")
体感できるほどの時間差はないと思います。 ところで、 >いちど Application.ScreenUpdating = True に戻して >ステータスバーに処理の進捗状況を表示させてます。 とありますが、ステータスバーはScreenUpdatingにかかわらず表示しますよ。 Sub sample() Dim t As Single Dim i As Integer Application.ScreenUpdating = False Application.EnableEvents = False t = Int(Timer) For i = 1 To 10 Application.StatusBar = i Do While t = Int(Timer): DoEvents: Loop t = Int(Timer) Next Application.StatusBar = False Application.ScreenUpdating = True Application.EnableEvents = True End Sub VBAを高速化したかったら、 「セルの読み書きはまとめてする、行や列の削除もまとめてする」 つまり、 「できるだけセルに触らない。やるまらまとめて。」 でしょう。
モジュールは、オブジェクトモジュール、フォームモジュール、標準モジュール、クラスモジュールに分類されます。この分類の中にどういうモジュールがあるのかを表示するのが、フォルダー毎に表示する方法です。 一方、切り替えボタンを押すと、フォルダー毎の表示ではなく、全てのモジュールをアルファベット順に並べて表示します。 モジュール名で探すときはアルファベット順に表示したほうが探しやすいでしょう。 しかし、このことはモジュール名をつけるときに考えておかなければいけないということを意味します。 何の規則性もなくモジュール名を適当につけてしまうと、全てのモジュールを表示したとき、オブジェクトモジュール、フォームモジュール、標準モジュール、クラスモジュールが入り混じって表示されてしまいます。（それぞれの塊で表示されない） アイコンで判別はできますが、相当見難くなってしまうでしょう。 メリット・デメリットというより、目的や見易さに応じて使い分ければいいのではないでしょうか。
下記のサイトを参照して下さい。 http://www.officepro.jp/excelvba/ini/index2.html
ＤＸライブラリは誰かが作った自作関数 知らない人が作った自作関数の質問なんて誰も答えられるわけが無い
siguma = WorksheetFunction.StDevP(Range(Cells(start, 24), Cells(last, 24))) としてください。
こんにちは。 wordやpptのアプリの場合、「自動でしてほしいこと」そのものが、 少ないため、書籍にしても、かなりありません。 本来、VBAを応用した高度なコードは、MSDNでの資料を読みこなし、officeの開発環境があるユーザーの善意で、ツールバー関係のサンプルコードを公開していたりしてます。 ツールの知識の習得よりも、「そもそもなにがしたい」という部分を明確にして、それをVBAで対応でできるのか、ということのほうが、作りやすいです。 wordもpptも、「自動の記録」は、期待できないので、開発環境のユーザーでないと、相当大変です。
お尋ね頂いた事項は、「簡単には」できません。 Set ApplLST = GetObject("winmgmts:").InstancesOf("win32_process") で、インスタンスを参照可能な情報が得られて、「CreationDate」というプロパティでインスタンスが作られた日時が取得できます。ですから、日時を比較することで「最後に開いたもの」を探せそうに思えます。 ですが、（実際にApplLSTで取得できたインスタンス情報をリストアップすれば分かりますが）explorerはいくつウィンドウを開いても、インスタンスの実体は１つなのです。 ですのでお示し頂いたコードでいうと、For Eachで網羅的にウィンドウを閉じているように思えるけど、実は１つのインスタンスをTerminateしているだけです。それで全部のウィンドウが閉じてしまいます。 ではウィンドウの一覧を取得すればいいかというと、ウィンドウから作成日時情報は取り出せません。なので、これもダメです。 という訳で、まったくエレガントではないのですが、必要な期間ずっとスクリプトを動作させてexplorerの挙動を監視し、ウィンドウが増減するたびにそのウィンドウの参照と日時を記録する、ぐらいしか方法がないように思います。
GroupBoxの枠線はプロパティで色を変えることは出来ません。 Paintイベントで自分で線を描画する必要があります。
下記のコードでどうでしょうか。 Sub sample() Dim bk1 As Workbook, bk2 As Workbook Dim bkNames As Variant Dim num As Double, cnt As Double Dim i As Integer On Error Resume Next Application.ScreenUpdating = False Set bk1 = ThisWorkbook bkNames = Array("B.xlsx", "C.xlsx") num = 0 For i = 0 To UBound(bkNames) Set bk2 = Workbooks.Open(bkNames(i)) num = num + CDbl(bk2.Worksheets(1).Cells(1, 1).Value) bk2.Close If Err = 0 Then cnt = cnt + 1 Next If cnt > 0 Then bk1.Worksheets(1).Cells(1, 1).Value = num / cnt On Error GoTo 0 Application.ScreenUpdating = True End Sub 50ほどあるブックをArrayに書き連ねるのは大変だと思います。 通常はAの邪魔にならない場所（たとえばZ列）にブックの名前を書いておくのがいいでしょう。 あるいはAと同じフォルダにまとめておく方法もあります。 これらの方法をとる場合のコードの書き方は知恵袋にもネットにもたくさんQ&Aがあります。
>エクセルの住所録をここにいれて翻訳結果をエクセルに取り込みたいです。そのようなことは可能でしょうか？ 可能です。 >VBA書いていただけませんか？ ID非公開で頼んでやってもらえるような物ではありません。 >また、いくつか作業が必要なのですが、こちらも教えていただけますか？ それは取り込んだデーターの処理なので、物が無ければ制作することも不可能です。
>satoutakao1515さん2016/5/714:50:07 >エクセルVBAでFX自動売買プログラムを制作出来ますか？ 出来るでしょうが、自動売買プログラムを設計出来るレベルの人がエクセルVBAのような非効率＆妥協を予測される物で作ったりはしないんじゃないかな。
テーブルには制約を設けて制約のあるデータは登録出来ないようにする機能があります、その一つにユニーク（UNIQUE)制約が有ります。これをDATE型の列に設定しておけば、同じ日付けを登録しようとした場合はエラーと成るので、プログラムでエラーを拾って再入力を促します。ただし、基本的には同じ日付けでも良いはずですので、ユーザーと日付けの２項目でユニークとされた方がエラーとならない分ベターと考えます。
>Iferrorを外すと、うまくいきます。 IsError(VLookup(Sheet2!AN2),Sheet3!$A$154:$B$154,2,FALSE) IsErrorに、引数が4つあるということになってますね？ （）の位置を見直すところでしょう？
こんなぶつ切りのソースでは判りません。 抜き出し方も肝心な部分を外しているので全く参考になりませんね。 変数名にアンダースコアを多用したりすべて大文字で表記する、というのは誰かから教わりましたか？少なくともVisualBasicで推奨される命名規則からはかなり逸脱しているので、やめた方がいいですよ。 初回で表示した文字が消えないというのは、ボタンクリックイベントの先頭でラベルのテキストをクリアしていない可能性が非常に大きいです。
開始日はG列、終了日はH列で５行目以降に記述されるとします。 開始日、終了日を入力された（セルが変更された）場合に色を塗るようにします。 ワークシートのモジュールに記述します。 サンプル（何をやっているかは、コメントを見てください） Private Sub Worksheet_Change(ByVal Target As Range) Dim Rng As Range Dim StartRng As Range Dim EndRng As Range Dim i As Long Dim m As Long Dim s As Long Dim e As Long '変更されたセルにG、H列の5行目以降のセルが含まれる場合に処理する If Not Intersect(Target, Range("G5:H" & Rows.Count)) Is Nothing Then Set StartRng = Nothing Set EndRng = Nothing '日付の行（4行目）の最終列判定 m = Cells(4, Columns.Count).End(xlToLeft).Column '変更されたセルのうちG、H列のセルを一つずつチェック For Each Rng In Intersect(Target, Range("G:H")) '開始日を変更された場合 If Rng.Column = 7 Then Set StartRng = Rng Set EndRng = Rng.Offset(, 1) ElseIf Rng.Column = 8 Then '終了日を変更された場合 Set StartRng = Rng.Offset(, -1) Set EndRng = Rng End If 'その行を塗りつぶしなしにする（開始日、終了日を含めて） StartRng.Resize(, m - 8 + 2).Interior.ColorIndex = xlNone If (Not IsDate(StartRng.Value)) Or (Not IsDate(EndRng.Value)) Then '開始日、終了日のいずれかの指定がなければ処理なし ElseIf StartRng.Value > EndRng.Value Then '開始日＞終了日の場合・・開始日、終了日のセルの色を赤くする StartRng.Resize(, 2).Interior.Color = RGB(255, 0, 0) ElseIf (StartRng.Value > Cells(4, m).Value) Or (EndRng.Value < Cells(4, 9).Value) Then '開始日が日付行の右端より大きい、終了日が日付行の先頭より小さい場合処理なし Else '開始日、終了日の列を求める s = 0 e = 0 'I列から最終列までチェック For i = 9 To m '開始日が等しいか小さい日が最初に現れた列番号を控える If (StartRng.Value <= Cells(4, i).Value) And (s = 0) Then s = i '終了日が等しい日が最初に現れた列番号を控える If (EndRng.Value = Cells(4, i).Value) And (e = 0) Then e = i '終了日が等しい日が過ぎ、小さい日が最初に現れた列番号のひとつ前を控える If (EndRng.Value < Cells(4, i).Value) And (e = 0) Then e = i - 1 Next '開始日、終了日が見つかっていなけれな先頭（I列）、最終列をセット If s = 0 Then s = 9 If e = 0 Then e = m '該当範囲のセルの色を付ける（青色） Range(Cells(StartRng.Row, s), Cells(EndRng.Row, e)).Interior.Color = RGB(0, 0, 255) End If Next End If End Sub
for文の次の行にif文を入れてmが13～15の間は翌年の1～3月になるように書き換えてあげないとダメですよ。
G列のデータで今月1日以降の日付の件数から来月1日以降の日付の件数を引いたものを取得する つまり、G列内に入っている日付データから今月中の日付の件数が算出されます
私は秀和システムの「ExcelVBA逆引き大全」という本と ネットの 「Office TANAKA - Excel VBA Tips」 http://officetanaka.net/excel/vba/tips/index.htm 「Excel VBA を学ぶなら moug モーグ」 http://www.moug.net/ を利用しています。 ログ解析で判らないことがあったら 「ログ解析 ○○」でググれば何かしらの情報は得られます。
添付図を参考にしています。左図はSheet1、右図はSheet2として。 Sub Test() Dim sh1 As Worksheet, sh2 As Worksheet, EndRow As Long Dim i As Long, num(2) As String, Gyou As Long Set sh1 = Worksheets("Sheet1") Set sh2 = Worksheets("Sheet2") With sh1 EndRow = .Range("A" & Rows.Count).End(xlUp).Row Gyou = ActiveCell.Row EndRow = EndRow - Gyou Select Case EndRow Case 0 num(0) = .Range("A" & Gyou) num(1) = .Range("A2") num(2) = .Range("A3") Case 1 num(0) = .Range("A" & Gyou) num(1) = .Range("A" & Gyou).Offset(1) num(2) = .Range("A2") Case Else num(0) = .Range("A" & Gyou) num(1) = .Range("A" & Gyou).Offset(1) num(2) = .Range("A" & Gyou).Offset(2) End Select End With With sh2.Range("A1") .AutoFilter Field:=3, Criteria1:=num, Operator:=xlFilterValues End With End Sub
FFFTPはFTPソフトの名前。サーバーではありません。 1. sというフォルダに業者からもらったデータを入れ（すでにsフォルダに入っているなら新たにフォルダを作らずフォルダごと）、サーバーにそのままアップロードすればOK。 2. 業者に頼みましょう。そこまでやってもらえないなら金は払えないと言いましょう。
こんにちは。 環境がないので、その対応ですが、 1 小文字のデータを処理したときの、 パターンを、ビットイメージで、ファイルつくり、ペイントで、見比べてください。 どこで、変換エラーがあるかを、確認してください。 規格資料を確認し、大文字と小文字の違いがあるかの確認も、してください。 もし、区別のない仕様ならば、読み込みしてから、大文字に読み替える関数を、組み合わせることに、なります。
マクロを記述したブックと同じフォルダに保存します。 Sub STC() Dim CSVST As Worksheet With Application .DisplayAlerts = False .ScreenUpdating = False For Each CSVST In Worksheets CSVST.Copy ActiveWorkbook.SaveAs Filename:=ThisWorkbook.Path & "\" & ActiveSheet.Name & ".csv", _ FileFormat:=xlCSV, CreateBackup:=False ActiveWorkbook.Close False Next CSVST .ScreenUpdating = True .DisplayAlerts = False End With End Sub
AddRangeで追加するのではなく Addで追加するのであれば Public Class Form1 Private Sub Button1_Click_1(sender As Object, e As EventArgs) Handles Button1.Click ListBox1.Items.Clear() Dim item_dataList As New Class1 Class1.Main() For Each i As String In item_dataList.d ’ListBox1.Items.Add(i) ' dの各要素の 4文字目以降であれば … ListBox1.Items.Add(i.Substring(3)) Next End Sub End Class で 希望通りの動きなのでは …
こんばんは 特定の行だけ色を変更するサンプルです。 Public Class Form1 Private Sub Form1_Shown(sender As System.Object, e As System.EventArgs) Handles MyBase.Shown ListBox1.DrawMode = DrawMode.OwnerDrawFixed ListBox1.Items.Add("a") ListBox1.Items.Add("b") ListBox1.Items.Add("c") End Sub Private Sub ListBox1_DrawItem(sender As System.Object, e As System.Windows.Forms.DrawItemEventArgs) Handles ListBox1.DrawItem If e.Index = -1 Then Exit Sub End If e.DrawBackground() '奇数項目の背景をブルーにする。 If e.Index = 2 Then '項目が選択されている場合は色を塗らない。 If CBool(e.State And DrawItemState.Selected) = False Then e.Graphics.FillRectangle(Brushes.Blue, New RectangleF(e.Bounds.X, e.Bounds.Y, e.Bounds.Width, e.Bounds.Height)) End If End If Dim myBrush As Brush = New SolidBrush(ListBox1.ForeColor) e.Graphics.DrawString(ListBox1.Items(e.Index), e.Font, myBrush, New RectangleF(e.Bounds.X, e.Bounds.Y, e.Bounds.Width, e.Bounds.Height)) e.DrawFocusRectangle() End Sub End Class 行の番号は自由に変更してください。
A列に顧客NO、B列に預かり中が入力されている時の例です。 Sub sample() Dim xDic, rng As Range, xAry Set xDic = CreateObject("Scripting.Dictionary") For Each rng In Range("A1", Cells(Rows.Count, 1).End(xlUp)) With rng If .Offset(, 1).Value = "預かり中" Then xAry = Split(.Value, "-") On Error Resume Next xDic.Add xAry(0), xAry(0) On Error GoTo 0 End If End With Next rng MsgBox " 預かり中は、" & xDic.Count & " 人です" End Sub
最初に AutoFilter を宣言しているのは何のためでしょうか。 AdvancedFilter を使用するなら特にAutoFilter の宣言は不要だと思います。 また、Range("A7").AutoFilter としているので、途中に空白行（すべての列が空白）があった場合には、その上までが自動的に AutoFilter の範囲になります。 ただし、実際には AdvancedFilter をかけていますので、AutoFilter は無視されると思います。 またAdvancedFilter はRange("A7:M5000")に対して行っていますので、AutoFilter の範囲は関係なく、7行目から5000行目が対象です。 >新しくデータを入力したものや、 >元に入っているデータを書き替えたりすると、 >全く抽出してくれません。 新しく入力したのが5000行目以降ということはありませんか？ 書き替えのデータが抽出できないのは・・わかりません。 >空欄もありません。 空欄も抽出するような条件が入っているのでしょうか？ とりあえず、最初の AutoFilter はやめ、すでにフィルタがかかっていれば解除するように以下のようなステップを追加してもだめでしょうか。 If ActiveSheet.FilterMode = True Then ActiveSheet.ShowAllData
PowerShellの配列は基本 固定長で可変長な 使い方をすると遅めなので、最初から可変長 なArrayList辺りを使った方が早くて楽かと。 $al = New-Object System.Collections.ArrayList $al.Add(～) foreach($e in $al){echo "[$e]"} $al.Count $al[2] #または $al.Item(2)# $al.ToArray()
C#経験者であれば VisualStudioでASP.NET Webアプリケーションを利用して構築するのが早いですね。 社内検証用であれば、開発機がそのままWebサーバになります。 後はDBとの連携ですが,ASP.NETに組み込みやすいのはMS SQL Serverですね。 当然UI設計はhtml,css,Javascriptなどの知識がある程度必要になります。 時間あるならまずはVSでプロジェクト作ってみては？ ないなら外注で
ヘルプで出てきたコードにちょっと加えてみました。 Sub Sample() Dim triArray(1 To 4, 1 To 2) As Single triArray(1, 1) = 25 triArray(1, 2) = 100 triArray(2, 1) = 100 triArray(2, 2) = 150 triArray(3, 1) = 150 triArray(3, 2) = 50 triArray(4, 1) = 25 ' Last point has same coordinates as first triArray(4, 2) = 100 Set MyDocument = Worksheets(1) With MyDocument.Shapes.AddPolyline(triArray) .Line.ForeColor.RGB = RGB(255, 255, 0) .Fill.ForeColor.RGB = RGB(0, 255, 0) .Fill.Transparency = 0.8 .Name = "ポリライン01" End With End Sub
outlook VB msg読み込み↓参考 http://www.dotnetgallery.com/lab/resource157-How-to-Read-MS-Outlook... #キャストできない場合のエラー処理等は追加が必要ですが、、 で、添付は普通に For Each buf In item.Attachments MsgBox(buf.FileName) Next こんな感じで参照できます 後は適当に保存 （ここら辺の添付の扱いはサンプルがごろごろ転がってます）
>そこでAの中のものをBへUSB伝いで移行させたのですが それは、ファイルをコピーしたってことですか？ レジストリの設定やらいろいろあるので、Bでインストールしなければ使えないでしょうね。 ライセンスについては詳しくないのですが、Visual Studioは開発者ごとにライセンスのはずですから、Bにインストールしなおしても、使うの人にライセンスがあれば問題ないはずです。
下記のコードでいかがでしょうか。 Public Class Form1 Dim bDrag As Boolean, ptDrag As Point Private Sub PictureBox_MouseDown(sender As Object, e As EventArgs) Handles PictureBox1.MouseDown, PictureBox2.MouseDown If bDrag = False Then bDrag = True ptDrag = Cursor.Position End If End Sub Private Sub PictureBox_MouseMove(sender As Object, e As EventArgs) Handles PictureBox1.MouseMove, PictureBox2.MouseMove If bDrag Then sender.Location = sender.Location + Cursor.Position - ptDrag ptDrag = Cursor.Position End If End Sub Private Sub PictureBox_MouseUp(sender As Object, e As EventArgs) Handles PictureBox1.MouseUp, PictureBox2.MouseUp bDrag = False End Sub End Class
textbox1.clear() の事なのかな？
明確になっていない部分は下記のとおりでマクロを作成しました。 データは全て1行目からとしています。 1行目が項目名でしたらコードを修正して下さい。 また、Bブックの各シートのデータには100行の価格データがあるものとして固定で扱っています。 AブックとBブックは同じフォルダに入っているものとします。 fpath = "D:\Data\" 'ここに実際のディレクトリを設定 この部分で設定して下さい。（最後に\をつけるのを忘れないように） A,Bどちらでもないエクセルファイルにこのマクロを登録して実行します。 Sub Sample() Dim fpath As String Dim wb1 As Workbook, wb2 As Workbook Dim sh As Worksheet Dim rr As Long, rmax As Long Dim sname As String Application.ScreenUpdating = False Application.DisplayAlerts = False Set wb1 = ThisWorkbook fpath = "D:\Data\" 'ここに実際のディレクトリを設定 Set wb1 = Workbooks.Open(fpath & "A.xlsx") Set wb2 = Workbooks.Open(fpath & "B.xlsx") With wb1.Worksheets("Sheet1") rmax = .Cells(Rows.Count, "M").End(xlUp).Row For rr = 1 To rmax Step 100 sname = "1510C" & .Range("M" & rr).Value Set sh = Nothing With wb2 For Each sh In Worksheets If sh.Name = sname Then Set sh = wb2.Worksheets(sname) Exit For End If Next sh End With If Not sh Is Nothing Then sh.Range("B1:E100").Copy Destination:=.Range("C" & rr) End If Next rr End With wb1.Save wb1.Close wb2.Close Application.DisplayAlerts = True Application.ScreenUpdating = True End Sub
こんにちは。 「文字数が多い」 のでしょうか。 URLのルールを守っていない、つまり、間違った文字列になっている、というのが心配です
検索範囲に検索対象のセルが存在するというのなら Dim r As Range Set r = Range("A2:A99").Find(ComboBox1.Value).Offset(0, 1).Value ComboBox2.Value = r Dim r As Range Set r = Range("B2:B99").Find(ComboBox2.Value).Offset(0, -1).Value Set ComboBox1.Value = r ↓ Dim r As Range Set r = Range("A2:A99").Find(ComboBox1.Value).Offset(0, 1) ComboBox2.Value = r.Value Set r = Range("B2:B99").Find(ComboBox2.Value).Offset(0, -1) Set ComboBox1.Value = r.Value 値を、セル範囲を表す変数をSetするのはおかしいですよね？
例えば1行目が見出しで、A列が名前、B列が血液型、C列が生年月日、D列が住所 の場合です。 ユーザーフォームに、ComboBox1,ListBox1,CommandButton1,Label1,Label2,Label3 がある場合です。 同姓同名が無い場合と、同姓同名がある場合の2つです。 [ 同姓同名が無い場合 ] 'ユーザーフォームの初期化 Private Sub UserForm_Initialize() 'Combo1の初期値(血液型)設定 ComboBox1.AddItem "全て" ComboBox1.AddItem "A" ComboBox1.AddItem "B" ComboBox1.AddItem "O" ComboBox1.AddItem "AB" End Sub 'コンボ1が変更されたときの処理 Private Sub ComboBox1_Change() Dim lastRow As Long Dim r As Long ListBox1.Clear 'リスト1クリア lastRow = Range("A" & Rows.Count).End(xlUp).Row 'A列最終行 For r = 2 To lastRow '注目行を2行目からA列最終行まで If (ComboBox1.Value = "全て") Or (Range("B" & r).Value = ComboBox1.Value) Then 'B列(血液型)の注目行の値がコンボ1で選んだ値(血液型)なら ListBox1.AddItem Range("A" & r).Value 'リスト1にA列注目行の値(名前)を追加 End If Next ListBox1.SetFocus 'リスト1を選択 End Sub 'コマンドボタン1を押したとき Private Sub CommandButton1_Click() Dim rng As Range Dim r As Long Set rng = Range("A:A").Find(ListBox1.Value, lookAt:=xlWhole) 'A列でリストボックス1の値(名前)を探す If rng Is Nothing Then Exit Sub '無ければ終了 r = rng.Row '名前があった行 Label1.Caption = Range("C" & r).Value '生年月日 Label2.Caption = Range("D" & r).Value '住所 Label3.Caption = Range("B" & r).Value '血液型 End Sub [ 同姓同名がある場合 ] 'ユーザーフォームの初期化 Private Sub UserForm_Initialize() 'Combo1の初期値(血液型)設定 ComboBox1.AddItem "全て" ComboBox1.AddItem "A" ComboBox1.AddItem "B" ComboBox1.AddItem "O" ComboBox1.AddItem "AB" End Sub 'コンボ1が変更されたときの処理 Private Sub ComboBox1_Change() Dim lastRow As Long Dim r As Long ListBox1.Clear 'リスト1クリア lastRow = Range("A" & Rows.Count).End(xlUp).Row 'A列最終行 For r = 2 To lastRow '注目行を2行目からA列最終行まで If (ComboBox1.Value = "全て") Or (Range("B" & r).Value = ComboBox1.Value) Then 'B列(血液型)の注目行の値がコンボ1で選んだ値(血液型)なら ListBox1.AddItem Range("A" & r).Value 'リスト1にA列注目行の値(名前)を追加 ListBox1.List(ListBox1.ListCount - 1, 1) = r '今追加したリストボックスの2列目(見えないけれど)に追加した名前の行番号を設定(ちなみにListBox1.ListCount - 1なのは、Listbox1.List(row,column)のrow,columnは0から始まるので例えば1行目ならrow=0なので) End If Next ListBox1.SetFocus 'リスト1を選択 End Sub 'コマンドボタン1を押したとき Private Sub CommandButton1_Click() Dim r As Variant If ListBox1.ListIndex = -1 Then Exit Sub 'まだリストボックス1(名前)が選択されてないなら終了 r = ListBox1.List(ListBox1.ListIndex, 1) '選ばれたリストの2列目の値(名前の人のデータがある行) Label1.Caption = Range("C" & r).Value '生年月日 Label2.Caption = Range("D" & r).Value '住所 Label3.Caption = Range("B" & r).Value '血液型 End Sub
細かい仕様が不明なので、 １行目が見出しで、A列に名前、B列に血液型とします。 最終行はA列(名前)がある間とします。 コンボボックス1、コンボボックス2は、ユーザーフォームのコンボボックスとします。 あらかじめユーザーフォームに、ComboBox1、ComboBox2 という名前で2つのコンボボックスが作られているとします。 'ユーザーフォームの初期化 Private Sub UserForm_Initialize() 'Combo1の初期値(血液型)設定 ComboBox1.AddItem "A" ComboBox1.AddItem "B" ComboBox1.AddItem "O" ComboBox1.AddItem "AB" End Sub 'コンボ1が変更されたときの処理 Private Sub ComboBox1_Change() Dim lastRow As Long Dim r As Long ComboBox2.Clear 'コンボ2クリア lastRow = Range("A" & Rows.Count).End(xlUp).Row 'A列最終行 For r = 2 To lastRow '注目行を2行目からA列最終行まで If Range("B" & r).Value = ComboBox1.Value Then 'B列(血液型)の注目行の値がコンボ1で選んだ値(血液型)なら ComboBox2.AddItem Range("A" & r).Value 'コンボ2にA列注目行の値(名前)を追加 End If Next ComboBox2.SetFocus 'コンボ2を選択 End Sub
調べ方 エラーが出たら、 エラーメッセージを読む デバッグボタンが表示されたら押し、場所を確認する 変数にマウスを当てると、値が表示されるので、意図した通りか確認する
以前のQAで、複数のセルへの書き出ししてましたが･･･ 以前に、こちらでVBAでのコードを教えてもらい http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1415655149... Array(8, 5, 3) は固定で良いですか 出力先には 8:2, 5:2, 3:0 のような形式としてみると、 処理するシートのコードに、以下を記述してどうなりますか Private Sub Worksheet_Change(ByVal Target As Range)    Dim vA As Variant, vB As Variant    Dim iNum As Long    Dim i As Long    Const CRC As String = "BA7" ' 入力    Const C2RC As String = "BB7" ' 出力先    If (Intersect(Target, Range(CRC)) Is Nothing) Then Exit Sub    iNum = Val(Range(CRC).Value)    If (iNum < 1) Then Exit Sub    vA = Array(8, 5, 3)    vB = Samp1(iNum, vA)    If (Not IsEmpty(vB)) Then       For i = LBound(vA) To UBound(vA)          vB(i) = vA(i) & ":" & Val(vB(i))       Next       Application.EnableEvents = False       Range(C2RC).Value = Join(vB, ", ")       Application.EnableEvents = True    End If End Sub
Do While Cells(i, 2) <> "" でCells(i, 2)の内容が空白なら終了としていますが、この時のシートが指定されていません。 Do While Worksheets("入力").Cells(i, 2) <> "" とするか、その前で Sheets("入力").Activate または Sheets("入力").Select でアクティブシートを"入力"にする必要があります。
Do While Cells(i, 2) <> "" でCells(i, 2)の内容が空白なら終了としていますが、この時のシートが指定されていません。 Do While Worksheets("入力").Cells(i, 2) <> "" とするか、その前で Sheets("入力").Activate または Sheets("入力").Select でアクティブシートを"入力"にする必要があります。
マクロの保存先とは、作業中のブック、それとも個人用マクロブックのことですか？それなら、マクロの記録の開始画面で指定できます。 標準モジュールであれば、プロジェクトウィンドウにモジュールが表示されます。記述するマクロを分けたいなら、挿入メニューから標準モジュールを追加すれば良いです。 移動は、マクロ（プロシージャ）単位で切り取って、他のモジュール内で貼り付け。 モジュール名はいつでも変更できます。名前を変更したいモジュールを選択して、プロパティウィンドウの上の「オブジェクト名」の右側のテキストボックスで任意の名前を入力できます。
ZwQuerySystemInformation っていう非公開APIを使うようです。 http://www.papy.in/bbs/delphi/201002/10020065.html 利用例 http://mrxray.on.coocan.jp/Delphi/plSamples/332_ProcessListNtQuery....
シートの保護はご存知ですか。 リボンの「校閲」に「シートの保護」というのがあり、これを行うことで「ロック」を掛けたセルは入力不可になります。 ただし、全てのセルは標準で「ロック」がかかっているため、入力可能なセルのみ「セルの書式設定」－「保護」タブを開いて「ロック」のチェックを外す必要があります。 色付けを行っても印刷時に色を出ないようにするには、リボンの「ページレイアウト」の「印刷タイトル」を開き、「白黒印刷」にチェックを入れると塗りつぶしの色は出なくなります。 Visual Basicのカテなので、これらのことをVBAで行いたいってことなんでしょうか？
Sub sample() Dim xFSO, xPath As String, xFld As String, xSub Set FSO = CreateObject("Scripting.FileSystemObject") xPath = ThisWorkbook.Path xFld = Dir(xPath, vbDirectory) Application.ScreenUpdating = False Worksheets("Sheet6").Copy With ActiveWorkbook For Each xSub In FSO.GetFolder(xPath).ParentFolder.SubFolders If xSub.Name <> xFld Then .SaveAs Filename:=xSub & "\" & "AAA" End If Next xSub .Close savechanges:=False End With Set FSO = Nothing Application.ScreenUpdating = False End Sub
可能です。 テストしてみればわかると思いますが・・ ただし、サンプルのコードでListBox1_Clickの txtbox3.value=" &T & "分～" & TT & "分” は構文エラーです。
対象行を決定するために、A-E列の中に重複データが無い列がある場合と、どの列も重複がある場合が考えられます。 コマンドボタンはCommandButton1です。 [A-E列の中に重複データが無い列がある場合] 例えばA列が重複データが無い場合です。 B-E列が重複データが無い場合はコメントになっているどれかを有効にしてください。 Private Sub CommandButton1_Click() 'チェック If ListBox2.ListIndex = -1 Then MsgBox "選んでください" ListBox2.SetFocus Exit Sub End If ' Dim rng As Range Set rng = Range("A:A").Find(ListBox2.List(ListBox2.ListIndex, 0), LookIn:=xlValues, lookat:=xlWhole) 'A列でチェックする場合 'Set rng = Range("B:B").Find(ListBox2.List(ListBox2.ListIndex, 1), LookIn:=xlValues, lookat:=xlWhole) 'B列でチェックする場合 'Set rng = Range("C:C").Find(ListBox2.List(ListBox2.ListIndex, 2), LookIn:=xlValues, lookat:=xlWhole) 'C列でチェックする場合 'Set rng = Range("D:D").Find(ListBox2.List(ListBox2.ListIndex, 3), LookIn:=xlValues, lookat:=xlWhole) 'D列でチェックする場合 'Set rng = Range("E:E").Find(ListBox2.List(ListBox2.ListIndex, 4), LookIn:=xlValues, lookat:=xlWhole) 'E列でチェックする場合 Rows(rng.Row).Delete End Sub [A-E列の中に重複データが無い列が無い場合] リストボックスの中に行データを埋め込みます。 TextBox1_Changeに変更と追加をします。 >ReDim Preserve w(1 To 6, 1 To UBound(w, 2) + 1) を ReDim Preserve w(1 To 7, 1 To UBound(w, 2) + 1) に変更する。 >ReDim w(1 To 7, 1 To 1) を ReDim w(1 To 7, 1 To 1) に変更する。 >w(6, UBound(w, 2)) = Obj.EntireRow.Range("F1").Value の後に w(7, UBound(w, 2)) = Obj.Row を追加する。 CommandButton11_Clickです。 Private Sub CommandButton11_Click() 'チェック If ListBox2.ListIndex = -1 Then MsgBox "選んでください" ListBox2.SetFocus Exit Sub End If ' Rows(ListBox2.List(ListBox2.ListIndex, 6)).Delete End Sub
この記述をどのように修正したらうまくいくでしょうか？ If c.Formula = "" Then c.Value = Range("B1").Copy c.PasteSpecial Paste:=xlPasteFormulas ↓ If c.Formula = "" Then .Range("B1").Copy c.PasteSpecial Paste:=xlPasteFormulas End If どうせなら Sub test() With ActiveSheet .Range("B1").Copy For Each c In .Range("B2:B20") If c.Formula = "" Then c.PasteSpecial Paste:=xlPasteFormulas End If Next End With End Sub >上記の記述以外で、良い方法があれば、お教え頂きたいです。 Sub sample() Dim rng As Range With ActiveSheet On Error Resume Next Set rng = .Range("B2:B20").SpecialCells(xlCellTypeBlanks) On Error GoTo 0 If Not rng Is Nothing Then .Range("B1").Copy rng.PasteSpecial Paste:=xlPasteFormulas End If End With End Sub 対象セルが、1000セルくらいになると速度の違いが解るはず。
コメントアウトの最初のほう Workbooks(ThisWorkbook.Path & "\" & FileName).Activate は、パスは不要なので Workbooks(FileName).Activate とします。 次の SelectedWorkbook.Range("A2").Value = 123 ですが、「SelectedWorkbook」なんてありませんので、書くなら「ActiveWorkbook」ですが、ブックの指定はあってもシートの指定がありません。 複数シートがある場合はどうするのでしょうか？ 開いた時にアクティブなシートで良ければ、特に指定なしで Range("A2").Value = 123 でもいいです。 たとえば必ず先頭のシートなら ActiveWorkbook.Worksheets(1).Range("A2").Value = 123 でしょうか。
Visual Basicの知識がまったくないのであれば手作業で行うことをお勧めします。 会社の業務でマクロを使うのであれば多少なりともVBAの勉強をしてからでないと、失敗したときのリカバリーが効きませんよ。
対象はソートされているものと考えて良いでしょうか？ EXCELのCOUNTIF関数を使って「い」の数を数えて、行番号を起点行＋COUNTIF結果でどうでしょう？ －１しないと「ろ」の先頭を取得にはなりますが。
上記のようなことを行うためには、ユーザーフォームを使用します。 新しいユーザーフォームを作成し、ラベルとコマンドボタンを４つ配置します。 ラベルにはメッセージを書いておき、コマンドボタンをクリックされたらその結果を元のモジュールに返し、ユーザーフォームを閉じる。 ここでユーザーフォームの作り方を１から説明するのは簡単なことではありませんので、下記のサイトなどを参考にしてください。 Excelユーザーフォーム入門 http://excel-ubara.com/excelvba3/ VBA:ユーザーフォームを組み込みダイアログのように使う http://blog.goo.ne.jp/40vq77a80/e/cef67c4dcf3b5cef2388ad69a547214b 知恵袋の過去の質問から http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1454138194 作成途中で疑問などがあれば、ここで質問すれば誰かが答えてくれるでしょう。 －－－－－－－－－－－－－－－ 考えてみれば、最初からシートの登録ボタンを４つ用意するという案もありますよ。
コード例です。 Sub Sample() Dim Rng As Range For Each Rng In ActiveSheet.UsedRange If Rng.Interior.Color = vbYellow Then Rng.Interior.Color = vbBlack Next End Sub
>すでに結合されているセルを更に結合する場合、H5:H6というような先頭のセルの>みの指定でいけますか？ >それともH5：T6のような全てを指定しないとダメでしょうか？ 先頭のセルのみでも結合できますよ。 （例） Range("H5:H6").Merge ただし、列数が違う場合には長いほうに合わせられます。 たとえば、H5～O5とH6～T6の場合はH5～T6になります。 >結合されているセルを検索して、その結合されているセルと下のセルを結合するというようなこともできるのでしょうか？ 結合しているセルの検索方法はわかりません。 しらみ潰しにMergeCellsで確認するしかないかもしれませんね。 特定の列なら上から順にチェックするとか。
特定文字Bというのが、「"特定文字A"」と同じ意味なら、こういう↓変更なのですかね？初級のうちも、Option Explicit を使用するのがお勧め。 If Not c.Offset(0, -1).Value Like "*" & 特定文字B & "*" Then ↓ If Not (c.Offset(0, -1).Value Like "*" & "特定文字B" & "*") Then
VBは詳しくないけど、正規表現は使えないん？ (.*？)え で、いけると思うが。 あ、「あいうえ」になっちゃうかもだから、最後の”え”は、消す方向で。 「正規表現 言語名」 で検索すれば、見つかると思うが。
一例で・・。 Private Sub Worksheet_Change(ByVal Target As Range) If Intersect(Target, Range("D:D,F:F")) Is Nothing Then Exit Sub Target.Offset(, -1) = Date End Sub
パスワードが判っているのなら開けます。 Workbooks.Open "Book1.xlsx", Password:="aaaaa", WriteResPassword:="bbbbb" Workbooks.Openの詳しい使い方はヘルプを参照してください。
下記VBAの修正をお願いします。 と言われてもテストの上、回答しています。 そのエラーはマクロのロジックが原因ではないです。 どのように登録しましたか。 出力したいエクセルのシートのシートモ－ジュールに登録するマクロです。 別質問をたてるのではなく、元の質問で返信して頂きたいと思いました。
アマゾンでのJANコード検索というのは、どうやって行なうのでしょうか。それが分からないと、コードの組みようがありません。 ちなみに、有料ツールだと、私には手が出せません。
こんにちは。 gyo = 1 for i=2 to activeworkbook.sheets.count sheets(1).range("A" & gyo).value = sheets(i).name sheets(1).range("B" & gyo).value = sheets(i).range("a1").CurrentRegion.SpecialCells(xlCellTypeLastCell).Value gyo = gyo + 1 next です。
ActiveCell.FormulaR1C1 に対して関数の文字列を代入していますが、文字列はダブルクォーテーション（"）でくくってあります。 しかし、文字列の途中にもダブルクォーテーションがあることからエラーになります。 文字列の途中にダブルクォーテーションが入る場合は、ふたつ重ねて「""」とする事でひとつのダブルクォーテーションと認識してくれます。 したがって、次のように記述します。 ActiveCell.FormulaR1C1 = "=IF(ISERROR(FIND(CHAR(10),RC[-30])),"""",""改行有"")"
クロス集計クエリを作成し、 製品名を行見出し 工程順を列見出し 工程の先頭を値 として設定してください。 後はこのクエリをExcelとしてエクスポートするか、 単純に結果をExcelにコピペしてください。
IE操作命令だけでは取り出せません。余計な文字がどうしてもついてきますので、一旦取り出した後、文字列操作命令で抽出する必要があります。 msg=doc.getElementByID("kabu_ti").InnerText p1=InStr(msg, "[単]")+3 p2=InStr(msg, "名")-1 res=Mid(msg, p1, (p2-p1)+1) 確認していませんので、文字列の切り取り位置が正確かどうかは分かりません。 Mid(切り取り対象, 切り取り開始位置, 切り取り文字数) 書式はこうなっているので、ずれていたら調節してください。
＞A列に記入されている文字をタイトルとしてPDF出力を行いたいのですが、 タイトルとして出力とは (1) ヘッダーにする (2) ファイル名にする のどちらでしょうか？ わからないので、ヘッダーに指定したうえ、ファイル名にしています。 （ファイル名には".pdf"を追加しています。 以下のサンプルでは、出力するフォルダはConstで指定しています。 やっていることは、 (1) A列先頭から結合セルなら結合している行数、そうでなければ1行を対象とし (2) A~B列の対象行数を印刷範囲に指定し、ヘッダーを指定（ついでに水平方向に中央寄せ） (3) PDF出力 (4) 対象行数分進めて(1) に戻る サンプル（何をやっているかはコメントを見てください） Const outPath = "C:\出力フォルダ\" Sub Sample() Dim i As Long Dim j As Long Dim m As Long '最終行を求める m = Range("A" & Rows.Count).End(xlUp).Row '先頭行からはじめる i = 1 '終了行まで繰り返す Do Until i > m With Range("A" & i) If .MergeCells Then '結合セルなら、結合されている行数を控える j = .MergeArea.Rows.Count Else '結合されていなければ行数は 1 j = 1 End If '印刷範囲、ヘッダー、水平方向に中央寄せ ActiveSheet.PageSetup.PrintArea = .Resize(j, 2).Address ActiveSheet.PageSetup.CenterHeader = .Value ActiveSheet.PageSetup.CenterHorizontally = True 'PDFに出力 ActiveSheet.ExportAsFixedFormat Type:=xlTypePDF, Filename:=outPath & .Value & ".pdf" '行数分進める i = i + j End With Loop End Sub
>マクロで以下のようなものを組んだのですが、これだとオートフィルターを >かける範囲が$A$1:$U$1001を超えたときにうまく作動しなくなってしまう >ので直したいのですが、やり方がうまくわからず困っています。 よくやる方法としては、特定の列の最終行までを対象とする方法です。 ActiveSheet.Range("$A$1:$U$1001").AutoFilter Field:=8, Criteria1:="AAA" ↓ With ActiveSheet .Range(.Range("$A$1"), Range("$U$" & Rows.Count).End(xlUp)).AutoFilter Field:=8, Criteria1:="AAA" End With あるいは有効範囲すべてを対象にするとか ActiveSheet.UsedRange.AutoFilter Field:=8, Criteria1:="AAA"
単に Private Sub CheckBox1_Click() If 条件 Then CheckBox.Value = False End If End Sub ではだめなんでしょうか。
VBAでは実行しているモジュールの情報を取ってくることはできません。 単純に Private Sub TextBox2_Change() TextBox3 = TextBox2.Name End Sub とするしかありません。
細かい仕様が不明ですが、商品の価格マスタができているという事ですが、 >１：得意先毎に同じ物でも販売している物の単価が違う。 はどのようにしているのでしょうか。 また、商品マスタは別にあるのでしょうか。 各テーブルの詳細を教えてください。 例えば質問のような場合は、商品マスタに単価を持っているけれど、特定の得意先の特定の商品はいくらだとする価格テーブルを別に用意します。 また、ある商品の単価が変わるとこの商品の特別価格を全て変えなければならないので、単価でなく、価格差を持つ方がメンテナンスが楽になるかもしれません。 価格テーブルがあるだけで、伝票テーブルは一般的なものでいいと思います。 1枚の売上伝票に商品は1個だけなのか、複数なのかで違ってきますが、通常は1枚の伝票に1得意先で、複数行の商品ということだと思います。 消費税の取り扱いによってテーブルの内容も変わりますが、簡単にするために全て税込みの場合で考えます。 その場合のテーブルの例です。 [得意先マスタ] 得意先コード:長整数 得意先名:テキスト [商品マスタ] 商品コード:長整数 商品名:テキスト 通常単価:通貨型 [価格テーブル] 得意先コード:長整数 商品コード:長整数 特別単価:通貨型 [伝票見出しテーブル] ID：オートナンバー型 日付：日付型 得意先コード:長整数 [伝票明細テーブル] 伝票ID：長整数 商品コード:長整数 数量：通貨型 得意先マスタ、商品マスタ、価格テーブル は一般的なフォームで作れると思うので以下のようなデータが用意されているとします。 [得意先マスタ] 得意先コード,得意先名 1,あああ 2,いいい 3,ううう [商品マスタ] 商品コード,商品名,単価 1,かかか,100 2,ききき,200 3,くくく,300 [価格テーブル] 得意先コード 商品コード 単価 1,2,50 1,3,40 2,3,30 ちなみに価格テーブルは "ききき"商品(商品コード2)は200円だけれど、"あああ"得意先(得意先コード1)には50円とします。 "くくく"商品(商品コード3)は300円だけれど、"あああ"得意先(得意先コード1)には40円とします。 "くくく"商品(商品コード3)は300円だけれど、"いいい"得意先(得意先コード2)には30円とします。 と言う状況です。 伝票見出用のクエリと伝票明細用のクエリを作ります。 クエリデザインで作るのですが、ここでは説明が難しいのでSQLビューの画面で下記のクエリを入力してください。 [伝票見出クエリ] SELECT 伝票見出しテーブル.*, 得意先マスタ.得意先名 FROM (伝票見出しテーブル INNER JOIN 伝票明細テーブル ON 伝票見出しテーブル.ID = 伝票明細テーブル.伝票ID) INNER JOIN 得意先マスタ ON 伝票見出しテーブル.得意先コード = 得意先マスタ.得意先コード; [伝票明細クエリ] SELECT 伝票明細テーブル.*, 商品マスタ.商品名, DLookUp("[特別単価]","[価格テーブル]","([得意先コード]=" & [Forms]![伝票フォーム]![得意先コード] & ")And([商品コード]=" & [商品マスタ].[商品コード] & ")") AS 特別単価, IIf([特別単価]<>0,[特別単価],[標準単価]) AS 単価, [数量]*[単価] AS 金額 FROM 伝票明細テーブル LEFT JOIN 商品マスタ ON 伝票明細テーブル.商品コード = 商品マスタ.商品コード; フォームデザインで伝票入力フォームを作ります。 [伝票明細フォーム] レコードソース:伝票明細クエリ 5つのテキストボックスを用意します 名前,コントロールソース 商品コード：商品コード 商品名：商品名 数量：数量 単価：単価 金額：金額 商品名、単価、金額 のタブストップを「いいえ」にしてください。 [伝票フォーム] レコードソース:伝票見出クエリ 3つのテキストボックスと、サブフォーム/サブレポートと、コマンドボタンを用意します。 テキストボックス 名前,コントロールソース 日付：日付 得意先コード：得意先コード 得意先名：得意先名 得意先名のタブストップを「いいえ」に コマンドボタン 名前：登録 クリック時：マクロビルダー：レコードの移動：新しいレコード サブフォーム/サブレポート 名前：伝票明細フォーム ソースオブジェクト：伝票明細フォーム リンク親フィールド：ID リンク子フィールド：伝票ID
以下のように修正 Columns("2:" & Col).Delete ↓ Range(Columns(2),Columns(Col)).Delete
セルのIF関数と同じで If Ａ = Ｂ = Ｃ Then という書き方はできません。 VBAならば If (Ａ = Ｂ) And (Ａ = Ｃ) Then にします。（かっこは無くても大丈夫です） したがって、 If Val(TextBox1) = Val(Range("H1")) = Val(Range("AA3")) Then ↓ If Val(TextBox1) = Val(Range("H1")) And Val(TextBox1) = Val(Range("AA3")) Then
range1.Copy Range("L10").PasteSpecial Paste:=xlPasteValues Application.CutCopyMode = False ↓ Range("L10").Resize(range1.Rows.Count, range1.Columns.Count).Value = range1.Value コピー貼り付けをしなくても、このようにValueプロパティを設定すればいいと思います。
※指定日(シート"A"のB2の日付）がシートAのA列に該当>>シートBのA列の・・・の間違いではないですか 下記の表ですと、 シートAのＡ2～Ｋ7までを選択したいです>>そこまででよいのですか? そのあとは自分でコーディングするのでしょうか。
ユーザーフォーム１からユーザーフォーム２を開く時、いきなり ユーザーフォーム２.Show とせず、一度ロードし、値を入れてから表示します。 Load ユーザーフォーム２ ユーザーフォーム２.コンボボックス１.Value = Me.コンボボックス１.Value ユーザーフォーム２.Show
Sheets(1).Range("A65535").End(xlUp).Offset(1, 0).Selectは A列の最終行の次を指定する分です。 １行目の右端を指定するなら Sheets(1).Cells(1, Columns.Count).End(xlToLeft).Offset(0, 1).Select に 成ります。
作業用のセルを用いる方法があります。 ①D1,E1,F1と同じ行でデータ入力に差支えの無いセル（たとえばBZ1など）の幅をD1からF1の結合されたセルと同じ幅にします。フォントやフォントサイズも同じにします。 ②BZ1に「=D1」という数式を入力します。 ③BZ1の配置を「折り返して全体を表示する」に設定します。 以上でセルの高さが自動調整されるはずです。
手動で設定すると、ブラウザではChangeイベントを拾っているはずですので、そのせいかもしれません。Select1の値をセットした後、以下の方法で、強制的にChangeイベントを発生させてみてください。また、下記の後、少し待ち時間を作らないといけないかもしれません(ログインが必要なので、こちらでは試せません)。 Set ev=objIE.document.createEvent("HTMLEvents") ev.initEvent "change", True, True Select1.dispatchEvent(ev)
Sub test() Dim i As Long With Selection.Areas If .Count <> 2 Then Exit Sub End If .Item(2).Resize(5, 5).Interior.ColorIndex = xlNone For i = 1 To 25 If .Item(1).Resize(5, 5).Cells(i).Value = .Item(2).Resize(5, 5).Cells(i).Value Then .Item(2).Resize(5, 5).Cells(i).Interior.Color = vbYellow End If Next i End With End Sub
こんにちは。 「こんなことができたらいいな」という機能のほとんどは、基本機能の組み合わせで、 なんとかなる場合が多いです。 マクロを使うのは、その基本部分を高速に処理させたい、ということが多いんです。 主様、小額の費用で、できる、と考えているのが、間違いです。 ビジネスモデルとしては今後あるかもしれませんが、それは、ボランティアで作成したプログラマに、チップを渡す、というようなものです。 マクロは、「出来てから、ユーザーの手に渡ります」 ユーザーが、そのマクロを理解しないと、正しいことをしているのか、悪いことをしているのか、分かりません。 エクセルの性能限界を探すくらい、まず、調べてください。 エクセルは道具です。結果が正しいのか使う側で理解できないのは、関数にしても、 信用のあるファイルとは、いえません。
2016で追加されたtextjoin関数の出番ですね。2013以前だと、ユーザー定義関数で同様のことをヤリます。 配列を用意すれば区切り文字を指定して結合出来るので、rept関数を使って配列を生成します。 rept(B$2:I$2, B3:I3) B列からI列の2行目の値を、3行目回ずつ返します。大昔はこれで暗黙の配列として扱えましたが今はそうはいかないのでindex関数で包んでちゃんとした配列にします。 index(rept(B$2:I$2, B3:I3),0) {1,2,3,4,5,6,7,8}という配列の要素を{0,0,0,1,0,0,1,0}回ずつだと結果は {"","","","4","","","7",""} となります。これを指定の文字列で区切りながら空白を無視して並べるのがtextjoin関数。

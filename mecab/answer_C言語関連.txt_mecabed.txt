順番 に 書き ます ① カンマ で 区切ら れ た 数字 の 読み方 が 解ら ない ファイル に 書か れ た カンマ 区切り の データ を 配列 データ として 読み込む 方法 を ２つ 提示 し ます （ １ ） ファイル より １ 行 読み込ん で 、 改行 コード を 削除 し た 後 に ',' で 分割 する 方法 with open (' data ', ' r ') as f : __ data = f . readline (). rstrip (). split (',') print ( data ) （ ２ ） 標準 ライブラリ で ある csv パッケージ を 使用 する http:// docs . python .jp / 3 . 5 / library / csv . html import csv with open (' data ',' r ') as f : __ data = csv . reader ( f ) # py 3 の 場合 は list ( csv . reader ( f )) と する 必要 あり print ( data ) この 方法 の 場合 は 全て の 行 が 読み込ま れ ます ので 、 結果 は ２ 重 配列 にて 行 毎 の データ が 出力 さ れ ます ③（ 順番 が 前後 し ます が ） 読み込ん だ 値 を 文字列 から 整数 値 に 変える 方法 が 分から ない 文字 型 を 数値 型 に 変換 する に は 組み込み 関数 int () を 使用 し ます 。 http:// docs . python .jp / 3 . 5 / library / functions . html # int また 、 配列 の データ 全て に 上記 の int () を 適用 する に は 同じく 組み込み 関数 で ある map () を 使用 し ます 。 http:// docs . python .jp / 3 . 5 / library / functions . html # map ２つ を 合わせる と この よう に なり ます data = [' 25 ', ' 10 ', ' 5 '] data = map ( int , data ) # py 3 の 場合 は data = list ( map ( int , data )) print ( data ) ② 値 の 数字 の 数 に 寄ら ない 一般 化 の 仕方 が 分から ない 配列 データ に対して 累積 的 に 処理 を 行う に は reduce () を 使い ます 。 http:// docs . python .jp / 2 / library / functions . html # reduce http:// docs . python .jp / 3 / library / functools . html ( reduce は py 2 では 組み込み 関数 です が 、 py 3 では 標準 ライブラリ functools パッケージ に 移動 し て おり ます ) from functools import reduce # py 3 のみ これ が 必要 data = [ 25 , 10 , 5 ] res = reduce ( lambda a , b : ( a * b ) , data ) print ( res ) 上記 の ３つ を まとめる と 、 以下 の よう に なり ます from functools import reduce # py 3 のみ with open (" data ", " r ") as f : __ res = reduce ( lambda a , b : ( a * b ), map ( int , f . readline (). rstrip (). split (","))) print ( res ) 
下 の よう に 書い て 実行 し て み て ください 。 printf (" aiueo "+ 2 ); ヒント です 。 
こちら の 「 順序 論理回路 」 が 参考 に なる の で は 。 https :// www . yonago - k. ac.jp / denki / lab / nitta / lecture / E3 _ digital / note /... ( R , S ) が 逆 に なっ て い ます が ( 0 , 0 )→ 不変 ( 1 . 0 )→ Reset ( 0 , 1 )→ Set と する と ( 0 , 0 ) では 不変 で ( 1 , 0 ) ( 1 . o ) で Reset で ( 0 , 1 ) ( 0 , 0 ) で 不変 な ので ( 0 , 1 ) では ？ 
LcdLib . h , LcdLib . c を 流用 し て いる と 思わ れ ます が ANSEL = 0 ; // digital I/O mode が 無い 為 、 R B7 , RB 6 が アナログ モード の まま です 初期 設定 に 追加 し て み て 下さい また main の 最後 に while ( 1 ); // STOP が 無い と リセット が かかり 、 再度 main から 始まり ます 。 
問題 文 を （ 原文 で ） 示し て み て 下さい 。 「 大域 変数 num に は 配列 t に 設定 さ れ て いる 要素 数 が 格納 さ れ て いる 。 」 だ と 普通 、 要素 の 数 の 事 だ と 思う の です が ？ 
エラーメッセージ は 何 です か ？ 
エラー が 出る の を 「 恒久 的 に 」 防ぐ 事 は おそらく 出来 ない と 思い ます 。 「 いいえ 」 ボタン を 押しまくっ て 無視 し て 下さい 。 ソフト 自体 の 動作 に は 影響 し ませ ん 。 【 エラー が 出る 原因 】 じつは 「 苦 C 」 タブ の ヘルプ ページ の 中 に 「 広告 」 が 表示 さ れる よう に なっ て いる の です が 、 ソフト 自体 が 古い ので 広告 の 中 で 使用 さ れ て いる スクリプト に 対応 でき ず エラー が 発生 し て いる よう です 。 つまり 、 【 広告 の 表示 に 失敗 し て エラー が 出 て いる 】 よう です 。 【 一時的 に エラー が 出る の を 防ぐ 方法 】 PC を インターネット から 切断 し た 状態 で ソフト を 使用 し て 下さい 。 そう し ます と 、 広告 の スクリプト を 読み込め ない ので エラー が 出 なく なり ます 。 (^_^; 
1 . 23 という 数 は 二 進数 で は 割り切れ ない 数 で 循環小数 に なる 。 それ を 単精度 の 有限 桁 で 切る ので 、 どうしても 誤差 が 出る 。 それ が 最後 に ２ が 付く 理由 で ある 。 2 / 3 という 数 を 十進法 で 書く と 、 0 . 6666 .... と なる が 有限 桁 で 切っ て 四捨五入 すれ ば 0 . 6666667 と なる よう な もの で ある 。 IEEE 754 で 検索 すれ ば 分かる が 、 単精度 実数 の 場合 、 符号 に １ ビット 、 指数 部 に ８ ビット 、 仮数 部 に 23 ビット 割り当て て いる 。 1 . 23 の 場合 、 指数 部 による シフト は 無く 、 1 . 0 は 暗黙 の 内 に 勘定 さ れ て いる ので 、 23 ビット で 0 . 23 を 表す こと に なる 。 23 ビット は 、 先頭 から 十 進 表記 で 0 . 5 , 0 . 25 , 0 . 125 , 0 . 0625 , 0 . 03125 , 0 . 015625 .... という 数 を 表わし て いる ので 、 今 の 場合 0 , 0 , 1 , 1 , 1 , 0 .... という 表記 に なる 。 24 ビット 目 で 丸め 処理 を 行っ て いる が 、 丸め の ルール は 複雑 で ある 。 1 . 23000002 1 . 2300000190734863 0 01111111 00111010111000010100100 0 01111111111 0 0 1 1 1 0 1 0 1 1 1 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 0 0000000000000000000000000 0 0 1 1 1 0 1 0 1 1 1 0 0 0 0 1 0 1 0 0 1 0 0 1 0 . 500000000 0 . 00000000 E + 00 0 . 00000000 E + 00 2 0 . 250000000 0 . 00000000 E + 00 0 . 00000000 E + 00 3 0 . 125000000 0 . 125000000 0 . 125000000 4 6 . 25000000 E - 02 6 . 25000000 E - 02 0 . 187500000 5 3 . 12500000 E - 02 3 . 12500000 E - 02 0 . 218750000 6 1 . 56250000 E - 02 0 . 00000000 E + 00 0 . 218750000 7 7 . 81250000 E - 03 7 . 81250000 E - 03 0 . 226562500 8 3 . 90625000 E - 03 0 . 00000000 E + 00 0 . 226562500 9 1 . 95312500 E - 03 1 . 95312500 E - 03 0 . 228515625 10 9. 76562500 E - 04 9. 76562500 E - 04 0 . 229492188 11 4 . 88281250 E - 04 4 . 88281250 E - 04 0 . 229980469 12 2 . 44140625 E - 04 0 . 00000000 E + 00 0 . 229980469 13 1 . 22070312 E - 04 0 . 00000000 E + 00 0 . 229980469 14 6 . 10351562 E - 05 0 . 00000000 E + 00 0 . 229980469 15 3 . 05175781 E - 05 0 . 00000000 E + 00 0 . 229980469 16 1 . 52587891 E - 05 1 . 52587891 E - 05 0 . 229995728 17 7 . 62939453 E - 06 0 . 00000000 E + 00 0 . 229995728 18 3 . 81469727 E - 06 3 . 81469727 E - 06 0 . 229999542 19 1 . 90734863 E - 06 0 . 00000000 E + 00 0 . 229999542 20 9. 53674316 E - 07 0 . 00000000 E + 00 0 . 229999542 21 4 . 76837158 E - 07 4 . 76837158 E - 07 0 . 230000019 22 2 . 38418579 E - 07 0 . 00000000 E + 00 0 . 230000019 23 1 . 19209290 E - 07 0 . 00000000 E + 00 0 . 230000019 参考 プログラム program hello implicit none real :: a , f , g real ( kind ( 0 . 0 d0 )):: d character ( len = 80 ):: text 1 , tex t2 integer :: i , m ( 23 ) a = 1 . 23 d = a Print *, a , d write ( text 1 , '( b 32 . 32 )') transfer ( a , 0 _ 4 ) write ( tex t2 , '( b6 4 . 64 )') transfer ( d , 0 _ 8 ) print '( a , 1 x , a , 4 x , a )', text 1 ( 1 : 1 ), text 1 ( 2 : 9 ), text 1 ( 10 :) print '( a , 1 x , a , 1 x , a )', tex t2 ( 1 : 1 ), tex t2 ( 2 : 12 ), tex t2 ( 13 :) ! read ( text 1 ( 10 :), '( 23 i 1 )') m print '( 23 i 2 )', m f = 0 . 0 g = 1 . 0 do i = 1 , 23 g = g / 2.0 f = f + g * m ( i ) print *, i , g , g * m ( i ), f end do end program Hello 
こんばんは こんな 感じ でしょ う か ？ private void Form 1 _ Shown ( object sender , EventArgs e ) { listView 1 . Columns . Add (" 番号 ", 100 ); listView 1 . Columns . Add (" 住所 ", 100 ); listView 1 . Columns . Add (" 名前 ", 100 ); ListViewItem item x1 = new ListViewItem (); ListViewItem itemx 2 = new ListViewItem (); item x1 . Text = " 001 "; item x1 .S ubItems . Add (" 東京都 "); item x1 .S ubItems . Add (" 田中 "); listView 1 . Items . Add ( item x1 ); itemx 2 . Text = " 002 "; itemx 2 .S ubItems . Add (" 千葉県 "); itemx 2 .S ubItems . Add (" 佐藤 "); listView 1 . Items . Add ( itemx 2 ); listView 1 . CheckBoxes = true ; listView 1 . Items [ 0 ]. BackColor = Color . White ; listView 1 . Items [ 1 ]. BackColor = Color . White ; } private void listView 1 _ ItemChecked ( object sender , ItemCheckedEventArgs e ) { if ( listView 1 . Items [ 0 ]. Checked == true ) { listView 1 . Items [ 0 ]. BackColor = Color . Blue ; } else if ( listView 1 . Items [ 0 ]. Checked == false ) { listView 1 . Items [ 0 ]. BackColor = Color . White ; } if ( listView 1 . Items [ 1 ]. Checked == true ) { listView 1 . Items [ 1 ]. BackColor = Color . Blue ; } else if ( listView 1 . Items [ 1 ]. Checked == false ) { listView 1 . Items [ 1 ]. BackColor = Color . White ; } } 
TA 7291 は ドロップ が ヒドイ ので 使わ ない ほう が いい ですよ。 普通に MOS - FET で H ブリッヂ 組ん だ ほう が 分かり やすい のに 。 あと 省エネ 目指し てる わけ で も ない なら 、 「 内部 プルアップ 」 つかっ た ほう が 良い よ 。 楽 だ し 。 やり方 は 幾らでも ある から 、 下 の 回答者 の 言っ てる いみ が 分から ない なら 他 の やり やすい 方法 で やっ て みれ ば 。 
それぞれ スレッド プール から 別 の スレッド で 実行 さ れる よう に なる ため 、 処理 1 と 処理 2 が 別 スレッド で 並行 し て 実行 さ れる よう に なり ます 。 もし 処理 1 の 処理 が 長く て 処理 2 の 処理 が 短い 場合 、 処理 2 の ほう が 早く 完了 する こと も 起こり 得 ます 。 
hiroto _ kimura _ 0802 さん # include < stdio . h > # include < conio . h > # include < limits . h > # include < ma t h. h > void main () { int i ; double x , y ; printf ( " x sqrt ( x )\ n " ); printf ( "--------------\ n " ); for ( i = 0 ; i <= 100 ; i ++ ) { x = i ; x = x / 100 . 0 ; y = sqrt ( x ); printf ( "% 4 . 2 f % 5 . 3 f \ n ", x , y );// 関数 は 外 へ 出す 。 } _ getch (); } 
hiroto _ kimura _ 0802 さん _ getch ( ) を ヘルプ で 調べる と 、 # include < conio . h > 
conio . h を include し て み て ください 。 
c _ crimer さん ファイル は フォルダ の 中 に ある ので 、 1 . ファイル FileName Perc . txt 中村太郎 2 . FilePath c :￥ Program ￥ Perc . txt 福岡県福岡市城南区飯倉 2 - 58 中村太郎 3 . 上 の よう に 、 住所 付き 氏名 のようなもの 。 
source という 英語 は 、 「 元 」 という 意味 です 。 プログラム の 元 に なる コード の 事 です ね 。 主 に 、 コンパイル し て 実行 プログラム を 作る プログラミング言語 の 人間 が 直接 入力 する コード の 事 です 。 これ を コンパイル または 、 アセンブル し て リンク し て 、 実行 プログラム を 作成 し ます 。 でも 、 Java script とか 、 perl とか 、 ruby なんか は 、 コンパイル し ない インタープリター 言語 な ので 、 ソースコード と は 、 あまり 言い ませ ん 。 そのまま 実行 し ます 。 
乗除 算数 は 左 から 順番 に 計算 し ます 。 です ので 、 右 を 先 に 計算 し たら 結果 は 違い ます 。 簡潔 に し たい なら = ROUNDUP ( RAND ()* 5 , 0 ) です 。 2 で 割っ て から 10 を 掛ける の は 5 を 掛ける の と 同じ です が 20 で 割る の と は 違い ます 。 
C言語 は プログラミング言語 の 1つ です 。 プログラミン ッグ 言語 は 世の中 に 沢山 存在 し ます 、 因みに 、 私 も 作っ て い ます 。 その 中 でも C言語 は UNIX と 呼ば れる OS の 移植性 を 高める 為 に 開発 さ れ た プログラミング言語 で 、 それ 以降 に 開発 さ れ て いる プログラミング言語 は 殆ど が C言語 で 開発 さ れ て いる と 言っ て も 過言 で 無い ほど の 、 ベース と なっ て いる プログラミング言語 です 。 
私 の 環境 で は 以下 の やり方 で 可能 でし た 。 お 試し ください 。 var shellAppType = Type . GetTypeFromProgID (" Shell . Application "); dynamic shell = Activator . CreateInstance ( shellAppType ); var win = shell . Windows (); 
for 文 の i ++ 1 の 1 を 消す か 、 i += 1 に し て ください 。 
直角三角形 の 面積 と 最大 辺 の 2 乗 は 比例 関係 に ある か と 思い ます 。 （ これ が 間違い なら 済み ませ ん 。 ) だから 、 長い 順 に ソート し て 、 最初 に 直角三角形 が 成り立つ もの が 、 最大 の 面積 に なる か と 思い ます 。 # include < stdio . h > # define N 2000 int main ( void ) { FILE * fp ; char fn [ 30 ]; int n , i , j , d [ N ], t ; double max , m ; printf (" Number of Bars : "); scanf ("% d ",& n ); printf (" Bar Length File : "); scanf ("% s ", fn ); fp = fopen ( fn ," r "); for ( i = 0 ; i < n ; i ++) fscanf ( fp ,"% d ",& d [ i ]); fclose ( fp ); for ( i = 0 ; i < n - 1 ; i ++){ for ( j = i + 1 ; j < n ; j ++){ if ( d [ j ]> d [ i ]){ t = d [ i ]; d [ i ]= d [ j ]; d [ j ]= t ; }}} printf (" Max Area of Rectangular Triangle : "); for ( i = 0 ; i < n - 2 ; i ++){ for ( j = i + 2 ; j < n ; j ++){ if ( d [ i ]* d [ i ]== d [ i + 1 ]* d [ i + 1 ]+ d [ j ]* d [ j ]){ printf ("%. 1 f \ n ", d [ i + 1 ]* d [ j ]/ 2.0 ); return 0 ; } }} printf (" 0 . 0 \ n "); return - 1 ; } =＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 総 当り 方式 は 面倒 、 、 、 、 、 、 、 、 、 # include < stdio . h > # define N 2000 int main ( void ) { FILE * fp ; char fn [ 30 ]; int n , i , j , k , d [ N ], x , y , z ; double max , m ; printf (" Number of Bars : "); scanf ("% d ",& n ); printf (" Bar Length File : "); scanf ("% s ", fn ); fp = fopen ( fn ," r "); for ( i = 0 ; i < n ; i ++) fscanf ( fp ,"% d ",& d [ i ]); fclose ( fp ); for ( max = 0 . 0 , i = 0 ; i < n ; i ++){ for ( j = 0 ; j < n ; j ++){ for ( k = 0 ; k < n ; k ++){ if ( i != j && i != k && j != k ){ x = d [ i ]; y = d [ j ]; z = d [ k ]; if ( x < d [ j ]){ x = d [ j ]; y = d [ i ]; z = d [ k ]; } if ( x < d [ k ]){ x = d [ k ]; y = d [ i ]; z = d [ j ]; } if ( x * x == y * y + z * z ){ m = y * z / 2.0 ; if ( max < m ) max = m ; } } }}} printf (" Max Area of Rectangular Triangle : %. 1 f \ n ", max ); return 0 ; } 
ウォッチ ウィンドウ に k を 貼り 付け て 必要 な 部分 を 展開 さ せ て 表示 さ せる しか あり ませ ん 。 
月末 の 判定 に DateTime を 使用 し て い て は ． ． ． TimeSpan なら こう し ます 。 int TotalDay ( DateTime dt 1 , DateTime dt 2 ) { return ( int )( dt 2 . Date - dt 1 . Date ). TotalDays ; } 手動 の 場合 は 、 西暦 1年 １月 1日 から の 通算 日数 に 換算 し て から 比較 する の が 簡単 です 。 以下 は 、 ツェラーの公式 を 応用 し た もの です 。 http:// ufcpp .net / study / algorithm / o _ days . html // グレゴリオ 歴 → 西暦 0 年 3月1日 から の 通算 日数 int DateToSerial ( int y , int m , int d ) { // 1 ・ 2月 → 前年 の 13 ・ 14 月 if ( m <= 2 ) { -- y ; m + = 12 ; } int dy = ( y - 1 ) * 365 + y / 4 - y / 100 + y / 400 + ( m * 979 - 1033 ) / 32 + d - 1 ; return dy ; } 
まず 、 旋回 しよ う と し て いる の に なぜ Translate を 使用 し て いる の でしょ う か 。 transform . Translate ( Vector 3 . forward * masinspeed , Space . World ); この ソース だ と 「 ワールド 空間 における Z + 方向 へ masinspeed だけ 進む 」 と なる ので 、 そもそも 旋回 も し ない と 思う の です が … … ローカル 座標 だ と 角度 が おかしい 、 バウンド する という の も 不思議 な 話 な ので 、 根本 的 に 間違っ て いる よう に 思い ます 。 とりあえず こちら を ご覧 の 上 、 少し ずつ 進める と よい か と 思い ます 。 http:// tsubaki t 1 . hateblo .jp / entry / 2014 / 08 / 02 / 030919 
PIC 18 は , delay の パラメータ 範囲 が 狭い ので void delay 10m s ( unsigned int i ){ while ( i ){ __ delay _ ms ( 10 ); i -- ; } } を 定義 し て い ます 但し 余分 な 処理 が 入る ので 実際 は 少し 長く なり ます 
/* phahu 14 さん へ コメント を 入れ て み まし た 使用 し て いる が 型 が unsigned char * で なく char * に なっ て いる の が 気 に なり ます 。 0 x 80 以上 の 文字 の 場合 、 これ を インデクス に 使用 する と マイナス 方向 へ 移動 し ます 。 よって 意図 し ない メモリ 領域 を 読み書き し ます 。 */ # include < stdio . h > # include < string . h > char * search ( char * , char *); void table ( char *); int skip [ 256 ];// 0 ～ 255 void main ( void ) { static char text []=" This is a pen . That is a pencil ."; char * p ,* key =" pen "; table ( key ); p = search ( text , key ); while ( p != NULL ) { printf ("% s \ n ", p ); p = search ( p + strlen ( key ), key ); } } void table ( char * key ) /* スキップ テーブル の 作成 */ { int k , n ; n = strlen ( key ); for ( k = 0 ; k <= 225 ; k ++)//★ おそらく 225 で なく 、 unsigned char の 最大 値 で ある 255 だ と 思わ れる skip [ k ]= n ;// とりあえず 全 要素 に キー 長さ を セット （ キー に 含ま れ ない 文字 の 時 は キー と 同じ 長 さ だけ スキップ する 為 ） for ( k = 0 ; k < n - 1 ; k ++)// キー の 末尾 文字 を 除く 文字 に対して 処理 を 行う skip [ key [ k ]]= n - 1 - k ;// キー に 含ま れる 文字 に 該当 する スキップ 量 に 「 ( キー 長さ - 1 )-（ キー 中 の 文字 位置 ） 」 を セット 。 ※ これ は キー の 末尾 位置 を ０ と し 、 末尾 文字 を 除い て 先頭 方向 へ 探索 し た 時 に その 文字 が 最初 に 現れる 距離 で ある 。 例 ： key =" abcba " の 時 、 skip [' b ']= 1 , skip [' c ']= 2 , skip [' a ']= 4 と なる 。 } char * search ( char * text , char * key ) { int m , n ; char * p ; m = strlen ( text ); n = strlen ( key ); p = text + n - 1 ;// p に キー の 最終 文字 位置 に 相当 する text 位置 を セット while ( p < text + m ) {// テキスト 末端 から 飛び出 ない 位置 まで if (* p == key [ n - 1 ]) {// 現在 位置 の 文字 が キー 末尾 文字 と 同じ 時 if ( strncmp ( p - n + 1 , key , n )== 0 )// キー と 同じ 文字列 を 見つけ た 時 return p - n + 1 ;// 見つけ た 位置 を 返す } p = p + skip [* p ];// 異なる 時 は スキップ テーブル に従って スキップ する （* p 文字 が キー に 含ま れ て い なけれ ば キー 長さ 分 スキップ 。 * p 文字 が キー に 含ま れ て いれ ば 、 キー 末尾 方向 から 最も 近い 該当 文字 が * p 位置 に 合致 する よう に スキップ ） } return NULL ; } 
/* poi _ kou さん へ こんな かんじ で … ----- 実行 結果 ----- 合言葉 は ？ ： ひらけ ゴマ ドア を 開け て さしあげ ましょ う 。 */ # include < stdio . h > # include < string . h >// 文字列 処理 関数 用 int main ( void ) { char input [ 256 ];// 半角 255 文字 ＋ 文字列 終端 コード １ 文字 を 入れる バッファ printf (" 合言葉 は ？："); scanf ("% 255 s ", input ); //※↓ strcmp () は 文字列 を 比較 する 関数 です 。 // http:// www . c - tipsref . com / reference / string / strcmp . html if ( strcmp ( input ," ひらけ ゴマ ")== 0 ){ // 入力 さ れ た 文字列 が 「 ひらけ ゴマ 」 と 同じ 時 printf (" ドア を 開け て さしあげ ましょ う 。 \ n "); } else { printf (" 出直し て き なさい 。 \ n "); } return 0 ; } 
回答 に なっ て い ませ ん し 、 有効 な 解き方 も 分かり ませ ん が 「 入力 し た １つ の 数値 に 含ま れる 素数 を 計算 し て 、 素数 を 全部 画面 に 出力 する 」 という の は 、 例えば 1 2345678910111213124151617 という 数値 の なか から 2 , 23 , 5 , 11 , 13 , 17 ... など を 抽出 せよ という 意味 でしょ う か ？ 数値 を 一旦 文字列 に し て から 、 その 中 から 部分 文字 を 取り出し て 数値 に 戻し て 、 エラトステネス の ふるい に かける と か でしょ う か ？ 
> rebaqb さん 1つ め で 出力 を ファイル に 書き だし て 2つ め で その ファイル の 中身 を み て ます man less と すれ ば less の マニュアル を 見れる 
# include < stdio . h > void calculation ( int , int , int *); struct DATA { int height ; int weight ; int BMI ; }; int main ( void ) { struct DATA data ; int i ; for ( i = 0 ; i < 10 ; i ++){ printf ("\ n 身長 :"); scanf ("% d ",& data . height ); printf (" 体重 :"); scanf ("% d ",& data . weight ); printf (" 身長 [ cm ]:% d \ n ", data . height ); printf (" 体重 [ Kg ]:% d \ n ", data . weight ); calculation ( data . height , data . weight ,& data . BMI ); printf (" あなた の BMI は % d 。", data . BMI ); if ( data . BMI < 18 ) printf (" やせすぎ です 。 "); if ( data . BMI >= 18 && data . BMI < 25 ) printf (" やや やせ です 。 \ n ", data . BMI ); if ( data . BMI >= 25 && data . BMI < 35 ) printf (" 普通 です 。 \ n ", data . BMI ); if ( data . BMI >= 35 && data . BMI < 40 ) printf (" かなり 肥満 です 。 \ n ", data . BMI ); if ( data . BMI >= 40 ) printf (" 肥満 です 。 \ n ", data . BMI ); } return 0 ; } void calculation ( int h , int w , int * b ) { * b = w * 10000 /( h * h ); } BMI 判定 を 適当 に 修正 し まし た 。 判定 は 以下 の よう に し て も 間違い で は ない と 思う が 、 、 、 、 、 好き で は ない 、 、 、 、 、 if ( data . BMI < 18 ) printf (" やせすぎ です 。 "); else if ( data . BMI >= 18 && data . BMI < 25 ) printf (" やや やせ です 。 \ n ", data . BMI ); else if ( data . BMI >= 25 && data . BMI < 35 ) printf (" 普通 です 。 \ n ", data . BMI ); else if ( data . BMI >= 35 && data . BMI < 40 ) printf (" かなり 肥満 です 。 \ n ", data . BMI ); else if ( data . BMI >= 40 ) printf (" 肥満 です 。 \ n ", data . BMI ); 
一部 に 誤り が あり まし た ので 取り消し まし た 。 再度 回答 し ます 。 「 案 」 BCDコード を タクト スイッチ みたい な もの で 実現 する なら 、 もう １ ヶスイッチ を 設け て 、 BCD スイッチ を 押し て から 確定 し た という 信号 に する の が 簡単 で いい と 思う 。 確定 し た という 信号 を 受け て BCD を 読み込み 変数 に 代入 すれ ば 保持 し た こと に なる 。 BCDコード を デコード する に は 出力 コード を 配列 で 持ち 、 BCDコード で index すれ ば 簡単 。 const unsigned char ot _ dat [ 10 ] = { 0 x 00 , 0 x 01 , 0 x 02 , 0 x 04 , 0 x 08 , 0 x10 , 0 x 20 , 0 x40 , 0 x 80 }; // 0 ~ 8 まで の 出力 コード if ( 0 <= BCD && BCD < 9 ){ ____ PORTA = ot _ dat [ BCD ]; ____ PORTB . 0 = 0 ; } else if ( BCD == 9 ){ ____ PORTA = 0 ; ____ PORTB . 0 = 1 ; } else { ____// 適当 な 処理 } この プログラム の 欠点 ポート 構成 が ８ ビット で ある 以上 、 ものすごく 速い マイコン を 使っ て も 出力 に 数 十 nS の グリッチ が 出る 。 これ を 防ぐ に は もう １ ビット 出力 を 増設 し 、 コード が 確定 し た した 後 、 パルス を だし 外部 で ラッチ する よう に すれ ば よい でしょ う 。 以上 を 参考 に 適当 に アレンジ し て ください 。 
OS は 縁の下の力持ち 、 安定 稼動 し て ナンボ な の です 。 MS 社 は 昔 から 、 未 完成 品 を 世の中 に 出し 、 まるで ユーザ に 「 バグ 出し 」 という プログラム コーディング 作業 の 一部 を 負わ せ て いる と 感じ ます 。 全く 、 MS 社 の 為 に 人柱 に なる 必要 は なく 、 是非 、 工場 出荷 状態 に 戻し 、 その OS を 更新 し て 使用 する こと を お勧め し ます 。 
indy _ indy 80 さん 次 の よう な コード で いける か 試し て み て ください 。 DataGridView （ インスタンス 名 は dataGridView 1 ） の ある フォーム の コンストラクタ で 、 次 の よう に し ます 。 ■ コード 例 dataGridView 1 . KeyDown += ( o , e ) => { if ( e . KeyCode == Keys . Delete ) { DataGridView d = o as DataGridView ; foreach ( DataGridViewCell c in d .S electedCells ) { c . Value = null ; } } }; ■ 解説 DataGridView の KeyDown イベント に 、 キー が 押さ れ た とき の イベント を 追加 し ます 。 内容 は 、 Delete キー が 押さ れ た とき に 選択 さ れ て い た セル を すべて 拾い上げ て 、 値を消す （ null を 代入 ） という 処理 に なり ます 。 
すいません 、 その 仕様 だ と ログイン フォーム に する 意味 が ない と 思い ます が 。 何 の ため の ログイン フォーム です か ？ 本来 の 承認 機能 は 全て 入力 さ せ 、 それ が 正しい か どう か を チェック する 為 の もの だ と 私 は 思っ て い ます 。 もし 実装 する なら ば ID を 完全 に 入力 し 終わり 、 PW に フォーカス が 移っ た 時点 で INI ファイル や xml ファイル 等 を 読み込み 、 キー が 一致 すれ ば PW を 表示 する という 形 に する か な ・ ・ ・ 。 でも 、 ID が 流出 し た 時点 で アウト です よ ね ・ ・ ・ 。 
> naoakigain 15 さん 推奨 手順 1 ) まず 画素 の 読み出し を やっ て 正しく 画素 に アクセス でき てる か 確認 ( テスト 用 画像 を 作成 する の が 良い 、 ImageMagick とか 使え ば 簡単 に 作れる ) 推奨 手順 2 ) 計算 式 の 結果 を 標準出力 に 出して 手 計算 と あう か 確認 ( 手 計算 でき て 、 確認 が 簡単 な よう に 小さい テスト 用 画像 で テスト ) 推奨 手順 3 ) 上 が 上手く いって から 元 やっ て た もの にたいして 行なう で 多分 解決 し そう だ けど デバッグ まで が プログラム な ので デバッグ も 頑張ら ない と デバッグ が 楽 に なる 手順 を 書い て おき まし た ( Python Debug とか で ネット 検索 すれ ば 、 デバッガ の 利用 方法 も で て くる ので デバッガ を 使え ば かなり デバッグ は 楽 に なり ます ) 
線形代数 で 行列 を 習う とき か なぁ 。 プログラム 組む 時 に 使っ た ぐらい だ けど 。 
# include < stdio . h > # define NUM ( 200 ) int isPrime ( int a ); int isPrime ( int a ) { int i ; int ret = 1 ; /* 偶数 は 素数 で は ない */ if ( a % 2 == 0 ) { ret = 0 ; } /* 1 は 素数 で は ない */ else if ( a == 1 ) { ret = 0 ; } /* 3 以上 の 奇数 */ else { /* 3 以上 の 奇数 で 余り を 出し て 素数 か チェック する */ for ( i = 3 ; i * i <= a ; i = i + 2 ) { if ( a % i == 0 ) { ret = 0 ; break ; } } } return ret ; } int main ( void ) { int isPrimes [ NUM + 1 ] = { 0 }; int i ; /* 配列 に 素数 か どう か の 情報 を 詰める */ for ( i = 5 ; i <= NUM ; i = i + 2 ) { isPrimes [ i ] = isPrime ( i ); /* 要素 i に i が 素数 か どう か を 詰める */ } printf ("% d 以下 の 三つ子素数 の 組 は 次 の 通り :\ n ", NUM ); /* バッファ を オーバー し ない よう に ループ */ for ( i = 5 ; i <= NUM - 6 ; i = i + 2 ) { /* 3つ の 要素 を チェック し て 、 すべて 1 なら 三つ子 */ if ( ( isPrimes [ i ] == 1 ) && ( isPrimes [ i + 2 ] == 1 ) && ( isPrimes [ i + 6 ] == 1 ) ) { printf (" 三つ子素数 { % d , % d , % d }\ n ", i , i + 2 , i + 6 ); } if ( ( isPrimes [ i ] == 1 ) && ( isPrimes [ i + 4 ] == 1 ) && ( isPrimes [ i + 6 ] == 1 ) ) { printf (" 三つ子素数 { % d , % d , % d }\ n ", i , i + 4 , i + 6 ); } } return 0 ; } 
> eclipse に 最初 から 入っ て いる mingw に は 入っ て い ませ ん 。 Pleiades All in One の 事 を 言っ て いる の か ? だっ たら これ は eclipse に 日本語 プラグイン を セット し て 配布 し て いる 亜種 で あっ て 公式 の Eclipse で は あり ませ ん 。 
正確 に は 、 Serial . print に なり ます Serial . print ('' vale =''); // 文字列 " vale =" の 表示 （ シリアル 出力 ） Serial . println ( vale ); // 変数 vale の 値 を 表示 し て から 改行 し ます 表示 例 vale = xxx ( xxx は 数値 が 入り ます ） Arduino 日本語 リファレンス http:// www . musashinodenpa . com / arduino / ref / index . php 
return 0 ; の 前 に free ( new ); 明示 的 に メモリ の 解放 が 必要 な の は 、 malloc で 確保 し た メモリ だけ です 。 
return 0 ; の 前 に free ( new ); 明示 的 に メモリ の 解放 が 必要 な の は 、 malloc で 確保 し た メモリ だけ です 。 
build.xml で 指定 し て いる 対象 の クラス が 間違っ て いる の で は ない でしょ う か 。 http:// www . atmarkit . co.jp / bbs / phpBB / viewtopic . php ? topic = 24042 & forum ... 
与え られる テキスト データ の 最大 長 や 、 その 中 に 格納 さ れる 文 の 最大 長 は 不明 な ので 、 配列 で 処理 する 手法 は あまり 使い たく あり ませ ん 。 「 最も 」 スマート な やり方 について は 存じ ませ ん が 、 処理 目的 を 達する だけ なら 、 以下 に 示す よう な ２つ の 方法 で 可能 でしょ う 。 ・ ・・・・・・・・・ １ ． 順次 走査 法 何 文目 を 取り出す か という 入力 を 受け付け て から 、 与え られ た テキスト データ を １ 文字 ずつ 読み 、 区切り 文字 を 見つけ出し て その 範囲 を １ 文字 ずつ 表示 する 。 たとえば 、 3 という 入力 が あれ ば 、 テキスト データ を １ 文字 ずつ 読み込ん で いき 、 ２つ 目 の 区切り 文字 の 次 の 文字 から １ 文字 ずつ 表示 し 、 ３つ 目 の 区切り 文字 の ところ で 表示 を やめれ ば よい 。 この 方法 は 簡易 だ が 、 後ろ の 方 の 文 を 取り出す の に 時間 が かかる 。 ・ ・・・・・・・・・ ２ ． 擬似 ランダムアクセス 法 この 方法 で は 「 走査 処理 」 と 「 問い合わせ 処理 」 を 行う 。 「 走査 処理 」 で は 、 与え られ た テキスト データ を １ 文字 ずつ 読み込み 、 区切り 文字 が 出 て き たら 、 その バイト 位置 を 別 の テキストファイル に 出力 し て いく 。 出力 ファイル は 以下 のようなもの に なる 。 0 35 148 246 テキスト データ を 全て 読み 終え たら 出力 ファイル を クローズ し 、 問い合わせ 処理 に 移る 。 「 問い合わせ 処理 」 で は 、 ｎ 文目 を 取り出す か という 入力 を 受け付け たら 、 「 走査 処理 」 で 作成 し た ファイル の ｎ 行 目 を 読み取り 、 それ を アクセス 開始 バイト 位置 として 、 元 テキスト データ の アクセス 開始 バイト 位置 から 区切り 文字 まで を １ 文字 ずつ 弓 込ん で 表示 する 。 この 方法 は やや 複雑 だ し 、 元 テキスト データ に 変更 が あれ ば 「 走査 処理 」 を 再度 実行 し なけれ ば なら ない が 、 「 何 文目 を 取り出す か 」 という 問い合わせ が 頻繁 に 有り 、 かつ 元 テキスト データ の 変更 が 少ない 場合 は 、 「 順次 走査 法 」 より も トータル の 処理 コスト は 低い 。 ・ ・ ・ ・ ・ ・ ・ ・ ・ ・ どうしても 配列 に 格納 し たい 、 という の で あれ ば 、 上記 「 擬似 ランダムアクセス 法 」 の 「 走査 処理 」 に 似 た 処理 を 実行 し て 、 １ 文 あたり の 最大 所要 バイト 数 を 求め 、 それ で 配列 領域 を malloc () する という 方法 も あり ます が 、 元 テキスト データ を 「 ２ 度 読み 」 する 事 に なり 、 処理 コスト は 高い です 。 
http:// itpro . nikkeibp . co.jp / article / COLUMN / 20090622 / 332341 /? rt = nocn ... POI って ライブラリ な ん です ね 。 出来る ん じゃ ない です か 。 使え ば 。 
windows 19970718 さん 基礎 から 、 学ぶ 。 ソース を 読ん で 、 理解 できる の は 、 自作 できる レベル の 少し 上 ぐらい 。 
セグメンテーション 違反 が で て い ます ので 、 どこ か で メモリ オーバー （ たとえば char 配列 以上 の 文字列 を 読み込も う と し た とか ） が 起こっ て い ます 。 ファイル によって 出 たり 、 出 なかっ たり し た の は 、 ファイル の 中身 の サイズ による もの で は ない でしょ う か 。 
Arduino 初心者 と の こと な ので 下記 の URL を 参考 に すれ ば できる 。 http:// www . japanese - makers . com / archives / 633 お釈迦様 に 説法 かも しれ ませ ん が 、 数値 と 数字 は 違い ます 。 普段 パソコン を 使っ て いる とき は ” 数字 ” と ” 数値 ” を 区別 し ない で も 困り ませ ん が マイコン 通信 の よう な プリミティブ な ところ で は 区別 し ない と 思っ た よう に 動き ませ ん ので ご 注意 。 テキストファイル から 読み込ん だ ” 数値 ” と ある が テキストファイル で あれ ば 数字 ” です 。 ASCII コード ８ ビット と すれ ば 同じ よう に １ と 書き ます が 数字 １ は ３ １ （ HEX ) ０ ０ １ １ ０ ０ ０ １ （ B ) 数値 １ は ０ １ （ HEX ) ０ ０ ０ ０ ０ ０ ０ １ （ B ) です 。 それ な ので 数字 を 送っ て それ を 数値 に 直し て 大小 判断 する こと に なり ます 。 この 処理 も 上 の URL の プログラム に 入れる 。 パソコン 側 が わから なけれ ば 別に 質問 を 立て た ほう が いい と と 思う 。 
こんばんは 動作 として は こんな 感じ です か ？ private void Form 2 _ FormClosing ( object sender , FormClosingEventArgs e ) { this . Visible = false ; Form dialog = new Form (); dialog . Owner = this ; dialog .S howDialog (); } 
インテルグラフィックスカーネルモードドライバ か な ？ 基本 自動 更新 な ん だ よ ね これ WindowsUpdate で 更新 さ れる の を まつ か あと は INTEL に いっ て 新しい の を 手動 で おとす か です ね 品名 が わから ない ので この 辺 で 自分 の を さがし て み て ください 。 http:// www . intel . co.jp / content / www / jp / ja / support / graphics - drivers / 0 ... 
quickbrwn ~ さん の 情報 を 使わ させ て いただき 回答 し て い ます 。 で ない と 読め ない 。 デバッグ は 順序 を よく 考え て すすめる 。 １ ． LED の 取り付け 方向 は あっ て いる か ？ volatile int led = HIGH ; と し 、 attachInterrupt (***); の 行 を コメントアウト 。 これ で LED が 点灯 し なけれ ば LED の 配線 を 追う 。 ２ ． スイッチ の 配線 は あっ て いる か ？ プルアップ ／ プルダウン は どう なっ て いる か ？ プログラム から は 回路 が 予想 でき ませ ん 。 sw == 0 から は 押し た とき GND の よう で ある が attachInterrupt () から は 押し た とき HIGH の よう な ので 。 ３ ． Arduino の ピン 番号 と プログラム の attachInterrupt 文 の 指定 に 間違い が ないか ？ attachInterrupt () は ” 割り込み 番号 ” を 指定 する よう だ けど あっ て いる か ？ ４ ． 割り込み が かかっ て いる か ？ 簡単 な プログラム で チェック する の が いい 。 led = ~ led ; 以外 の ステートメント を コメントアウト する 。 貼り 付け て ある プログラム は おかしい 。 !（ ビックリマーク ） で は ない 。 だいたい １ 〜 ４ の 順序 で は ない でしょ う か ？ 簡単 な こと から 難しい こと へ の 順序 が いい です 。 など など 
> surahuto さん 入力 し た 文字 を はりつけ て くれ 読め ない こっち で 再現 テスト する し Sympy + Python で も 積分 可能 な ので そっち で 試し て みる の も 良い かもしれん ( 他 に も 多数 数式 処理 ツール ある ので 、 Sympy 以外 で も 良い けど ) 
C言語 だけ に 限っ た 話 で は ない が 、 コンパイル エラー が 発生 し ない こと と 、 意図 し た 動作 を する か は 別 で ある こと を 理解 し て ください 。 C言語 で は 文字列 は = では 代入 でき ない が 、 コンパイル エラー に も なら ない 。 # include < stdio . h > int main ( void ) { char str [ 128 ]; int i ; scanf ("% s ", str ); for ( i = 0 ; str [ i ]!='\ 0 '; i ++); if ( i % 2 == 1 ){ for ( i ; i >= 0 ; i --) str [ i + 1 ]= str [ i ]; str [ 0 ]=' 0 '; } printf ("% s \ n ", str ); return 0 ; } 文字列 関連 の 関数 と ワーク 用 の 変数 を 使え ば 、 記述 が 少し は スッキリ する か も 、 、 、 、 
/* hunkhunk 1022 さん こんな かんじ で … ----- 実行 結果 ----- 0 : 300 . 000000 1 : 500 . 000000 2 : 700 . 000000 3 : 1100 . 000000 4 : 1500 . 000000 */ # include < stdio . h > # define DSIZE 3 // 行 数 # define AT 5 // 列 数 int main ( void ) { double Data [ DSIZE ][ AT ]={ { 1 , 4 , 700 , 10 , 13 }, { 2 , 500 , 8 , 1100 , 14 }, { 300 , 6 , 9 , 12 , 1500 } }; double Max [ AT ]={ 0 };// 列 の 最大 値 を 入れる ※ １ 次元 配列 に し まし た int i , j ; for ( j = 0 ; j < AT ; j ++){// 列 数 分 for ( i = 0 ; i < DSIZE ; i ++){// 行 数 分 if ( i == 0 ){ // １つ 目 は そのまま 入れる Max [ j ] = Data [ i ][ j ]; } else if ( Data [ i ][ j ] > Max [ j ]){ // ２つ 目 以降 は 、 大きかっ たら 入れる Max [ j ] = Data [ i ][ j ]; } } // DrawFormatString ( 30 + 90 * e , 200 + 20 * f , Color , "% lf ", Max [ 1 ][ j ]); printf ("% d :% f \ n ", j , Max [ j ]); } return 0 ; } 
WinForms な の か WPF な の か 、 それとも まったく 別 の もの な の か わかり ませ ん が 、 WPF なら System . Windows . Threading . DispatcherTimer クラス で タイマー 処理 する という 方法 が あり ます 。 
> SOR 法 で の 最適 緩和 定数 ω と は 、 どう 計算 すれ ば いい です か ？ 「 sor 法 加速 パラメータ 」 など で 検索 する と 、 例えば 以下 の よう な サイト が 出 て くる ので 、 それ を 読解 すれ ば 早い です 。 C により 近い C++ の ソースコード で あり 、 すでに 完成 さ れ た ソースコード な ので 、 もはや 「 どう する か 」 の 次元 で は なく 、 さらに 、 「 どう やっ て やる の か 」 という 疑問 は 吹き飛ぶ と 思い ます 。 つまり 、 やり方 、 仕方 そのもの が 掲載 さ れ て い ます ので 、 あと は それ を 納得 する まで 眺めれ ば 、 計算 方法 を 理解 でき ます 。 SOR 法 の 加速 パラメータ ω を 最適 化 し て み た - eukaryo の ブログ http:// eukaryote . hateblo .jp / entry / 2015 / 06 / 29 / 004723 
もしか する と cmd . exe から 直接 gcc を 実行 しよ う と し て い ませ ん か ? だ と し たら まず msys の bash . exe を 起動 し 、 bash から gcc を 実行 し て み て ください 。 MinGW の ファイル を / usr / include の よう な UNIX 流儀 の パス で アクセス できる よう に し て いる の は msys の シェル の 機能 です 。 あと 、 私 は m sy s2 を 使っ て いる ので 若干 違う かも しれ ませ ん が 、 stddef . h は / usr / include で は なく 、 / usr / lib / gcc / x86 _ 64 - w 64 - mingw 32 / 6 . 1 . 0 / include / の 下 です ね 。 
# include < stdio . h > void calculation ( int , int , double *); struct DATA { char name [ 20 ]; int height ; int weight ; double BMI ; }; int main ( void ) { struct DATA data ; printf (" 名前 :"); scanf ("% s ", data . name ); printf (" 身長 :"); scanf ("% d ",& data . height ); printf (" 体重 :"); scanf ("% d ",& data . weight ); printf (" 名前 :% s \ n ", data . name ); printf (" 身長 [ cm ]:% d \ n ", data . height ); printf (" 体重 [ Kg ]:% d \ n ", data . weight ); calculation ( data . height , data . weight ,& data . BMI ); printf (" BMI :% 5 . 1 f \ n ", data . BMI ); return 0 ; } void calculation ( int h , int w , double * b ) { double t ; t = h / 100 . 0 ; * b = w/ t / t ; } ＝ ＝ ＝ ＝ ＝ ＝ ＝ ＝ ＝ ＝ ＝ calculation ( data . height , data . weight ,& data . BMI ); が 無い の が 0 に なる 原因 。 後 は 電卓 で 計算 し た 場合 と 同じ よう に なる よう に 若干 の 修正 を し て いる 。 質問 の 場合 です と h = h / 100 ; は 小数点 以下 が 切り捨て に なる 。 t = h / 100 . 0 ; と し て いる の は 実数 に する だけ で は 実数 演算 に なら ない から です 。 t =( double ) h / 100 ; と する の が 分かり やすい かも 、 、 、 、 、 ＝ ＝ ＝ ＝ ＝ ＝ ＝ ＝ ＝ ＝ ＝ 整数 で の 入力 を 想定 し て いる として も 、 小数点 以下 の 演算 が 必要 に なる なら 、 初め から 実数 の 変数 に 代入 する という 考え方 も ある 。 # include < stdio . h > void calculation ( double , double , double *); struct DATA { char name [ 20 ]; double height ; double weight ; double BMI ; }; int main ( void ) { struct DATA data ; printf (" 名前 :"); scanf ("% s ", data . name ); printf (" 身長 [ cm ]:"); scanf ("% lf ",& data . height ); printf (" 体重 [ Kg ]:"); scanf ("% lf ",& data . weight ); printf (" 名前 :% s \ n ", data . name ); printf (" 身長 :%. 0 fcm \ n ", data . height ); printf (" 体重 :%. 0 fKg \ n ", data . weight ); calculation ( data . height , data . weight ,& data . BMI ); printf (" BMI :% 5 . 1 f \ n ", data . BMI ); return 0 ; } void calculation ( double h , double w , double * b ) { h /= 100 ; * b = w/ h / h ; } どう で も 良い こと で は ある が 、 この プログラム を 他人 が 使う こと を 想定 する なら 、 入力 する 時 に 単位 を 表示 し た 方 が 良い か と 思い ます 。 特に 身長 は 例えば 160cm なら 、 1 . 6 とか 入力 さ れ そう 、 、 、 、 、 
C# の バージョン を 決定づけ て いる の は 、 MonoDevelop で は なく て 、 Unity に 含ま れる mono でしょ う 。 Windows 版 C :\ Program Files \ Unity \ Editor \ Data \ Mono \ bin \ mono . exe - V Mono JIT compiler version 2.0 ( Visual Studio built mono ) Mac 版 / Application s / Unity / Unity . app / Contents / Framework s / Mono / bin / mono - V Mono JIT compiler version 2 . 6 . 5 ( tarball Tue Apr 12 22 : 30 : 16 CEST 2016 ) な ので 、 C# 3 . 0 の よう です 。 https :// en . wikipedia . org / wiki / Mono _% 28 software % 29 http:// ufcpp .net / blog / 2015 / 07 / unityasyncbridge / > C# 3 . 0 相当 もっと 新しい の も こっそり 入っ て い て 、 C :\ Program Files \ Unity \ Editor \ Data \ MonoBleedingEdge \ bin \ mono . exe - V Mono JIT compiler version 2 . 11 ( Visual Studio built mono ) / Application s / Unity / Unity . app / Contents / Framework s / MonoBleedingEdge / bin / mono - V Mono JIT compiler version 3 . 4 . 0 ( unity - future - fix - el capi ta n2 / f5 03 adb Wed Jul 15 15 : 15 : 36 CEST 2015 ) これ だ と 、 C# 4 . 0 ～ 5 . 0 あたり か と 思わ れ ます 。 
実は 、 結構 簡単 です 。 まず 、 form の コード は 、 こんな おまじない を 書き ます 。 C :\ Users \ nanco \ test . html は 、 ご 自分 の html の パス を 書い て ください 。 < System . Runtime . InteropServices . ComVisibleAttribute ( True )> Public Class Form 1 Private Sub Form 1 _ Load ( sender As System . Object , e As System . EventArgs ) Handles MyBase . Load WebBrowser 1 . ObjectForScripting = Me WebBrowser 1 . Url = New System . Uri (" file :// C :\ Users \ nanco \ test . html ", UriKind . RelativeOrAbsolute ) End Sub Public Sub CallMe ( msg As String ) MsgBox ( msg & " OKOK ") End Sub End Class これ で 、 html の javascript で 、 <! DOCTYPE HTML PUBLIC "-// W3C // DTD HTML 4 . 01 Transition al // EN "> < HTML > < HEAD > < META http - equiv =" Content - Type " content =" text / html ; charset = SHIFT _ JIS "> < META http - equiv =" Content - Style - Type " content =" text / css "> < TITLE ></ TITLE > </ HEAD > < BODY > < FORM >< INPUT type =" button " name =" TEST " value =" 押し て ね " onClick =" window . external . CallMe (' KITAYO !')"></ FORM > </ BODY > </ HTML > こんな 感じ で 、 window . external . CallMe (' hogehoge ') を 呼ぶ と form の CallMe に 引数 を 渡し て 飛ん で き ます 。 
/* 2016 / 8 / 18 02 : 26 : 09 次 の プログラム を stracat 関数 を 使わ ず に 、 同じ 実行 結果 と なる よう に 、 プログラム を 作り なさい ＞ ＞ ＞ stracat ← strcat ？ ＿ ＿ ＿ 何れ に しろ 「 次 の プログラム 」 に これら は 影 も 形 も ありません ＿ ＿ ＿ 文脈 と 文字列 から 、 やり たい こと は 容易 に 想像 出来る ので ＿ ＿ ＿ 勝手 に 作り ます 、 御 参考 に 。 */ // Visual C++ 2013 # define _ CRT _ SECURE _ NO _ WARNINGS // VC++ only , to stop warning for fopen (), scanf () etc. # include < stdio . h > # include < stdlib . h > # include < string . h > char * strscat ( char * s1 , char * s2 ); int main ( void ){ ＿ char ＿ st r1 [ 40 ], st r2 [ 40 ], st r3 [ 40 ]; ＿ ＿ strcpy ( st r1 , " Let's " ); ＿ strcpy ( st r2 , " study " ); ＿ strcpy ( st r3 , " program ming ." ); ＿ ＿ strscat ( st r1 , st r2 ); ＿ strscat ( st r1 , st r3 ); ＿ ＿ printf ("% s \ n " , st r1 ); ＿ ＿// 終了 ＿ printf ("\ n # 正常 終了 #\ n \ n "); // 確認 表示 ＿ system (" pause ");＿// キイ 待ち 停止 ＿ return 0 ;＿ // main () 終了 } // strscat (" aaa "," bbb ") → " aaa bbb " char * strscat ( char * s1 , char * s2 ){ ＿ char ＿＿* p = s1 ; ＿ do { p ++; } while (* p ); ＿* p ++ = ' '; ＿ do { * p ++ = * s2 ++; } while (* s2 ); ＿* p = '\ 0 '; ＿ return s1 ; } /* 実行 出力 ： console Let's study program ming . # 正常 終了 # 続行 する に は 何 か キー を 押し て ください . . . */ 
出力 文字コード が UTF-8 な のに 画面 表示 が Shift_JIS ( Windows なら ば CP932 ) に なっ て いる から 起こる 文字化け です 。 出力 文字コード と 表示 する 文字コード を 合わせ ましょ う 。 なお 、 閏年 ロジック 間違っ て ませ ん か 。 100 で 割り切れ かつ 400 で 割り切れ なかっ たら 平年 です 。 
コード だけ とか フォーム の 画像 だけ で は 関連性 が 掴み にくい と 思う よ 必要 な の は 回答者 が 再現 する ため の 情報 だ けど 、 そもそも 質問者 さん が 混乱 し て いる なら プロジェクト 毎 頼む の も 良い かも しれ ない → 有償 ・ 無償 で 色んな 依頼 先 が ある けど せめて 画像 の どの コントロール が コード の どの コントロール に なる の か 、 画像 に 書き込む って の も ある よ 
この 辺 は どうでしょう か ？ 管理者権限 の ある なし で 動作 が 異なる 。 今回 作成 し た アプリケーション を 管理者権限 で 実行 し た 場合 、 管理者権限 の ない 状態 で 実行 し て いる Excel アプリケーション は 取得 でき ませ ん 。 両者 を 管理者権限 で 実行 する か 、 両者 を 管理者権限 なし で 実行 する か 、 または 、 UAC ( User Account Control ) を 無効 に する 必要 が あり ます 。 参考 ： http:// pro . art 55 .jp /? eid = 1304141 
クイックソート と 選択 ソート は 全然 違い ます ので 、 ソート 部分 は 流用 でき ませ ん 。 ごっそり 入れ替え て ください 。 クイックソート https :// ja . m . wikipedia . org / wiki /% E3 % 82 % AF % E3 % 82 % A 4 % E3 % 83 % 83 % E3 % 82 % A ... なお 、 標準 で 用意 さ れ て いる qsort 関数 を 使用 する こと も でき ます 。 
◆ C言語 … ◎ 極座標系 の 座標 ( r , θ )→ 直交座標系 の 座標 ( x , y ) に 変換 する 関数 だ と … # include < stdio . h > # include < ma t h. h > # define pi 3.14 159265 /* 円周率 の 定義 */ # define r 2 /* 半径 の 定義 */ int getXY ( double rad ) { double x , y ; x = r * cos ( rad ); y = r * sin ( rad ); return x , y ; } int main ( void ) { int deg ; double rad ; double x , y ; for ( deg = 0 ; deg <= 90 ; deg += 5 ) { rad = deg * pi / 180 ; getXY ( rad ); printf (" θ = % d deg \ n ", deg ); printf (" x = % f \ n ", x ); printf (" y = % f \ n ", y ); } return 0 ; } 以上 … ★ 蛇足 … グローバル変数 に する 必要 は ある けど ね … 違う か な … ( 泣 ) getXY と main 関数 内 が 不味い か な … ？( 泣 ) だ と し たら double x , y を 中止 し て # define の 直下 の 行 で 宣言 する と いい かも ね … 以上 … 早稲田大学理工学部 マキ 姫 
DX ライブラリ は 誰 か が 作っ た 自作 関数 知ら ない 人が 作っ た 自作 関数 の 使い方 なんて わから ない PlaySoundMem () なんて 今 初めて 見 た 
kahgja さん 1 . エクセル から (*. csv ) ファイル に 出力 し て 、 それ を 使う 。 2 . エクセル から 直接 読む の は 、 上級 ? か な 
> Item を Player に 追加 する > Player の 中 に ある これ が 具体 的 に どういう 状況 か 分から ない と なんとも 言え ませ ん 。 次 から もっと 具体 的 に 書く よう に し て ください 。 Player という クラス が あっ て その 変数 に 代入 し て いる の か 、 それとも 単に Player という オブジェクト の transform の 子 に つけ て いる の か 。 多分 後者 だ と 思う けど 、 後者 だっ たら int itemCount ; // アイテム の 数 は こっち に 保存 void CountItems (){ int count = 0 ; Transform [] objList = gameObject . GetComponentsInChildren ( typeof ( Transform )); foreach ( Transform child in objList ) { if ( child . gameObject . tag == " Item "){ count ++; } } itemCount = count ; } これ で OK な はず 。 
ほとんど 想像 です が 。 C は 古い です 。 1970年代 の 技術 で 作ら れ まし た 。 複数 の 値 を 返せる こと を 基本 設計 と し て しまう と 、 その 領域 の 確保 だ とか 返り 値 の 格納 で コンピュータ 様 の CPU タイム を 浪費 し て しまい ます 。 それ は おそれ 多い ので 、 一つ の 値 だけ 、 特に int 型 について は レジスタ ( 特に アキュムレータ ) に 格納 し て 返す こと に すれ ば 高速 な 処理 が 期待 出来 ます 。 当時 の コンピュータ ( システム ) の 能力 は 低かっ た ので 、 コンピュータ 様 の お 時間 を 使う の は 申し訳ない ので 人間 が 苦労 する 、 という の が 基本 思想 です 。 ( 完全 に その 思想 に 染まり きっ て 、 未だに C の やり方 が 当然 だ という 解説 を さ れる 方 も 多い よう です ね ) 高速 大 容量 の 今どき の コンピュータ で あれ ば 、 「 それで どれ だけ 得する の ?」 という よう な こと も 多い です が 、 昔 と 違っ て C ぐらい しか 使える 言語 が ない という 状況 で も なく 、 そう 思っ た 時 に は 他 の 言語 を 選択 出来る こと も 多い です 。 
// neutral iz e.c 弱酸 & 強 塩基 限定 /* 参考 : https :// ja . wikipedia . org / wiki /% E 4 % B 8 % AD % E 5 % 92 % 8 C % E 6 % BB % B4 % E 5 % AE % 9 A %... */ # include < stdio . h > # include < stdlib . h > # include < ma t h. h > // 定数 # define ACID _ V 10 . 0 e-3 // CH 3 COOH 体積 # define ACID _ C 0 . 100 // CH 3 COOH 濃度 # define Ka 1 . 75 e-5 // CH 3 COOH 電離 定数 # define BASE _ V 20 . 0 e-3 // NaOH 体積 # define BASE _ C 0 . 100 // NaOH 濃度 # define DELTA 50 . 0 e - 6 // 一滴 の 量 # define Kw 1 e-1 4 // 水 の イオン 積 // プロトタイプ 宣言 double calc _ H _ plus _ in _ acid ( double Na _ plus , double c ); double calc _ H _ plus _ in _ base ( double Na _ plus , double c ); int main ( void ){ // 変数 宣言 double x , y , v , c , Na _ plus , acid _ mol = ACID _ V * ACID _ C ; int i , kaisu =( int )( BASE _ V / DELTA ); // 酸性 にて 滴 定 for ( i = 0 ; i < kaisu / 2 ; i ++){ x = DELTA * i ; // 滴 定量 v = ACID _ V + x ; Na _ plus = ( BASE _ C * x )/ v ; c = acid _ mol / v ; y = - lo g10 ( calc _ H _ plus _ in _ acid ( Na _ plus , c )); // pH printf ("% f \ t % f \ n ", x , y ); } // 塩基性 にて 滴 定 for (; i < kaisu + 1 ; i ++){ x = DELTA * i ; // 滴 定量 v = ACID _ V + x ; Na _ plus = ( BASE _ C * x )/ v ; c = acid _ mol / v ; y = - lo g10 ( calc _ H _ plus _ in _ base ( Na _ plus , c )); // pH printf ("% f \ t % f \ n ", x , y ); } printf ("## Calculation is over !\ n "); } // ニュートン法 による 水素イオン 濃度 の 計算 double calc _ H _ plus _ in _ acid ( double Na _ plus , double c ){ double a = Ka + Na _ plus , b =( Na _ plus - c )* Ka , func , result = 1 . 0 ; func = pow ( result , 2 )+ a * result + b ; while ( func > 1 e - 20 ){ result = result -( func /( 2 * result + a )); func = pow ( result , 2 )+ a * result + b ; } return result ; } double calc _ H _ plus _ in _ base ( double Na _ plus , double c ){ double a = Ka + Na _ plus , b = Na _ plus * Ka - Kw - Ka * c , d = Ka * Kw , func , result = 1 . 0 ; func = a * pow ( result , 2 )+ b * result - d ; while ( func > 1 e - 20 ){ result = result -( func /( 2 * a * result + b )); func = a * pow ( result , 2 )+ b * result - d ; } return result ; } 
OS は ？ とりあえず 、 環境 に あっ た の を 入れれ ば いい ですよ。 https :// gcc . gnu . org / install / binaries . html 
正解 は 、 - 64 を 表す ① でしょ う 。 
よく でき て いる と 思い ます 。 
/* 2016 / 8 / 3 15 : 38 : 08 c言語 フィボナッチ数列 emacs で フィボナッチ数列 の n 項 を 求める プログラム を つくっ た の です が セグメンテーション エラー と 表示 さ れ 実効 でき ませ ん 。 プログラム は 以下 の とおり です ＞ ＞ ＞ １ ． なん でも かん で も malloc で は 、 ぎごち ない 場合 が ある 。 ２ ． ここ は 、 大きめ の 固定 域 を 設定 し て 、 要求 の n が こなせる か を ＿ ＿ チェック する だけ に し て おく と どんな 感じ に なる か 試す 。 ３ ． 固定 域 を int fsn [ 1000 ]; ぐらい に し て も 、 実用 上 何 も ＿ ＿ 問題 ない し 、 ここ に 質問 する レベル と 使用 環境 （ 課題 ？ ） ＿ ＿ なら 、 この サイズ で 十分 と 思わ れる 。 ４ ． 上記 に 必要 な 変更 の 他 、 出力 命令 の 改善 を 行っ た 。 */ // Visual C++ 2013 # define _ CRT _ SECURE _ NO _ WARNINGS // VC++ only , to stop warning for fopen (), scanf () etc. # include < stdio . h > # include < stdlib . h > # define ＿ M ＿ 1000 void fib ( int n , int * a ){ ＿ int i ; ＿ ＿ a [ 0 ] = 0 ; ＿ a [ 1 ] = 1 ; ＿ for ( i = 2 ; i <= n ; i ++){ ＿ ＿ a [ i ] = a [ i - 1 ]+ a [ i - 2 ]; ＿} ＿ return ; } int main (){ ＿ int ＿ fsn [ M ]; // n 項 フィボナッチ数列 の 配列 ＿ int ＿ n ;＿＿＿// フィボナッチ数列 の n 項 ＿ int ＿ k ;＿＿＿// 上記 を 格納 する 配列 の インデクス ＿ int ＿ repeat ; // 入力 繰り返し フラグ ＿ int ＿ ntry = 0 ; // n 入力 回数 ＿ ＿ do { ＿ ＿ printf (" n ?= "); scanf ("% d ",& n ); ＿ ＿ repeat = n < 1 || M < n + 1 ;＿// 0 , 1 , 2 ,..., n ＿ ＿ if ( repeat ){ ＿ ＿ ＿ if ( ntry > 5 ) goto ERR ; ＿ ＿ ＿ printf (" n must be > 0 , or less than M (=% d )\ n ", M ); ＿ ＿ ＿ printf (" repeat by another n , if please .\ n "); ＿ ＿ ＿ printf (" may be able while ntry (==% d ) <= 5 .\ n ", ntry ); ＿ ＿ ＿ ntry ++; ＿＿} ＿} while ( repeat ); ＿ ＿ fib ( n , fsn ); ＿ ＿ printf (" series for upto % d is :\ n ", n ); ＿ printf ("----------------------\ n "); ＿ for ( k = 0 ; k <= n ; k ++){ ＿ ＿ printf (" % d ", fsn [ k ]); ＿ ＿ if ( k > 0 && k % 8 == 0 ){ ＿ ＿ ＿ printf (" (～% d )\ n ", k ); ＿＿} ＿} ＿ if ( k % 8 != 0 ) printf (" (～% d )", n ); ＿ printf ("\ n "); ＿ ＿// 終了 ＿ printf ("\ n # 正常 終了 #\ n \ n "); // 確認 表示 ＿ ERR : ＿ system (" pause ");＿// キイ 待ち 停止 ＿ return 0 ;＿ // main () 終了 } /* 実行 出力 ： console n ?= 30 series for upto 30 is : ---------------------- 0 1 1 2 3 5 8 13 21 (～ 8 ) 34 55 89 144 233 377 610 987 (～ 16 ) 1597 2584 4181 6765 10946 17711 28657 46368 (～ 24 ) 75025 121393 196418 317811 514229 832040 (～ 30 ) # 正常 終了 # 続行 する に は 何 か キー を 押し て ください . . . */ 
ソース ファイル の より 変わり ます 。 大きな 違い は Fortran 77 ： 固定 フォーマット （ ソース は 7 カラム から 72 カラム に 書く ） fortran 90 ： フリーフォーマット 
知ら へん で ～～～～～～ 
ScriptA の 中 で public bool swicthOn ; // 必ず public で 宣言 ScriptB の 中 で public ScriptA switch ; // 画面 上 で スイッチ の オブジェクト を ドラッグ&ドロップ する if ( switch .s witchOn == true ){ } else { } これ で OK 。 基本 中 の 基本 。 
PIC 12 F1 612 は 新しい 石 な ので 未経験 です が 単に ANSELA = 0 ; デジタル I/O ポート 指定 が 抜け て いる 為 と 思わ れ ます プルアップ抵抗 は 10K Ω で 十分 です 、 また 内蔵 プルアップ 機能 を 使え ば 外 付け 抵抗 は 不要 です 
http:// detail . chiebukuro . yahoo . co.jp / qa / question _ detail / q 1116232596 ... の 逆 だ よ 。 要は 、 aa が 含ま れ ない 文字列 。 理由 は 簡単 で 受理 状態 ( 終了 状態 ) が 入れ替わっ てる よ ね 。 
下記 のようなもの は 如何 でしょ う か 。 \ documentclass { jsarticle } \ usepackage { amsmath , amssymb } \ usepackage { enumerate } \ begin { document } \ noindent \ textbf { 問題 2 - 4 }\ raisebox {-. 3485 zh }[ 1 ex ][- 3 ex ]{\ Huge {\ text {$\ boxplus $}}} \ hrulefill （ 復元 抽出 ・ 非 復元 抽出 ） $ n $ を 5 以上 の 自然数 と する 。 1 から $ n $ まで の 数字 が 1つ ずつ 書か れ た カード が 1 枚 ずつ 、 合計 $ n $ 枚 あり 、 箱 の 中 に 入っ て いる 。 \ begin { enumerate }[( 1 )] \ item 箱 の 中 から カード を 1 枚 取り出し て 数字 を 記録 し て カード を 箱 に 戻す こと を 3回 繰り返す とき 、 次 の 確率 を 求め よ 。 \ begin { enumerate }[( i )] \ item 3つ の 数字 が すべて 5 以下 に なる 確率 \ item 3つ の 数字 の 最大 値 が 5 と なる 確率 \ item 3つ の 数字 の 中 に 1 と 5 が 必ず 含ま れる 確率 \ end { enumerate } \ item 箱 の 中 から カード を 3 枚 同時に 出す とき 、 上記 の ( i )( ii )( iii ) の 確率 を それぞれ 求め よ 。 \ end { enumerate } \ end { document } 問題 2 - 4 の 4 を カウンタ か enumerate .s ty で 扱う こと も 出来る かも しれ ませ ん が 、 こんな 感じ で … 
一 例 です 。 Set の ひとつ で ある HashSet を 使い まし た 。 contains () メソッド で 既に 含ま れ て いる か を 取得 でき ます 。 -- import java . util . HashSet ; import java . util .S canner ; import java . util .S et ; public class Yahooq 14163088574 { public static void main ( String [] args ) { // 入力 文字列 を 保持 する ため の インスタンス Set < String > set = new HashSet <>(); // 入力 受付 Scanner scanner = new Scanner ( System . in ); while ( true ) { String inputStr = scanner . nextLine (); if ( inputStr . equals (" print ")) { System . out . println ( set ); continue ; } if ( inputStr . equals (" end ")) { break ; } if ( set . contains ( inputStr )) { System . out . println ( inputStr + " は すでに 入力 さ れ て い ます 。 "); } else { set . add ( inputStr ); } } scanner . close (); } } 
一 例 です 。 -- import java . util . ArrayList ; import java . util . List ; public class Yahooq 11163087601 { public static void main ( String [] args ) { List < String > list = new ArrayList <>(); list . add (" イチゴ "); list . add (" クリーム "); list . add (" マンゴー "); list . add (" チョコレート "); for ( String s : list ) { System . out . println ( s ); } } } 
programme r _ hiro さん ノーベル賞 とか 、 フィールズ賞 とか 、 何 年間 か の 論文 審査 の 上 で 選考 さ れる 賞 は 、 サイエンス という か 学術 的 な 土台 から の 積み上げ が 検証 さ れ た 事柄 で 無い と 、 受賞 でき ない もの です 。 ところが 、 Ｃ 言語 の コンパイラ は 、 プログラミング言語 の デザイン における 学術 的 評価 は 低い と いわ ざる を 得 ませ ん 。 後段 に 示す よう に 、 何時 まで も 、 ドロ 臭い 造り で あり 続ける 宿命 を 負っ た Ｃ コンパイラ に 、 サイエンス チック な 賞 など 、 与える の は 、 不適切 でしょ う 。 ＜ 補足 ＞ 何故 なら 、 「 未だに 誰 も 、 学術 的 な 厳格 さ で は 、 Ｃ 言語 の 文法 を 記述 でき て い ない 」 から です 。 その 為 、 Ｃ コンパイラ の 実装 として gcc コンパイラ や clang コンパイラ の 他 、 幾つも 在り ます が 、 「 全く 同一 の 仕様 の Ｃ コンパイラ を 、 複数 の 実装 者 が 創り 上げ た 」 という 瞬間 は 、 コレ まで 一 度 も 無かっ た の です 。 Ｃ 言語 が 、 AT&T ベル研究所 の デニス・リッチー が 主体 と なっ て 、 1972年 に 作ら れ て ５ ０ 年 近く も 、 曖昧 な 文法 の まま 放置 さ れ て き た 理由 も あり ます 。 それ は 「 Ｃ コンパイラ を 開発 メンバ を 招集 できる よう な スポンサー は 、 ソノ 時々 の 新しい ＣＰＵ の メーカ で 、 何時も ＣＰＵ が 完成 し て から 間も無く 、 ” 早く 、 動く ＯＳ を 造れ ！ ！ ” 、 ” ＯＳ を 造る 前提 の Ｃ コンパイラ を 早く 作れ ” 、 という 突貫 作業 で 造ら れ 続け て き た し 、 これから も 突貫 作業 が 続く から です 。 ” 突貫 作業 ” の ニュアンス は 、 数 ヶ月 位 の 場合 も ある が 、 最近 の ＩＴ 業界 の ニュース に モレ 出 て き た 例 も 在り ます 。 Apple社 が mac や iPhone の APU で ある ARM 系 の CPU 用 の コンパイラ として 、 初期 の 段階 は gcc コンパイラ を 用い て い た ものの 、 gcc コンパイタ が 図体 が 大きく なり すぎ て 簡単 に カスタマイズ でき なく なっ て き た 。 そして 、 「 gcc コンパイラ の 改造 速度 で は ビジネス 的 に 間に合わ ない ！ だから 0 から 綺麗 に 作り直し た clang コンパイラ に 乗り換える の だ ！ ！ 」 という こと が 起き た そう です 。 最近 の モダン な プログラミング言語 は 、 Ｃ 言語 の 20 分の 1 以下 の コンパクトサ で 、 数学 的 に も 厳格 に 定義 でき て い て 、 なおかつ Ｃ 言語 より 高 機能 な プログラミング言語 は 幾つも ある の です 。 ＜ 参考 １ ＞ ★ Towards ・ Higher - Order Syntax of ・ C Programming Language http : www . kmonos .net / pub / Presen / HiC . pptx 引用 「 中間 的 な 表現 力 を 持つ 言語 を 使っ て . C言語 の 文法 を 記述 し て み たい . ・ C の 文法 は 文脈 自由 で は ない と 言わ れる 。 ・ 文脈 自由 じゃ ない なら 、 BNF より 強力 な 文法 記述 言語 で 書け ば いいじゃない ！ ・ ISO / IEC 9899 : 1999 自然言語 で 書い て ある ・ gcc , clang , ... ： C や C++ で 書い て ある ・ 「∞: チューリングマシン 」 、 「 再帰 文法 」 「 停止 証明 付き 計算 」 「 文脈依存文法 」 この 辺 なら 書ける はず だ けど ・ 人類 に は 難しい ・ 高階 文法 で も まだ 無理 な こと が わかり まし た 。 」 ＜ 参考 ２ ＞ 智恵袋 に は 、 Ｃ 言語 の 文法 を 正確 に 理解 でき て いる 人 が 居 ない 証拠 ； ★ ｃ 言語 の 複雑 さ を 悟る クイズ 「 a * b * c ; に 括弧 を 入れ た パターン の 内 、 有効 な 宣言 文 と 、 それ 以外 （ 代入 文 や 式 等 ） として 多重 に 解釈 できる パターン を 、 出来る だけ 沢山 列挙 し て み て ください 」 http:// detail . chiebukuro . yahoo . co.jp / qa / question _ detail / q 1414284588 ... この パズル は 、 上述 の 論文 が 元ネタ で 、 Ｃ 言語 の 文法 を 正確 に 理解 し て い ない と 解け ない 問題 だ が 、 まとも な 正解 例 を 何 例 か 示す こと が でき た の は 、 智恵袋 で は 、 私 位 しか い ませ ん 。 回答 例 ＝ http :// ideone . c o m / j2 v f1 n 
文面 から 察 する に 、 オブジェクト の 移動 に関して 誤解 が ある よう に 思わ れ ます 。 まず 、 「 Translate 」 は 、 物理 挙動 と は 関係 の 無い 処理 です 。 移動 と 言う より は 、 ごく 短い 距離 を 連続 し て ワープ する 事 で 、 画面 上 で は 、 あたかも 移動 し て いる か の よう に 見え て いる だけ です 。 な ので 、 本来 で あれ ば 、 「 Translate 」 で 動い て いる オブジェクト は 、 他 の どの オブジェクト とも 衝突 でき ませ ん 。 （ めり込む だけ ） しかし 、 ご 質問 の 内容 で は 、 物理 挙動 以外 の 方法 で 動かし て いる オブジェクト に 、 Rigidbody が 付い て いる 事 で 、 意図 せ ず し て 弾か れる という 現象 が 起き て いる もの と 思わ れ ます 。 つまり 、 本来 で あれ ば 、 Rigidbody を 持つ コライダー 同士 が 接近 し 、 接触 し た 瞬間 に 衝突 イベント が 発生 し 、 停止 する なり の 処理 を 行う ハズ です 。 が 、 今回 の 状況 で は 、 Rigidbody を 持つ コライダー 同士 が 、 短距離 の ワープ によって 近付き 、 どか の 段階 で 相手 の コライダー に めり込ん だ 位置 に ワープ する 事 に なり ます 。 重なっ た まま で は 、 正常 に 物理 挙動 が 計算 でき ない 為 か 、 Rigidbody を 持つ コライダー 同士 が めり込む と 、 弾ける よう に し て 離れよ う と し ます 。 これ が 、 今回 の 原因 と 思わ れ ます 。 結論 として は 、 Rigidbody を 持つ オブジェクト を 移動 さ せる なら 、 「 velocity 」 で 移動 速度 を 指定 する の が 、 最も 単純 で 分かり やすい 方法 です ので 、 これ に 切り替え て み て は いかが でしょ う か 。 ↓ 公式 ドキュメント 「 Rigidbody . velocity 」 docs . unity 3d . com / ja / current / ScriptReference / Rigidbody - velocity . html 
PIC の C言語 と 言っ て も 色々 な C コンパイラ が あり ます 。 中 に は RC 0 の よう に ビット 単位 の 名称 を 使用 でき ない もの も あり ます 。 PORTA は バイト 単位 の 名称 で ほとんど 全部 の C コンパイラ で 使用 でき ます 。 ポート 名 と 16 進数 の 論理積 を 用い た 書き方 は ビット 単位 の 名称 を 扱え ない C コンパイラ で も 通用 する 書き方 に なり ます 。 
環境 に 合わせ て で いい と 思い ます 。 ソース の 流用 が 前提 で 、 （ Win → Linux 等 ） プログラミング し なけれ ば なら ない 場合 は UTF-8 、 Win のみ だっ たら s-jis という 形 で 。 サンプル プログラム の 書きため でし たら 、 そこ まで こだわる 必要 も ない でしょ う し 、 どうしても 文字コード の 変更 が 必要 に なっ た 場合 に 、 テキストエディタ 等 で 文字コード 変換 し て 再度 保存 すれ ば いい と 思い ます 。 
割り込み を 使っ て みれ ば 良い か と 思い ます 。 ピン 変化 割り込み とか 参考 に なり そう な サイト https :// developer . mbed . org / users / okini 3939 / notebook / ref _ jp / 
ラズベリーパイ に ワイヤレスマウス ・ キーボード と WiFi アダプター と 「 ラズベリーパイ 」 専用 の 液晶ディスプレイ と AC 電源 を 繋い で 、 PC として 使っ て い ます 。 電子工作 等 に も 使っ て い ます 。 参考 HP 「 http:// store . techshare .jp / html / page 101 . html 」 従っ て 、 「 ラズベリーパイ 」 に 他 の パソコン は 、 ロボット など 、 本体 を 積み込ま ない 限り 必要 は ない の で は ない でしょ う か ？ 夏休み の 課題 と の こと な ので 、 こんな ところ で 。 
＞ C言語 で の ゲーム 作り の 参考 に なる サイト Rogue http:// yozvox . web . fc2 . com / 526 F 677565 . html デバッグ ではじめる C プログラミング : 山本 貴光 : 本 : Amazon https :// www . amazon.co.jp / dp / 4798114197 
/* tanabe _ tatsuya _ 0516 さん へ こんな かんじ で … ----- 実行 結果 ----- 5 ○ △ □ ○ △ */ # include < stdio . h > int main ( void ) { char * list []={"○","△","□"}; int n , i ; scanf ("% d ",& n ); for ( i = 0 ; i < n ; i ++){ printf ("% s ", list [ i % 3 ]); } printf ("\ n "); return 0 ; } 
条件 を 満たそ う と する と これ 以上 は 短く なら なかっ た import static java . util . stream . IntStream . range ; import static java . lang .S ystem . out ; public class T { public static void main ( String [] a ){ a = range ( 1 , 13 ). mapToObj ( i -> i +" 月 "). toArray ( String []:: new ); for ( int i = 0 ; i < 12 ; out . println ( a [ i ++])); } } 
その 書き方 だ と 、 for   / r   % % i   in   (*. jpg   *. jpeg   *. cr2 )   do   ( と 混同 さ れ て ループ 変 数 % % i と 区別 が 付か ない か と 。 "   "   で 囲っ たら 上手く 行く かも 。 for   % % i   in   (" E "   " F "   " G "   " H "   " I "   " J "   " K "   " L "   " M ")   do   (    for   / r   "%% i :\ DCIM \"   % % k   in   (*. jpg   *. jpeg   *. cr2 )   do   (      if   exist   % % k   ( move   /- Y   % % k   % outputdir %) )   ) 
# include < io stream > int main () { std :: cout << "(^_^)\\/\ n "; return 0 ; } こんな 感じ です 。 
人 に 教え を 乞う のに 何で ID 非公開 な ん です か ？ ID 非公開 の バカ が 、 はめ まし て ( 笑 ) 
Intel Fortran に 付属 の installation guide ないし インストール ・ ガイド に 詳しい こと が 書い て ある ので 、 それ を 参照 する の が もっとも 確実 で ある 。 （ 必要 と する もの が ヴァージョン ごと に 異なっ て いる ので 。 ） 最近 の Intel Visual Fortran で は 、 コマンドライン 実行 の 場合 でも Microsoft 配布 の SDK など を あらかじめ インストール し て おく 必要 が ある 。 不明 だ が リンカ など を 利用 し て い た と 思う 。 Visual Studio と の 統合 に関して は 、 Visual Studio を 先 に インストール し て おく 必要 が ある 。 Fortran の インストーラ が 、 インストール さ れ て いる Visual Studio を 探し出し て 、 統合 できる ヴァージョン なら ば 統合 する か どう か 、 選択肢 を 出し た と 思う 。 （ 日本語 環境 で は うまく いか ない こと が あっ た 。 ） たしか 有料 版 で は Visual Studio 2010 込み の インストーラ も ある 。 
・ アルファベット （ 小文字 ） 判定 if ( char >= ' a ' and char <= ' z ' ) ・ toupper 関数 大文字 へ 変換 （ 大文字 から 大文字 で も 問題 なし ） これ が 分かれ ば あと は 完成 できる はず 。 がんばっ て ください 。 
１ ． Ｘ ＿__ X1 ＿_ X 2 ___ 10 進数 000 __ 111 __ 000 __ 0 =( 0 ) 001 __ 110 __ 111 __ 1 =(- 7 ) 010 __ 101 __ 110 __ 2 =(- 6 ) 011 __ 100 __ 101 __ 3 =(- 5 ) 100 __ 011 __ 100 __( 4 )=- 4 101 __ 010 __ 011 __( 5 )=- 3 110 __ 001 __ 010 __( 6 )=- 2 111 __ 000 __ 001 __( 7 )=- 1 ２ ． ＞ ＞ 2 、 1 、 の 結果 を 用い て 、 「 この 計算機 の 」 積 和 標準形 を 求めよ ちょっと 、 この 「 」 部分 が ひっかかっ て 悩ん で ます 。 。 。 
/* 2016 / 8 / 2 13 : 14 : 55 C言語 について 質問 です 。 以下 に 示す ソースコード は 、 配列 と 関数 の 定義 を 使っ た もの です 。 以下 の ソースコード を 変更 する ところ は 変え て ファイル (. txt ) から 入力 ⇒ ソート ⇒ ファイル に 出力 する プログラム に 変更 し て い た だけ ませ ん か ？ 10 個 の 数字 が あり 、 ソーティング し て 小さい 順 に 並べ 替え たい です 。 よろしくお願いします 。 */ // Visual C++ 2013 # define _ CRT _ SECURE _ NO _ WARNINGS // VC++ only , to stop warning for fopen (), scanf () etc. # include < stdio . h > # include < stdlib . h > # include < ma t h. h > # define N ( 10 )＿＿＿// データ 数 void sort ( int * data ); int main ( void ){ ＿ char ＿＿* fni =" tst . txt "; // 入出力 ファイル ＿ char ＿＿* fno =" tst . log "; // 出力 ファイル ＿ FILE ＿＿* fi ;＿＿＿// 入力 ファイル ＿ FILE ＿＿* fo ;＿＿＿// 出力 ファイル ＿ int ＿ ＿ num [ N ];＿ // データ保存 配列 ＿ int ＿ ＿ i ;＿＿＿＿// 配列 の インデクス ＿ ＿// 入力 ＿ if (( fi = fopen ( fni ," r "))== NULL ){ ＿ ＿ printf ("% s not found , stop job .\ n ", fni );＿ goto ERR ; ＿} ＿ printf (" 数値 は "); ＿ for ( i = 0 ; i < N ; i ++){ ＿ ＿ fscanf ( fi ,"% d ", num + i );＿ printf (" % d ", num [ i ]); ＿} printf (" です \ n "); ＿ printf ("% s から 読込み まし た \ n ", fni ); ＿ fclose ( fi ); ＿ ＿// ソート ＿ printf ("\ n 昇順 に 並べ 替え ます \ n "); ＿ sort ( num );＿ printf (" sort ( num );\ n "); ＿ printf (" 交換 し まし た \ n \ n "); ＿ ＿// 出力 ＿ if (( fo = fopen ( fno ," w "))== NULL ){ ＿ ＿ printf ("% s not opened , stop job .\ n ", fno ); goto ERR ; ＿} ＿ printf (" 数値 は "); ＿ for ( i = 0 ; i < N ; i ++){ ＿ ＿ fprintf ( fo ," % d ", num [ i ]); printf (" % d ", num [ i ]); ＿} printf (" です \ n "); ＿ printf ("% s に 書き込み まし た \ n ", fno ); ＿ fclose ( fo ); ＿ ＿// 終了 ＿ printf ("\ n # 正常 終了 #\ n \ n "); // 確認 表示 ＿ ERR : ＿ system (" pause ");＿// キイ 待ち 停止 ＿ return 0 ;＿ // main () 終了 } // 昇順 に ソート する void sort ( int * data ){ 数値 は ＿ 2 4 6 8 10 1 3 5 7 9 です tst . txt から 読込み まし た 昇順 に 並べ 替え ます sort ( num ); 交換 し まし た 数値 は ＿ 1 2 3 4 5 6 7 8 9 10 です tst . log に 書き込み まし た # 正常 終了 # 続行 する に は 何 か キー を 押し て ください . . . ＿ for ( int i = 0 ; i < N - 1 ; i ++){ ＿ ＿ for ( int j = i + 1 ; j < N ; j ++){ ＿ ＿ ＿ if ( data [ i ] > data [ j ]){ ＿ ＿ ＿ ＿ int tmp = data [ i ]; ＿ ＿ ＿ ＿ data [ i ] = data [ j ]; ＿ ＿ ＿ ＿ data [ j ] = tmp ; ＿＿＿} ＿＿} ＿} } /* 実行 出力 ： console 数値 は ＿ 2 4 6 8 10 1 3 5 7 9 です tst . txt から 読込み まし た 昇順 に 並べ 替え ます sort ( num ); 交換 し まし た 数値 は ＿ 1 2 3 4 5 6 7 8 9 10 です tst . log に 書き込み まし た # 正常 終了 # 続行 する に は 何 か キー を 押し て ください . . . */ 
この へん 見れ ば わかる と 思う 。 http:// www .s cs .s tanford . edu / histar / src / pkg / uclibc / include / limits . h http:// www . tutorialspoint . com / c _ standard _ library / limits _ h. htm 
ID 非公開 さん int w [ 2000 ]; void fx ( int x , int s , int k ) { int i ; if ( x == 1 ) { if ( k > 1 ) { for ( i = 0 ; i < k ;++ i ) { if ( i == 0 ) printf (" = % d ", w [ i ]); else printf (" * % d ", w [ i ]); } } return ; } for ( i = s ; i <= x ;++ i ) { if (( x % i ) == 0 ) { w [ k ] = i ; fx ( x / i , i , k + 1 ); } } } void gx ( int u ) { printf ("% d ", u ); fx ( u , 2 , 0 ); printf ("\ n "); } int main () { int d ; d = 24 ; do { gx ( d ); printf (" Input not zero !"); scanf ("% d ",& d ); } while ( d > 1 ); return 0 ; } 
quest ion aco un t3 さん べき乗 の 計算 は y = x ^ k ( x の k 乗 ) と なり ます が 、 power 関数 の 引数 と 変数 に 対応 さ せる と 、 base → x n → k p → y と なり ます 。 あと 、 プログラム 間違っ て い ます ね 。 下記 に 訂正 し た もの を 掲載 し ます 。 /* ← ★ ココ だ よ ！ ★ */ の 部分 を よく 見 て ください 。 # include < stdio . h > int power ( int m , int n ); int main () { int i ; for ( i = 0 ; i < 10 ; i ++)/* ← ★ ココ だ よ ！ ★ */ printf ("% d % d % d \ n ", i , power ( 2 , i ), power (- 3 , i )); return 0 ; } int power ( int base , int n ) { int i , p ; p = 1 ; for ( i = 1 ; i <= n ; i ++)/* ← ★ ココ だ よ ！ ★ */ p = p * base ; return p ; } 
/* 2016 / 8 / 16 15 : 08 : 09 c言語 の 問題 を 解こ う と し た の です が 、 どう いっ た プログラム に なる の か わから なかっ た ので 質問 し まし た 。 問題 char 型 の 配列 を 、 " OKINAWA " を 初期 配列 として 宣言 し 、 文字列 の 順番 を 逆 に し て 、 " AWANIKO " と 出力 する プログラム を 作り なさい */ # include < stdio . h > # include < stdlib . h > int main ( void ){ ＿ char ＿ okinawa []=" OKINAWA "; ＿ char ＿* p = okinawa ; ＿ ＿ printf (" original : "); while (* p ) printf ("% c ",* p ++);＿ p --; ＿ printf ("\ n "); ＿ printf (" reversed : "); while ( okinawa <= p ) printf ("% c ",* p --); ＿ printf ("\ n "); ＿ ＿// Hold screen before back to OS . ＿ printf ("\ n # Normal End #\ n \ n "); ＿ system (" pause "); ＿ return 0 ; } /* 実行 出力 ： console original : OKINAWA reversed : AWANIKO # Normal End # 続行 する に は 何 か キー を 押し て ください . . . */ 
http:// www . avnet . co.jp / embedded / column / The m e3 / 04 . aspx の サイト が 参考 に なる かも 知れ ませ ん 。 
dszsxpm さん 囲碁 ・ 将棋 ・ C言語 本 を 読め ば 、 中学生 で も わかる 。 気楽 に 学ぶ 。 
＞ 組み込み の C言語 を 使っ た 簡単 な プログラミング Z80 の シミュレータ で CPU の 構成 と 機械語 の コツ を 学ぶ 
周期 が 同じ なら 同じ タイマー を 使用 する こと が でき ます 。 
OS は 、 機械語 で 作れ ます 。 機械語 は 、 コンピュータ を 直接 制御 でき ます 。 
EventChartCustom () で ユーザ 定義 イベント を 任意 の チャート へ 送る こと が でき 、 送信先 チャート の OnChartEvent () で 受け取る こと が でき ます 。 ボタン が 押さ れ た チャート の OBJECT _ CLICK イベント 契機 で 、 他 の チャート に ユーザ イベント を ブロードキャスト してやれ ば よい と 思い ます 。 ほぼ そのよう な 仕様 の サンプル が 以下 の ページ に あり まし た 。 https :// docs . mql 4 . com / eventfunctions / eventchartcustom 
内容 が テキスト な ので 、 データ 幅 が バラバラ だ と 思い ます ので 、 一旦 全部 読み だして から 不要 な データ を 削除 し て 、 書き込み 直す の が 一番 スマート でしょ う 。 または … １ ． 読み出し つつ 、 作業 用 ファイル に 書き込み つつ 不 必要 データ を 書込み スキップ し て 目的 の 内容 を 作成 。 ２ ． 元 ファイル を 削除 。 ３ ． 作業 用 ファイル の 名前 を 元 ファイル 名 に 変更 みたい な 感じ でしょ う か … // ファイル 移動 （ ファイル 名 変更 ） 関数 http:// yukifx . web . fc2 . com / sub / reference / 19 _ file _ func / cone / file _ move ... - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ------------------------- ただ 、 なぜ そのよう な 事 を し たい の か という 根本 的 な 問題 から の 解決 を 考える と 、 より スマート な 解決 法 が 存在 する か も しれ ませ ん 。 
一 例 です 。 -- package test 20160808 . q10 162701125 ; public class NewMember extends Member { public String tel ; // 電話番号 public void displayTel () { System . out . println (" 電話番号 : " + tel ); } @ Override public void display () { System . out . println (" 名前 : " + name ); } } 
show Click に IMouse インターフェース の 実装 クラス の インスタンス を 渡せ ば よい と 思い ます 。 以下 一 例 です 。 -- package test 20160815 . q 13162994958 ; public class P orim o2 { public static void main ( String [] args ){ showClick ( new PrimeMouse ()); showClick ( new FujitsuMouse ()); } private static void showClick ( IMouse mouse ){ mous e.c lick (); } } -- package test 20160815 . q 13162994958 ; public class PrimeMouse implements IMouse { public void click () { System . out . println (" Prime マウス "); } public void double Click () { System . out . println (" Prime マウス 連打 "); } } -- package test 20160815 . q 13162994958 ; public class FujitsuMouse implements IMouse { public void click () { System . out . println (" 富士通 マウス "); } public void double Click () { System . out . println (" 富士通 マウス 連打 "); } } -- package test 20160815 . q 13162994958 ; public interface IMouse { abstract public void click (); abstract public void double Click (); } 
以下 の 一文 だ と 思い ます 。 キャスト が 必要 な 問題 だ と 思わ れ ます 。 (( Kodomo ) oya ). showName (); 
一 例 です 。 -- Manga . java -- package test 20160808 . Yahooq 11162700331 ; public class Manga extends Book { String author ; // 著者 String title ; // タイトル int chapter ; // 章 public int getPageByChapter () { // 1 章 あたり の ページ 数 を 返す return getPage () / chapter ; } } -- MangaTest . java ( Manga クラス を 使う テスト クラス )-- package test 20160808 . Yahooq 11162700331 ; public class MangaTest { public static void main ( String [] args ) { Manga manga = new Manga (); manga .s etPage ( 100 ); manga . chapter = 3 ; System . out . println ( manga . getPageByChapter ()); } } 
ここ で いう カプセル化 と は 、 フィールド を private に し 、 getter / setter を 作成 せよ 、 という こと でしょ う 。 答え は 以下 の コード に なり ます 。 あくまで 教科書 的 な 回答 で 、 本来 は getter / setter を 用意 する だけ で カプセル化 さ れる わけ で は ありません が 。 -- class Capsule { private String name ; private double amount ; private boolean poisonFlag ; public String getName () { return name ; } public void setName ( String name ) { this . name = name ; } public double getAmount () { return amount ; } public void setAmount ( double amount ) { this . amount = amount ; } public boolean getPoisonFlag () { return poisonFlag ; } public void setPoisonFlag ( boolean poisonFlag ) { this . poisonFlag = poisonFlag ; } } 
参考 XC 8 BLINK GP2 -- GPx 点滅 する ポート 番号 0 , 1 , 2 , 4 , 5 __ delay _ ms ( 500 ); -- 点滅 速度 単位 mS / 500m S = 0 . 5 秒 間隔 # include < xc . h > # pragma config CP = OFF # pragma config OSC = IntRC # pragma config MCLRE = OFF # pragma config WDT = OFF # define _ XTAL _ FREQ 4000000 // 4 MHz void main (){ OPTION = 0 xDF ; // GP2 - I/O T 0 CS _ OFF GPIO = 0 ; TRISGPIO = 0 B 11001000 ; // GPIO 5 , 4 , 2 , 1 , 0 OUTPUT while ( 1 ){ GP2 ^= 1 ; // GP2 反転 __ delay _ ms ( 500 ); // 0 . 5S } // while } 
タスクスケジューラ を 使わ ない と なる と 、 力 押し しか 手段 は なくなり ます 。 Do WS cri pt. Sleep 100 Loop Until ( Now () = " 2016 / 08 / 14 22 : 02 : 00 ") MSGBOX Now () こんな 形 で 、 指定 時刻 が 得 られる まで ループ さ せ て おき ます 。 他 の 手段 だ と 、 間接 的 に で あっ て も タスクスケジューラ を 利用 する 方法 に なっ て しまう でしょ う 。 
> a [ i ] = i -- * 2 + 1 ; この 動作 は 未 定義 。 http:// www . kouno .jp / home / c _ faq / c3 . html # 0 
間違い が いくつ か 。 赤 の 下線 は 、 なんらかの ミス として 認識 さ れ て い ます 。 最初 の # include 文 に も つい て い ます 。 見る と 、 studion . h と なっ て い ます が 、 そんな もの あり ませ ん 。 ( 自作 ヘッダ なら と も かく 。 ) stdio . h です 。 ( 1 ) とか は 外し て ください 。 ( 2 ) は 回答 さ れ て い ませ ん よ ? ( 3 ) も 。 ... もしかして 問題 文 です か ？ それなら OK です 。 エラトステネス の ふるい の 概念 と いう か ロジック (?) を 思い出し て ください 。 エラトステネス の ふるい は 、 0 から n - 1 の n 個 の 配列 を 使い ます 。 0 と 1 は 素数 に 含ま れ ませ ん から 0 番目 と 1番 目 の フラグ を 折れ ば いい 。 で 、 2 から 開始 ... で 、 すべて 終わっ たら 、 フラグ が 立っ て いる もの が 素数 という 扱い です 。 な ので 、 表示 等 で 素数 を ・ ・ ・ の とき は 、 if 文 で フラグ が 立っ て いる か どう か を 調べ て 、 立っ て いれ ば 素数 、 立っ て い ない なら 素数 で は ない という 風 に 。 たとえば 、 質問 の 例 だ と 、 0 = 素数 で ない , 1 = 素数 ( 0 番目 と 1番 目 が 0 に なっ て いる こと から 。 ) と なっ て い ます ので 、 if ( flag [ i ] == 1 ){ __ printf ( "% d : 素数 " ); } を for 文 に 埋め込む 。 みたい な 。 
学習 方法 って いろいろ あり ます 。 ひとつだけ で は ない です 。 なので 一 例 。 私 は 1 . その 言語 の 最低限 必要 な 書式 を 覚える 2 . 実際 に 作り たい もの 、 あったらいいな と 思う もの を イメージ 3 . ( なく て も いい が ) 2 を ノート 等 に 絵 や 文字 で 表現 ( 忘れないよ うに する ため 。 ) 4 . 3 ( または 2 ) を 実際 に 作る 5 . わから ない こと が あれ ば 書籍 や サイト を 辞書 代わり に し て 調べる 6 . 5 で も わから ない なら 、 最終 手段 として 知恵袋 や その 手 の 掲示板 で 聞く みたい な 感じ 。 あと 、 いろんな ソースコード を 読む 。 サイト や 書籍 は ひとつだけ で は なく て 複数 読む 。 ( 読ん で いる うち に ひらめく こと が ある 。 ) 「 データ構造 と アルゴリズム 」 もやっ て みる 。 オブジェクト指向言語 ( C++ , Java etc. ) なら 「 デザインパターン 」 もやっ て みる 。 「 " C++ " デザインパターン 」 等 で 検索 する 。 とにかく 何 度 も 組ん で みる 。 挑戦 し て みる こと 。 
他 の 方 も おっしゃっ て いる よう に 、 情報 が 少な すぎ ます 。 C# や Java 等 の 別 の 言語 に する とき 、 どういう 風 に 記述 すれ ば いい の か ... な の か 、 JNI 等 で Java と 連携 を とり たい が 、 String 型 の ため 、 どういう 風 に すれ ば いい か ... な の か 、 String クラス っていう 自作 クラス を 作っ て string を 使い やすく し た もの に ... な の か 、 ... もしかして 、 string 型 の 配列 です か ？ 大文字 と 小文字 で は だいぶ 印象 が 変わり ます よ ？ もし 配列 に し たい なら 、 普通に string sLine [ 10 ]; // sLine という 変数 を 10 個 (?) と すれ ば いい と 思い ます よ ？ 
Player character ();// これ は Player を 返す 関数 の プロトタイプ 宣言 です か ？ それとも 、 Player character ; の 間違い です か ？ 
> gm aili d1 さん 入れ なおす 必要 は なく て http:// nozawashinichi . sakura . ne.jp / fs / 2009 / 07 / octave mac - x11 - or - aqua. .. に従って 必要 な 設定 を 行なえ ば 良い と 思う 適当 に やっ てる から わけ わから なく なっ てる ので ちゃんと 調べ て から やり ましょ う 本家 の 文書 が 一番 信頼 できる けど 今回 の 上 の リンク 先 を 探す よう に octave termina l とか 「 ツール 名 キーワード 」 「 ツール 名 やり たい こと 」 「 OS 名 ツール 名 やり たい こと 」 「 OS 名 ツール 名 キーワード 」 など で ネット 検索 し て も 良い 
append ([ a , b ], [ c , d ], X ). ↓ append ([ b ],[ c , d ], X ). /* １つ め の 引数 を 分割 し て 再帰 */ ↓ append ([], [ c , d ], X ). /* １つ め の 引数 を 分割 し て 再帰 */ ↓ append ([], [ c , d ], [ c , d ]). /* １つ め の append 定義 によって 確定 */ ↓ append ([ b ],[ c , d ],[ b , c , d ]). ↓ append ([ a , b ], [ c , d ], [ a , b , c , d ]). という 動き に なり ます 。 処理系 によって 、 debug とか trace とか 、 途中 の 式 を 表示 し ながら 動かせる 機能 が ある ので 、 調べ て み て ください 。 
整数 は 小数点 以下 の 無 い数 です 、 全て の ビット で 値 を 表現 し ます 。 浮動小数 点 は 小数点 が 浮動 です ので ビット を 指数 部 と 仮数 部 に 分け て 持ち 極端 に 小さな 値 から 極端 に 大きな 値 を 記憶 出来 ます 、 ただし 、 仮数 部 の 桁 数 の 関係 で 計算 し た 時 に 丸め られ て 誤差 が 出る 場合 が 有り ます 。 ２ の 補数 は 加算 回路 で 引き算 が 出来る メリット が 有り ます 。 
答え は ① という 事 で いが が ？ 
> 前回 の 質問 で いつ の 質問 ？ ここ は チャット じゃ ない もん で 、 明示 し ない と わからん で 本題 だ けれども 、 謎 だ なぁ 。 VS を 修復 インストール し て みる か 、 ウィルス 対策 ソフト を アンインストール し て 試し て みる か 、 VS 入れ なおし て みる か 、 くらい しか 浮かば ない 。 
n >= 1 に対し G ( n )= | F ( n + 1 ) F ( n )| | F ( n ) F ( n - 1 )| とおく と | 1 1 || F ( n + 1 ) F ( n )| | 1 0 || F ( n ) F ( n - 1 )| = | F ( n + 2 ) F ( n + 1 )| | F ( n + 1 ) F ( n )| = G ( n + 1 ) ∴ G ( n + 1 )= | 1 1 | | 1 0 | G ( n ) ( n >= 1 ) ∴ G ( n )= | 1 1 |^( n - 1 ) | 1 0 | G ( 1 ) G ( 1 )= | F ( 2 ) F ( 1 )| | F ( 1 ) F ( 0 )| = | 1 1 | | 1 0 | より G ( n )= | 1 1 |^ n | 1 0 | ( n >= 1 ) 
Character . isDigit メソッド で 数値 か どう か 判定 でき ます 。 以下 、 サンプル です 。 -- ソース -- package test 20160731 ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Yahooq 12162352827 { public static void main ( String [] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in )); char [] aaa = new char [ 2 ]; for ( int i = 0 ; i < aaa . length ; i ++){ String str = br . readLine (); aaa [ i ] = str . charAt ( 0 ); } for ( int i = 0 ; i < aaa . length ; i ++){ if ( Character . isDigit ( aaa [ i ])) { System . out . println ( aaa [ i ] + " は 数値 です 。 "); } else { System . out . println ( aaa [ i ] + " は 数値 以外 です 。 "); } } } } -- 実行 例 -- a1 1 a a は 数値 以外 です 。 1 は 数値 です 。 
＞ 下 の 画像 の よう な 図 エスパー 検定 ３ 級 試験 ・ 遠視 
単精度 ： 2 進数 で 仮数 部 ２ ３ ビット 、 指数 部 ８ ビット 、 符号 1 ビット → １ ０ 進数 だ と 有効数字 ７ 桁 くらい 、 大き さ は 10 の ± 38 乗 くらい 倍精度 ： 2 進数 で 仮数 部 ５ ２ ビット 、 指数 部 １ １ ビット 、 符号 1 ビット → １ ０ 進数 だ と 有効数字 １ ５ 桁 くらい 、 大き さ は 10 の ± 308 乗 くらい ＞ 数字 の 直後 に d0 を つける の は Double Precision です か 。 間違い で は ない 。 指数 表現 1000 → 1 . 0 e3 の 倍精度 版 1000 → 1 . 0 d3 → 1000 d0 で も 間違い で は ない が アホ っぽい 。 
gatoringorira さん main () が ない と 、 テスト でき ない 。 
問題 あり ませ ん 。 http:// www . wdic . org / w/ TECH /% E3 % 82 % B5 % E3 % 83 % 95 % E3 % 82 % A3 % E3 % 83 % 83 % E3 %... 
どうぞ 。 http:// neareal . com / 1230 / ちなみに 、 初心者 の 場合 コード を ０ から 考える の は 恐らく 不可能 です 。 １ ． 「 どう し たら 目的 の コード を 検索 出来る か 」 を 考える 。 （ 今回 は 「 unity ドラッグ オブジェクト を 動かす 」 で 発見 し まし た ） ２ ． お手本 と なる コード を 見付け たら そのまま コピペ する 。 ３ ． その コード が なぜ 動い て いる か 考える 。 → わから ない スクリプト が あっ たら 、 その 部分 だけ 調べ て みる 。 → お手本 の コード を 少し だけ 改変 し て みる 。 これ を 繰り返し て いる と 、 Unity が どう 動い て いる か 、 どの コンポーネント が どんな 役目 を 持っ て い て どう すれ ば どんな 動き を する の か わかっ て き ます 。 コード を ０ から 考える の は それ から です 。 
いい と 思い ます あり です 
split は 解決 し た よう な ので 、 後半 の 改良 です が ・ ・ ・ サンプルソース の うち 、 if 文 と 「 int iAns = iVal 1 + iVal 2 ;」 以外 は 各 計算 式 で 共通 な ので 、 共通部分 を 何度も 書い て いる と すれ ば 無駄 か と 。 個別 の 部分 だけ を if 文 で 切り替える の は どうでしょう ♪ 
見方 に よる と 思い ます 。 【 C言語 は 簡単 】 文法 が 単純 な ん です ね 。 一瞬 で 覚え られ ます 。 覚える べき ところ が あまり ない から です 。 演算子 が やや 多め です けれども 、 機械語 の 感覚 から する と あまり 違和感 が 無い ため 、 これ また 習得 の 妨げ に は なり ませ ん 。 おそらく １ 週間 は かから ない と 思い ます 。 ていう か 、 ２ 日 も あれ ば 十分 じゃ ない でしょ う か 。 それ くらい 簡単 な もの です 。 【 C言語 は 難しい 】 前述 の 通り 、 C 言語 が 難しい だ なんて 、 まず そういう こと は 無い です 。 なのに １００人 中 １００人 （ じゃ ないか 、 １００人 中 ９ ０ 人 くらい に し とき ます か ） 、 C 言語 は 難しい と 言う 。 何故 です か ね 。 C 言語 が 難しい よう に 見え て 実は 、 C 言語 で は ない 部分 が 難しかっ たり する の です よ 。 （ １ ） 二 進数 、 ブール代数 二 進数 や ブール代数 の 勉強 って C 言語 に 入門 しよ う と する 何 か月 も 前 に 終わっ て なけれ ば 駄目 です よ 。 まさか 、 C 言語 と 同時 入門 だ なんて 、 それ じゃ C 言語 も （ ？ ） ビックリ です 。 ビット演算 の & 、 | 、 ^ 、 そして >> と << とか 、 二 進数 を 知ら ず に どう やっ て 勉強 する の ？ 無理 です よ ね 。 & と &&、| と || の 違い とか も 、 ワケ が 分から なく なっ て しまう 可能性 が 大 。 ! 演算子 で 論理 反転 さ せ て 、 && が || に なっ たり 、 その 逆だっ たり 、 とか 、 そういう の も C 言語 と 同時 入門 って 変 です よ 。 そういう こと する から 難しく なる 。 （ ２ ） メモリ の こと メモリ の こと が 分かっ て い ない 状況 で いきなり C 言語 に 入門 し たら 大変 だ と 思う 。 ポインタ が 分から ない とかいう 話 を よく 聞き ます けれども 、 それ 、 ポインタ が 問題 な の で は なく て 、 メモリ の こと が 分かっ て ない だけ の こと です 。 配列 の 勉強 とか で [ ] 記号 が 出 て くる 。 実際 、 [ ] は 演算子 な ん です よ ね 。 それと * 演算子 と 、 どちら で 書い て も 意味 は 同じ だ なんて 聞かさ れる と 、 入門 者 の 多く は 驚い て しまう と 思い ます 。 他 の 言語 に ある よう な 立派 な 配列 が C 言語 に ある わけ が あり ませ ん 。 単に 、 メモリ 上 に 連続 領域 が 確保 さ れ て いる （ あるいは 、 その よう に 想定 さ れ て いる ） 、 と いう だけ の 話 です 。 メモリ の こと が 分かれ ば 配列 も ポインタ も 直ちに 理解 出来 て しまい ます 。 全く 悩む べき ところ が あり ませ ん 。 反対 に 、 メモリ の こと が 分かっ て ない と 配列 の こと も 理解不能 。 ポインタ も ダメ 。 なのに 両者 を 絡め た 練習問題 とか が 出 て き て しまっ て 、 そう なっ たら もう 丸投げ 質問 を 知恵袋 で する しか ない でしょ 。 （ ３ ） システム の こと C 言語 単体 で 何 か を 出来る と 思っ て い たら 大 間違い です 。 出来る わけ ない です ね 。 だって 、 言語 自体 に は 入出力 の 機能 が ありません から 。 一応 、 ライブラリ 関数 に 古臭い printf だの scanf だ の といった バカ 関数 が あっ たり し ます けど 、 こんな の で まとも な プログラム なんか 作れる 筈 が ない です 。 文字 を 大きく する に は どう し たら 良い か と か は マシ な 方 かも 。 色 を 付ける に は ？ 曲 の 演奏 ？ 動画 再生 ？ そういった 質問 が 出 て 来る こと も 多々 ある わけ です が 、 だから 、 できる わけ ない でしょ 。 という こと を 知ら ず に C 言語 に 入門 し て しまう なんて …。 です から ね 、 C 言語 で そんな こと でき たら おかしいっ て 。 でも 、 出来る 。 システム を 特定 すれ ば ね 。 システム が 備え て いる 機能 を 呼び出す 。 OS の 機能 呼び出し （ システムコール 、 Windows の 場合 なら Win32 API ） です 。 C 言語 で 呼び出す こと が 出来 ます から ね 。 じゃ 、 呼び出す と し ます か 。 どういう 関数 が ある ん だろ う 。 引数 は ？ 戻り値 は ？ ここ から 大変 な こと に なり ます 。 何 千 （ いや 、 何 万 か な ） と ある 機能 呼び出し を どう やっ て 覚えれ ば 良い の ？ 説明 見 て も ワケ が 分から ない し … 。 そりゃ そう です よ 。 単に 一つ の 関数 を 呼び出し て 済む 話 で は ない の です 。 準備 処理 が あっ て 、 そして 本番 （ ？ ） の 処理 、 その後 の 処理 … と か 。 いろいろ やっ て 、 目的 の 動作 を 行わ せる こと が 出来る 。 その 流れ を 全部 分かっ て ない と 辛い ですよ。 C 言語 、 難しい … 。 いや 、 C 言語 じゃなくて 、 システム の 機能 呼び出し が 難しい ん です よ ね 。 とか 、 こんな 具合 で C 言語 そのもの と は 関係 ない 次元 で 難しいっ て 皆さん おっしゃっ てる と 思う 。 そんな こと で は 丸 １ 年 やっ て も 無理 でしょ う 。 ２ 年 やっ て も 無理 かも しれ ませ ん よ 。 と いう より も 、 その 前 に 投げ出し て しまう の が 普通 だ と 思い ます 。 なぜ なら ば 、 その 途中 段階 で は 全く 面白く ない バカ っぽい プログラム しか 出来 ない から です 。 それ じゃ 面白く ない でしょ 。 だから 続か ない の です 。 え ？ 面白いっ て ？ バカ っぽい プログラム で も 自分 で 作っ たら 面白いっ て ？ そう 思える 人 は 成功 し ます 。 そう 思える 人 のみ 、 成功 し ます 。 数 として は あまり 居 ませ ん よ 。 だって 、 面白く ない もの 。 そんな の で 面白いっ て 思える なんて 、 滅多 に 居 ませ ん から ね 。 《 備考 》 一般教養 という 意味合い で C 言語 に 入門 する 場合 、 それで 本当に C 言語 技術 を 習得 しよ う という わけ で は ない です から 、 これ は 何 か月 か 取り組ん で 雰囲気 を 体験 し て です ね 、 大雑把 な 形 で 理解 できれ ば 、 とりあえず それ だけ でも 成功 かも しれ ませ ん 。 その 程度 で あれ ば 、 C 言語 と 二 進数 とか の 同時 入門 で も 、 そんなに 難しく ない かも しれ ませ ん ね 。 
> まで は OK だ と 思い ます 。 OK じゃ ない ん じゃ ？ 5 . 75 = 101 . 11 ( 2 進数 )= 1 . 0111 * 100 ( 2 進数 ) 100 ( 2 進数 )= 2 ^( 2 )= 2 ^( 129 - 127 ) ゆえに 、 S = 1 E = 10000001 M = 01110000000000000000000 1 1 0 0 0 0 0 0101110000000000000000000 ( 2 進数 )= C 0 B 80000 ( 16 進数 ) だから 、 ④ です 。 試験 で は 、 先頭 が 全て 異なる こと に 着目 。 5 . 75 = 101 . 11 ( 2 進数 )= 1 . 0111 * 100 ( 2 進数 ) E = 10000001 さらに マイナス な ので 、 1100 ( C ) から 始まる の を 探せ ば いい 。 だから ④ です 。 
cgengoaqua さん 以下 抜粋 部 で 、 for 文 の 繰り返し 条件 の 不等号 が 逆 でし た 。 /* ← ★ ココ だ よ ★ */ と し た 部分 が 直し た ところ です 。 printf ("\ n 得点 ヒストグラム \ n \ n "); printf ( " - - - - - - - ------------------------\ n "); printf (" 0 ～ 19 % d ", a ); for ( k = 0 ; k < a ; k ++) {/* ← ★ ココ だ よ ★ */ printf ("*"); } printf ("\ n2 0 ～ 39 % d ", b ); for ( k = 0 ; k < b ; k ++){/* ← ★ ココ だ よ ★ */ printf ("*"); } printf ("\ n4 0 ～ 59 % d ", c ); for ( k = 0 ; k < c ; k ++){/* ← ★ ココ だ よ ★ */ printf ("*"); } printf ("\ n 60 ～ 79 % d ", d ); for ( k = 0 ; k < d ; k ++){/* ← ★ ココ だ よ ★ */ printf ("*"); } printf ("\ n 80 ～ 100 % d ", e ); for ( k = 0 ; k < e ; k ++){/* ← ★ ココ だ よ ★ */ printf ("*"); 
なんか 、 変 です 。 関数 の ポインタ を 渡し て も 、 引数 が 無い と 計算 し て くれ ませ ん し 、 無駄 です 。 これ は 、 平均 を 覚え て おい て 、 値 を 渡す 様 に 直し て ください 。 # include < stdio . h > # include < ma t h. h > float sd ( int , float [], float ); float ave ( float , int ); int main ( void ){ int n ; float x [ 100 ], kei = 0 , ave 1 ; printf (" データ を 入力 し て 下さい 。 \ n "); n = 0 ; while ( 1 ){ printf ("% d 件 目 -> ", n + 1 ); scanf ("% f ", & x [ n ]); if ( x [ n ] == 0 ) break ; kei = kei + x [ n ]; n ++; } printf (" 合 計 ＝ % 10 . 1 f \ n ", kei ); printf (" 件 数 ＝ % 10 d \ n ", n ); printf (" 平均値 ＝ % 10 . 1 f \ n ", ave 1 = ave ( kei , n )); printf (" 標準偏差 ＝ % 10 . 1 f \ n ", sd ( n , x , ave 1 )); return 0 ; } float ave ( float kei , int n ){ return kei / n ; } float sd ( int n , float x [], float ave ){ int i ; float sum = 0 , sd ; for ( i = 0 ; i < n ; i ++){ sum = su m + ( x [ i ] - ave )*( x [ i ] - ave ); } sd = sqrt ( sum / n ); return sd ; } 
List < T > tlist = new List < T >(); List < List < T >> ttlist = new List < List < T >>(); ttlist . Add ( tlist ); 実行 し て い ない ので 、 ビルド エラー に なっ たら ご 容赦 。 
おそらく scanf が 悪 さ を し て い ます // a 値 を キーボード から 入力 する puts (" Type a value ."); scanf ("% d ",& a ); この 部分 で 標準入力 バッファ に は 最後 の 入力 の 改行 が 残っ て しまい ます その後 , 下 から 5 行 目 の getchar (); で 残っ て い た 改行 が 読ま れる ため 入力 待ち に なら ない の でしょ う scanf の 部分 を // a 値 を キーボード から 入力 する puts (" Type a value ."); scanf ("% d %* c ",& a ); // %* c で 残っ た 改行 を 読み 捨てる に すれ ば よい と 思い ます ここ が 参考 に なり ます http:// www 9. plala . or .jp / sgwr - t / c / sec 05 . html http:// blog . unfindable .net / archives / 604 
どの 様 な 入力 に対して 、 どの よう な 結果 を 期待 し て どの 様に " うまく いか ない " の か 、 を 書く 事 。 エラー が 出る 場合 は 、 何処 で 、 どの 様 な エラー が 出る の か 、 を 書く 事 。 エラーメッセージ は 省略 せ ず に 書く 事 。 > for ( a = 0 ;( p 1 = strstr ( p 1 , search )) != NULL ; a ++){ > p 1 ++; >} > if ( a > 0 ){ > printf (" run away \ n "); >} >... if ( strstr ( p 1 , search )) printf (" run away \ n "); で いい の では ? 
「 <」 は 関係演算子 です 。 a < b と し た とき 、 a が b より 小さい とき 1 に 、 それ 以外 は 0 に 評価 さ れ ます 。 sample 関数 は 、 その 評価 結果 を float 型 に型 変換 し て 返し て いる こと に なり ます 。 なお 、 value は float 型 である に も かかわら ず 、 printf の 書式 に % d を 使っ て い ます 。 未 定義 の 動作 に なる ので 要注意 です 。 
そもそも 、 何 か よ ほど の 理由 が ある の で ない 限り 、 「 ド 素人 が １ から C言語 を 学ぶ 」 べき で は あり ませ ん 。 もっと 新しく て 学び やすい 言語 に す べき です 。 C言語 は 40年 も 前 に 、 当時 の エキスパート が 使う ため に 設計 さ れ た 言語 で あり 、 初心者 の 学び やす さ とか 、 安全性 とか は ほとんど 考え られ て い ませ ん 。 それ ゆえ 多く の 人 が つまずき ます 。 似 た よう な 系統 の 言語 なら Java や C# 、 もっと ゆるい 言語 なら Python や Ruby から 始め た ほう が いい です 。 
daichi _ 0803 _ 777 さん ググッテ 補える ” 暗記 ” レベル の 知識 など 、 ソモソモ 役に立ち ませ ん 。 意味 や 概念 を 本質的 に ” 理解 ” でき て い なけれ ば 、 ” ダメ ” です 。 ＞ c言語 で switch . while . do ~ while . for . if 文 は 完璧 に 理解 し ない と ダメ です か ？ と は いえ 、 知恵袋 に 回答 を よせ て いる 程度 の ” ナンチャッテ C言語 プログラマ ” に は 、 「 そんな もの 全部 覚え なく て も 、 行き当 たり ばったり で 、 試行錯誤 し て ソースコード を 修正 する 」 という こと しか 出来 ない 人 も 多い よう です 。 ＞ 皆さん は どう です か ？ 「 C言語 の 文法 の 全体 に 比べれ ば 、 タッタ の １ ％ に も 満た ない 部分 を 覚え ない で 、 良い 訳 が ない 」 でしょ う 。 また 、 私 の C言語 の 理解 を 下回る ” ナンチャッテ C言語 プログラマ ” は 、 納期 通り に 御 仕事 が 出来る ” プロ ” の プログラマ と は 認め られ ない でしょ う 。 何故 なら 、 C コンパイラ の エラーメッセージ を 見 て 試行錯誤 無く 修正 でき なく て 、 何 時 終わる か 予定 を 立てる こと が 出来 ない 試行錯誤 の 繰り返し の 上 で ようやく ソースコード を 修正 できる 程度 の 人 は 、 納期 に 間に合わ せる こと が でき ない から です 。 もし 、 そんな プログラマ を 許容 する 組織 が あっ たら 、 それ は 「 予定 期限 を 過ぎ たら 、 給与 を 支払わ ない から ね ！ 」 的 な 、 ブラック企業 でしょ う 。 C言語 を 中途半端 に 覚え て 、 ブラック企業 に 入り たい ？ で は 、 「 救わ れる 道 は 無い の か ？ 」 と いう と 、 ある こと は 在っ て 、 「 C言語 より 圧倒的 に 文法 が コンパクト で 、 凸凹 で 覚え 難い 複雑 さ も 無い Ruby 言語 を 覚える 」 という 方法 も 有り ます 。 ６ ５ ０ ０ 行 を 超える C言語 の 文法 を ナントナク ５ ０ ％ 位 、 つまり ３ 千 行 相 当行 を 覚え て も 役に立た ない が 、 「 Ruby 言語 なら 、 文法 が コンパクト で ４ ０ ０ 行 弱 な ので 、 全て を 覚える こと が 現実的 」 な の です 。 ＜ 補足 ＞ C言語 の 文法 は 、 解説 文 を 取り除い て も ６ ５ ０ ０ 行 以上 の 定義 が 在る もの です 。 その 中 で 、 select ion _ statement とか iter ati on_ statement に 分類 さ れ て いる if / while / for 文 等 は 、 約 ５ ０ 行 で 定義 さ れ て いる 部分 です 。 つまり 、 if / while / for 文 は 、 C言語 の 全体 の 中 の １ ％ 程度 の 部分 で 、 残り の ９ ９ ％ は 宣言 文 や 式 の 定義 など 雑多 で 凸凹 な 文法 の 部分 です 。 もし 、 C言語 の if / while / for 文 を 理解 でき ない で 居る なら 、 残り の 残り の ９ ９ ％ を 占める 凸凹 仕様 を 理解 する こと など でき ない でしょ う 。 しかも 、 C言語 の 文法 の ６ ５ ０ ０ 行 全体 を ナントナク 覚え た だけ で は 、 C コンパイラ が 出す エラーメッセージ 観 て も 、 適切 な 修正 方法 を 考え出す こと が 出来 ない でしょ う 。 また 、 Apple社 の 様に 、 社会 的 な 影響 力 も 大きな 会社 で は 、 C コンパイラ の 開発 達 と 対峙 し た こと も ある よう です が 、 C コンパイラ の 開発者 達 と 対等 な レベル で 「 C言語 の 文法 を 知っ てる 」 という 人 が 居 なけれ ば 、 喧嘩 でき て い ませ ん 。 Microsoft 社 の Visual studio の C コンパイラ を つかっ て いる 企業 の 中 でも 或 る 程度 の 大手 ・ 中堅 の 会社 に も 、 C コンパイラ の 開発者 達 と 対等 な レベル で C言語 に 詳しい 人が 居 て 、 喧嘩 の 相手 たる Microsoft 社 を 呼びつける ため に 年間 数 百 万 円 程度 の 費用 を かけ て いる もの です 。 ＜ C言語 の 文法 の 全容 ＞ ・ C/C++ 本体 の 文法 の 全容 ： 約 5000 行 この 中 で 、 if / while / for 文 の 定義 は 、 下記 の 行番号 の 当り に 記述 さ れ て いる 約 ５ ０ 行 です 。 4075 select ion _ statement ： 4077 LITERAL _ if LPAREN 4078 condition RPAREN 4079 single _ statement 4080 ( options { warnWhenFollowAmbig = false ;}: 4081 LITERAL _ else single _ statement )? 4082 {# select ion _ statement = #(#[ CSM _ IF _ STATEMENT , " CSM _ IF _ STATEMENT "], # select ion _ statement );} 4083 | 4084 LITERAL _ switch LPAREN condition RPAREN single _ statement 4085 {# select ion _ statement = #(#[ CSM _ SWITCH _ STATEMENT , " CSM _ SWITCH _ STATEMENT "], # select ion _ statement );} 4086 ; 4088 iter ati on_ statement 4090 while _ statement | do _ while _ statement | for _ statement 4091 ; http:// hg . netbeans . org / main / file / tip / cnd . modelimpl / src / org / netbeans ... ・ C/C++ プリプロセッサ の 全容 ： 約 1500 行 http :// hg . netbeans . o rg / main / file / tip / cnd . apt / src / org / netbeans / modules / cnd / apt / impl / support / aptlexer . g ・ Ruby 言語 の 文法 ： ４ ０ ０ 行 弱 http:// www . ant l r3 . org / grammar / 1160820213459 / rubyParserLexerSPGramma ... ★ C言語 の 複雑 さ を 悟る クイズ 「 a * b * c ; に 括弧 を 入れ た パターン の 内 、 有効 な 宣言 文 と 、 それ 以外 （ 代入 文 や 式 等 ） として 多重 に 解釈 できる パターン を 、 出来る だけ 沢山 列挙 し て み て ください 」 http:// detail . chiebukuro . yahoo . co.jp / qa / question _ detail / q 1414284588 ... この パズル は 、 C言語 の 文法 に 詳しく ない と 解け ない パズル です 。 でも 、 まとも な 正解 例 を ４ 例 出せ て いる の は 、 私 くらい です 。 正解 例 ＝ http :// ideone . c o m / j2 v f1 n < 見捨て られ た C コンパイラ の 例 = GCC > C言語 を 用い て いる と 、 C言語 の コンパイラ 担当 と 対立 する 局面 は 出 て くる もの です 。 C言語 の コンパイラ 担当 と 対立 する とき 、 「 俺 の 方 が C言語 の 在る べき 姿 に 詳しい 」 と 言え なけれ ば 、 勝ち 目 は 無い 。 Apple社 が GCC という C コンパイラ 担当者 たち と 対峙 し た とき 、 GCC を 見捨て て clang という C言語 コンパイラ を 造っ た そう です 。 「 GCC は 巨大 な システム で 開発 が し づらい 面 も あり 、 長年 の GCC の 開発者 の 一 人 は 「 カバ に ダンス を 踊ら せる の は あまり 楽しい こと で は ない 」 と 述べ て いる 。 アップル は Objective-C を 多用 し て いる ため 性能 を 向上 さ せる こと に 興味 を 抱い て い た が 、 通常 の GCC の 開発 から は ほとんど 進展 が 見 られ ず 、 Objective-C の 性能 を 上げる ため に は 、 GCC を アップル 版 に 分岐 さ せる か 、 新しい コンパイラ を 採用 する か を 選択 する こと に なっ た 。 そこで 、 アップル は C 99 、 Objective-C と C++ を サポート する コンパイラ を 1 から 作成 し た 。 この Clang プロジェクト は 2007年 7月 に オープンソース 化 さ れ た 。 」 
いわゆる 、 サインカーブ という ヤツ です ね 。 一応 、 回答 は 書き ます が 、 この 例 は JavaScript の 書式 な ので 、 C# へ の 翻訳 は 、 公式 ドキュメント 等 を 見 て 確認 し て 下さい 。 gameObject . GetComponent .< Rigidbody >(). velocity = Vector 3 ( 0 , Mathf .S in ( Time. time ), 1 . 0 ); まず 、 前提 として 、 この 敵 オブジェクト が RigidBody で ある 物 と し て い ます 。 そして 、 RigidBody の 速度 （ velocity ） を 指定 する 事 で 、 オブジェクト を 移動 さ せ て い ます （ こう し ない と 、 攻撃 やら 他 の オブジェクト と 衝突 でき ませ ん ので ） さて 、 上下 に 移動 する 部分 を 「 Mathf .S in ( Time. time )」 として あり ます 。 「 Mathf .S in () 」 は 、 数学 関数 の サイン です 。 その 引数 「 Time. time 」 は 、 経過 時間 です 。 つまり 、 時間 と共に サイン の 値 が 計算 さ れ 、 その 計算 結果 を 敵 オブジェクト の 上下 の 速度 に 使っ て いる 訳 です 。 これ に 、 前進 方向 の 移動 を 足せ ば 、 サインカーブ を 描い て 移動 する 事 が でき ます 。 あと は 、 前進 の 速度 や 上下 の 速度 に 係数 を 掛ける など し て 、 自分 の ゲーム に あっ た 波長 や 速度 に 調整 し て 下さい 。 参考 に なれ ば 。 
kaee _ aoiw さん 自分 で 、 作る 。 他人 に 従う の は 、 足軽 。 
chielien _ 6 c 97 b 5752 c 86 c1 9 a ff6 a 0736 f さん なんとなく 調べ て み た ん です が 以下 の よう な こと で は ない です か ？ c = 0 xABCD addi ・ ・ ・ r1 = r 0 + c : 上位 16 bit _ r1 = 0 x ?? AB sla ・ ・ ・ r1 <<= 16 _ r1 = 0 xAB 00 ori ・ ・ ・ r1 += c : 下位 16 bit _ r1 = 0 xABCD 
そもそも オブジェクト 図 に 変数 の 値 が どうこう を 書い て いる の なら それ は 粒度 が 細か すぎる と 思い ます 。 プログラム ( ソースコード ) に 書い て ある の と は 違う 視点 から みる から こそ 別 の 図 に 描く 意味 が ある ので 、 プログラム を 機械的 に 変換 する よう で は 何 の 役 に も 立た ない 、 もし それ を 設計図 面 と する の なら 逆 に メンテナンス が 面倒 な だけ の お荷物 に なる でしょ う 。 
( int / int ) は int に なり ます 。 int は 小数点 以下 を 表現 でき ませ ん 。 buy は buytotal より おそらく 小さい ので 、 ( buy / buytotal ) は 必ず ０ に 。 ０ に 何 を かけ て も ０ に なる ので 、 waru は 常に ０ 。 (^_^; static int bartotal , buytotal , buy ; を static double bartotal , buytotal , buy ; に する か 、 if ( buy > 0 && buytotal > 0 ) waru = ( buy / buytotal )* 1000 ; を if ( buytotal > 0 ) waru = (( double ) buy / buytotal )* 100 ; に すれ ば たぶん 大丈夫 だ と 思い ます 。 って 、 前 の 質問 で okamoch さん が 上記 の ヒント を 書い て い て くれ た ので 、 それで 大丈夫 だ と 思っ て い た ん です けど ね … (^_^; 
ファンクションポイント法 は 、 ソフトウエア の 見積もり において 、 外部 ファイル や 内部 ファイル の 数 と 難易度 の 高さ から 論理的 に ファンクション ポイント ( FP ) を 算出 し 、 開発 規模 を 見積もる 手法 です 。 プログラム 言語 に 依存 し ない 、 開発 する 機能 数 を 測る ため ユーザ 側 から 見 て も わかり やすい など の 利点 が ある 。 内部 モジュール 数 は プログラム 言語 や 、 設計 技法 ・ 技能 に 依存 する ため FP に に 適し ませ ん 。 
【 サンプル 】 struct WindowOfThread { WindowOfThread ( DWORD _ dwThreadId ) : hWnd ( nullptr ) , dwThreadId (_ dwThreadId ) { ( void ) EnumWindows ( EnumWindowsProc , LPARAM ( this )); } HWND hWnd ; private : DWORD dwThreadId ; bool SetWindowHandleOfThread ( HWND _ hWnd ) { if ( GetWindowThreadProcessId (_ hWnd , NULL ) == dwThreadId ) { hWnd = _ hWnd ; return true ; } else return false ; } static BOOL CALLBACK EnumWindowsProc ( HWND hWnd , LPARAM lParam ) { return ! reinterpret _ cast < WindowOfThread *>( lParam )-> SetWindowHandleOfThread ( hWnd ); } }; int main (){ const HWND hWnd = WindowOfThread ( GetCurrentThreadId ()). hWnd ; for (;;) { POINT mouse _ pos ; if ( GetCursorPos (& mouse _ pos )) { ScreenToClient ( hWnd ,& mouse _ pos ); printf (" クライアント 座標 →(% ld ,% ld )\ n ", mouse _ pos . x , mouse _ pos . y ); Sleep ( 10 ); } } return 0 ; } 【 解説 】 GetStdHandle は ファイル ハンドル を 返す もの です から ね 。 型 も HWND で は なく て HANDLE で あり 、 別物 。 それで 、 コンソール ウィンドウ の ハンドル を 得る に は どう する か という ところ が 問題 。 直接的 な やり方 が 存在 し て いる の か どうか 知り ませ ん けれども 、 単純 な 形 で やる と し ます と 上記 の サンプル の 形 が 思い 浮かび ます 。 EnumWindows によって ウィンドウ を 列挙 。 それぞれ の ウィンドウ に関して GetWindowThreadProcessId で スレッド ID を 取得 し ます 。 それ と GetCurrentThreadId で 得 た 自己 スレッド ID と が 一致 し て いる ウィンドウ を 探せ ば 良い という わけ です 。 
>> visualStudio (?) で ソフト を 作る の が 良い と 聞い た の です が 、 visual studio community は 、 商業 利用 でき ます でしょ う か ？ 個人 で なら 商用 利用 で も できる よう です 。 組織 の 場合 は エンタープライズ の 組織 の 場合 は 一定 の 条件 で 利用 できる よう です ( PC が 250 台 以上 か ユーザー が 250 人 以上 または または 年間 売上 が 100 万 米ドル 以上 ( または ほか の 通貨 の 相当 額 ) の 場合 は 利用 でき ない よう です ) エンタープライズ の 組織 で ない 場合 は 、 最大 5 人 で 利用 できる よう です 。 
抵抗器 の 抵抗 値 が 十分 大きい なら 、 流れる 電流 は 微々たる もの な ので 、 １ ０ 個 付け て も 大丈夫 だ と 思い ます 。 同時に 押し たら 、 判定 が 可能 な ポート が ちゃんと ３ 個 あれ ば 、 同時に 押し た の が 分かり ます 。 
画像 は 小さく て わかり ませ ん 。 Main メソッド は static な ので 静的 関数 として 実行 さ れる ので 問題 ない の です が 、 メソッド c は 普通 の メソッド な ので class App の インスタンス が 必要 です 。 な ので 、 private int c ( int value ){ ↓ private static int c ( int value ){ に する と 、 c も static メソッド として 普通 の C言語 の 関数 の よう に 実行 できる よう に なり ます 。 そう で なく インスタンス を 生成 する 場合 は 、 Main の 中 で 、 App app = new App (); a = app . c ( c ); の よう に 書く 必要 が あり ます 。 ついで に 本題 と は 無関係 です が 、 a = c ( b ); に なっ て い ます けれど 、 b = c ( b ); の 誤記 だ と 思い ます 。 
「 ちゃんと 奇数 が 表示 さ れる 」 方 の 動作 順序 です 。 ① i = 1 ② i < 101 なら ③、 そう じゃ なけれ ば ⑧ ③ !( i % 2 ) なら ④、 そう じゃ なけれ ば ⑤ ④ ⑥ へ ⑤ printf ("% d ", i ); ⑥ i ++ ⑦ ② へ ⑧ return 0 ; continue は ④ のところ です 。 「 偶数 が 表示 さ れ て しまい ます 」 の 方 の 動作 順序 です 。 ① i = 1 ② i < 101 なら ③、 そう じゃ なけれ ば ⑧ ③ !( i % 2 ) なら ④、 そう じゃ なけれ ば ⑤ ④ printf ("% d ", i ); ⑤ ⑥ へ ⑥ i ++ ⑦ ② へ ⑧ return 0 ; continue は ⑤ のところ です 。 ＜ continue の 仕組み について よく わかっ て い ない ため 、 詳しく 説明 し て くれる と 有り難い です ＞ for 文 で continue が 現れる と 、 for の カッコ 内 に ある ３つ 目 の パラメータ の ところ に 飛び ます 。 ご 提示 の 例 だ と i ++ のところ です よ 。 そして 、 第 ２ パラメータ の 判定 式 に 飛び 、 真 である 間 ループ が 続け られる 。 そういう 形 です 。 continue は 「 続ける 」 という 意味 。 ループ を 続ける わけ 。 途中 の 処理 は 飛ばす けど 、 でも 、 ループ 自体 は 続ける 。 break と は 違い ます から ね 。 break の 場合 は ループ を やめ て しまい ます 。 途中 の 処理 を 飛ばす っていう の は 、 continue を 含む 複文 、 つまり { と } の 区間 において 、 } のところ まで 飛ばす っていう 話 ですよ。 そう 考える と 簡単 だ と 思い ます 。 
Visual Studio Community 2015 お勧め です 。 https :// www . visualstudio . com / ja - jp / products / visual - studio - community ... 8月2日 の Anniversary Update 後 なら 、 Windows Subsystem for Linux で gcc が 使える の でしょ う か 。 MinGW や Cygwin は 選択肢 で なく なっ て ゆく の か な ？ 
コンビニ の レジ だって IT だろ う が 。 道路 の 信号 も IT 。 冷蔵庫 や 洗濯機 だって IT 。 発電所 も 。 病院 の カルテ も （ 場合 によって は 診断 も ） 。 個人商店 すら 在庫管理 に コンピュータ を 使う 時代 だ 。 テレビ だって デジタル な ん だ から コンピュータ が ない と 発信 でき ない 。 応力 計算 が でき ない と ビル も 建た ない 。 むしろ 、 IT なし で できる 事 を 数え た 方 が 早い 。 
演算子 も キーボード から 入力 さ せる よう に すれ ば 宜しい と 思い ます 
とりあえず 思い付い た 方法 を 3 通り 挙げ て み ます 。 挙動 として は B が 一番 合っ て いる と 思い ます が 、 場合 によって は 一番 難しい 方法 かも しれ ませ ん 。 A . SelectionChanged イベント SelectionChanged イベント が あり ます が 、 これ は 画面 が 切り替わっ た 後 に なっ て しまう ので ちょっと 違い ます よ ね 。 B . TabItem コントロール の カスタマイズ だ と し たら TabItem の Header に ボタン を 置く よう に し て 、 この ボタン を 押す こと によって 確認 ダイアログ の 表示 や タブ の 切り替え を おこなう よう に すれ ば いい と 思い ます 。 この とき 、 外観 が だいぶ おかしな こと に なる と 思う ので 、 ボタン の 配置 は TabItem の デフォルト スタイル を 変更 すれ ば いい と 思い ます 。 ボタン も 標準 の Button で は なく 、 Button . Tempalte に対して ControlTemplate を 指定 し た 独自 の ボタン に する と いい でしょ う 。 C . SelectedIndex プロパティ ちょっと 強引 です が 、 SelectedIndex プロパティ と データ バインド し て 無理矢理 やる 方法 も あり ます 。 手順 は 次 の 通り です 。 ( 0 . ViewModel の int SelectedIndex と View の TabControl .S electedIndex を データ バインド で 紐 付け て おく ) 1 . SelectedIndex の set アクセサ で 、 変更 時 に 変更 前 の 値 に 戻す ( 画面 が 切り替わら ない よう に する ) 2 . 確認 ダイアログ を 表示 する よう に View に 指示 を 出す ( 添付 ビヘイビア が 有用 です ) 3 . ダイアログ の コールバック を View Model で 処理 し 、 OK なら SelectedIndex を 変更 する 手順 1 と 3 で SelectedIndex を 変更 する のに 、 一方 は 変更 前 に 戻し 、 一方 は そのまま 変更 を 受け付ける よう に する の に 少し 工夫 が 必要 です 。 また 、 手順 1 で 変更 時 に 変更 前 の 値 に 戻し て いる ので 、 目 に は 見え ない として も 、 一瞬 画面 が 切り替わっ て いる こと に なり ます 。 その ため 、 切り替え 後 の 画面 の Loaded イベント など で 何 か し て いる 場合 は 影響 が 出 て しまう かも しれ ませ ん 。 手順 2 は SelectedIndex プロパティ の 変更 通知 が View に 伝わっ て から 実行 する 必要 が ある ため 、 Dispatcher . BeginInvoke など で 実行 さ せる 必要 が あり ます 。 
push _ back を 使用 し た vector へ の 追加 は 他 の 方 の ご 回答 通り です が 、 もしも CPoint 型 に 以下 の よう な コンストラクタ が 存在 し て いる の なら 、 emplace _ back を 使う べき です 。 CPoint ( double x , double y ) : x ( x ), y ( y ) {} //... { vector < CPoint > v ; v . emplace _ back ( 1 . 0 , 2.0 ) // CPoint ( 1 . 0 , 2.0 ) が 格納 さ れる } 
（ １ ） Windows API （ Win32 API ） という の は 、 今 は ほとんど 使わ れ て い ない の です か ？ 毎日 使っ て ます 。 これ でも か っていう 位 。 え ？ 個人 的 な 話 じゃなくて … です か ？ じゃ 、 使う 人が 減っ て き て いる の は 事実 として ある と 思い ます 。 「 今 は ほとんど 使わ れ て い ない 」 って 、 いや 、 そこ まで の レベル に は なっ て い ない と 思い ます けど 。 ただし 、 ある 種 の 希少 価値 が 生じ て き て いる 感じ 。 やる 人が 少ない 。 やり たく て も でき ない 。 だから 、 Win32 API を 呼ぶ よう な プログラム を 開発 する 場合 の 単価 が 高い 。 .NET は 誰 も が 出来る ので 安い 。 そういった 状況 か と 。 （ ２ ） 最近 は .NET ？ など で 作る と 聞き まし た が ・ ・ ・ 。 C++ から C# に 逃げ た 人が 多数 居る 模様 。 C++ で イヤ な 思い を し て た人 は C# で 救わ れ た 格好 じゃ ない でしょ う か 。 また 、 昔 の VB 6 . 0 を やっ て た人 とか は 、 これ は かなり 頑張っ た みたい です ね 。 VB.NET を 覚え て 、 今 まで 以上 の アプリケーション を どんどん 作っ て いる 。 .NET 、 流行っ て ます ね 。 ところで 、 もともと C++ で イヤ な 思い を し て なかっ た 人 （ ていう か 喜ん で た人 ） は C# とか 、 やら ない と 思う 。 やっ て も 良い と 思っ て た の です けれども 頼ま れ ない ん です ね 。 C# で 何 か を やっ て くれ って 全然 言わ れ ない 。 （ サンプル を C# や VB.NET で 作っ て くれ って 頼ま れる こと は あり ます けど 。 ） .NET 絡み で 頼ま れる ケース で は 、 根本 的 に C# だ と キツイ もの だっ た し ます ので 、 C++/CLI を 使っ て です ね 、 C# 用 の 切り口 は .NET 、 そして OS と の やり取り は Win32 API という 形 で 作り ます 。 こう する と 喜ば れる の です よ 。 C# で やろう と する と 無理 が 出る から こそ C++ プログラマ に 頼も う っていう 話 に なっ てる ので 、 それ に 応える に は C++/CLI が 最適 です 。 結局 、 .NET が 出る 前 って 、 無理 し て Win32 API を 使っ て た人 たち が 沢山 居 た と 思う の です よ 。 今 、 .NET が ある ので 無理 する 必要 が 殆ど 無い ん です よ ね 。 C# だけ 、 VB.NET だけ で 十分 な の です 。 C++/CLI を 登場 さ せ なきゃ なら ない よう な ケース は 稀 です 。 元 から Win32 API を 無理 なく 存分 に 使っ て た人 は 、 そりゃ 、 今 でも 存分 に 使っ てる 。 .NET など 、 使う 気 が し ない でしょ う から 。 だって 、 自分 が 直接 OS に 話しかけ られる わけ です 。 なのに .NET Framework など という もの を 間 に 挟ん で 、 伝言ゲーム 的 な こと を する なんて バカバカしい です から ね 。 とか 、 そういう 話 か と 。 
opendir , readdir , closedir あたり を 調べ ましょ う 。 https :// developer . apple . com / legacy / library / documentation / Darwin / Ref ... 
jlkhgasvybil さん 多分 、 波形 を 作り たい だけ じゃ ない ん です か 。 求める 式 を 書い て 範囲 を 決めれ ば どんな 波形 でも 書い て くれる 。 # include < stdio . h > # include < ma t h. h > int main ( void ) { ＿ ＿ ＿ FILE * fp ; ＿ ＿ ＿ double t , y ; ＿ ＿ ＿ double pi = 3.14 ; ＿ ＿ ＿ fp = fopen (" sin . csv "," w "); ＿ ＿ ＿ for ( t =- pi ; t <= pi ; t += 0 . 1 ){ ＿ ＿ ＿ ＿ ＿ y = sin ( t ); ＿ ＿ ＿ ＿ ＿ fprintf ( fp ,"% f ,% f \ n ", t , y ); ＿＿＿} ＿ ＿ ＿ fclose ( fp ); ＿ ＿ ＿ return 0 ; } 
カンマ 単独 で は 演算子 として 成り立ち ませ ん ので 、 「 そんな もの ない 」 という 答え しか つか ない です ね 。 もしかして 、 三項演算子 の こと を 言っ て い ます か ？ ( a == b )? c : d ; の よう な 。 で あれ ば 、 A ?B : C と 考え た 時 に 、 「 A が 偽 と 評価 できる なら ば C を 返し て 、 それ 以外 なら ば B を 返す よう な 式 」 と 考える こと が できる と いう だけ です 。 ちなみに C++ だ と 、 :: は スコープ の 解決 として 使わ れる 演算子 です 。 
分から ない 単語 ( 多重定義 ) は 勝手 に 解釈 せ ず に 調べ ましょ う 。 間違え て 理解 し て しまっ たり 、 理解 でき なく なっ たり する こと に なり ます 。 多重定義 ( オーバーロード ) と は 、 引数 の 型 の 異なる 同名 の 関数 を 定義 する こと です 。 int a ( int x ) { … } double a ( double x ) { ... } の よう に 同じ 名前 だ が 引数 の 型 の 異なる 関数 を 定義 する こと です 。 引数 が int で あれ ば int a ( int x ) の 方 が 実行 さ れ 、 引数 が double で あれ ば double a ( double x ) の 方 が 実行 さ れる 、 という 仕組み です 。 ここ で 、 typedef int hoge ; として 、 int a ( int x ) { ... } hoge a ( hoge x ) { ... } と する こと は でき ませ ん 、 という こと です 。 あくまで int も hoge も 名前 が 違う だけ で 同じ もの な ので 、 int a ( int x ) { ... } int a ( int x ) { ... } と 同じ 意味 に なり 、 どちら を 実行 し て 良い の か わから なく なる から です 。 
if ( key & ボタン の 定義 ) と 書い て その 下 に 処理 を 書け ば 取得 できる と 思い ます 。 同時 入力 は if 文 を 並べて 書け ば 大丈夫 で は ない でしょ う か ？ 
① は スーパースカラー の 定義 が 複数 命令 の 同時 実行 が 可能 な こと から 当然 発生 する 可能性 を 持ち ます 。 ③ の VLIW は 、 ① と 関係 し て ハザード が 発生 し ない よう に VLIW を 構築 する 必要 が ある ので 、 ” 依存 関係 に ない 複数 の 命令 を まとめ て ” の 部分 が 間違い だ と 思い ます 。 ④ は VLIW の 話 で あり 、 スーパースカラー 自体 は 、 reorder 等 実行 し て スケジューリング し ます 。 
＞ どの よう に 考える べき か 近く に 仲間 が いる と 攻撃 力 が 上がり ます すなわち 、 密集 する と 何かしら の ポテンシャル が 単体 の とき より も 上がり ます つまり 、 半径 ｒ 以内 に 他 の 〈 粒子 〉 が 存在 し ます と 、 その 粒子 の 『 ナントカ 能 』 は さらに 向上 し ます 電子 など です と 、 場 の 影響 力 は 、 半径 の 二 乗 に 反比例 し ます 。 
結構 沢山 あり ます 。 ここ なんか 、 どう です か ？ https :// paiza . io /? locale = ja - jp 
必要 ない よ ( else が 不要 な 場合 は 省略 できる よ )。 
3D の 描画 の 話 は 知ら ない 。 それ と 、 return の ない ラベル に gosub し 続ける と 良く ない こと が 起こら ない か なぁ ? ユーザー が 制御 出来 ない wparam を 毎回 読み だす の を やめ て 、 キー イベント が あっ た 時 だけ wparam を 読み込み 、 処理 し たら キー 結果 を クリア し て おけ ば いいんじゃない ? onkey gosub * handle repeat color 255 , 255 , 255 boxf color 0 , 0 , 0 pos 0 , 0 mes key key = 0 ; クリア await 20 loop stop * handle key = wparam ; ハンドル の 中 で だけ 読み出し return キー イベント の 性質 上 、 「 キー が 押さ れ て いる 」 の 検出 で は なく て 「 キー が 押さ れ た 」 の 検出 に なる から 、 キー リピート に 応じ て 反応 する こと に なり ます けれど 。 それ が 嫌 なら イベントハンドラ で は なく て getkey で ボーリング とか 。 repeat getkey w , 87 getkey s , 83 getkey d , 68 getkey a , 65 x = x - w + s y = y +d - a color 255 , 255 , 255 boxf color 0 , 0 , 0 pos 0 , 0 mes x mes y await 20 loop 
いろんな 、 やり方 が ある か と 思い ます けど 、 1 行 単位 で 読み込ん で 、 プログラム 名 だけ 取り出し て い ます 。 # include < stdio . h > # include < stdlib . h > # define MM 128 int main ( void ) { FILE * fp ; char w [MM] , Name [ 512 ][ MM ]; int i , n ; if (( fp = fopen ("./ 232 / MDFPC 201 . csv "," r "))== NULL ){ printf (" Error "); system (" pause "); } n = 0 ; while ( fgets ( w , MM , fp )!= NULL ){ sscanf ( w ,"%[^,]", Name [ n ++]); } for ( i = 0 ; i < n ; i ++){ printf ("% s \ n ", Name [ i ]); } system (" pause "); return 0 ; } 今 は ファイル 名 が 固定 さ れ て いる が 、 以下 の よう に すれ ば 実行 時 の 引数 で ファイル 名 を 与える こと が できる 。 ただ 、 クラス 別 の ファイル 名 を 書い た ファイル から 、 1 行 読ん で は 処理 を 繰り返す の が 良い か と 思い ます 。 処理 結果 も ファイル 出力 が 良い か と 思い ます 。 # include < stdio . h > # include < stdlib . h > # define MM 128 int main ( int argc , char * argv []) { FILE * fp ; char w [MM] , Name [ 512 ][ MM ]; int i , n ; if (( fp = fopen ( argv [ 1 ]," r "))== NULL ){ printf (" Open Error \ n "); system (" pause "); } n = 0 ; while ( fgets ( w , MM , fp )!= NULL ){ sscanf ( w ,"%[^,]", Name [ n ++]); } for ( i = 0 ; i < n ; i ++){ printf ("% s \ n ", Name [ i ]); } system (" pause "); return 0 ; } 
少し 前 の MS VC++ です と 、 プロジェクト 新規作成 で アプリケーション 設定 画面 において 、 「 □ Security Development Lifecycle ( SDL ) の チェック ( C )」 という オプション の チェック を 外せ ば _ CRT _ SECURE _ NO _ WARNING S を 打ち込ま なく て も 大丈夫 でし た 。 もし 、 その オプション が 新規作成 の 設定 画面 から 消え て しまっ て いる 場合 は 、 https :// msdn . microsoft . com / ja - jp / library / jj 161081 . aspx １ ． プロジェクト の [ プロパティ ページ ] ダイアログ ボックス を 開き ます 。 ２ ． [ C/C++ ] フォルダー を 選択 し ます 。 ３ ． [ 全般 ] ページ で 、 [ SDL チェック ] ドロップ ダウン リスト から オプション を 選択 し ます 。 （ SDL チェック し ない よう に 設定 し ます ） と する と よ さ そう な 気 が し ます 。 
Java … ですよ ね ？ int [] x ＝ new int [ 10 ] は 、 int 型 データ が １ ０ 個 並ん だ メモリ を x に 割り当て ます 。 Java の 配列 変数 は 参照 型 変数 （ どこ か に 存在 する データ を 参照 する 変数 ） で 、 それ 自体 は データ の 実体 を 持ち ませ ん 。 です ので 、 例えば … int ar ra y1 [] = { 1 , 2 , 3 , 4 , 5 }; int array 2 [] = ar ra y1 ; と する と 、 ar ra y1 と array 2 は 同じ メモリ を 参照 し ます 。 その ため 、 array 2 [ 0 ]= 10 ; と する と 、 ar ra y1 [ 0 ] も 10 に なり ます 。 
http:// echoes . ha k. hokkyodai . ac.jp / db / 369 / dsp 0426 . pdf ? id = 13848 
樹脂 カバー 精度 は 甘い です が 使え ます 参考 写真 上 が 「 DC プラグ 2.1mm ロング タイプ 」 です 
素数判定 の 高速 な アルゴリズム （ 数学 的 な もの ） について は ほか の 方 に 譲る として 、 プログラミング 的 な 観点 で お答え し ます 。 ループ 処理 （ for , while , do - while ） の 高速化 の 指針 として 、 ① ループ 内 で 同じ 計算 を 何 回 も し ない こと ② for 文 の 繰り返し 条件 （ この 場合 は k <= sqrt ( i )） は 毎回 評価 さ れる ので 、 できれ ば 定数 に する こと が あり ます 。 ご 質問 の プログラム で は 、 8 行 目 、 10 行 目 で sqrt ( i ) を それぞれ 呼ん で い ます が 、 これ は ８ 行 目 の for 文 に 入る 前 に 計算 し て おけ ば 良い です よ ね 。 なので ８ 行 目 に int sq = ( int ) sqrt ( i ); を 挿入 し 、 以降 の sqrt ( i ) を sq に 置き換えれ ば ①、② と も 解決 し 、 多少 速く なる と 思い ます 。 ただし 最近 の コンパイラ は 賢い ので 、 コンパイル の 際 に 自動的 に 上記 の よう な こと が 行わ れ て しまい （ 最適化 と いい ます ） 、 速く なら ない こと も 多々 あり ます 。 
PORTC = a / 0 x64 % 0 x 0 A ; この 式 が 正しい か どう か が わかる の は プログラム を 組ん だ 人 だけ です 。 だって 、 こう こう こうゆう 計算 を し たい という 説明 が ない 。 第三者 は これ で いい の か な と は 思い ます 。 ポート B は ８ ビット しか ない ので 正負 の 整数 で ある なら − １ ２ ８ 〜 １ ２ ７ の 範囲 。 それ を 計算 すれ ば 答え は いつも − １ か ０ か １ 。 これでいいのだ ろう か ？ と 疑問 に は おもう 。 だけど プログラム を 組ん だ 人 は そう しよ う と し て いる の かも しれ ない 。 非負 数 ０ 〜 ２ ５ ５ でも ０ か １ か ２ 。 なので 一言 で 式 が おかしい と は いえ ない です 。 PORTA = ((( a / 0 x 0 A ) % 0 x 0 A ) * 0 x10 ) + a % 0 x 0 A ; これ も 同じ 。 あと 、 １ ） PIC は やっ た こと ない が ANSELH は ０ セット し なく て いい い の です か ？ Note : The ANSELH register must be initialized to configure an analog channel as a digital input . Pins configured as analog inputs will read ‘ 0 ’ . と マニュアル に 書い て ある の だ けれど 。 マニュアル から 無断転載 し て 怒ら れる か な ？ ２ ） ポート B に 接続 さ れ て いる 回路 が 気 に なる 。 OPTION _ REG . NOT _ RBPU = 1 ; /* プルアップ 無効 */ と ある ので 。 
今 手元 に ある の は 、 CC-R X の 「 ユーザーズ マニュアル RX コーディング 編 」 です が ･･････ 7 . 3 . 4 低 水準 インタフェース ルーチン に 、 以下 の 関数 は ユーザー が 自作 し なけれ ば なら ない 旨 が 明記 さ れ て い ます 。 open , close , read , write , lseek , sbrk その他 、 スタートアップ で 記述 す べき 内容 など も マニュアル に 明記 さ れ て い ます ので 、 必ず 最初 に 通読 す べき です 。 RX 以外 の マイコン 、 具体 的 に は SH 、 H8 、 R8C 、 M16 C 、 M32 C など で も 同様 か と 思い ます 。 
>> programme r _ hiro さん アスキー コード だ と 思う アスキー コード 表 で 検索 し て トップ が 以下 http:// www 9. plala . or .jp / sgwr - t / c _ sub / ascii . html 
budoupan 19 さん 回答 し ます 。 ■ プログラム 例 # include < stdio . h > /* int 型 配列 を 逆順 に 並べ 替える */ void reverse ( int * a , int size ) { int * a1 = a , /* 配列 の 前 部分 を 示す ポインタ */ * a 2 = a + size - 1 ; /* 配列 の 後 部分 を 示す ポインタ */ int tmp ; while ( a1 <= a 2 ) { /* 配列 の 前 部分 と 後部 分 を 入れ替え */ tmp = * a1 ; * a1 = * a 2 ; * a 2 = tmp ; /* ポインタ を 移動 */ a1 ++, a 2 --; } } /* メイン */ int main ( void ) { int a [ 10 ]; /* 配列 */ int num = sizeof (a) / sizeof (* a ); /* 配列 の 要素 数 */ int i ; printf (" 配列 の 値 を 入力 \ n "); for ( i = 0 ; i < num ; i ++) { printf (" a [% d ] = ", i ); scanf ("% d ", & a [ i ]); } /* 配列 を 逆順 に 並べ 替える */ reverse ( a , num ); printf (" 逆順 に し た 配列 を 表示 \ n "); for ( i = 0 ; i < num ; i ++) { printf (" a [% d ] = % d \ n ", i , a [ i ]); } return 0 ; } ■ 実行 例 配列 の 値 を 入力 [ 0 ] = 1 [ 1 ] = 2 [ 2 ] = 3 [ 3 ] = 4 [ 4 ] = 5 [ 5 ] = 6 [ 6 ] = 7 [ 7 ] = 8 [ 8 ] = 9 [ 9 ] = 10 逆順 に し た 配列 を 表示 [ 0 ] = 10 [ 1 ] = 9 [ 2 ] = 8 [ 3 ] = 7 [ 4 ] = 6 [ 5 ] = 5 [ 6 ] = 4 [ 7 ] = 3 [ 8 ] = 2 [ 9 ] = 1 
TC に 入っ て いる 日本 の 銀行 銀行 名 （ 旧 銀行 名 も 含 ） と 同じ 銀行 なら 、 既に 買い取り を 止め て いる 銀行 で も 換金 可能 です 。 又 、 Travelex は 下記 の TC に 限り 換金 可能 です 。 Travelex http:// www . tra vel ex. co.jp / JP / For - Individuals / Products - and - Services /... ※ みずほ銀行 、 三菱東京UFJ銀行 、 三井住友銀行 で は 自 行 発行 以外 の TC の 買い取り を 止め て い ます 。 
二 番目 の IF の 後 の = は 不要 です 。 = IF ( C1 ="", "", IF ( A1 + B 1 < D1 , F1 , 0 )) 
プロセス は 処理 手続き です ので プログラミング に 重点 を 置い た 開発 手法 と 考え ます 。 一方 、 データ は データ に 重点 を 置い た 開発 手法 と 考え ます 。 平たく 言え ば プロセス は データ の 登録 から 結果 まで プロセス を 繋げ て い ます が 、 データ は 中心 に データベース を 置い て データ を 登録 する システム と データ を 使っ て 何らかの 結果 を 出す システム を 分離 する 手法 と なっ て いる と 考え ます 。 どちら に し て も 最近 の システム 作り は リレーショナル データベース を 使う 場合 が 多い ので 、 プログラム と データ が 完全 に 分離 し て いる ので 、 結果的 に は データ 中心 アプローチ に 近い 方法 に システム 作り が 変化 し て いる と 考え ます 。 
> gorygory 02111 さん 作者 が 使い方 を 決め てる ので 作者 提供 の 文書 を 読む の が 良い よ 本家 の サイト に 文書 ある でしょ 関数 の マニュアル も 見れる けど 見かた 知っ てる ？ ソース も 表示 可能 な ので そこら を 利用 すれ ば 使い方 わかる と 思う けど R は 非常 に 使い かた 調べ やすい 環境 な ので ちゃんと 調べ ない と いか ん よ 
■ １ プログラム を 学ぶ と 世界中 どこ でも ネット が あれ ば 仕事 が できる 又 なぜ ？ たぶん ほとんど の 人 は 、 プログラミング が 出来る だけ で は 「 世界中 どこ で も～ 仕事 が できる 」 よう に は なら ない でしょ う 。 なぜなら 、 「 プログラミング が 出来る 」 という の は 、 「 日本語 が 使える 」 「 絵 が 描ける 」 「 楽器 が 弾ける 」 という の と 似 て い て 、 それ が 出来る から と 言っ て 、 それ で 仕事 が 出来る か どう か は 、 また 別 の 話 だ から です 。 ■ ２ 好き な 場所 で 、 パソコン 一つ で 本当に 生き て いける 、 ごく 一部の人 ？ はい 。 ■ ３ もし 本当 で あれ ば 、 皆 やっ て いる と おもい ます が ？？？ だ から ほとんど の 人が やっ て い ませ ん 。 ■ ４ そ も そお プログラミング と は どう ゆう もの でしょ う か ？ 似 た 質問 と 回答 が あり ます ので 参考 に なさっ て ください 。 http:// detail . chiebukuro . yahoo . co.jp / qa / question _ detail / q 1498092824 ■ ５ 言語 を 使っ て 、 パソコン を 動かす の です か ？ 狭義 に は 、 その 通り です 。 ■ ６ どの よう な 人 が 向い て い ます か ？ プログラミング を 「 楽しい 」 と 感じ て 、 やり 続け て いる 人 です 。 逆 に 、 プログラミング が キツ い 、 難しい と 感じ て しまう 人 は 向い て い ませ ん 。 また 、 下記 「 知恵 ノート 」 の よう な 質問 を する 人 も 向い て い ませ ん 。 http:// note . chiebukuro . yahoo . co.jp / detail / n 197358 ■ ７ じっと し て い られ ない 人 は 向い て い ませ ん か ？ そう で も ない と 思い ます 。 ■ ８ 英語 が できる と 有利 に なり ます か ？ はい 。 プログラミング や コンピュータ に関する 事 は 米国 で 発展 し て き た ので 、 使う 用語 は ほぼ 英単語 です 。 英語 を 知っ て いる と 、 そうした 用語 の 意味 を 素早く 推測 出来る ので 、 学習 効率 は 上がり ます 。 スペル ミス を 繰り返し たり 、 単数形 ／ 複数形 で 惑わさ れ たり し て いる と 学習 効率 が 低く なり ます 。 ■ ９ 自営 で 生き て いけ ます か ？ 分かり ませ ん 。 「 日本語 が 使える 」 「 絵 が 描ける 」 「 楽器 が 弾ける 」 から と 言っ て 、 自営 で 生き て いける か どう か は 、 また 別 の 話 だ から です 。 ■ 10 TECH CAMP 研修 という 学校 について 教え て 下さい 「 TECH :: CAMP 研修 」 は 、 企業 向け の プログラミン グ・キャンプ・サービス です 。 つまり 、 企業 で 採用 予定 の 新人 さん や 、 すでに 企業 で 働い て いる 人達 の 研修 の ため に 供 さ れ て いる サービス で あり 、 個人 向け で は あり ませ ん 。 （ 最短 ２ 週間 ・ 16 万 円 、 助成金 制度 有り ） 同社 の 個人 向け サービス に は 「 TECH :: CAMP 」 が あり ます 。 （ １ ヶ月 コース 社会人 12 万 8000円 、 学生 6 万 4000円 ） 参加 条件 は 、 ・ １ ヶ月 コース で は 期間 内 に 100 時間 以上 の 学習 時間 が 確保 できる こと ・ Mac 持参 （ 月額 5 千 円 ＋ 税 の レンタル 有り ） ・ キャンプ 終了 後 も 継続的 に 学習 を 続け て いく 覚悟 を 持つ こと だ そう です 。 なお 、 「 TECH :: CAMP に関する 質問 に なん でも お答え 」 する チャット ・ サービス が 公式 に 用意 さ れ て いる ので 、 そこ で 詳しい 話 が 聞ける と 思い ます 。 https :// tech - camp . in / training 参考 https :// blog . codecamp .jp / program ming _ camp http:// shiroku . ma / visit / 8591 / 05 / 10 / 
/* akakakakqaka さん 効率 は ともかく 、 分かり やす さ 重視 で … (^_^; ----- 実行 結果 ----- 200 以下 の 三つ子素数 の 組 は 次 の 通り : 三つ子素数 { 5 , 7 , 11 } 三つ子素数 { 7 , 11 , 13 } 三つ子素数 { 11 , 13 , 17 } 三つ子素数 { 13 , 17 , 19 } 三つ子素数 { 17 , 19 , 23 } 三つ子素数 { 37 , 41 , 43 } 三つ子素数 { 41 , 43 , 47 } 三つ子素数 { 67 , 71 , 73 } 三つ子素数 { 97 , 101 , 103 } 三つ子素数 { 101 , 103 , 107 } 三つ子素数 { 103 , 107 , 109 } 三つ子素数 { 107 , 109 , 113 } 三つ子素数 { 191 , 193 , 197 } 三つ子素数 { 193 , 197 , 199 } */ # include < stdio . h > # define NUM 200 int isPrime ( int n ){ int i ; if ( n < 2 ){ return 0 ; } if ( n == 2 ){ return 0 ; } if ( n % 2 == 0 ){ return 0 ; } for ( i = 3 ; i * i <= n ; i += 2 ){ if ( n % i == 0 ) return 0 ; } return 1 ; } int main () { int i ; printf (" 200 以下 の 三つ子素数 の 組 は 次 の 通り :\ n "); for ( i = 5 ; i <= NUM - 6 ; i += 2 ){ if ( isPrime ( i ) && isPrime ( i + 2 ) && isPrime ( i + 6 )){ printf (" 三つ子素数 { % d , % d , % d }\ n ", i , i + 2 , i + 6 ); } else if ( isPrime ( i ) && isPrime ( i + 4 ) && isPrime ( i + 6 )){ printf (" 三つ子素数 { % d , % d , % d }\ n ", i , i + 4 , i + 6 ); } } return 0 ; } 
カテゴリ マスター > buynnnmmm 1 さん 答え に なっ て ない から カテゴリ マスター （笑） くん 論点 ずらさ ない と 答え られ ない ガイジ な の か なぁ ？？？ 
> kyarottokun さん 2016 / 7 / 2818 : 05 : 41 > I 2 I ID て なん です か ？ 前後 の 文脈 に より ます 。 
# include < stdio . h > # define MM 100 void Sort ( int *, int ); void Show ( int *, int , int ); int main ( void ) { int i , n , a [MM] ; printf (" Input integers :\ n "); for ( n = 0 ; n < MM ; n ++){ scanf ("% d ",& a [ n ]); if ( a [ n ]== 0 ) break ; } Show ( a , n , 0 ); Sort ( a , n ); Show ( a , n , 1 ); return 0 ; } void Sort ( int * a , int m ) { int i , j , t ; for ( i = 0 ; i < m-1 ; i ++){ for ( j = i + 1 ; j < m ; j ++){ if ( a [ i ]> a [ j ]){ t = a [ j ]; a [ j ]= a [ i ]; a [ i ]= t ; }}} } void Show ( int * a , int m , int s ) { char * h []={" Before sorting :"," After sorting :"}; int i ; printf ("\ n % s % d ", h [ s ], a [ 0 ]); for ( i = 1 ; i < m ; i ++) printf (",% d ", a [ i ]); printf ("\ n "); } 
これ だけ だ と エラー 場所 が 特定 でき ない ので 、 AVIFileOpen , AVIFileGetStream の ２つ を 実行 し て 、 何 が エラー 原因 な の か 見 て み て は ？ 
thegreat さん 、 こんな の どう ？ //【 １ 次 遅れ 】 t = linspace ( 0 , 0 . 12 , 100 ); // ｔ 0 ～ 0 . 12 秒 を 100 分割 s = poly ( 0 ,' s '); // 多項式 の 変数 s を 定義 G = 4 /( 1 + 0 . 02 * s ); // 1 次 遅れ 系 ・ 直列 接続 例 の 伝達関数 sys = syslin (' c ', G ); // 連続 時間 線形 システム へ 、 関数 G を 登録 y = csim (' step ', t , sys ); // sys へ ステップ 入力 ( t 秒 ) xset (" window ", 0 ); clf (); xtitle (' G ( s )= 4 /( 1 + 0 . 02 s )',' Time ( sec )',' Step Respons ') B = get (' current _ axes '); // 現在 の 軸 情報 を 変数 B に 代入 する 。 title = B . title ; title . font _ size = 4 ; // タイトル の フォント サイズ xset (" wdim ", 600 , 400 ); // 画面 の 大き さ xset (' thickness ', 2 ); plot 2d ( t , y , 1 ); // 黒色 xset (' thickness ', 1 ); xgrid () // 黒色 の グリッド 
リクエスト を いただき ありがとう ござい ます 。 C++ の 項目 が 大体 終わっ た と の こと で 、 早い です ね 。 これ は 素晴らしい と 思い ます 。 さて 、 「 ほか に 覚える 事 って あり ます か ？ 」 と の こと で 、 「 ほか に 」 と いう と 何 の 他 に … か な 。 これ まで に 差し上げ た 回答 の 中 で 既に 申し上げ て い ます けれども 、 機械語 が 何より 重要 。 機械語 を 知ら ない という の は あり 得 ない 。 で 、 機械語 が 分かる と 、 とりあえず リバースエンジニアリング の 勉強 が 始め られる かも しれ れ ない 。 という くらい の もの です 。 あと 、 英語 。 英語 について も 、 もう お 話して た かも しれ ませ ん が 、 資料 は すべて 英語 です 。 日本語 の 資料 に 価値 が ある こと は 稀 です 。 な ので 、 英語 の 資料 を 読み 進め なけれ ば なり ませ ん 。 なお 、 英会話 じゃ ない です 。 資料 が 読めれ ば 良い の です よ 。 あまり 有意義 な 回答 に なっ て い ない かも しれ ませ ん が 、 いずれ に しろ 頑張っ て ください ね 。 
4つ の タイヤ が つい た もの に なっ て し まし ます が http:// www . zmp . co.jp / products / robocar - 110 ? lang = jp で 様々 な センサー や 通信 方法 に 対応 し た ラジコン カー を 買う こと が でき ます よ 少し だけ お金 が かかり ます が あなた の 要求 する 条件 に 一致 する 製品 として は かなり 安い もの だ と 思い ます 実車 1 / 10 スケールロボットカー RoboCar 1 / 10 2016 RoboCar 1 / 10 2016 一般 80 万 円 （ 税別 ） アカデミック 68 万 円 （ 税別 ） RoboCar 1 / 10 2016 前後 レーザレンジセンサセット 一般 104 万 円 （ 税別 ） アカデミック 92 万 円 （ 税別 ） 
> ID 非公開 さん *** お勧め の 手法 ( 前 処理 を 文字列 操作 が 楽 な ツール で やっ て から 読み込む 一番 簡単 な の は 前 処理 を 他 の 文字列 操作 が 楽 な ツール で やる こと Windows なら cygwin とか を 入れれ ば grep とか Awk を 簡単 に 使え ます Ruby とか Python , Perl など の ツール を 入れ て も 良い grep なら grep DEB , 元 データ . csv で いけ そう な 気 は する もっと 真面目 に マッチ 部分 の 条件 を 正規表現 使っ て 書け ば 2 番目 の , の 前 が DEB なら とか 簡単 だ よ *** あまり お勧め し ない 手法 1 読み込ん で から 正規表現 マッチ ライブラリ を 利用 し て そういう データ か どう か 判別 し て 読み込む *** あまり お勧め し ない 手法 2 , で 区切っ て 二 番目 の 文字列 を 調べ て 判別 処理 する 
アニメーション を もう 一つ 用意 し て 、 そこで X 座標 の 位置 を 拡大 量 の 半分 だけ 減らす 。 サンプル コード いる ？ 
> kyarottokun さん 2016 / 7 / 2818 : 16 : 45 > I 2 I ID って 何 です か ？ 前後 の 文脈 に より ます 。 
まず 最初 に 。 ラムダ式 と stream api は 異なる もの です 。 確か に stream api は ラムダ式 を 前提 と し た 記述 方法 で は あり ます が 、 ラムダ式 そのもの は stream api を 使わ なく て も 記述 でき ます 。 その ため 、 stream api を もっ て ラムダ式 と 書く の は 根本 で 間違っ て い ます 。 そして parallel クエリ は stream api の 特徴 で あっ て ラムダ式 と は 無関係 です 。 ラムダ式 の 本質 は 、 メソッド を 式 として 扱う こと に あり ます 。 Java の 場合 は interface と デフォルト メソッド という 形 で 実現 し て い ます 。 記述 さ れ た if 文 を ラムダ式 に 変える の で あれ ば 、 if ( 5 < num ) という 条件 を 判断 し て boolean を 返す メソッド を 作成 すれ ば いい でしょ う 。 ようは boolean p ( int n ){ return 5 < n ; } という メソッド です 。 int を 受け取り boolean を 返す interface は IntPredicate です ので 、 これ を 使っ て ラムダ 表記 する と IntPredicate p = n -> n < 5 ; と なり ます 。 以上 より 、 ラムダ式 表記 する なら IntPredicate p = n -> n < 5 ; int num = 0 ; if ( p . test ( num )){ return ; } と なり ます 。 元 の コード と 比べる と 冗長 に なっ て いる よう に 思わ れる かも 知れ ませ ん し 、 メリット も 感じ られ ない かも しれ ませ ん ね 。 しかし 、 実は 大きな メリット が あり ます 。 たとえば 、 現在 の 条件 は n < 5 です が 、 これ が n > 0 に 変わっ た 場合 は どう し ます か 。 プログラム 中 から if 文 を 探し出し て 、 その ロジック を 修正 し なけれ ば なり ませ ん よ ね 。 では 、 ラムダ式 の 場合 は どうでしょう か 。 コード 先頭 の IntPredicate p = n -> n < 5 ; を IntPredicaet p = n -> n > 0 ; と 書き換える だけ で 修正 でき ます 。 今回 の ケース は 単純 な ロジック でし た ので メリット は 薄い です が 、 複雑 な ビジネスロジック で あっ た 場合 、 インターフェース を 切り替える だけ で コード 細部 を 修正 し なく て 済む ラムダ式 は 、 大きな メリット を 持っ て い ます 。 
そういう 場合 に は タイマー （ System . Windows . Forms . Timer ） の 使用 は おすすめ でき ませ ん 。 なぜ か と いう と 、 タイマー が 実行 さ れる スレッド は 、 Form を 処理 する スレッド と 同じ で ある ため 、 タイマー で 重い 処理 を 実行 する と 、 フォーム の 更新 処理 が 滞っ て しまう から です 。 な ので 、 重い 処理 は 別 スレッド を 使い ましょ う 。 .net で は 、 きわめて 簡単 に マルチ スレッド 処理 を 利用 でき ます 。 使用 する の は Task クラス （ System . Threading . Tasks 名前空間 ） に なり ます 。 使い方 は 簡単 で 、 Task . Factory .S tartNew (() => { // ここ に 重い 処理 を 書く }); の よう に 使い ます 。 以下 の プログラム 例 で は 、 タイマー と Task クラス を 使用 し て 同じ よう な 処理 （ Sleep () で 処理 を 中断 する ） を し て い ます 。 button 1 を クリック し て フォーム を 移動 さ せる と 、 カクカク し て うまく 動か ない の が 分かり ます 。 これ は Form を 処理 する スレッド の 処理 が Sleep によって 滞る ため です 。 対し て bu t to n2 を クリック し た 場合 、 フォーム を 移動 さ せ て も スムーズ に 移動 でき ます 。 これ によって マルチ スレッド 処理 が でき て いる こと が 分かり ます 。 プログラム 例 ： using System ; using System . Windows . Forms ; using System . Threading . Thread ; using System . Threading . Tasks ; name space WindowsFormsApplication 1 { public partial class Form 1 : Form { Timer tm ; // UI タイマー public Form 1 () { InitializeComponent (); tm = new Timer (); tm . Interval = 1000 ; tm . Tick += ( sender , e ) => { // button 1 を 押し た とき の 処理 Sleep ( 1000 ); }; } // UI タイマー を 使う private void button 1 _ Click ( object sender , EventArgs e ) { tm .S tart (); } // Task を 使う private void bu t to n2 _ Click ( object sender , EventArgs e ) { Task . Factory .S tartNew (() => { // bu t to n2 を 押し た とき の 処理 Sleep ( 10000 ); }); } } } 
AVR は やっ た こと ない です 。 それ な ので 質問者 さん の 書き方 が 正しい と し て い ます 。 int main ( void ) { ____ DDRB = 0 b 00000111 ; ____ PORTB = 0 b 00000000 ; // 初期化 ____ int i ; ____ PORTB = _ BV ( PB 0 );// PB 0 のみ High ____ shift _ SCK (); ____ delay _ us ( 10 );// 10 マイクロ セコンド の つもり 。 正しい 書き方 に し て ください 。 ____ shift _ RCK (); ____ delay ( 300 );// 300m S の Delay の つもり 。 正しい 書き方 に し て ください 。 ____ PORTB &= ~_ BV ( PB 0 ); // PB 0 だけ を LOW ____ for ( i = 0 ; i < 7 ; i ++) ____{ ________ shift _ SCK (); ________ delay _ us ( 10 );// 10 マイクロ セコンド の つもり 。 正しい 書き方 に し て ください 。 ________ shift _ RCK (); ________ delay ( 300 ); ____} ____ while ( 1 ) ____{ ____} } その後 どう し たい か 質問 に 書い て ない ので 。 74 HC 595 の リセット は リセット が かかる よう に する 。 アウトプットエネーブル も 制御 し た ほう が 将来 の ため 良い でしょ う 。 「 注意 点 」 １ ． void shift _ SCK ( void ){ PORTB = _ BV ( PB 1 ); // PB 1 だけ HIGH PORTB &= ~_ BV ( PB 1 ); // PB 1 だけ を LOW } マイコン の スピード と コンパイラー の 吐く アッセン ブリ により これ だ と PB 1 の パルス が 短く なる 恐れ が ある の です が いい の でしょ う か ？ プロ で あれ ば チェック する ところ です 。 ２ ． for ( i = 0 ; i < 8 ; i ++) { PORTB = _ BV ( PB 0 ); shift _ SCK (); } この ループ だ と シフト クロック が ものすごい スピード （ 定量 的 で なく て 申し訳ない ） で 出る が 74 HC 595 が 動作 する か 検討 する 余地 あり 。 プロ で あれ ば シンクロ スコープ を 持ち だして チェック する ところ です 。 マイクロ セコンド 単位 の ディレイ を 入れ た ほう が よ さ そう 。 動く か どう か わから ない ので 参考 程度 。 
こんにちは 先頭 列 の 検索 サンプル です 。 private void Form 1 _ Shown ( object sender , EventArgs e ) { button 1 . Text = " 検索 "; listView 1 . View = View . Details ; listView 1 . Columns . Add (" 名前 ", 100 ); listView 1 . Columns . Add (" 住所 ", 100 ); string [][] s1 = new string [][] { new string [] { " 伊藤 "," 東京 " }, new string [] { " 佐藤 "," 神奈川 "}, new string [] { " 田中 "," 千葉 "} }; for ( int i = 0 ; i < s1 . Length ; i ++) { listView 1 . Items . Add ( new ListViewItem ( s1 [ i ])); } } private void button 1 _ Click ( object sender , EventArgs e ) { List < string > strlist = new List < string >(); strlist . Clear (); foreach ( ListViewItem itm in listView 1 . Items ) { strlist . Add ( itm . Text ); } foreach ( string str in strlist ) { if ( str . Contains ( textBox 1 . Text )) { Message Box .S how (( strlist . IndexOf ( str )+ 1 ). ToString ()+" 行 目 です "); } } } 列 を 全て 検索 する に は 条件文 （ if ) で 追加 検索 し て ください 。 
こんばんは ＞ Form 1 の ListView を 読み取っ て プロパティ を 使い ます 。 こんな 感じ です 。 public string ms g1 { get { return this ._ ms g1 ; } } 項目 を 選択 し て ボタン を 押し ます 。 単純 な サンプル です class Form 1 側 private void Form 1 _ Shown ( object sender , EventArgs e ) { // アイテム の 作成 listView 1 . View = View . Details ; ListViewItem item x1 = new ListViewItem (); ListViewItem itemx 2 = new ListViewItem (); item x1 . Text = " 001 "; item x1 .S ubItems . Add (" 東京都 "); item x1 .S ubItems . Add (" 田中 "); listView 1 . Items . Add ( item x1 ); itemx 2 . Text = " 002 "; itemx 2 .S ubItems . Add (" 千葉県 "); itemx 2 .S ubItems . Add (" 佐藤 "); listView 1 . Items . Add ( itemx 2 ); } private void button 1 _ Click ( object sender , EventArgs e ) { // 項目 が １つ も 選択 さ れ て い ない 場合 if ( listView 1 .S electedItems . Count == 0 ) // 処理 を 抜ける return ; ListViewItem itemx = new ListViewItem (); // 1番 目 に 選択 さ れれ いる アイテム を itemx に 格納 itemx = listView 1 .S electedItems [ 0 ]; string txt 1 = itemx . Text ; string tx t2 = itemx .S ubItems [ 1 ]. Text ; string tx t3 = itemx .S ubItems [ 2 ]. Text ; Form 2 f2 = new Form 2 (); f2 .S how (); // class Form 2 に 値 を 渡す f2 . itm ( txt 1 , tx t2 , tx t3 ); } class Form 2 側 string _ ms g1 ; string _ ms g2 ; string _ ms g3 ; private void Form 2 _ Shown ( object sender , EventArgs e ) { ListViewItem itemx = new ListViewItem (); itemx . Text = ms g1 ; // アイテム の 追加 itemx .S ubItems . Add ( ms g2 ); itemx .S ubItems . Add ( ms g3 ); listView 1 . Items . Add ( itemx ); } public void itm ( string st r1 , string st r2 , string st r3 ) { // class Form 1 から 値 を 受け取る _ ms g1 = st r1 ; _ ms g2 = st r2 ; _ ms g3 = st r3 ; } public string ms g1 { get { return this ._ ms g1 ; } } public string ms g2 { get { return this ._ ms g2 ; } } public string ms g3 { get { return this ._ ms g3 ; } } 
どちら も 型 の ポインタ を 定義 する 書き方 で 、 機能 的 に 違い は あり ませ ん 。 C/C++ どちら の 言語 も 、 どちら の 表現 で も 書け ます が 、 C言語 の 場合 は [ 型名 ] *[ 変数 名 ];、 C++ の 場合 は [ 型名 ]* [ 変数 名 ]; で 書く こと が 多い よう です 。 つまり もともと は 前者 の 書き方 でし た 。 後者 の よう に なっ た の は 、 * も 含め 型名 と みなす 、 という こと の よう です 。 ただし int * p , q ; と 書く 場合 、 p は int * 型 です が 、 q は int 型 です ので 注意 が 必要 です 。 
// ダメ な 例 private void Form 1 _ Load ( object sender , EventArgs e ) { var timer = new System . Timers . Timer (); timer . Interval += 1000 . 0 ; timer . Elapsed += ( s , ev ) => listBox 1 . Items . Clear (); timer .S tart (); } ↑ System . Timers . Timer は 、 Elapsed イベント を 別 スレッド で 実行 し ます 。 これ です と 、 UI に対する 操作 が 別 スレッド で 実行 さ れ て しまう ため 、 例外 が 発生 し ます 。 // 大丈夫 な 例 1 private void Form 1 _ Load ( object sender , EventArgs e ) { var timer = new System . Timers . Timer (); timer . Interval += 1000 . 0 ; timer . Elapsed += ( s , ev ) => listBox 1 . Invoke (( Action )(() => listBox 1 . Items . Clear ())); timer .S tart (); } ↑ Elapsed イベント が 別 スレッド な ので 、 Control . Invoke メソッド により UI スレッド 上 で 実行 する よう に 依頼 し て い ます 。 // 大丈夫 な 例 2 private void Form 1 _ Load ( object sender , EventArgs e ) { var timer = new System . Timers . Timer (); timer . Interval += 1000 . 0 ; timer . Elapsed += ( s , ev ) => listBox 1 . Items . Clear (); timer .S ynchronizingObject = this ; timer .S tart (); } ↑ Timer .S ynchronizingObject に Form を 設定 する こと により 、 Timer の Elapsed イベント が UI スレッド 上 で 発生 する よう に なり ます 。 
何 が 問題 な の か わかり ませ ん が 、 その よう に キーボード を 叩く とか 、 ファイル に 記述 し て おけ ば よい の で は ない です か ? C で は 処理系 毎 に INT _ MAX は 違う 可能性 が あり ます が 。 int が 16 bit の C 処理系 で あれ ば 、 普通 は # include < stdio . h > int main ( void ){ int n ; scanf ("% d ",& n ); return 0 ; } として 、 キーボード から 32767 と 入力 すれ ば INT _ MAX に 相当 する 値 を 入力 出来る でしょ う 。 何なら 、 # include < stdio . h > # include < limits . h > int main ( void ){ int n ; printf (" INT _ MAX =% d \ n ", INT _ MAX ); scanf ("% d ",& n ); return 0 ; } と すれ ば 、 見 た まま を 入力 すれ ば いい ので 楽 です 。 
if ( s 6 == s 6 ) // リミット が 押さ れ たら Y モーター 停止 これ は 誤記 ？ if X の 処理 else Y の 処理 なんか やっ て たら おかしい でしょ ？ else 外し て それぞれ 単独 で if 文 完結 さ せる こと 
2008年 2月 は 29日 で 2009年 2月 は 28日 とか そんな ん じゃ ない の ？ 
マイコン の よう に ソフト も ハード も 自分 が やる よう な システム で は まず ハード を 確実 な もの に し ない と ハード が 悪い の か ソフト が 悪い の か わから なく なり ます 。 複雑 な もの の 開発 時 で あれ ば ソフト の 力 を 借りて ハード の 動作 を チェック する こと は ある がそ の 場合 は ソフト の 影響 を できるだけ 排除 する ため 極力 簡単 な もの に し ます 。 １ ） スイッチ は 押し た とき 、 ” H " か ” L " か はっきり 質問 に かく 。 スイッチ 回路 は 押し た とき ” L " に なる 回路 なら ば プルアップ抵抗 が 要り ます 。 これ が ないと ” H " レベル が 確定 せ ず プログラム が 正常 に 動き ませ ん 。 Arduino は ピン ごと に プルアップイネーブル に でき た と 思う 。 ２ ） モータ ２ が 回転 し ない と の こと です が プログラム 上 は 回転 する はず です 。 モータ １ と ２ で 回路 が 同じか チェック する 。 回転 方向 は 質問 に 回路 の こと が 書い て ない ので わかり ませ ん 。 以下 の プログラム が ソフト の 力 を 借り た ハード の 動作 チェック の 例 と なり ます 。 極力 簡単 に し て い ます 。 // int val = 0 ; void setup () ｛ pinMode ( 2 , OUTPUT ); // モーター 1 pinMode ( 3 , OUTPUT ); pinMode ( 4 , OUTPUT ); // モーター 2 pinMode ( 5 , OUTPUT ); pinMode ( 6 , OUTPUT ); // モーター 3 pinMode ( 7 , OUTPUT ); pinMode ( 8 , INPUT _ PULLUP ); // リミット 1 pinMode ( 9 , INPUT _ PULLUP ); // リミット 2 pinMode ( 10 , INPUT _ PULLUP ); // リミット 3 }________// 質問 の プログラム に ない よう です が ？ digital Write ( 2 , HIGH ); digital Write ( 3 , LOW ); digital Write ( 4 , LOW ); digital Write ( 5 , HIGH ); void loop () ｛ } あと 、 プログラム の デバッグ は 一 歩 一 歩 すすめる ほう が 結果的 に は 早く できる 。 この 場合 は モータ ２ が 回ら ない こと を 最初 に 解決 する 。 次に スイッチ の 論理 を 解決 する 。 で 上 の よう な 案 を 提案 し まし た 。 以上 、 お 役 に たてれ ば 嬉しい です 。 
まず 、 Visual Studio 2015 は 、 おまかせ で インストール し た だけ で は C/C++ は 使え ませ ん が 、 そこ は いい です か ? インストール 時 に C/C++ を 追加 し なかっ た 場合 は 、 vs _ community . exe を 再度 実行 し て 追加 する こと が でき ます 。 で 、 その プログラム を 見せ て ほしい の です が 、 黒い 画面 が 開い て 白い 文字 が ずらずら 出る タイプ の プログラム ( コンソールアプリケーション ) か 、 綺麗 な 窓 が 開く タイプ の プログラム ( GUI アプリケーション ) か 、 どっち です か ? それ によって 、 新規 プロジェクト 作成 時 の テンプレート を 適切 に 選ぶ 必要 が あり ます 。 
public static string henshin ( string message ) { if ( message . contains (" 好き ")) { return " 寝ぼけ た こと を 抜かす な "; } else if ( message . contains (" 嫌い ")) { return " わらわ は ピーマン が 嫌い じゃ "; } else { return $"「{ message } と 聞こえ た よう な 気 が し た 」"; } return ""; } ケータイ から な ので タイプミス 、 スペル ミス など が ある かも しれ ませ ん が そこ は 修正 し て 下さい 
budoupan 19 さん 次 の よう に なり ます 。 繰り返し 文 に は while を 使用 し まし た 。 # include < stdio . h > int main ( void ) { int n = 0 , /* 自然数 */ a ; /* 階乗 */ printf (" n = "); scanf ("% d ", & n ); a = n ; while ( n > 1 ) { n --; a *= n ; } printf (" 階乗 = % d \ n ", a ); return 0 ; } おそらく 次 は 、 繰り返し を 使わ ず 再帰 関数 を 使え 、 に なり ます ね 。 この パターン は 。 
> kusuna _ kithune さん 配布 元 に たいてい の 場合 どういう 手順 で やれ ば コンパイル できる か っていう 説明書 が ついてる ケース が 多い よ 本家 の Documents とか ( 本家 と Github が 別れ てる ケース も 多い ) 有名 な ソフト なら バイナリ も 配布 さ れ てる こと 多い し そっち を 使う とか C# の オープンソース バージョン も ある ので そっち で コンパイル する 手順 を 試す とか VisualC # なら プロジェクト の 種類 を 色々 試し て みる とか 配布 物 の ディレクトリ に Readme とか Install とか が 含ま れ てる ファイル ない か それ を 読ま ない と いけ ない doc とか の ディレクトリ が あれ ば 、 その なか に 文書 ある 場合 も ある 
行列式 の 一般 化 の 結果 を コピペ し て み て ください 。 
具体 的 に どう 操作 し て どういう エラー に なる の か を 正確 に 具体 的 に 書い て ください 。 
ListViewItem を 元 に 新た な クラス を 作っ て いろいろ オーバーラド し て 苦労 する と 出来 ます 。 でも 、 おそろしく 難しい です 。 はっき て 言っ て やっ て られ ない ので 、 誰 も やっ て ませ ん 。 こういう 複雑 な 入力 は 、 DataGridView 上 に 実現 する の が 、 普通 です 。 それでも 、 結構 難しく て 、 みんな 苦労 し て 作っ て いる 様 です 。 ちなみに 、 DataGridView 用 の は 、 作っ て み まし た 。 using System ; using System . Windows . Forms ; name space WindowsFormsApplication 1 { public class NumericUpDownColumn : DataGridViewColumn { public NumericUpDownColumn () : base ( new NumericUpDownCell ()) { } public override DataGridViewCell CellTemplate { get { return base . CellTemplate ; } set { base . CellTemplate = value ; } } } public class NumericUpDownCell : DataGridViewTextBoxCell { public override void InitializeEditingControl ( int rowIndex , object initialFormattedValue , DataGridViewCellStyle dataGridViewCellStyle ) { base . InitializeEditingControl ( rowIndex , initialFormattedValue , dataGridViewCellStyle ); Numeri cUpDownCellEditingControl ctl = DataGridView . EditingControl as Numeri cUpDownCellEditingControl ; if ( this . Value != null ) ctl . Value = decimal . Parse ( this . Value . ToString ()); } public override Type EditType { get { return typeof ( Numeri cUpDownCellEditingControl ); } } public override Type ValueType { get { return typeof ( decimal ); } } public override object DefaultNewRowValue { get { return ( decimal ) 0 ; } } public override object ParseFormattedValue ( object formattedValue , DataGridViewCellStyle cell Style , System . ComponentModel . TypeConverter forma ttedValueTypeConverter , System . ComponentModel . TypeConverter valueTypeConverter ) { return base . ParseFormattedValue ( formattedValue . ToString (), cellStyle , forma ttedValueTypeConverter , valueTypeConverter ); } } class Numeri cUpDownCellEditingControl : NumericUpDown , ID ataGridViewEditingControl { DataGridView dataGridView ; private bool valueChanged = false ; int rowIndex ; public object Ed it ingControlFormattedValue { get { return this . Value ; } set { String newValue = value as String ; if ( newValue != null ) { this . Value = decimal . Parse ( newValue ); } } } public object G et Ed it ingControlFormattedValue ( Da ta GridViewDataErrorContexts context ) { return Ed it ingControlFormattedValue ; } public void A pp l y CellStyleToEditingControl ( DataGridViewCellStyle dataGridViewCellStyle ) { this . Font = dataGridViewCellStyle . Font ; } public int EditingControlRowIndex { get { return rowIndex ; } set { rowIndex = value ; } } public bool Ed itingControlWantsInputKey ( Keys key , bool dataGridViewWantsInputKey ) { switch ( key & Keys . KeyCode ) { case Keys . Left : case Keys . Up : case Keys . Down : case Keys . Right : return true ; default : return false ; } } public bool R epo sit ion Ed itingControlOnValueChange { get { return false ; } } public DataGridView Ed itingControlDataGridView { get { return dataGridView ; } set { dataGridView = value ; } } public bool Ed itingControlValueChanged { get { return valueChanged ; } set { valueChanged = value ; } } public Cursor EditingPanelCursor { get { return base . Cursor ; } } protected override void OnValueChanged ( EventArgs eventargs ) { valueChanged = true ; this . Ed itingControlDataGridView . NotifyCurrentCellDirty ( true ); base . OnValueChanged ( eventargs ); } public void P r ep areEditingControlForEdit ( bool selectAll ) { } } } 
これ です か ね 。 http:// detail . chiebukuro . yahoo . co.jp / qa / question _ detail / q 1216220091 ... 以下 、 便乗 解答 （ ？ ） です 。 C 言語 と C++ と で 違い が あり ます よ 。 カッコ 内 に 何 も 書い て ない 場合 、 【 Ｃ 言語 】 引数 の 構成 について 言及 無し 【 Ｃ ＋ ＋ 】 引数 は １ 個 も 無い こう なり ます 。 今回 は C++ です ので 、 引数 は １ 個 も ない の だ という 宣言 を し て しまっ て いる 。 void Sort _ 1 (); void Sort _ 2 (); これ が 、 void Sort _ 1 ( void ); void Sort _ 2 ( void ); と 解釈 さ れ て いる という わけ です 。 C言語 の 場合 は プロトタイプ 宣言 なる もの が 登場 する 前 に 、 引数 の 部分 を 書か ない （ ていう か 、 書け なかっ た ので ） 形 の 宣言 を 置い て 、 それで 戻り値 の 型 だけ を 明らか に する 。 そういう やり方 が あり まし た 。 プロトタイプ 宣言 登場 後 も この 形 は 有効 。 よって 、 カッコ 内 に 何 も 書か ない の と ( void ) と は 別物 という こと に なっ た ん です ね 。 
loveutikawa さん 以下 の よう に なり ます 。 # include < stdio . h > int frac ( int n ) { if ( n > 1 ) return n * frac ( n - 1 ); else return 1 ; } int main ( void ) { int n ; printf (" n = "); scanf ("% d ", & n ); printf ("% d ! = % d \ n ", n , frac ( n )); return 0 ; } 
http:// detail . chiebukuro . yahoo . co.jp / qa / question _ detail / q 1416217820 ... を 、 teraterm か なにか の ターミナル プログラム で 受信 し て log に 記録 し て いけ ば 特に プログラム は 不要 な 気 が する けれど 、 それ じゃ ダメ ? 
loveutikawa さん strcpy () と strrev () を 、 ① 使用 する バージョン と 、 ② し ない バージョン で 回答 し ます 。 ① の プログラム 例 # include < stdio . h > # include < string . h > int main ( void ){ char st r1 [ 256 ]; char st r2 [ 256 ]; /* 文字列 を 入力 */ printf (" Input string : "); scanf ("% s ", st r1 ); /* 入力 さ れ た 文字列 を 表示 */ printf (" st r1 : % s \ n ", st r1 ); /* 文字列 を コピー */ strcpy ( st r2 , st r1 ); /* 文字列 を 反転 */ strrev ( st r2 ); /* 反転 さ れ た 文字列 を 表示 */ printf (" st r2 : % s \ n ", st r2 ); return 0 ; } ② の プログラム 例 # include < stdio . h > # include < string . h > int main ( void ){ char st r1 [ 256 ]; char st r2 [ 256 ]; char * p 1 , * p2 ; /* 文字列 を 入力 */ printf (" Input string : "); scanf ("% s ", st r1 ); /* 入力 さ れ た 文字列 st r1 を 表示 */ printf (" st r1 : % s \ n ", st r1 ); /* st r1 の 末尾 を 探す */ p 1 = st r1 , p2 = st r2 ; while (* p 1 != '\ 0 ') p 1 ++; p 1 --;/* 1 文字 戻す */ /* st r1 を st r2 に コピー する 。 この とき st r1 は 末尾 から 、 st r2 は 先頭 から たどる */ while ( p 1 >= st r1 ) { * p2 = * p 1 ; p 1 --; p2 ++; } * p2 = '\ 0 ';/* st r2 の 末尾 */ /* 反転 さ れ た 文字列 を 表示 */ printf (" st r2 : % s \ n ", st r2 ); return 0 ; } 
ハードウエア では ” 算術 演算 だ と 、 - 32768 ～ 32767 が 範囲 、 論理演算 だ と 、 0 ～ 65535 が 範囲 ” など は わかり ませ ん 。 ようするに そん こと を 判断 し て いる 論理回路 など ない という こと です 。 もちろん 、 SLA で 算術 レフト シフト と は わかり ます 。 （ アッセン ブル 後 の 機械語 の レベル で ） 算術 レフト の 規則 （ CASL の ） に従って シフト する だけ です 。 ハードウエア が そう なっ て いる 。 CASL 2 の 「 算術 レフト シフト 」 規則 に よる と １ ５ 〜 ０ ビット で １ ５ ビット は そのままで １ ４ 〜 ０ が 指定 数 だけ シフト し OF に は １ ４ 、 １ ３ 、 １ ２ 、 １ １ ・ ・ ・ ・ １ 、 ０ ビット の 状態 が 入る 。 で 、 質問 の こと 。 GR1 = 0 xD 12 C = 1101 0001 0010 1100 ( B ) これ を ４ ビット 左 算術 シフト する の だ から 、 OF に は シフト と する 度 に 1 、 0 、 1 、 0 と 入っ て いく こと に なる 。 最後 は 0 したがって シフト が 終わっ た あと は OF = ０ です 。 「 SLL GR1 , 4 」 は ロジカル ４ ビット 左 シフト だ から ・ ・ ・ ・ ・ あと は 考え て ください 。 １ ０ 進数 に 直し て は 反対 に わから なく なり ます 。 
2進法 で 説明 し て み ます 。 。 
ジャンプ 処理 は 、 重力 による 落下 処理 と 組み合わせ て 、 成立 する もの です 。 その ため 、 キー 判定 だけ で なく 時間 に 応じ た 落下 処理 も 必要 な ので 以下 の 部分 だけ で は 、 作成 でき ませ ん 。 「 / / / / / / / / / / / / / / / / / ///////////////////////// if ( GetKeyboardPress ( DIK _ Z )){ ＿＿// ジャンプ 処理 } / / / / / / / / / / / / / / / / / / ////////////////////////」 
12 番 を 最初 に 作っ て から に する と いい よ 。 一番 難しいっ て ？ そう だ ね 。 でも 一番 ・ ・ ・ 。 
私 が 試し た 方法 で よけれ ば 、 少し 。 これ は 、 いわゆる シューティングゲーム の 追尾 弾 の 挙動 を 作っ た 時 の 方法 です 。 まず 、 追尾 する 弾 オブジェクト （ 以下 、 本体 ） は 、 Velocity 等 の 方法 で 常に 前進 し て い ます 。 そして 、 本体 の スクリプト に 、 着弾 地点 と なる 座標 （ 実際 に は 動い て いる オブジェクト の transform . position ） を 指定 し ます が 、 その 座標 に 直接 向かう 訳 で は あり ませ ん 。 本体 に 着弾 地点 が 指定 さ れ たら 、 その 時点 で の 本体 の 座標 から 、 着弾 地点 の 座標 まで の 間 を 、 Vector 3 . Lerp () を 使っ て 、 時間 を かけて 移動 する ” 可動 ターゲット 座標 ” を 算出 し ます 。 そして 本体 は 、 この ” 可動 ターゲット 座標 ” に 向かっ て 進む （ Transform . LookAt () で この 動い て いる 座標 を 指定 する ） 事 で 、 本体 は ある程度 の 時間 を かけ て 、 進路 を 曲げ つつ （ 弧状 の 軌道 で ） 目標 に 着弾 する という 挙動 に なり まし た 。 と まぁ 、 文章 に する と 分かり にくい の です が 、 要するに 、 本体 が 向かお う する 座標 自体 を 時間 と共に 移動 さ せ て やれ ば 、 直線 的 な 動き に は なり にくい 、 という 事 です 。 参考 に なれ ば 。 
回答 し ます 。 ■ １ ． 整数 値 128 を 変数 に 記憶 し た 後 、 表示 する ▼ プログラム 例 # include < stdio . h > int main ( void ) { /* 整数 値 128 を 変数 に 記憶 */ int i = 128 ; /* 表示 */ printf ("% d \ n ", i ); return 0 ; } ▼ 実行 例 128 ■ ２ ． int 型 の 変数 a と double 型 の 変 数b を 宣言 する 。 キーボード から 変 数b に 値 を 入力 し た 後 、 100 で 割っ た 余り を 求め 、 変 数 a に 代入 する 。 最後 に 、 変 数b と a の 値 を 表示 する ⇒ 剰余 算 （ % ） は double 型 に対して は 適用 でき ない ので 、 b を int 型 に キャスト （ 変換 ） し て から 計算 し ます 。 ▼ プログラム 例 # include < stdio . h > int main ( void ) { int a ; double b ; /* キーボード から 変 数b に 値 を 入力 */ printf (" b = "); scanf ("% lf ", & b ); /* 100 で 割っ た 余り を 求め 、 変 数 a に 代入 */ a = ( int ) b % 100 ; /* 変 数b と a の 値 を 表示 */ printf (" b = % lf \ na = % d \ n ", b , a ); return 0 ; } ▼ 実行 例 b = 150 b = 150 . 000000 a = 50 ■ ３ ． キーボード から ２つ の 値 を 変 数 a と b に 入力 する 。 a と b の 参照 値 の 符号 が 一致 し て いる 場合 は "+"、 それ 以外 の 場合 は "-" と 表示 する ⇒ a と b の 型 の 指定 が 無い ので 、 int 型 と し ます 。 ▼ プログラム 例 # include < stdio . h > int main ( void ) { int a , b ; /* キーボード から ２つ の 値 を 変 数 a と b に 入力 */ printf (" a = "); scanf ("% d ", & a ); printf (" b = "); scanf ("% d ", & b ); /* a , b の 符号 が 一致 し て いる か 確認 → 掛算 し て 正 なら 符号 一致 、 負 または 0 なら 符号 違い か 、 どちら か または 両方 が 0 */ if ( a * b > 0 ) printf ("+\ n "); else printf ("-\ n "); return 0 ; } ▼ 実行 例 1 a = 3 b = - 2 - ▼ 実行 例 2 a = 9 b = 6 + ■ ４ ． 入力 値 が 999 と なる まで 、 繰り返し キーボード から 値 を 入力 し 、 合計 を 求める 。 ただし 、 break 文 を 使っ て は いけ ない 。 ⇒ 合計 は 表示 し ます 。 また 、 999 は 合計 し ませ ん 。 ▼ プログラム 例 # include < stdio . h > int main ( void ) { int in = 0 , /* キーボード から の 入力 */ sum = 0 ; /* キーボード から の 入力 の 合計 */ /* 入力 値 が 999 と なる まで 、 繰り返し */ while ( in != 999 ) { /* 合計 を 求める ( 最初 は 0 ) */ sum += in ; /* キーボード から 値 を 入力 */ printf (" number = "); scanf ("% d ", & in ); } printf (" 合計 = % d \ n ", sum ); return 0 ; } ▼ 実行 例 number = 1 number = 2 number = 3 number = 4 number = 5 number = 999 合計 = 15 
・ ２つ の 整数 値 を 入力 し 、 加減乗除 算 および 剰余 演算 を 行ない 、 結果 を 表示 する # include < stdio . h > int main ( void ) { int x , y ; printf (" x :"); scanf ("% d ",& x ); printf (" y :"); scanf ("% d ",& y ); printf ("% d +% d =% d \ n % d -% d =% d \ n % d *% d =% d \ n % d /% d =% d \ n ", x , y , x+ y , x , y , x - y , x , y , x * y , x , y , x / y ); return 0 ; } ・ 小 数値 を ５つ 入力 し 、 最小 値 １つ と 、 最大 値 １つ を 除い た ３つ の 値 の 平均値 を 求めて 表示 する # include < stdio . h > # define MM 5 int main ( void ) { double d [MM] , t ; int i , j ; for ( i = 0 ; i < MM ; i ++) scanf ("% lf ",& d [ i ]); for ( i = 0 ; i < M M-1 ; i ++){ for ( j = i + 1 ; j < MM ; j ++){ if ( d [ i ]< d [ j ]){ t = d [ j ]; d [ j ]= d [ i ]; d [ i ]= t ; }}} printf ("% f \ n ",( d [ 1 ]+ d [ 2 ]+ d [ 3 ])/ 3 ); return 0 ; } ・ 得点 データ として - 1 が 入力 さ れる まで 繰り返し 得点 データ を 入力 し 、 平均値 を 求めて 表示 する 。 ただし 、 最後 に 入力 さ れ た - 1 は 平均値 の 計算 に 含ま ない 。 # include < stdio . h > int main ( void ) { int n , g , i ; scanf ("% d ",& n ); i = 0 ; g = 0 ; while ( n !=- 1 ){ i ++; g+ = n ; scanf ("% d ",& n ); } if ( i > 0 ) printf ("% d \ n ", g / i ); return 0 ; } ・ 10000 個 の データ （ 小数 ） を キーボード から 入力 し 、 分散 を 求める ==> 分散 の 計算 式 を 提示 し て ください 。 
/* 2016 / 8 / 10 14 : 56 : 43 配列 の 要素 を ランダム に 0 引数 で 与え られ た 確率 で ランダム に 配列 の 要素 を 0 に し たい 例えば ， P = 0 . 1 ( 10 ％ ) の 場合 ， 配列 の 10 個 に 1 個 が 0 に なる よう に し たい 「 1 . 配列 の 確保 ・ 表示 」 「 2 . 要素 を 0 に する 関数 で 処理 」 「 3 . 配列 の 表示 」 という 流れ に し た の です が 「 2 . 要素 を 0 に する 関数 で 処理 」 の 中身 が わから ない ので 教え て 下さい ． ＞ ＞ ＞ それ 以外 に も 実行 結果 の 確認 に 便利 な ＿ ＿ ＿ 改善 を 施し た ので よく 読ん で 理解 し て 下さい 。 */ # include < stdio . h > # include < stdlib . h > # include < time. h > # define N ＿ 100 ＿ ＿ // 配列 の サイズ 、 データ 数 # define M ＿ 10000 ＿ // 配列 要素 の 上限 値 # define P ＿ 0 . 3 ＿ ＿ // ランダム な 要素 0 化 の 期待 確率 /* 確率 P で 配列 の 要素 を ランダム に 0 化 */ void loss ( double p , int * ary ); int main ( int agc , char * agv []){ ＿ int ＿ ＿ trim = 0 ; // count of trim ＿ by loss () ＿ int ＿ ＿ org [ N ]; // サンプル 配列 ： 0 化 以前 ＿ int ＿ ＿ ary [ N ]; // サンプル 配列 ： 0 化 以後 ＿ int ＿ ＿ i ;＿＿＿// 同 インデクス ＿ ＿// 初期化 ＿ srand (( int ) time ( NULL ));＿ // rand () 系列 初期化 ＿ ＿// 配列 の 初期 状態 表示 ＿ printf (" Initial status of array [% d ]:\ n ", N ); ＿ printf (" original array copied array \ n "); ＿ for ( i = 0 ; i < N ; i ++){ ＿ ＿ org [ i ] = rand () % M ;＿＿＿＿// 要素 初期化 ： 5 桁 乱数 ＿ ＿ ary [ i ] = org [ i ];＿＿＿＿＿// 0 化 用 配列 に コピー ＿ ＿ printf (" org [% 2d ]=% 5 d ＿", i , org [ i ]); ＿ ＿ printf (" ary [% 2d ]=% 5 d \ n ", i , ary [ i ]); ＿} printf ("\ n "); ＿ ＿// トリミング 実行 ＿ printf (" Execute randum trimming by loss ( P , ary )\ n "); ＿ printf (" Probability P = % f \ n ", P ); ＿ loss ( P , ary ); ＿ ＿// トリム 後 の 配列 表示 ＿ printf ("\ nAfter randam trim by rate % f \ n ", P ); ＿ printf (" original array trimmed array \ n "); ＿ for ( i = 0 ; i < N ; i ++){ ＿ ＿ printf (" org [% 2d ]=% 5 d ＿", i , org [ i ]); ＿ ＿ printf (" ary [% 2d ]=% 5 d \ n ", i , ary [ i ]); ＿ ＿ if ( ary [ i ]== 0 ) trim ++; ＿} printf ("\ n "); ＿ printf ("% d elements of ary [% d ] were cleared .\ n ", trim , N ); ＿ printf (" Probability P = % f \ n ", P ); ＿// 終了 ＿ printf ("\ n # normal end #\ n \ n "); // 確認 表示 ＿ system (" pause ");＿// キイ 待ち 停止 ＿ return 0 ;＿ // main () 終了 } // Execute randum trimming by P the ex pect rate . void loss ( double p , int * ary ){ ＿ int ＿ i ;＿＿// 要素 インデクス ＿ ＿ for ( i = 0 ; i < N ; i ++){ ＿ ＿ if ( ary [ i ] < p * M ) ary [ i ] = 0 ; ＿} } /* 実行 出力 ： console Initial status of array [ 100 ]: original array copied array org [ 0 ]= 7170 ＿ ary [ 0 ]= 7170 org [ 1 ]= 9373 ＿ ary [ 1 ]= 9373 org [ 2 ]= 3240 ＿ ary [ 2 ]= 3240 org [ 3 ]= 8323 ＿ ary [ 3 ]= 8323 org [ 4 ]=＿ 780 ＿ ary [ 4 ]=＿ 780 org [ 5 ]=＿ 623 ＿ ary [ 5 ]=＿ 623 org [ 6 ]= 5276 ＿ ary [ 6 ]= 5276 org [ 7 ]= 5540 ＿ ary [ 7 ]= 5540 org [ 8 ]=＿ 481 ＿ ary [ 8 ]=＿ 481 org [ 9 ]= 9025 ＿ ary [ 9 ]= 9025 org [ 10 ]= 9517 ＿ ary [ 10 ]= 9517 org [ 11 ]= 4614 ＿ ary [ 11 ]= 4614 org [ 12 ]= 9010 ＿ ary [ 12 ]= 9010 org [ 13 ]= 6617 ＿ ary [ 13 ]= 6617 org [ 14 ]= 8400 ＿ ary [ 14 ]= 8400 org [ 15 ]=＿ 181 ＿ ary [ 15 ]=＿ 181 org [ 16 ]= 2539 ＿ ary [ 16 ]= 2539 org [ 17 ]= 6390 ＿ ary [ 17 ]= 6390 org [ 18 ]= 2959 ＿ ary [ 18 ]= 2959 org [ 19 ]= 9813 ＿ ary [ 19 ]= 9813 org [ 20 ]=＿ 405 ＿ ary [ 20 ]=＿ 405 org [ 21 ]= 4589 ＿ ary [ 21 ]= 4589 org [ 22 ]= 2092 ＿ ary [ 22 ]= 2092 org [ 23 ]= 1553 ＿ ary [ 23 ]= 1553 org [ 24 ]= 5115 ＿ ary [ 24 ]= 5115 org [ 25 ]= 4173 ＿ ary [ 25 ]= 4173 org [ 26 ]= 4178 ＿ ary [ 26 ]= 4178 org [ 27 ]=＿ 388 ＿ ary [ 27 ]=＿ 388 org [ 28 ]= 7260 ＿ ary [ 28 ]= 7260 org [ 29 ]=＿ 154 ＿ ary [ 29 ]=＿ 154 org [ 30 ]= 3886 ＿ ary [ 30 ]= 3886 org [ 31 ]= 3452 ＿ ary [ 31 ]= 3452 org [ 32 ]= 8241 ＿ ary [ 32 ]= 8241 org [ 33 ]=＿ 775 ＿ ary [ 33 ]=＿ 775 org [ 34 ]= 1855 ＿ ary [ 34 ]= 1855 org [ 35 ]= 2475 ＿ ary [ 35 ]= 2475 org [ 36 ]= 2320 ＿ ary [ 36 ]= 2320 org [ 37 ]= 2965 ＿ ary [ 37 ]= 2965 org [ 38 ]= 7146 ＿ ary [ 38 ]= 7146 org [ 39 ]=＿ 976 ＿ ary [ 39 ]=＿ 976 org [ 40 ]= 2144 ＿ ary [ 40 ]= 2144 org [ 41 ]= 6188 ＿ ary [ 41 ]= 6188 org [ 42 ]= 6769 ＿ ary [ 42 ]= 6769 org [ 43 ]= 2549 ＿ ary [ 43 ]= 2549 org [ 44 ]= 7117 ＿ ary [ 44 ]= 7117 org [ 45 ]= 4647 ＿ ary [ 45 ]= 4647 org [ 46 ]= 2341 ＿ ary [ 46 ]= 2341 org [ 47 ]= 7306 ＿ ary [ 47 ]= 7306 org [ 48 ]= 9662 ＿ ary [ 48 ]= 9662 org [ 49 ]= 6437 ＿ ary [ 49 ]= 6437 org [ 50 ]= 8009 ＿ ary [ 50 ]= 8009 org [ 51 ]= 9251 ＿ ary [ 51 ]= 9251 org [ 52 ]= 8469 ＿ ary [ 52 ]= 8469 org [ 53 ]= 9133 ＿ ary [ 53 ]= 9133 org [ 54 ]= 5417 ＿ ary [ 54 ]= 5417 org [ 55 ]= 9054 ＿ ary [ 55 ]= 9054 org [ 56 ]= 7447 ＿ ary [ 56 ]= 7447 org [ 57 ]= 8114 ＿ ary [ 57 ]= 8114 org [ 58 ]= 8587 ＿ ary [ 58 ]= 8587 org [ 59 ]= 1623 ＿ ary [ 59 ]= 1623 org [ 60 ]= 3933 ＿ ary [ 60 ]= 3933 org [ 61 ]= 7095 ＿ ary [ 61 ]= 7095 org [ 62 ]= 6196 ＿ ary [ 62 ]= 6196 org [ 63 ]= 1231 ＿ ary [ 63 ]= 1231 org [ 64 ]= 1658 ＿ ary [ 64 ]= 1658 org [ 65 ]= 4405 ＿ ary [ 65 ]= 4405 org [ 66 ]= 7070 ＿ ary [ 66 ]= 7070 org [ 67 ]= 2522 ＿ ary [ 67 ]= 2522 org [ 68 ]=＿ 334 ＿ ary [ 68 ]=＿ 334 org [ 69 ]=＿ 634 ＿ ary [ 69 ]=＿ 634 org [ 70 ]= 2169 ＿ ary [ 70 ]= 2169 org [ 71 ]= 4631 ＿ ary [ 71 ]= 4631 org [ 72 ]= 3963 ＿ ary [ 72 ]= 3963 org [ 73 ]= 2276 ＿ ary [ 73 ]= 2276 org [ 74 ]= 4160 ＿ ary [ 74 ]= 4160 org [ 75 ]= 6118 ＿ ary [ 75 ]= 6118 org [ 76 ]= 9110 ＿ ary [ 76 ]= 9110 org [ 77 ]= 9742 ＿ ary [ 77 ]= 9742 org [ 78 ]= 9997 ＿ ary [ 78 ]= 9997 org [ 79 ]= 9622 ＿ ary [ 79 ]= 9622 org [ 80 ]= 9887 ＿ ary [ 80 ]= 9887 org [ 81 ]= 6075 ＿ ary [ 81 ]= 6075 org [ 82 ]= 2511 ＿ ary [ 82 ]= 2511 org [ 83 ]= 5660 ＿ ary [ 83 ]= 5660 org [ 84 ]=＿ 260 ＿ ary [ 84 ]=＿ 260 org [ 85 ]= 6881 ＿ ary [ 85 ]= 6881 org [ 86 ]= 7051 ＿ ary [ 86 ]= 7051 org [ 87 ]= 7242 ＿ ary [ 87 ]= 7242 org [ 88 ]= 1939 ＿ ary [ 88 ]= 1939 org [ 89 ]=＿ 759 ＿ ary [ 89 ]=＿ 759 org [ 90 ]= 1505 ＿ ary [ 90 ]= 1505 org [ 91 ]=＿ 239 ＿ ary [ 91 ]=＿ 239 org [ 92 ]= 4191 ＿ ary [ 92 ]= 4191 org [ 93 ]= 6098 ＿ ary [ 93 ]= 6098 org [ 94 ]= 6641 ＿ ary [ 94 ]= 6641 org [ 95 ]= 6732 ＿ ary [ 95 ]= 6732 org [ 96 ]= 3829 ＿ ary [ 96 ]= 3829 org [ 97 ]= 4764 ＿ ary [ 97 ]= 4764 org [ 98 ]= 2494 ＿ ary [ 98 ]= 2494 org [ 99 ]= 2439 ＿ ary [ 99 ]= 2439 Execute randum trimming by loss ( P , ary ) Probability P = 0 . 300000 After randam trim by rate 0 . 300000 original array trimmed array org [ 0 ]= 7170 ＿ ary [ 0 ]= 7170 org [ 1 ]= 9373 ＿ ary [ 1 ]= 9373 org [ 2 ]= 3240 ＿ ary [ 2 ]= 3240 org [ 3 ]= 8323 ＿ ary [ 3 ]= 8323 org [ 4 ]=＿ 780 ＿ ary [ 4 ]=＿＿ 0 org [ 5 ]=＿ 623 ＿ ary [ 5 ]=＿＿ 0 org [ 6 ]= 5276 ＿ ary [ 6 ]= 5276 org [ 7 ]= 5540 ＿ ary [ 7 ]= 5540 org [ 8 ]=＿ 481 ＿ ary [ 8 ]=＿＿ 0 org [ 9 ]= 9025 ＿ ary [ 9 ]= 9025 org [ 10 ]= 9517 ＿ ary [ 10 ]= 9517 org [ 11 ]= 4614 ＿ ary [ 11 ]= 4614 org [ 12 ]= 9010 ＿ ary [ 12 ]= 9010 org [ 13 ]= 6617 ＿ ary [ 13 ]= 6617 org [ 14 ]= 8400 ＿ ary [ 14 ]= 8400 org [ 15 ]=＿ 181 ＿ ary [ 15 ]=＿＿ 0 org [ 16 ]= 2539 ＿ ary [ 16 ]=＿＿ 0 org [ 17 ]= 6390 ＿ ary [ 17 ]= 6390 org [ 18 ]= 2959 ＿ ary [ 18 ]=＿＿ 0 org [ 19 ]= 9813 ＿ ary [ 19 ]= 9813 org [ 20 ]=＿ 405 ＿ ary [ 20 ]=＿＿ 0 org [ 21 ]= 4589 ＿ ary [ 21 ]= 4589 org [ 22 ]= 2092 ＿ ary [ 22 ]=＿＿ 0 org [ 23 ]= 1553 ＿ ary [ 23 ]=＿＿ 0 org [ 24 ]= 5115 ＿ ary [ 24 ]= 5115 org [ 25 ]= 4173 ＿ ary [ 25 ]= 4173 org [ 26 ]= 4178 ＿ ary [ 26 ]= 4178 org [ 27 ]=＿ 388 ＿ ary [ 27 ]=＿＿ 0 org [ 28 ]= 7260 ＿ ary [ 28 ]= 7260 org [ 29 ]=＿ 154 ＿ ary [ 29 ]=＿＿ 0 org [ 30 ]= 3886 ＿ ary [ 30 ]= 3886 org [ 31 ]= 3452 ＿ ary [ 31 ]= 3452 org [ 32 ]= 8241 ＿ ary [ 32 ]= 8241 org [ 33 ]=＿ 775 ＿ ary [ 33 ]=＿＿ 0 org [ 34 ]= 1855 ＿ ary [ 34 ]=＿＿ 0 org [ 35 ]= 2475 ＿ ary [ 35 ]=＿＿ 0 org [ 36 ]= 2320 ＿ ary [ 36 ]=＿＿ 0 org [ 37 ]= 2965 ＿ ary [ 37 ]=＿＿ 0 org [ 38 ]= 7146 ＿ ary [ 38 ]= 7146 org [ 39 ]=＿ 976 ＿ ary [ 39 ]=＿＿ 0 org [ 40 ]= 2144 ＿ ary [ 40 ]=＿＿ 0 org [ 41 ]= 6188 ＿ ary [ 41 ]= 6188 org [ 42 ]= 6769 ＿ ary [ 42 ]= 6769 org [ 43 ]= 2549 ＿ ary [ 43 ]=＿＿ 0 org [ 44 ]= 7117 ＿ ary [ 44 ]= 7117 org [ 45 ]= 4647 ＿ ary [ 45 ]= 4647 org [ 46 ]= 2341 ＿ ary [ 46 ]=＿＿ 0 org [ 47 ]= 7306 ＿ ary [ 47 ]= 7306 org [ 48 ]= 9662 ＿ ary [ 48 ]= 9662 org [ 49 ]= 6437 ＿ ary [ 49 ]= 6437 org [ 50 ]= 8009 ＿ ary [ 50 ]= 8009 org [ 51 ]= 9251 ＿ ary [ 51 ]= 9251 org [ 52 ]= 8469 ＿ ary [ 52 ]= 8469 org [ 53 ]= 9133 ＿ ary [ 53 ]= 9133 org [ 54 ]= 5417 ＿ ary [ 54 ]= 5417 org [ 55 ]= 9054 ＿ ary [ 55 ]= 9054 org [ 56 ]= 7447 ＿ ary [ 56 ]= 7447 org [ 57 ]= 8114 ＿ ary [ 57 ]= 8114 org [ 58 ]= 8587 ＿ ary [ 58 ]= 8587 org [ 59 ]= 1623 ＿ ary [ 59 ]=＿＿ 0 org [ 60 ]= 3933 ＿ ary [ 60 ]= 3933 org [ 61 ]= 7095 ＿ ary [ 61 ]= 7095 org [ 62 ]= 6196 ＿ ary [ 62 ]= 6196 org [ 63 ]= 1231 ＿ ary [ 63 ]=＿＿ 0 org [ 64 ]= 1658 ＿ ary [ 64 ]=＿＿ 0 org [ 65 ]= 4405 ＿ ary [ 65 ]= 4405 org [ 66 ]= 7070 ＿ ary [ 66 ]= 7070 org [ 67 ]= 2522 ＿ ary [ 67 ]=＿＿ 0 org [ 68 ]=＿ 334 ＿ ary [ 68 ]=＿＿ 0 org [ 69 ]=＿ 634 ＿ ary [ 69 ]=＿＿ 0 org [ 70 ]= 2169 ＿ ary [ 70 ]=＿＿ 0 org [ 71 ]= 4631 ＿ ary [ 71 ]= 4631 org [ 72 ]= 3963 ＿ ary [ 72 ]= 3963 org [ 73 ]= 2276 ＿ ary [ 73 ]=＿＿ 0 org [ 74 ]= 4160 ＿ ary [ 74 ]= 4160 org [ 75 ]= 6118 ＿ ary [ 75 ]= 6118 org [ 76 ]= 9110 ＿ ary [ 76 ]= 9110 org [ 77 ]= 9742 ＿ ary [ 77 ]= 9742 org [ 78 ]= 9997 ＿ ary [ 78 ]= 9997 org [ 79 ]= 9622 ＿ ary [ 79 ]= 9622 org [ 80 ]= 9887 ＿ ary [ 80 ]= 9887 org [ 81 ]= 6075 ＿ ary [ 81 ]= 6075 org [ 82 ]= 2511 ＿ ary [ 82 ]=＿＿ 0 org [ 83 ]= 5660 ＿ ary [ 83 ]= 5660 org [ 84 ]=＿ 260 ＿ ary [ 84 ]=＿＿ 0 org [ 85 ]= 6881 ＿ ary [ 85 ]= 6881 org [ 86 ]= 7051 ＿ ary [ 86 ]= 7051 org [ 87 ]= 7242 ＿ ary [ 87 ]= 7242 org [ 88 ]= 1939 ＿ ary [ 88 ]=＿＿ 0 org [ 89 ]=＿ 759 ＿ ary [ 89 ]=＿＿ 0 org [ 90 ]= 1505 ＿ ary [ 90 ]=＿＿ 0 org [ 91 ]=＿ 239 ＿ ary [ 91 ]=＿＿ 0 org [ 92 ]= 4191 ＿ ary [ 92 ]= 4191 org [ 93 ]= 6098 ＿ ary [ 93 ]= 6098 org [ 94 ]= 6641 ＿ ary [ 94 ]= 6641 org [ 95 ]= 6732 ＿ ary [ 95 ]= 6732 org [ 96 ]= 3829 ＿ ary [ 96 ]= 3829 org [ 97 ]= 4764 ＿ ary [ 97 ]= 4764 org [ 98 ]= 2494 ＿ ary [ 98 ]=＿＿ 0 org [ 99 ]= 2439 ＿ ary [ 99 ]=＿＿ 0 36 elements of ary [ 100 ] were cleared . Probability P = 0 . 300000 # normal end # 続行 する に は 何 か キー を 押し て ください . . . */ 
day が 1 ～ 7 の 時 、 day - 1 は 0 ～ 6 これ を 7 で 割っ たら 、 整数 値 なら 0 0 に 1 を 足す から 1 day が 8 ～ 14 の 時 、 day - 1 は 7 ～ 13 これ を 7 で 割っ たら 、 整数 値 なら 1 1 に 1 を 足す から 2 以下 同様 。 
どの 行 を 選択 し て も 結果 は 変わら ない と 思い ます が 、 列 ヘッダ 名 を 取得 し たい の なら こんな 感じ か な ? dataGridView 1 . Rows [ 1 ]. Selected = true ; foreach ( DataGridViewCell c in dataGridView 1 . CurrentRow . Cells ) { DataGridViewColumn col = dataGridView 1 . Columns [ c . ColumnIndex ]; textbox . AppendText ( col . HeaderText + "\ r \ n "); } dataGridView 1 .S electedRows は DataGridViewRow の コレクション な ので 、 DataGridViewColumn に は キャスト でき ない です 。 
文字列 1 と 2 の 文字列 長 は 同じ で ある こと が 前提 条件 です 。 # include < stdio . h > int main ( void ) { char w 1 [ 256 ], w 2 [ 256 ]; int i , j ; printf (" 文字列 1 ="); scanf ("% s ", w 1 ); printf (" 文字列 2 ="); scanf ("% s ", w 2 ); for ( j = 2 , i = 0 ; w 1 [ i ]!='\ 0 '; i ++) if ( w 1 [ i ]!= w 2 [ i ]) j --; if ( j < 0 ) j = 0 ; printf ("% d 点 \ n ", j ); return 0 ; } ＝ ＝ ＝ ＝ ＝ ＝ ＝ ＝ ＝ ＝ 文字列 1 と 2 の 文字列 長 は 異なる 場合 # include < stdio . h > int main ( void ) { char w 1 [ 256 ], w 2 [ 256 ]; int i , j , k ; printf (" 文字列 1 ="); scanf ("% s ", w 1 ); printf (" 文字列 2 ="); scanf ("% s ", w 2 ); i = 0 ; j = 0 ; k = 2 ; while ( 1 ){ if ( w 1 [ i ]!= w 2 [ j ]) k --; if ( w 1 [ i ]!='\ 0 ') i ++; if ( w 2 [ j ]!='\ 0 ') j ++; if ( w 1 [ i ]=='\ 0 '&& w 2 [ j ]=='\ 0 ') break ; } if ( k < 0 ) k = 0 ; printf ("% d 点 \ n ", k ); return 0 ; } ちなみに 宿題 とか では なく 、 ただ 単に 私 が 個人的 に 気 に なっ て 調べ 倒し まし た が 解決 し なかっ た ため 書き込み まし た ・ ・ ・ 。 ==> その よう な こと は 書か なく て 良い 。 純粋 に 仕様 を 明確 に し て 質問 し て ください 。 点数 が マイナス に なっ て も 引い て い ます 。 0 点 に なっ た 時点 で 比較 を 止め て も 構わ ない が 、 、 、 、 
「 プログラミング 関係 の お仕事 」 ばかり やっ て ます 。 ていう か 、 他 の こと は やっ た こと あり ませ ん 。 では 、 アドバイス し ます よ 。 「 将来 は ＡＩ や プログラミング 関係 の 職 」 と の こと 。 で 、 どっち ？ （ １ ） ＡＩ （ ２ ） プログラミング 関係 どちら の 方面 を 希望 し てる の か な 。 （ １ ） の 場合 、 プログラミング は 些末 に なる 可能性 が あり ます 。 おそらく 設計 が 大事 な に なる の で は ない でしょ う か 。 ましてや C 言語 とか 言っ てる 場合 で は ない と 思う 。 （ ２ ） の 場合 、 これ は 色々 です 。 プログラミング 職人 に なり たい です か ？ なら 、 今 の 内 から （ あるいは 小学生 の 時 から でも ） C 言語 を やる こと は 意味 が ある と 思い ます 。 あと 、 学校 の 勉強 、 大丈夫 です か ？ 「 年 から 二 年 かけ て じっくり 学ぼ う と 思っ て い ます 」 と の こと で 、 もしかして 中高一貫校 か な ？ 高校受験 が 不要 ？ だ として も 注意 し ない と 。 大事 な 時期 です ので 、 学業 に 悪影響 が 出 ない か 心配 な の です よ 。 特に 英語 と 数学 。 英語 、 得意 です か ？ 得意 なら 結構 。 もっと 伸ばし て ください ね 。 万一 苦手 だ と し たら 、 これ は 本当に 危険 です 。 将来 ＡＩ を やる 場合 、 非常 に まずい 事態 に なり ます 。 おそらく 、 プログラミング を やる 場合 も 同じ 。 ものすごく 困っ た 事態 に なり そう 。 資料 、 英語 です から ね 。 日本語 で 書い て ある わけ ないじゃないですか 。 え ？ 書い て ある ？ じゃ 、 そういう の も ある の かも しれ ませ ん 。 ある として 、 それ って 大した こと ない 資料 かも 。 ほぼ 、 読む 価値 が 無い 資料 かも しれ ませ ん 。 読む べき 資料 が 英語版 しか ない として 、 それ で 諦め て しまう という の は まずい です 。 要注意 です よ 。 数学 について は 、 ＡＩ やる 場合 は 無茶苦茶 大事 でしょ う 。 プログラミング を やる 場合 、 分野 に より ます 。 大 多数 の 分野 で は 数学 不要 。 全然 使い ませ ん 。 知っ てる と 使える こと が 稀 に ある かも しれ ませ ん が 。 でも 、 将来 は 大学受験 し ます か ？ 受験 する なら 数学 は 大事 です よ 。 苦手 だ と する と 急 に 取り組ん で も 間に合わ なく なり ます ので ね 。 英語 も だ けど 。 将来 の こと を 考える と 今 一番 大事 な の は 学校 の 勉強 です 。 この 時期 に C 言語 を 覚え て も 、 学業 成績 の 状況 によって は 、 将来 それ を 活かす こと が 難しく なる 恐れ が あり ます 。 そこ だけ 注意 し て ください ね 。 《 備考 》 小学生 の 時 から ハードウェア っていう か アナログ回路 の 電子工作 です けど 、 を やっ て まし た 。 中学生 の ころ マイコン なる もの が 登場 し まし て 、 デジタル回路 やら 二 進数 やら 勉強 し まし た 。 高校生 くらい で 機械語 など を やり まし て … 。 英語 は 資料 を 読む 都合 も あり 、 知ら ず 知ら ず に 語彙 が 増え て 得 し た の です けど 、 数学 は 絶望 的 な 状態 でし た 。 ホント に ひどかっ た 。 受験 で は 苦労 し まし た よ 。 そういう 実体験 に 基づく アドバイス です から ね 。 
# include < stdio . h > int main ( void ) { double x , y ; printf (" x :"); scanf ("% lf ",& x ); printf (" y :"); scanf ("% lf ", & y ); printf (" x + y = % f \ n ", x+ y ); printf (" x - y = % f \ n ", x - y ); printf (" x * y = % f \ n ", x * y ); printf (" x / y = % f \ n ", x / y ); return 0 ; } こんな 感じ で いかが です か ？ ？ 
class A { public : void m () {} }; の & A :: m を 返す として 、 一番 簡単 な 方法 は 下記 の 通り です 。 auto f () { return & A :: m ; } あるいは 、 明示 的 に auto f () -> decltype (& A :: m ) { return & A :: m ; } として も よい でしょ う 。 なお 、 一番 古い 書き方 で は 、 次 の よう に し ます 。 void ( A ::* f ())() { return & A :: m ; } 
回文 の 場合 が ない と つまらない ので 、 蛇足 を つけ まし た 。 # include < stdio . h > int is _ palindrome ( char * str ){ char * head = str ; char * tail = str ; while (*++ tail != '\ 0 '); tail --; while (* head ==* tail ){ head ++; tail --; } if ( head >= tail ){ return 1 ; } else { return 0 ; } } int main ( void ){ char * s1 =" abc "; char * s2 =" abab "; char * s3 =" abba "; char * s4 =" ababa "; printf ("% d \ n ", is _ palindrome ( s1 )); printf ("% d \ n ", is _ palindrome ( s2 )); printf ("% d \ n ", is _ palindrome ( s3 )); printf ("% d \ n ", is _ palindrome ( s4 )); return 0 ; } 
# include < stdio . h > int is _ sq _ num ( int n ) { int i , p ; for ( i = 1 ; ( p = i * i ) < n ; ++ i ){ int j , q ; for ( j = i + 1 ; ( q = j * j ) < n ; ++ j ){ if ( n == p + q ) return 1 ; } } return 0 ; } int main ( void ) { int i ; for ( i = 1 ; i <= 1000 ; ++ i ){ if ( is _ sq _ num ( i )) printf ("% d \ n ", i ); } return 0 ; } 
・ 終了 直前 に キー 入力 待ち に する 。 ・ 終了 直前 に ブレイク を セット する など など 。 
大体 そう です が 、 かなり 訓練 し ない 限り 100 M の 距離 で 撃ち合っ て も ほぼ 外れ ます ！ 訓練 し て ない から では ？ 
> manbou 1129 さん 参考書 も 必要 だ けど 重視 す べき は 過去問 過去問 を やり まくっ て 、 解け ない 問題 について 必要 なら 参考書 も 利用 し ながら 類題 を 解ける よう に 準備 言語 は C じゃなくて アセンブラ が 選択 可能 なら アセンブラ を 選択 す べき ( 格段 に 問題 が 簡単 で 容易 に 満点 取れる から ) 参考書 は 図書館 で 借り まくっ て 手元 に おき たい もの を 買う 方 が 外れ は 少ない と 思う 複数 ある ほう が わかり にくい 所 を 別 の 説明 で 読める ので 複数 持っ て た方 が 良い と 思う 参考書 で 準備 する と 効率 悪い ので 過去問 重視 で 準備 する こと を お勧め し ます 過去問 は 解説 が 詳しい もの が 良い こちら も 複数 もっ て て も 良い 過去問 は 多い もの も 必要 最初 は ほぼ でき ない けど その 苦し さ に 耐え て 何 年 も やれ ば 似 た 問題 が 出る 傾向 ある ので だんだん 解ける よう に なっ て くる 出来 ない 問題 に は マーク し て 何度も やりなおす よう に する ( 出来る 問題 を やっ て も 点 が のび ない ので ) 満点 を 取る 必要 は ない ので 労力 少なく 点 を 取れる もの を 優先 し て 準備 
> 一行 の 出力 ( 簡 潔 ) と 書式 出力 だけ の 違い だ と いえ ば 、 確か に その 通り です 。 大きな 違い です けど ね 。 
言っ て いる こと が よく わから ない 。 そもそも 、 この プログラム は 何 を する もの な の ？ どう いっ た値 を 入力 し て 、 どう いっ た 結果 が 出れ ば 正解 な の ？ こう いっ た こと を 具体 的 に 書い た 方 が よっぽど 答え に 近づく わ 。 
d = 1 は gcd ( 943 , gcd ( 1219 , 2173 )) から 得 られる として ， そこ から 先 は 「 不定 方程式 maxima 」 で ぐぐる と よさげ な 気 が し ます 。 
chielien _ dedd 15481 ec b7 a 2b dc 98 f 06 さん 1 から 100 まで の 整数 で 、 3 の 倍数 で ない もの の 合計 N 1 = 1 + 2 +...+ 100 = 101 * 50 = 5050 N2 = 3 + 6 +...+ 99 = 3 ( 1 + 2 +... 33 )= 3 * 33 * 34 / 2 = 1683 N = N 1 - N2 = 3367 ??? 
質問 文 で 「 実行 し た ところ エラー が 発生 」 と 書か れ て い ます が 、 kuro _ neko _ g _ san さん の 回答 へ の 返信 を 見る と ビルド 時 の エラー です よ ね 。 ( 実行 まで 行け て い ない はず ) 技術 的 な 話 を する 場合 です ので 、 どういう 環境 で 、 どういう 事 を し た とき に 、 どういう エラー が 出 た 、 という の を 正確 に 記述 し なけれ ば 正しい 情報 の やりとり が 出来 ませ ん 。 本題 です が 、 その エラー 内容 は リンク 時 の エラー です ので lib ファイル の 参照 が 出来 て い ない という こと に なり ます 。 まず 、 MIDI IO d.l ib と MIDIIO . lib は 1つ の ビルド 構成 で 片方 のみ を 設定 し ます 。 ビルド 構成 という の は 「 Debug 」 とか 「 Release 」 とか 選択 を 切り替え られる やつ です 。 すなわち 、 「 Debug 」 ビルド 用 の 設定 で は 「 MIDI IO d.l ib 」 の 参照 を 。 「 Release 」 ビルド 用 の 設定 で は 「 MIDIIO . lib 」 の 参照 を 行い ます 。 ( プロジェクト の 設定 ダイアログ で も 左上 で どの ビルド 構成 を 対象 に し て いる か わかり ます ) 次に 正しい パス で 参照 を 行わ なけれ ば なり ませ ん 。 リンカ の 入力 欄 に 単に 「 MIDIIO . lib 」 など ファイル 名 のみ を 記述 し て も だめ です 。 lib ファイル を どこ に 置く か に より ます が 、 たとえば 「 MIDIIO . lib 」 を ソリューション ファイル (*. sln ) の ある 場所 に 作っ た 「 rls 」 フォルダ 内 に 置い た 場合 に は 、 リンカ 入力 に 「 $( Solution Dir ) rls \ MIDIIO . lib 」 と 指定 する こと に なり ます 。 よく 分から なけれ ば 、 ひとまず 動作 さ せる ため に フル パス で 指定 し て おい て 先 に 進む の も 手 です 。 ( その 場合 は 後で 理解 し て より メンテ し やすい 設定 に なおし ましょ う ) そして 、 サンプル の コード を 実行 し て 音 を 出す に は 上 に も すこし 書き まし た が 環境 も 影響 し て き ます 。 リンク 先 の サンプル コード で は 古い OS よう に なっ て い ます が 、 たとえば Windows 7 で あれ ば 「" Microsoft GS Wavetable SW Synth "」 の 部分 は 「 " Microsoft GS Wavetable Synth "」 に 変える 必要 が あり ます 。 ( あるいは 他 に インストール し て あれ ば その MIDI音源 名 ) 当方 の 環境 で 試し た ところ 、 それ らしい 音 が でる こと は 確認 出来 まし た 。 
Visual Studio 2012 の どの エディション です か ? Express だ と 思い ます が 、 デスクトップ アプリ の 開発 に は " for Windows Desktop " が 必要 です 。 https :// www . microsoft . com / ja - jp / download / details . aspx ? id = 34673 " for Windows 8 " や " for Web " では コンソールアプリ は 作れ ませ ん 。 http:// forest . wat ch. impress . co.jp / docs / news / 559421 . html 
> mkn 4724 さん 宿題 を こんな ところ で 聞く の が まず よろしく な さ すぎ 出来 ない 理由 は はっ りし まくり 準備 不足 復習 ちゃんと やっ て ( もともと 授業 の 範囲 の 知識 できる よう に なっ て ん だ し ) ノート を とっ て ない なら ノート ちゃん と し てる ヤツ から ノート を コピー ( 賄賂 的 な もの を あげ て 、 高級 お菓子 とか 高級 な 食事 を おごる とか ) あと は キーワード はっきり し てる し ネット 検索 すれ ば 証明 方法 の 例 も すぐ みつかる から そこ の 問題 を 、 こっち の 問題 を おい て おい て まず やっ て み て 解説 み ず に できる よう に なっ て から こっち の 問題 やれ ば 多分 自己 解決 できる 自己 解決 でき ない なら それ は 君 の 能力 が 低 すぎる から 更 なる 工夫 を する か 他 の 単位 で なんとか する か だ ね 
私 も 悩み まし た が 、 それぞれ の 機能 を イメージ し て 使い ます 。 STL は vector , string , list , map , multimap , stack , deque , set , multiset ... と あり ます が 、 vector -> 配列 状 に ならん だ もの string -> 文字列 用 。 vector とか に 文字列 を 入れる とき は これ に なる 。 list -> ポインタ で つなぎとめ られ て い て 、 途中 挿入 や 、 途中 削除 に 有利 。 map -> 辞書 の よう に データ A と データ B が セット に なっ て いる もの 。 multimap -> map は 重複 は ゆるさ ない が 、 これ は 重複 OK 。 stack -> 上 に 積み重ね て 、 最新 の データ から 処理 する 必要 が ある 場合 。 あと 計算機 を 作る 場合 とか 。 キュー -> 古い やつ から 順に 処理 する 必要 が ある 場合 。( 順番 が 決まっ て いる と か 。 ) ... と 考える と 、 - - - - - - - ------------------------- データ を 入れる が 、 保存 用 ( 配列 等 ) な の か 順 を つけ て 一時的 に 確保 する の か " 保存 " なら vector か list , map etc 。 そう で なけれ ば stack , キュー ... - - - - - - - ------------------------- 1番 目 から n - 2 番目 の データ を 頻繁 に 削除 し たり 追加 し たり する か " 削除 ・ 追加 あり " なら list , "〃 なし " なら vector ... - - - - - - - ------------------------- という 感じ で 機能 を 考え て やれ ば なんとなく わかる か と 思い ます 。 違い が まっ っ ったく わからん っていう 感じ なら 、 STL を 使わ ず に 「 データ構造 と アルゴリズム 」 の " リスト 構造 ", " スタック ", ” キュー " 等 を やっ て み て ください 。 「 C言語 データ構造 アルゴリズム 」 みたい に 検索 すれ ば 出 て き ます 。 ( C++ で も でき ます が 、 STL が ある ので 、 それ の 使い方 が 主 に なる ので 。 ) 
Windows なら 1 . 対象 の ウィンドウ ハンドル を 取得 2 . 閉じる を 送る みたい な 感じ な ん でしょ う ね 。 
サクラエディタ で でき ます 。 印刷 の 設定 で ・ 行番号 を 印字 に チェック ・ 段数 を ２ ・ヘッダー ( フッター ) に $/$ f を 指定 （$/ で ファイル の パス 、 $ f で ファイル 名 ） ・ ヘッダー ( フッター ) に $ d を 指定 （ 現在日 付 ） その他 、 いろいろ と 、 特殊記号 の 組合せ で ヘッダー 、 フッター 各 ３ か所 （ 左寄せ 、 中央 、 右寄せ ） に 設定 でき ます ので 、 目的 の かたち で 印刷 できる か と 思い ます 。 http:// sakura - editor . sourceforge .net / html he lp2 / HLP 000284 . html 
> rorsonw さん エラーメッセージ から する と ファイル の パーミッション の 問題 の 可能性 も ある ので その ユーザー で 開く ファイル を コピー し て その コピー 先 を 開い たら どう なり ます か ？ 有料 ソフト っぽい し 、 ユーザー サポート が 利用 できる はず な ので メーカー の サポート に 電話 し て きく の が 効率 良い と 思う 
if ( ansr [ k 1 ] == ansrc [ k 1 ]){ 格納 さ れる ポインタ は 違う ので 、 当然 毎回 違う という 結果 に なり ます 。 文字列 が 同じ 文字列 か どう か を 判定 する の は 、 通常 strcmp () など の 関数 を 使い ます 。 当然 strcmp () と 同じ よう に 、 １ 文字 づつ 文字 が 同じ か どう か 確認 する よう に プログラム に し て も かまい ませ ん 。 
（ ＾ ＾ ） つ 【 ttp:// www . kk . iij4u . or .jp /~ kondo / wave /】 がんばり な はれ データ として は 、 L チャンネル R チャンネル の 順 に 交互 に 記録 し て いけ ば 良い だけ みたい ね 。 
> gorygory 02111 さん 無理 し て 作れ ない もの 作ら なく て も スプレッドシート ソフト でも 可能 だ よ その 処理 他 にも それ が できる ツール は 山 ほど ある 先人 の おかげ で 課題 なら 自分 で 出来る ところ まで やっ て 提出 や ね 他人 に やっ て もらお う と する ん じゃ ない よ 
> その 時 に a [ 0 ] 問 いっ た リスト の 呼び出し を 使っ て 計算 を 行い たい あなた が 自分 で 書い て いる 通り 、 a [ 0 ] と すれ ば リスト の 呼び出し に なる 。 a [ 0 ] で [ 1 , 2 ] が 出 て くる し 、 a [ 0 ][ 0 ] で 1 が 出 て くる 。 2つ の 「 int の リスト 」 の リスト が 前提 なら from math import sqrt sqrt ( sum (( a1 - b 1 )** 2 for a1 , b 1 in zip (* a ))) です か ね 。 a = [[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]] sqrt ( sum (( a1 - b 1 )** 2 for a1 , b 1 in zip (* a ))) #=> 5 . 196152422706632 sqrt (( 1 - 4 )** 2 + ( 2 - 5 )** 2 + ( 5 - 6 )** 2 ) #=> 5 . 196152422706632 http:// docs . python .jp / 3 . 5 / library / functions . html # zip 
8 1 7 3 4 5 9 6 2 2 4 6 1 9 7 8 5 3 5 9 3 6 2 8 1 7 4 6 2 9 8 3 1 5 4 7 3 8 1 5 7 4 6 2 9 7 5 4 2 6 9 3 1 8 4 3 2 9 1 6 7 8 5 9 6 5 7 8 2 4 3 1 1 7 8 4 5 3 2 9 6 
多角形 対 頂点 の 内外 判定 そのもの について は あまり 高速化 の 余地 は あり ませ ん ので 、 やはり 衝突判定 の 高速化 に 重要 な の は 空間分割 アルゴリズム を どう する か だ と 思い ます 。 よく 使わ れる アルゴリズム として は 、 ・ Uniform Grid ・ kd - tree ・ BVH あたり でしょ う か 。 実装 が 一番 お 手軽 な の は Uniform Grid か と 思い ます 。 
// Form 1 に String Gri d1 と Bu t to n2 を 配置 し て // Bu t to n2 を 押し た 時 に String Gri d1 に 読み込む 例 です 。 // あらかじめ String Gri d1 の 「 列 数 」 は 必要 な 量 を 設定 し て おく もの と し ます 。 void __ fastcall TForm 1 :: Bu t to n2 Click ( TObject * Sender ) { // 単純 に ファイル を グリッド に 流し込む 例 ( 比較的 簡単 です ) //※ 行 の 自動 拡張 を 行い ます 。 //※ 列 の 自動 拡張 はしません 。 if (! OpenDialog 1 -> Execute ()) return ;// ファイル 選択 キャンセル し た 時 // ファイル 選択 し た 時 // ファイル を StringList に 読み込み ます TStringList * StringList = new TStringList (); StringList -> LoadFromFile ( OpenDialog 1 -> FileName );// 読み込み に 失敗 する と 例外 が 発生 し ます 。 例外 で プログラム が ストップ する 事 を 避け たい 場合 は 、 例外処理 を 追加 し て 下さい 。 // StringList の 内容 を グリッド に 表示 し ます String Gri d1 -> RowCount = 1 ;// 行 数 は １ 未満 に は なら ない ので １ に し て おき ます for ( int i = 0 ; i < StringList -> Count ; i ++){ if ( String Gri d1 -> RowCount <= i ){ // 行 数 が 足ら ない 時 String Gri d1 -> RowCount = i + 1 ;// 行 数 を 拡張 し ます } // グリッド の 行 に ファイル の 行 を スペース 区切り で 流し込み ます String Gri d1 -> Rows [ i ]-> De limiter =' ';// スペース 区切り String Gri d1 -> Rows [ i ]-> StrictDelimiter = true ;// false に する と 非表示 文字 も 区切り 文字 扱い に なり ます String Gri d1 -> Rows [ i ]-> DelimitedText = StringList -> Strings [ i ]; } delete StringList ; } 
＞ 各 関数 ごと の 最終 的 な 演算 時間 を 求め たい 以下 の よう に し ます 。 各々 の 関数 を start と end で 挟み 、 total に 加算 し ます 。 ＊ ＊ ＊ # include < stdio . h > # include < time. h > # define FUNC 3 # define LEN 500 int funcA ( int x , int y , int z ){ int i , j ; int m = 5923 ; for ( i = 0 ; i < LEN ; i ++){ for ( j = 0 ; j < LEN ; j ++){ x += ( x * i * j ) % m ; } x %= m ; } printf (" m =% d , x =% d \ n ", m , x ); return x ; } int funcB ( int x , int y , int z ){// Tarai if ( x <= y ){ return y ; } funcB ( funcB ( x - 1 , y , z ), funcB ( y - 1 , z , x ), funcB ( z-1 , x , y )); } int funcC ( int x , int y , int z ){// Tak if ( x <= y ){ return z ; } funcC ( funcC ( x - 1 , y , z ), funcC ( y - 1 , z , x ), funcC ( z-1 , x , y )); } int main ( void ){ int i , j ; clock _ t start , end ; double total [ FUNC ] = { 0 }; int (* func [ FUNC ])( int , int , int );// 関数 ポインタ func [ 0 ] = funcA ; func [ 1 ] = funcB ; func [ 2 ] = funcC ; for ( i = 0 ; i < 5 ; i ++){ for ( j = 0 ; j < FUNC ; j ++){ start = clock (); (* func [ j ])( 10 , 7 , 0 );// 関数 ポインタ end = clock (); total [ j ] += ( double )( end - start )/ CLOCKS _ PER _ SEC ; } } for ( i = 0 ; i < FUNC ; i ++){ printf (" func % c : % f [ s ]\ n ", ' A '+ i , total [ i ]); } return 0 ; } 
そもそも 「 以下 」 が ない ん だ けど 。 基礎 的 な こと が わかっ て い ない こと が わかっ て いる の なら 、 それなり の 資料 を 調べ たら いか が かしら 。 & は アドレス 演算子 。 オブジェクト の アドレス を 求める 。 * は 、 間接 演算子 か な ? ポインタ が 指し て いる 先 に アクセス する 。 -> は 、 構造体 / 共用体 ポインタ 演算子 、 通称 ? アロー 演算子 。 構造体 等 へ の ポインタ から メンバー に アクセス する それぞれ ググ れ ば 出 て くる か と 思い ます 。 
ster _ sky _ 1101 さん for 文 を ビシッと つかい まし た 。 # include < stdio . h > void printaster ( int space , int aster , int sp ac e2 ) { while ( space > 0 ) printf (" "), space --; while ( aster > 0 ) printf ("*"), aster --; while ( sp ac e2 > 0 ) printf (" "), sp ac e2 --; printf ("\ n "); } int main ( void ) { int i ; for ( i = 1 ; i <= 10 ; i ++) { if ( i == 1 ) printaster ( 11 - i , i , 0 ); else printaster ( 10 - i , i , 1 ); } return 0 ; } 
> jicojapan 2006 さん 問題 の 番号 を 間違っ てる か リンク を 間違っ てる と 思う 23 は XML に関する 問題 だ よ 
> ryuyalikesoccer さん *** 本 の ソース を コンパイル でき ない こと は 普通 は ありません 普通 は 本 の とおり 打ち込め ば 動く はず エラーメッセージ を 真面目 に 読ん で 、 エラー 発生 行 が 書い て ある ので 、 そこ で 使っ てる 関数 とか の 使い方 に あっ て ない 打ち まちがい し てる 可能性 が かなり 高い エラー は 一番 最初 の エラー が 次に 影響 し てる かも しれ ない ので 一番 上 の エラー 発生 行 の エラー 原因 を 取り の そい たら もう一度 コンパイル 、 エラー が 発生 し なく なる まで くりかえせ ば 動く よう に できる 使っ てる 関数 は 全部 調べ て 、 使い かた を サンプルソース を 動かす ソース 熟読 ( わから ない 関数 は 前部 調べ て )、 元 の ソース を できるだけ 見 ない よう に し て 作る ( 使い かた の 練習 、 それ し ない と 普通 は 使え ない ) を 面倒く さがら ず に 地道 に やれ ば 質問 の よう な 事態 に は なら ない *** Excel で も プログラム できる け ん について は 言語 が ことなり ます 。 それでも 良けれ ば それ を 使え ば 良い *** エディタ で プログラム プログラム 用 の もの とか 補完 が できる もの 使う 方 が 良い と 思う 私 は Vim を 愛用 し て ます エディタ が 補完 機能 ない と 打ち まちがい が 増え て デバッグ 量 が 増える ので それなり の エディタ 使っ た 方 が 良い と 思う コンパイル は GNU Make を 使う と 楽 です ( IDE 使う より ) 短い プログラム を 書く 場合 は 特に **** まとめ * ソース を 真面目 に 読み ましょ う * わから ない 関数 は 関数 名 ソース に 含ま れ そう な キーワード で ネット 検索 。 例えば printf # include * エディタ は それなり の もの を 使っ て 、 GNU Make を 利用 する と IDE 使う より 楽 です http:// note . chiebukuro . yahoo . co.jp / detail / n3 6864 
まず こちら の 「 Arduino トラブルシューティング 」 を 試し て み て 下さい http:// 100 year . cocolog - nifty . com / blog / 2014 / 06 / arduino - 9471 . html 
簡単 な 話 チケット ナンバー を 受け取る グローバル変数 が あり ます よ ね ？ ここ で は gTicket と で も し とき ましょ う これ を 持ち たい 最大 ポジション 数 分 作る わけ です 。 gTicket 1 gTicket 2 gTicket 3 gTicket 4 という 具合 です 。 そして 、 チケット ナンバー を OrderSend 関数 から 各々 専用 の gTicket に 受け取っ て おき ます 。 この チケット ナンバー を 利用 し て OrderSelect し OrderModify で トレーリング ストップ を かけて やれ ば いい ん です よ 。 mql の OrderSend に は SELECT _ BY _ POS も あり ます が 私 の 場合 は この 機能 は ポジション の 管理 や リスク の 管理 が 非常 に し づらい と 感じる ので 基本 利用 し て ませ ん ポジション を 持てる 限り 持つ EA など リスク管理 上 よろしく ない と 思い ます ので 
( 1 ) 1001 ( 2 ) i ( 3 ) i ( 4 ) flag [ j ] = 0 ; j *= 2 ; ( 5 ) if ( flag [ i ] == 1 ){ printf ("% d ", i ); /* 横 に 並べ て 表示 する 場合 */ printf ("% d \ n ", i ); /* 縦 に 並べ て 表示 する 場合 */ } 
PIC の 種類 は ？ OSCCAL 欄 が 灰色 <- 設定 不要 です VCC , GND , / MCLR , ICSPDAT , ICSPCLK の 接続 ピン 確認 PIC 単体 で PICKIT 2 に 接続 し て ます か 、 ICSPDAT , ICSPCLK ピン は プルアップ 禁止 / MCLR は 10K Ω で プルアップ PICKIT 2 Programme r で も HEX ファイル は 読み込め ませ ん か ？ http:// www . ne.jp / asahi / air / variable / picmel / integration / write / pickit ... 
VBA でしょ う 就職 先 で 必要 なら どうせ 勉強 さ せ られ ます が 、 Ｃ を 使う よう な ガチガチ の ＩＴ 系 なら 言語 以外 の 仕様書 やら ネットワーク 技術 やら その 都度 勉強 に なる でしょ う し 、 事務 系 に いく なら ＶＢＡ は 覚え て い た ほう が 便利 そう です この 際 、 苦手 意識 を なくし て しまい ましょ う Ｃ を 復習 する なら 絶版 でしょ う けど Ｃ ノート （ 近代科学社 ） を お勧め し ます １ ０ ０ ページ ほど しか ありません が 、 Ｃ 言語 を 俯瞰 でき ます 
だいたい プログラム の ディレクトリ に readme とか リファレンス とか が あっ て バージョン なり 更新 ログ なり の 情報 が 書い て あり ます よ 。 それ か - version みたい な コマンド 探す か 。 man とか で 確認 でき ませ ん か ？ 
下記 の サイト を 参考 に し て ください 。 http:// dobon .net / vb / dotnet / file / writefile . html 
文字コード を 指定 し て テキストファイル に 書き込む http:// dobon .net / vb / dotnet / file / writefile . html 
scanf (" % c ", & name ); 文字列 入力 処理 を 文字 入力 命令 で やっ てる から だ と 思い ます 。 
SVG の 最大 の 利点 は 、 XML ベース で あり 、 XML ファミリー の 様々 な ツール を 使える という こと 。 逆 に 言え ば 、 XML で ある こと に 利点 を 感じ ない の なら 、 あまり 使う 意味 は ない よ 。 
あまり その 傾向 は 感じ取れ ませ ん が 、 皆 が 学ぶ 必要 は ない でしょ う 。 
n →∞ で 収束 する とき an + 1 も an も 同じ 値 に なる ので α と 置く と 、 α = 0 . 5 α + 3 α = 6 よって 、 6 に 収束 し ます 。 
> surahuto さん ツール 名 やり たい こと ツール 名 キーワード で ネット 検索 すれ ば 大抵 すぐ やり方 は 調べ れ ます データ は その 使い かた 調べ た サイト の 方法 に あわし て 用意 する 方 が 良い よ 今回 だ と gnuplot 等高線 データファイル で ネット 検索 http:// www . eml . el e.c st . nihon - u. ac.jp /~ momma / wiki / wiki . cgi / gnuplot /%... あたり が わかり やす そう 同じ キーワード で ネット 検索 かけ て もらっ て 検索 上位 で 一番 良い と 思う サイト を 利用 する の が 良い と 思う よ まず 自分 の やり たい こと を やる まえ に その サイト の データ を 使っ て 同じ こと やっ て み て データ の 構造 を 確認 自分 の やり たい こと も その データ フォーマット に あわせ て 用意 し て プット すれ ば 同じ こと できる はず 、 君 の やり たい テータ にたいして 
if ( a < b < c ) って 書ける の か ？ if ( a < b かつ b < c ) じゃなくて ？ 見当 違い だっ たら すまん 。 
% s に しか 対応 でき て い ませ ん が 、 作っ て み まし た 。 # include < stdio . h > # include < stdarg . h > int my _ printf ( const char * str , ...) { va _ list args ; va _ start ( args , str ); int count = 0 ; while (* str != '\ 0 ') { if (* str == '%') { ++ str ; switch (* str ) { case ' s ': { const char * p = va _ arg ( args , const char *); while (* p != '\ 0 ') { putchar (* p ); ++ count ; ++ p ; } break ; } } } else { putchar (* str ); ++ count ; } ++ str ; } va _ end ( args ); return count ; } int main () { my _ printf (" Hello , % s World !", " My "); return 0 ; } 
> ak _ meadokaemasitasupamu さん 検索 する とき に 漢字 間違っ てる から ヒット し て ない とか ないか な 線形 リスト で google で ネット 検索 し て トップ の サイト が 最高 に わかり やすい サンプルソース も ある し * 快 絶 を 全部 読む * サンプル コード を 全部 動かし て ソース 熟読 * わから ない 関数 は 全部 調べる + どうせ 授業 の 課題 やろ < ノート の 見直し と 、 買わさ れ てる 参考 図書 を 真面目 に 復習 これら で 準備 し て から やれ ば 馬鹿 じゃ なけれ ば 普通に 自己 解決 や 課題 を 人 に やっ て もらっ て なんとか しよ う とか 考え かた 間違っ て ます 時間 の 無駄 な ので そんな こと は 止め ましょ う どうしても やる気 に なれ ない なら やる気 に なれる もの で 単位 を そろえ ましょ う 必須 科目 なら 上 の 方法 で 準備 を し ない から 自己 解決 でき て ない 非常 に 重要 な こと として ( 難易度 を 下げる ) 開発 環境 を 家 の PC に も 入れ て ちゃんと コンパイル , 実行 できる よう に し とく こと デバッガ も 入れ て 使い かた 覚えれ ば かなり ハードル 下がる よ 最悪 は でき た ところ まで 提出 とか 勝手 に 難易度 が 下がる よう に 問題 の 設定 を 変更 し て それ で 出し とく こと や ね 出さ ない より は ずっと 良い し 他人 に やっ て もらう の より も はるか に 良い 
.NET の 仮想マシン を はさん で いる こと で 、 マルチプラットフォーム 化 が 容易 に なっ て いる こと は 確か でしょ う 。 しかし 、 そう で なけれ ば マルチプラットフォーム 化 でき ない わけ で は あり ませ ん 。 
日本語 等 のようなもの は 基本的 に 全角 です 。 全角 文字 は 2つ で ひとつ な ので 、 文字列 扱い です 。 なので 二 次元 配列 で やる か 、 ポインタ の ポインタ とか みたい に なり ます 。 例 . char eto [][] = { " 子 ", " 丑 ", ... }; または char * eto [] = { " 子 ", " 丑 ",... }; 等 。 
